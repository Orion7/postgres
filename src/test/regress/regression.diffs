*** /home/orion/postgres/src/test/regress/expected/create_index.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/create_index.out	2015-01-10 10:11:46.011649447 +0300
***************
*** 1697,2833 ****
  SET enable_indexscan = OFF;
  SET enable_bitmapscan = ON;
  CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
! explain (costs off)
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Sort
!    Sort Key: seqno
!    ->  Bitmap Heap Scan on array_index_op_test
!          Recheck Cond: (i @> '{32}'::integer[])
!          ->  Bitmap Index Scan on intarrayidx
!                Index Cond: (i @> '{32}'::integer[])
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (3 rows)
! 
! SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (11 rows)
! 
! SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
!  seqno |       i       |                                                             t                                                              
! -------+---------------+----------------------------------------------------------------------------------------------------------------------------
!     40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    101 | {}            | {}
! (4 rows)
! 
! SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
!  seqno |    i    |                                                        t                                                        
! -------+---------+-----------------------------------------------------------------------------------------------------------------
!     95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
! explain (costs off)
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Sort
!    Sort Key: seqno
!    ->  Bitmap Heap Scan on array_index_op_test
!          Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
!          ->  Bitmap Index Scan on textarrayidx
!                Index Cond: (t @> '{AAAAAAAA72908}'::text[])
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |  i   |                                 t                                  
! -------+------+--------------------------------------------------------------------
!     79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
!  seqno |         i          |                                                     t                                                     
! -------+--------------------+-----------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
!     45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!    101 | {}                 | {}
! (3 rows)
! 
! SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
!  seqno |     i      |           t            
! -------+------------+------------------------
!     96 | {23,97,43} | {AAAAAAAAAA646,A87088}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! -- And try it with a multicolumn GIN index
! DROP INDEX intarrayidx, textarrayidx;
! CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
!  seqno |               i                |                                                                              t                                                                              
! -------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
!     19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!    100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (7 rows)
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
!  seqno |               i                |                                                                              t                                                                              
! -------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
!     19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!    100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (7 rows)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
!  seqno |              i              |                                      t                                       
! -------+-----------------------------+------------------------------------------------------------------------------
!    100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
!  seqno |              i              |                                      t                                       
! -------+-----------------------------+------------------------------------------------------------------------------
!    100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (1 row)
! 
! SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! RESET enable_seqscan;
! RESET enable_indexscan;
! RESET enable_bitmapscan;
! --
! -- Try a GIN index with a lot of items with same key. (GIN creates a posting
! -- tree when there are enough duplicates)
! --
! CREATE TABLE array_gin_test (a int[]);
! INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
! CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
! SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
!  count 
! -------
!   2000
! (1 row)
! 
! DROP TABLE array_gin_test;
! --
! -- Test GIN index's reloptions
! --
! CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
!   WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
! \d+ gin_relopts_test
!      Index "public.gin_relopts_test"
!  Column |  Type   | Definition | Storage 
! --------+---------+------------+---------
!  i      | integer | i          | plain
! gin, for table "public.array_index_op_test"
! Options: fastupdate=on, gin_pending_list_limit=128
! 
! --
! -- HASH
! --
! CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! -- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
! --
! -- Test functional index
! --
! CREATE TABLE func_index_heap (f1 text, f2 text);
! CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
! INSERT INTO func_index_heap VALUES('ABC','DEF');
! INSERT INTO func_index_heap VALUES('AB','CDEFG');
! INSERT INTO func_index_heap VALUES('QWE','RTY');
! -- this should fail because of unique index:
! INSERT INTO func_index_heap VALUES('ABCD', 'EF');
! ERROR:  duplicate key value violates unique constraint "func_index_index"
! DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
! -- but this shouldn't:
! INSERT INTO func_index_heap VALUES('QWERTY');
! --
! -- Same test, expressional index
! --
! DROP TABLE func_index_heap;
! CREATE TABLE func_index_heap (f1 text, f2 text);
! CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
! INSERT INTO func_index_heap VALUES('ABC','DEF');
! INSERT INTO func_index_heap VALUES('AB','CDEFG');
! INSERT INTO func_index_heap VALUES('QWE','RTY');
! -- this should fail because of unique index:
! INSERT INTO func_index_heap VALUES('ABCD', 'EF');
! ERROR:  duplicate key value violates unique constraint "func_index_index"
! DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
! -- but this shouldn't:
! INSERT INTO func_index_heap VALUES('QWERTY');
! --
! -- Also try building functional, expressional, and partial indexes on
! -- tables that already contain data.
! --
! create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
! create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
! create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
! --
! -- Try some concurrent index builds
! --
! -- Unfortunately this only tests about half the code paths because there are
! -- no concurrent updates happening to the table at the same time.
! CREATE TABLE concur_heap (f1 text, f2 text);
! -- empty table
! CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
! CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! NOTICE:  relation "concur_index1" already exists, skipping
! INSERT INTO concur_heap VALUES  ('a','b');
! INSERT INTO concur_heap VALUES  ('b','b');
! -- unique index
! CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
! CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! NOTICE:  relation "concur_index2" already exists, skipping
! -- check if constraint is set up properly to be enforced
! INSERT INTO concur_heap VALUES ('b','x');
! ERROR:  duplicate key value violates unique constraint "concur_index2"
! DETAIL:  Key (f1)=(b) already exists.
! -- check if constraint is enforced properly at build time
! CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  could not create unique index "concur_index3"
! DETAIL:  Key (f2)=(b) is duplicated.
! -- test that expression indexes and partial indexes work concurrently
! CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
! CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
! -- here we also check that you can default the index name
! CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
! -- You can't do a concurrent index build in a transaction
! BEGIN;
! CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
! ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
! COMMIT;
! -- But you can do a regular index build in a transaction
! BEGIN;
! CREATE INDEX std_index on concur_heap(f2);
! COMMIT;
! -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
! VACUUM FULL concur_heap;
! REINDEX TABLE concur_heap;
! ERROR:  could not create unique index "concur_index3"
! DETAIL:  Key (f2)=(b) is duplicated.
! DELETE FROM concur_heap WHERE f1 = 'b';
! VACUUM FULL concur_heap;
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "concur_index2" UNIQUE, btree (f1)
!     "concur_index3" UNIQUE, btree (f2) INVALID
!     "concur_heap_expr_idx" btree ((f2 || f1))
!     "concur_index1" btree (f2, f1)
!     "concur_index4" btree (f2) WHERE f1 = 'a'::text
!     "concur_index5" btree (f2) WHERE f1 = 'x'::text
!     "std_index" btree (f2)
! 
! REINDEX TABLE concur_heap;
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "concur_index2" UNIQUE, btree (f1)
!     "concur_index3" UNIQUE, btree (f2)
!     "concur_heap_expr_idx" btree ((f2 || f1))
!     "concur_index1" btree (f2, f1)
!     "concur_index4" btree (f2) WHERE f1 = 'a'::text
!     "concur_index5" btree (f2) WHERE f1 = 'x'::text
!     "std_index" btree (f2)
! 
! --
! -- Try some concurrent index drops
! --
! DROP INDEX CONCURRENTLY "concur_index2";				-- works
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
! NOTICE:  index "concur_index2" does not exist, skipping
! -- failures
! DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
! ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
! BEGIN;
! DROP INDEX CONCURRENTLY "concur_index5";
! ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
! ROLLBACK;
! -- successes
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
! DROP INDEX CONCURRENTLY "concur_index4";
! DROP INDEX CONCURRENTLY "concur_index5";
! DROP INDEX CONCURRENTLY "concur_index1";
! DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "std_index" btree (f2)
! 
! DROP TABLE concur_heap;
! --
! -- Test ADD CONSTRAINT USING INDEX
! --
! CREATE TABLE cwi_test( a int , b varchar(10), c char);
! -- add some data so that all tests have something to work with.
! INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
! CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
! ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
! \d cwi_test
!           Table "public.cwi_test"
!  Column |         Type          | Modifiers 
! --------+-----------------------+-----------
!  a      | integer               | not null
!  b      | character varying(10) | not null
!  c      | character(1)          | 
! Indexes:
!     "cwi_uniq_idx" PRIMARY KEY, btree (a, b)
! 
! \d cwi_uniq_idx
!          Index "public.cwi_uniq_idx"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  a      | integer               | a
!  b      | character varying(10) | b
! primary key, btree, for table "public.cwi_test"
! 
! CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
! ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
! 	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
! 		USING INDEX cwi_uniq2_idx;
! NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
! \d cwi_test
!           Table "public.cwi_test"
!  Column |         Type          | Modifiers 
! --------+-----------------------+-----------
!  a      | integer               | not null
!  b      | character varying(10) | not null
!  c      | character(1)          | 
! Indexes:
!     "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)
! 
! \d cwi_replaced_pkey
!       Index "public.cwi_replaced_pkey"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  b      | character varying(10) | b
!  a      | integer               | a
! primary key, btree, for table "public.cwi_test"
! 
! DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
! ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
! HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
! DROP TABLE cwi_test;
! --
! -- Tests for IS NULL/IS NOT NULL with b-tree indexes
! --
! SELECT unique1, unique2 INTO onek_with_null FROM onek;
! INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = ON;
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! -- Check initial-positioning logic too
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = OFF;
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      147 |       0
!      931 |       1
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |        
!      278 |     999
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      278 |     999
!        0 |     998
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!        0 |     998
!      744 |     997
! (2 rows)
! 
! RESET enable_seqscan;
! RESET enable_indexscan;
! RESET enable_bitmapscan;
! DROP TABLE onek_with_null;
! --
! -- Check bitmap index path planning
! --
! EXPLAIN (COSTS OFF)
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!                                                                QUERY PLAN                                                                
! -----------------------------------------------------------------------------------------------------------------------------------------
!  Bitmap Heap Scan on tenk1
!    Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
!    ->  BitmapOr
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 1))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 3))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 42))
! (9 rows)
! 
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
! (1 row)
! 
! EXPLAIN (COSTS OFF)
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Aggregate
!    ->  Bitmap Heap Scan on tenk1
!          Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
!          ->  BitmapAnd
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 42)
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (thousand = 42)
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (thousand = 99)
! (11 rows)
! 
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Check behavior with duplicate index column contents
! --
! CREATE TABLE dupindexcols AS
!   SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
! CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
! ANALYZE dupindexcols;
! EXPLAIN (COSTS OFF)
!   SELECT count(*) FROM dupindexcols
!     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!                                                    QUERY PLAN                                                   
! ----------------------------------------------------------------------------------------------------------------
!  Aggregate
!    ->  Bitmap Heap Scan on dupindexcols
!          Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
!          ->  Bitmap Index Scan on dupindexcols_i
!                Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
! (5 rows)
! 
! SELECT count(*) FROM dupindexcols
!   WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!  count 
! -------
!     97
! (1 row)
! 
! --
! -- Check ordering of =ANY indexqual results (bug in 9.2.0)
! --
! vacuum tenk1;		-- ensure we get consistent plans here
! explain (costs off)
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Index Only Scan using tenk1_unique1 on tenk1
!    Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
! (2 rows)
! 
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!  unique1 
! ---------
!        1
!        7
!       42
! (3 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Index Only Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: (thousand < 2)
!    Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
! (3 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! SET enable_indexonlyscan = OFF;
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Sort
!    Sort Key: thousand
!    ->  Index Scan using tenk1_thous_tenthous on tenk1
!          Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
! (4 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! RESET enable_indexscan;
! --
! -- Check elimination of constant-NULL subexpressions
! --
! explain (costs off)
!   select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Index Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: ((thousand = 1) AND (tenthous = 1001))
! (2 rows)
! 
--- 1697,1712 ----
  SET enable_indexscan = OFF;
  SET enable_bitmapscan = ON;
  CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
! NOTICE:  REGISTER.slot = 0, gen = 1
! NOTICE:  works 0
! NOTICE:  REGISTER.slot = 1, gen = 1
! NOTICE:  works 1
! NOTICE:  REGISTER.slot = 2, gen = 1
! NOTICE:  works 2
! NOTICE:  REGISTER.slot = 3, gen = 1
! NOTICE:  works 3
! NOTICE:  nentries = 6
! server closed the connection unexpectedly
! 	This probably means the server terminated abnormally
! 	before or while processing the request.
! connection to server was lost

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_aggregate.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_aggregate.out	2015-01-10 10:11:46.079649449 +0300
***************
*** 1,129 ****
! --
! -- CREATE_AGGREGATE
! --
! -- all functions CREATEd
! CREATE AGGREGATE newavg (
!    sfunc = int4_avg_accum, basetype = int4, stype = _int8,
!    finalfunc = int8_avg,
!    initcond1 = '{0,0}'
! );
! -- test comments
! COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
! ERROR:  aggregate newavg_wrong(integer) does not exist
! COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
! COMMENT ON AGGREGATE newavg (int4) IS NULL;
! -- without finalfunc; test obsolete spellings 'sfunc1' etc
! CREATE AGGREGATE newsum (
!    sfunc1 = int4pl, basetype = int4, stype1 = int4,
!    initcond1 = '0'
! );
! -- zero-argument aggregate
! CREATE AGGREGATE newcnt (*) (
!    sfunc = int8inc, stype = int8,
!    initcond = '0'
! );
! -- old-style spelling of same
! CREATE AGGREGATE oldcnt (
!    sfunc = int8inc, basetype = 'ANY', stype = int8,
!    initcond = '0'
! );
! -- aggregate that only cares about null/nonnull input
! CREATE AGGREGATE newcnt ("any") (
!    sfunc = int8inc_any, stype = int8,
!    initcond = '0'
! );
! COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
! ERROR:  aggregate nosuchagg(*) does not exist
! COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
! COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
! -- multi-argument aggregate
! create function sum3(int8,int8,int8) returns int8 as
! 'select $1 + $2 + $3' language sql strict immutable;
! create aggregate sum2(int8,int8) (
!    sfunc = sum3, stype = int8,
!    initcond = '0'
! );
! -- multi-argument aggregates sensitive to distinct/order, strict/nonstrict
! create type aggtype as (a integer, b integer, c text);
! create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql strict immutable;
! create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql immutable;
! create aggregate aggfstr(integer,integer,text) (
!    sfunc = aggf_trans, stype = aggtype[],
!    initcond = '{}'
! );
! create aggregate aggfns(integer,integer,text) (
!    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,
!    initcond = '{}'
! );
! -- variadic aggregate
! create function least_accum(anyelement, variadic anyarray)
! returns anyelement language sql as
!   'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
! create aggregate least_agg(variadic items anyarray) (
!   stype = anyelement, sfunc = least_accum
! );
! -- test ordered-set aggs using built-in support functions
! create aggregate my_percentile_disc(float8 ORDER BY anyelement) (
!   stype = internal,
!   sfunc = ordered_set_transition,
!   finalfunc = percentile_disc_final,
!   finalfunc_extra = true
! );
! create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (
!   stype = internal,
!   sfunc = ordered_set_transition_multi,
!   finalfunc = rank_final,
!   finalfunc_extra = true,
!   hypothetical
! );
! alter aggregate my_percentile_disc(float8 ORDER BY anyelement)
!   rename to test_percentile_disc;
! alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
!   rename to test_rank;
! \da test_*
!                                        List of aggregate functions
!  Schema |         Name         | Result data type |          Argument data types           | Description 
! --------+----------------------+------------------+----------------------------------------+-------------
!  public | test_percentile_disc | anyelement       | double precision ORDER BY anyelement   | 
!  public | test_rank            | bigint           | VARIADIC "any" ORDER BY VARIADIC "any" | 
! (2 rows)
! 
! -- moving-aggregate options
! CREATE AGGREGATE sumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi
! );
! -- invalid: nonstrict inverse with strict forward function
! CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
! $$ SELECT $1 - $2; $$
! LANGUAGE SQL;
! CREATE AGGREGATE invalidsumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_n
! );
! ERROR:  strictness of aggregate's forward and inverse transition functions must match
! -- invalid: non-matching result types
! CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
! $$ SELECT CAST($1 - $2 AS INT); $$
! LANGUAGE SQL;
! CREATE AGGREGATE wrongreturntype (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_int
! );
! ERROR:  return type of inverse transition function float8mi_int is not double precision
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_function_3.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_function_3.out	2015-01-10 10:11:46.095649449 +0300
***************
*** 1,243 ****
! --
! -- CREATE FUNCTION
! --
! -- sanity check of pg_proc catalog to the given parameters
! --
! CREATE USER regtest_unpriv_user;
! CREATE SCHEMA temp_func_test;
! GRANT ALL ON SCHEMA temp_func_test TO public;
! SET search_path TO temp_func_test, public;
! --
! -- ARGUMENT and RETURN TYPES
! --
! CREATE FUNCTION functest_A_1(text, date) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
! CREATE FUNCTION functest_A_2(text[]) RETURNS int LANGUAGE 'sql'
!        AS 'SELECT $1[0]::int';
! CREATE FUNCTION functest_A_3() RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT false';
! SELECT proname, prorettype::regtype, proargtypes::regtype[] FROM pg_proc
!        WHERE oid in ('functest_A_1'::regproc,
!                      'functest_A_2'::regproc,
!                      'functest_A_3'::regproc) ORDER BY proname;
!    proname    | prorettype |    proargtypes    
! --------------+------------+-------------------
!  functest_a_1 | boolean    | [0:1]={text,date}
!  functest_a_2 | integer    | [0:0]={text[]}
!  functest_a_3 | boolean    | {}
! (3 rows)
! 
! --
! -- IMMUTABLE | STABLE | VOLATILE
! --
! CREATE FUNCTION functest_B_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_2(int) RETURNS bool LANGUAGE 'sql'
!        IMMUTABLE AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_3(int) RETURNS bool LANGUAGE 'sql'
!        STABLE AS 'SELECT $1 = 0';
! CREATE FUNCTION functest_B_4(int) RETURNS bool LANGUAGE 'sql'
!        VOLATILE AS 'SELECT $1 < 0';
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | i
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! ALTER FUNCTION functest_B_2(int) VOLATILE;
! ALTER FUNCTION functest_B_3(int) COST 100;	-- unrelated change, no effect
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | v
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! --
! -- SECURITY DEFINER | INVOKER
! --
! CREATE FUNCTION functext_C_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functext_C_2(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY DEFINER AS 'SELECT $1 = 0';
! CREATE FUNCTION functext_C_3(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY INVOKER AS 'SELECT $1 < 0';
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | t
!  functext_c_3 | f
! (3 rows)
! 
! ALTER FUNCTION functext_C_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_C_2(int) SECURITY INVOKER;
! ALTER FUNCTION functext_C_3(int) SECURITY DEFINER;
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | f
!  functext_c_3 | t
! (3 rows)
! 
! --
! -- LEAKPROOF
! --
! CREATE FUNCTION functext_E_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 100';
! CREATE FUNCTION functext_E_2(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 > 100';
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | f
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_1(int) LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) STABLE;	-- unrelated change, no effect
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_2(int) NOT LEAKPROOF;	-- remove leakproog attribute
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | f
! (2 rows)
! 
! -- it takes superuser privilege to turn on leakproof, but not for turn off
! ALTER FUNCTION functext_E_1(int) OWNER TO regtest_unpriv_user;
! ALTER FUNCTION functext_E_2(int) OWNER TO regtest_unpriv_user;
! SET SESSION AUTHORIZATION regtest_unpriv_user;
! SET search_path TO temp_func_test, public;
! ALTER FUNCTION functext_E_1(int) NOT LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) LEAKPROOF;
! ERROR:  only superuser can define a leakproof function
! CREATE FUNCTION functext_E_3(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 < 200';	-- failed
! ERROR:  only superuser can define a leakproof function
! RESET SESSION AUTHORIZATION;
! --
! -- CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
! --
! CREATE FUNCTION functext_F_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 50';
! CREATE FUNCTION functext_F_2(int) RETURNS bool LANGUAGE 'sql'
!        CALLED ON NULL INPUT AS 'SELECT $1 = 50';
! CREATE FUNCTION functext_F_3(int) RETURNS bool LANGUAGE 'sql'
!        RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
! CREATE FUNCTION functext_F_4(int) RETURNS bool LANGUAGE 'sql'
!        STRICT AS 'SELECT $1 = 50';
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | f
!  functext_f_3 | t
!  functext_f_4 | t
! (4 rows)
! 
! ALTER FUNCTION functext_F_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_F_2(int) STRICT;
! ALTER FUNCTION functext_F_3(int) CALLED ON NULL INPUT;
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | t
!  functext_f_3 | f
!  functext_f_4 | t
! (4 rows)
! 
! -- information_schema tests
! CREATE FUNCTION functest_IS_1(a int, b int default 1, c text default 'foo')
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1 + $2';
! CREATE FUNCTION functest_IS_2(out a int, b int default 1)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! CREATE FUNCTION functest_IS_3(a int default 1, out b int)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! SELECT routine_name, ordinal_position, parameter_name, parameter_default
!     FROM information_schema.parameters JOIN information_schema.routines USING (specific_schema, specific_name)
!     WHERE routine_schema = 'temp_func_test' AND routine_name ~ '^functest_is_'
!     ORDER BY 1, 2;
!  routine_name  | ordinal_position | parameter_name | parameter_default 
! ---------------+------------------+----------------+-------------------
!  functest_is_1 |                1 | a              | 
!  functest_is_1 |                2 | b              | 1
!  functest_is_1 |                3 | c              | 'foo'::text
!  functest_is_2 |                1 | a              | 
!  functest_is_2 |                2 | b              | 1
!  functest_is_3 |                1 | a              | 1
!  functest_is_3 |                2 | b              | 
! (7 rows)
! 
! -- Cleanups
! DROP SCHEMA temp_func_test CASCADE;
! NOTICE:  drop cascades to 19 other objects
! DETAIL:  drop cascades to function functest_a_1(text,date)
! drop cascades to function functest_a_2(text[])
! drop cascades to function functest_a_3()
! drop cascades to function functest_b_1(integer)
! drop cascades to function functest_b_2(integer)
! drop cascades to function functest_b_3(integer)
! drop cascades to function functest_b_4(integer)
! drop cascades to function functext_c_1(integer)
! drop cascades to function functext_c_2(integer)
! drop cascades to function functext_c_3(integer)
! drop cascades to function functext_e_1(integer)
! drop cascades to function functext_e_2(integer)
! drop cascades to function functext_f_1(integer)
! drop cascades to function functext_f_2(integer)
! drop cascades to function functext_f_3(integer)
! drop cascades to function functext_f_4(integer)
! drop cascades to function functest_is_1(integer,integer,text)
! drop cascades to function functest_is_2(integer)
! drop cascades to function functest_is_3(integer)
! DROP USER regtest_unpriv_user;
! RESET search_path;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_cast.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_cast.out	2015-01-10 10:11:46.099649449 +0300
***************
*** 1,74 ****
! --
! -- CREATE_CAST
! --
! -- Create some types to test with
! CREATE TYPE casttesttype;
! CREATE FUNCTION casttesttype_in(cstring)
!    RETURNS casttesttype
!    AS 'textin'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  return type casttesttype is only a shell
! CREATE FUNCTION casttesttype_out(casttesttype)
!    RETURNS cstring
!    AS 'textout'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  argument type casttesttype is only a shell
! CREATE TYPE casttesttype (
!    internallength = variable,
!    input = casttesttype_in,
!    output = casttesttype_out,
!    alignment = int4
! );
! -- a dummy function to test with
! CREATE FUNCTION casttestfunc(casttesttype) RETURNS int4 LANGUAGE SQL AS
! $$ SELECT 1; $$;
! SELECT casttestfunc('foo'::text); -- fails, as there's no cast
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! -- Try binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
! SELECT casttestfunc('foo'::text); -- doesn't work, as the cast is explicit
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT casttestfunc('foo'::text::casttesttype); -- should work
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! DROP CAST (text AS casttesttype); -- cleanup
! -- Try IMPLICIT binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION AS IMPLICIT;
! SELECT casttestfunc('foo'::text); -- Should work now
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! -- Try I/O conversion cast.
! SELECT 1234::int4::casttesttype; -- No cast yet, should fail
! ERROR:  cannot cast type integer to casttesttype
! LINE 1: SELECT 1234::int4::casttesttype;
!                          ^
! CREATE CAST (int4 AS casttesttype) WITH INOUT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  1234
! (1 row)
! 
! DROP CAST (int4 AS casttesttype);
! -- Try cast with a function
! CREATE FUNCTION int4_casttesttype(int4) RETURNS casttesttype LANGUAGE SQL AS
! $$ SELECT ('foo'::text || $1::text)::casttesttype; $$;
! CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  foo1234
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/constraints.out	2015-01-10 10:11:34.243649159 +0300
--- /home/orion/postgres/src/test/regress/results/constraints.out	2015-01-10 10:11:46.083649449 +0300
***************
*** 1,647 ****
! --
! -- CONSTRAINTS
! -- Constraints can be specified with:
! --  - DEFAULT clause
! --  - CHECK clauses
! --  - PRIMARY KEY clauses
! --  - UNIQUE clauses
! --  - EXCLUDE clauses
! --
! --
! -- DEFAULT syntax
! --
! CREATE TABLE DEFAULT_TBL (i int DEFAULT 100,
! 	x text DEFAULT 'vadim', f float8 DEFAULT 123.456);
! INSERT INTO DEFAULT_TBL VALUES (1, 'thomas', 57.0613);
! INSERT INTO DEFAULT_TBL VALUES (1, 'bruce');
! INSERT INTO DEFAULT_TBL (i, f) VALUES (2, 987.654);
! INSERT INTO DEFAULT_TBL (x) VALUES ('marc');
! INSERT INTO DEFAULT_TBL VALUES (3, null, 1.0);
! SELECT '' AS five, * FROM DEFAULT_TBL;
!  five |  i  |   x    |    f    
! ------+-----+--------+---------
!       |   1 | thomas | 57.0613
!       |   1 | bruce  | 123.456
!       |   2 | vadim  | 987.654
!       | 100 | marc   | 123.456
!       |   3 |        |       1
! (5 rows)
! 
! CREATE SEQUENCE DEFAULT_SEQ;
! CREATE TABLE DEFAULTEXPR_TBL (i1 int DEFAULT 100 + (200-199) * 2,
! 	i2 int DEFAULT nextval('default_seq'));
! INSERT INTO DEFAULTEXPR_TBL VALUES (-1, -2);
! INSERT INTO DEFAULTEXPR_TBL (i1) VALUES (-3);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (-4);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (NULL);
! SELECT '' AS four, * FROM DEFAULTEXPR_TBL;
!  four | i1  | i2 
! ------+-----+----
!       |  -1 | -2
!       |  -3 |  1
!       | 102 | -4
!       | 102 |   
! (4 rows)
! 
! -- syntax errors
! --  test for extraneous comma
! CREATE TABLE error_tbl (i int DEFAULT (100, ));
! ERROR:  syntax error at or near ")"
! LINE 1: CREATE TABLE error_tbl (i int DEFAULT (100, ));
!                                                     ^
! --  this will fail because gram.y uses b_expr not a_expr for defaults,
! --  to avoid a shift/reduce conflict that arises from NOT NULL being
! --  part of the column definition syntax:
! CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
! ERROR:  syntax error at or near "IN"
! LINE 1: CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
!                                                   ^
! --  this should work, however:
! CREATE TABLE error_tbl (b1 bool DEFAULT (1 IN (1, 2)));
! DROP TABLE error_tbl;
! --
! -- CHECK syntax
! --
! CREATE TABLE CHECK_TBL (x int,
! 	CONSTRAINT CHECK_CON CHECK (x > 3));
! INSERT INTO CHECK_TBL VALUES (5);
! INSERT INTO CHECK_TBL VALUES (4);
! INSERT INTO CHECK_TBL VALUES (3);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (3).
! INSERT INTO CHECK_TBL VALUES (2);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (2).
! INSERT INTO CHECK_TBL VALUES (6);
! INSERT INTO CHECK_TBL VALUES (1);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (1).
! SELECT '' AS three, * FROM CHECK_TBL;
!  three | x 
! -------+---
!        | 5
!        | 4
!        | 6
! (3 rows)
! 
! CREATE SEQUENCE CHECK_SEQ;
! CREATE TABLE CHECK2_TBL (x int, y text, z int,
! 	CONSTRAINT SEQUENCE_CON
! 	CHECK (x > 3 and y <> 'check failed' and z < 8));
! INSERT INTO CHECK2_TBL VALUES (4, 'check ok', -2);
! INSERT INTO CHECK2_TBL VALUES (1, 'x check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (1, x check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (5, 'z check failed', 10);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (5, z check failed, 10).
! INSERT INTO CHECK2_TBL VALUES (0, 'check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (0, check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (6, 'check failed', 11);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (6, check failed, 11).
! INSERT INTO CHECK2_TBL VALUES (7, 'check ok', 7);
! SELECT '' AS two, * from CHECK2_TBL;
!  two | x |    y     | z  
! -----+---+----------+----
!      | 4 | check ok | -2
!      | 7 | check ok |  7
! (2 rows)
! 
! --
! -- Check constraints on INSERT
! --
! CREATE SEQUENCE INSERT_SEQ;
! CREATE TABLE INSERT_TBL (x INT DEFAULT nextval('insert_seq'),
! 	y TEXT DEFAULT '-NULL-',
! 	z INT DEFAULT -1 * currval('insert_seq'),
! 	CONSTRAINT INSERT_CON CHECK (x >= 3 AND y <> 'check failed' AND x < 8),
! 	CHECK (x + z = 0));
! INSERT INTO INSERT_TBL(x,z) VALUES (2, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, -NULL-, -2).
! SELECT '' AS zero, * FROM INSERT_TBL;
!  zero | x | y | z 
! ------+---+---+---
! (0 rows)
! 
! SELECT 'one' AS one, nextval('insert_seq');
!  one | nextval 
! -----+---------
!  one |       1
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, Y, -2).
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! INSERT INTO INSERT_TBL(x,z) VALUES (1, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (1, -NULL-, -2).
! INSERT INTO INSERT_TBL(z,x) VALUES (-7,  7);
! INSERT INTO INSERT_TBL VALUES (5, 'check failed', -5);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL VALUES (7, '!check failed', -7);
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS four, * FROM INSERT_TBL;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 7 | -NULL-        | -7
!       | 7 | !check failed | -7
!       | 4 | -!NULL-       | -4
! (4 rows)
! 
! INSERT INTO INSERT_TBL(y,z) VALUES ('check failed', 4);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (5, check failed, 4).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, 'check failed');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, '!check failed');
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS six, * FROM INSERT_TBL;
!  six | x |       y       | z  
! -----+---+---------------+----
!      | 3 | Y             | -3
!      | 7 | -NULL-        | -7
!      | 7 | !check failed | -7
!      | 4 | -!NULL-       | -4
!      | 5 | !check failed | -5
!      | 6 | -!NULL-       | -6
! (6 rows)
! 
! SELECT 'seven' AS one, nextval('insert_seq');
!   one  | nextval 
! -------+---------
!  seven |       7
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, Y, -8).
! SELECT 'eight' AS one, currval('insert_seq');
!   one  | currval 
! -------+---------
!  eight |       8
! (1 row)
! 
! -- According to SQL, it is OK to insert a record that gives rise to NULL
! -- constraint-condition results.  Postgres used to reject this, but it
! -- was wrong:
! INSERT INTO INSERT_TBL VALUES (null, null, null);
! SELECT '' AS nine, * FROM INSERT_TBL;
!  nine | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 7 | -NULL-        | -7
!       | 7 | !check failed | -7
!       | 4 | -!NULL-       | -4
!       | 5 | !check failed | -5
!       | 6 | -!NULL-       | -6
!       |   |               |   
! (7 rows)
! 
! --
! -- Check constraints on system columns
! --
! CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,
!                   altitude int,
!                   CHECK (NOT (is_capital AND tableoid::regclass::text = 'sys_col_check_tbl')));
! INSERT INTO SYS_COL_CHECK_TBL VALUES ('Seattle', 'Washington', false, 100);
! INSERT INTO SYS_COL_CHECK_TBL VALUES ('Olympia', 'Washington', true, 100);
! ERROR:  new row for relation "sys_col_check_tbl" violates check constraint "sys_col_check_tbl_check"
! DETAIL:  Failing row contains (Olympia, Washington, t, 100).
! SELECT *, tableoid::regclass::text FROM SYS_COL_CHECK_TBL;
!   city   |   state    | is_capital | altitude |     tableoid      
! ---------+------------+------------+----------+-------------------
!  Seattle | Washington | f          |      100 | sys_col_check_tbl
! (1 row)
! 
! DROP TABLE SYS_COL_CHECK_TBL;
! --
! -- Check constraints on system columns other then TableOid should return error
! --
! CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,
!                   altitude int,
! 				  CHECK (NOT (is_capital AND ctid::text = 'sys_col_check_tbl')));
! ERROR:  system column "ctid" reference in check constraint is invalid
! --
! -- Check inheritance of defaults and constraints
! --
! CREATE TABLE INSERT_CHILD (cx INT default 42,
! 	cy INT CHECK (cy > x))
! 	INHERITS (INSERT_TBL);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,11);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,6);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_child_check"
! DETAIL:  Failing row contains (7, -NULL-, -7, 42, 6).
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (6,-7,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (6, -NULL-, -7, 42, 7).
! INSERT INTO INSERT_CHILD(x,y,z,cy) VALUES (6,'check failed',-6,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_con"
! DETAIL:  Failing row contains (6, check failed, -6, 42, 7).
! SELECT * FROM INSERT_CHILD;
!  x |   y    | z  | cx | cy 
! ---+--------+----+----+----
!  7 | -NULL- | -7 | 42 | 11
! (1 row)
! 
! DROP TABLE INSERT_CHILD;
! --
! -- Check NO INHERIT type of constraints and inheritance
! --
! CREATE TABLE ATACC1 (TEST INT
! 	CHECK (TEST > 0) NO INHERIT);
! CREATE TABLE ATACC2 (TEST2 INT) INHERITS (ATACC1);
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! CREATE TABLE ATACC1 (TEST INT, TEST2 INT
! 	CHECK (TEST > 0), CHECK (TEST2 > 10) NO INHERIT);
! CREATE TABLE ATACC2 () INHERITS (ATACC1);
! -- check constraint is there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc2" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST2) VALUES (3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST2) VALUES (3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test2_check"
! DETAIL:  Failing row contains (null, 3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! --
! -- Check constraints on INSERT INTO
! --
! DELETE FROM INSERT_TBL;
! ALTER SEQUENCE INSERT_SEQ RESTART WITH 4;
! CREATE TABLE tmp (xd INT, yd TEXT, zd INT);
! INSERT INTO tmp VALUES (null, 'Y', null);
! INSERT INTO tmp VALUES (5, '!check failed', null);
! INSERT INTO tmp VALUES (null, 'try again', null);
! INSERT INTO INSERT_TBL(y) select yd from tmp;
! SELECT '' AS three, * FROM INSERT_TBL;
!  three | x |       y       | z  
! -------+---+---------------+----
!        | 4 | Y             | -4
!        | 5 | !check failed | -5
!        | 6 | try again     | -6
! (3 rows)
! 
! INSERT INTO INSERT_TBL SELECT * FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -7 FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -8 FROM tmp WHERE yd = 'try again';
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, try again, -8).
! SELECT '' AS four, * FROM INSERT_TBL;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 4 | Y             | -4
!       | 5 | !check failed | -5
!       | 6 | try again     | -6
!       |   | try again     |   
!       | 7 | try again     | -7
! (5 rows)
! 
! DROP TABLE tmp;
! --
! -- Check constraints on UPDATE
! --
! UPDATE INSERT_TBL SET x = NULL WHERE x = 5;
! UPDATE INSERT_TBL SET x = 6 WHERE x = 6;
! UPDATE INSERT_TBL SET x = -z, z = -x;
! UPDATE INSERT_TBL SET x = z, z = x;
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (-4, Y, 4).
! SELECT * FROM INSERT_TBL;
!  x |       y       | z  
! ---+---------------+----
!  4 | Y             | -4
!    | try again     |   
!  7 | try again     | -7
!  5 | !check failed |   
!  6 | try again     | -6
! (5 rows)
! 
! -- DROP TABLE INSERT_TBL;
! --
! -- Check constraints on COPY FROM
! --
! CREATE TABLE COPY_TBL (x INT, y TEXT, z INT,
! 	CONSTRAINT COPY_CON
! 	CHECK (x > 3 AND y <> 'check failed' AND x < 7 ));
! COPY COPY_TBL FROM '/home/orion/postgres/src/test/regress/data/constro.data';
! SELECT '' AS two, * FROM COPY_TBL;
!  two | x |       y       | z 
! -----+---+---------------+---
!      | 4 | !check failed | 5
!      | 6 | OK            | 4
! (2 rows)
! 
! COPY COPY_TBL FROM '/home/orion/postgres/src/test/regress/data/constrf.data';
! ERROR:  new row for relation "copy_tbl" violates check constraint "copy_con"
! DETAIL:  Failing row contains (7, check failed, 6).
! CONTEXT:  COPY copy_tbl, line 2: "7	check failed	6"
! SELECT * FROM COPY_TBL;
!  x |       y       | z 
! ---+---------------+---
!  4 | !check failed | 5
!  6 | OK            | 4
! (2 rows)
! 
! --
! -- Primary keys
! --
! CREATE TABLE PRIMARY_TBL (i int PRIMARY KEY, t text);
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "primary_tbl_pkey"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS four, * FROM PRIMARY_TBL;
!  four | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | three
!       | 5 | one
! (4 rows)
! 
! DROP TABLE PRIMARY_TBL;
! CREATE TABLE PRIMARY_TBL (i int, t text,
! 	PRIMARY KEY(i,t));
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS three, * FROM PRIMARY_TBL;
!  three | i |   t   
! -------+---+-------
!        | 1 | one
!        | 2 | two
!        | 1 | three
!        | 4 | three
!        | 5 | one
! (5 rows)
! 
! DROP TABLE PRIMARY_TBL;
! --
! -- Unique keys
! --
! CREATE TABLE UNIQUE_TBL (i int UNIQUE, t text);
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO UNIQUE_TBL VALUES (4, 'four');
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! INSERT INTO UNIQUE_TBL (t) VALUES ('seven');
! SELECT '' AS five, * FROM UNIQUE_TBL;
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | four
!       | 5 | one
!       |   | six
!       |   | seven
! (6 rows)
! 
! DROP TABLE UNIQUE_TBL;
! CREATE TABLE UNIQUE_TBL (i int, t text,
! 	UNIQUE(i,t));
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_t_key"
! DETAIL:  Key (i, t)=(1, one) already exists.
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! SELECT '' AS five, * FROM UNIQUE_TBL;
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 1 | three
!       | 5 | one
!       |   | six
! (5 rows)
! 
! DROP TABLE UNIQUE_TBL;
! --
! -- Deferrable unique constraints
! --
! CREATE TABLE unique_tbl (i int UNIQUE DEFERRABLE, t text);
! INSERT INTO unique_tbl VALUES (0, 'one');
! INSERT INTO unique_tbl VALUES (1, 'two');
! INSERT INTO unique_tbl VALUES (2, 'tree');
! INSERT INTO unique_tbl VALUES (3, 'four');
! INSERT INTO unique_tbl VALUES (4, 'five');
! BEGIN;
! -- default is immediate so this should fail right away
! UPDATE unique_tbl SET i = 1 WHERE i = 0;
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! ROLLBACK;
! -- check is done at end of statement, so this should succeed
! UPDATE unique_tbl SET i = i+1;
! SELECT * FROM unique_tbl;
!  i |  t   
! ---+------
!  1 | one
!  2 | two
!  3 | tree
!  4 | four
!  5 | five
! (5 rows)
! 
! -- explicitly defer the constraint
! BEGIN;
! SET CONSTRAINTS unique_tbl_i_key DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'three');
! DELETE FROM unique_tbl WHERE t = 'tree'; -- makes constraint valid again
! COMMIT; -- should succeed
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  1 | one
!  2 | two
!  4 | four
!  5 | five
!  3 | three
! (5 rows)
! 
! -- try adding an initially deferred constraint
! ALTER TABLE unique_tbl DROP CONSTRAINT unique_tbl_i_key;
! ALTER TABLE unique_tbl ADD CONSTRAINT unique_tbl_i_key
! 	UNIQUE (i) DEFERRABLE INITIALLY DEFERRED;
! BEGIN;
! INSERT INTO unique_tbl VALUES (1, 'five');
! INSERT INTO unique_tbl VALUES (5, 'one');
! UPDATE unique_tbl SET i = 4 WHERE i = 2;
! UPDATE unique_tbl SET i = 2 WHERE i = 4 AND t = 'four';
! DELETE FROM unique_tbl WHERE i = 1 AND t = 'one';
! DELETE FROM unique_tbl WHERE i = 5 AND t = 'five';
! COMMIT;
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  3 | three
!  1 | five
!  5 | one
!  4 | two
!  2 | four
! (5 rows)
! 
! -- should fail at commit-time
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! -- make constraint check immediate
! BEGIN;
! SET CONSTRAINTS ALL IMMEDIATE;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- forced check when SET CONSTRAINTS is called
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! SET CONSTRAINTS ALL IMMEDIATE; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- test a HOT update that invalidates the conflicting tuple.
! -- the trigger should still fire and catch the violation
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! UPDATE unique_tbl SET t = 'THREE' WHERE i = 3 AND t = 'Three';
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  3 | three
!  1 | five
!  5 | one
!  4 | two
!  2 | four
! (5 rows)
! 
! -- test a HOT update that modifies the newly inserted tuple,
! -- but should succeed because we then remove the other conflicting tuple.
! BEGIN;
! INSERT INTO unique_tbl VALUES(3, 'tree'); -- should succeed for now
! UPDATE unique_tbl SET t = 'threex' WHERE t = 'tree';
! DELETE FROM unique_tbl WHERE t = 'three';
! SELECT * FROM unique_tbl;
!  i |   t    
! ---+--------
!  1 | five
!  5 | one
!  4 | two
!  2 | four
!  3 | threex
! (5 rows)
! 
! COMMIT;
! SELECT * FROM unique_tbl;
!  i |   t    
! ---+--------
!  1 | five
!  5 | one
!  4 | two
!  2 | four
!  3 | threex
! (5 rows)
! 
! DROP TABLE unique_tbl;
! --
! -- EXCLUDE constraints
! --
! CREATE TABLE circles (
!   c1 CIRCLE,
!   c2 TEXT,
!   EXCLUDE USING gist
!     (c1 WITH &&, (c2::circle) WITH &&)
!     WHERE (circle_center(c1) <> '(0,0)')
! );
! -- these should succeed because they don't match the index predicate
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 5>');
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 4>');
! -- succeed
! INSERT INTO circles VALUES('<(10,10), 10>', '<(0,0), 5>');
! -- fail, overlaps
! INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>');
! ERROR:  conflicting key value violates exclusion constraint "circles_c1_c2_excl"
! DETAIL:  Key (c1, (c2::circle))=(<(20,20),10>, <(0,0),4>) conflicts with existing key (c1, (c2::circle))=(<(10,10),10>, <(0,0),5>).
! -- succeed because c1 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 1>', '<(0,0), 5>');
! -- succeed because c2 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 10>', '<(10,10), 5>');
! -- should fail on existing data without the WHERE clause
! ALTER TABLE circles ADD EXCLUDE USING gist
!   (c1 WITH &&, (c2::circle) WITH &&);
! ERROR:  could not create exclusion constraint "circles_c1_c2_excl1"
! DETAIL:  Key (c1, (c2::circle))=(<(0,0),5>, <(0,0),5>) conflicts with key (c1, (c2::circle))=(<(0,0),5>, <(0,0),4>).
! -- try reindexing an existing constraint
! REINDEX INDEX circles_c1_c2_excl;
! DROP TABLE circles;
! -- Check deferred exclusion constraint
! CREATE TABLE deferred_excl (
!   f1 int,
!   CONSTRAINT deferred_excl_con EXCLUDE (f1 WITH =) INITIALLY DEFERRED
! );
! INSERT INTO deferred_excl VALUES(1);
! INSERT INTO deferred_excl VALUES(2);
! INSERT INTO deferred_excl VALUES(1); -- fail
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(1) conflicts with existing key (f1)=(1).
! BEGIN;
! INSERT INTO deferred_excl VALUES(2); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(2) conflicts with existing key (f1)=(2).
! BEGIN;
! INSERT INTO deferred_excl VALUES(3);
! INSERT INTO deferred_excl VALUES(3); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(3) conflicts with existing key (f1)=(3).
! ALTER TABLE deferred_excl DROP CONSTRAINT deferred_excl_con;
! -- This should fail, but worth testing because of HOT updates
! UPDATE deferred_excl SET f1 = 3;
! ALTER TABLE deferred_excl ADD EXCLUDE (f1 WITH =);
! ERROR:  could not create exclusion constraint "deferred_excl_f1_excl"
! DETAIL:  Key (f1)=(3) conflicts with key (f1)=(3).
! DROP TABLE deferred_excl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/triggers.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/triggers.out	2015-01-10 10:11:46.083649449 +0300
***************
*** 1,1733 ****
! --
! -- TRIGGERS
! --
! create table pkeys (pkey1 int4 not null, pkey2 text not null);
! create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
! create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
! create index fkeys_i on fkeys (fkey1, fkey2);
! create index fkeys2_i on fkeys2 (fkey21, fkey22);
! create index fkeys2p_i on fkeys2 (pkey23);
! insert into pkeys values (10, '1');
! insert into pkeys values (20, '2');
! insert into pkeys values (30, '3');
! insert into pkeys values (40, '4');
! insert into pkeys values (50, '5');
! insert into pkeys values (60, '6');
! create unique index pkeys_i on pkeys (pkey1, pkey2);
! --
! -- For fkeys:
! -- 	(fkey1, fkey2)	--> pkeys (pkey1, pkey2)
! -- 	(fkey3)		--> fkeys2 (pkey23)
! --
! create trigger check_fkeys_pkey_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
! create trigger check_fkeys_pkey2_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure check_primary_key ('fkey3', 'fkeys2', 'pkey23');
! --
! -- For fkeys2:
! -- 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2)
! --
! create trigger check_fkeys2_pkey_exist
! 	before insert or update on fkeys2
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
! -- Test comments
! COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
! ERROR:  trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
! --
! -- For pkeys:
! -- 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE:
! -- 		fkeys (fkey1, fkey2) and fkeys2 (fkey21, fkey22)
! --
! create trigger check_pkeys_fkey_cascade
! 	before delete or update on pkeys
! 	for each row
! 	execute procedure
! 	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',
! 	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
! --
! -- For fkeys2:
! -- 	ON DELETE/UPDATE (pkey23) RESTRICT:
! -- 		fkeys (fkey3)
! --
! create trigger check_fkeys2_fkey_restrict
! 	before delete or update on fkeys2
! 	for each row
! 	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
! insert into fkeys2 values (10, '1', 1);
! insert into fkeys2 values (30, '3', 2);
! insert into fkeys2 values (40, '4', 5);
! insert into fkeys2 values (50, '5', 3);
! -- no key in pkeys
! insert into fkeys2 values (70, '5', 3);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys2_pkey_exist" found tuple referencing non-existent key in "pkeys".
! insert into fkeys values (10, '1', 2);
! insert into fkeys values (30, '3', 3);
! insert into fkeys values (40, '4', 2);
! insert into fkeys values (50, '5', 2);
! -- no key in pkeys
! insert into fkeys values (70, '5', 1);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys_pkey_exist" found tuple referencing non-existent key in "pkeys".
! -- no key in fkeys2
! insert into fkeys values (60, '6', 4);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys_pkey2_exist" found tuple referencing non-existent key in "fkeys2".
! delete from pkeys where pkey1 = 30 and pkey2 = '3';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
! CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
! delete from pkeys where pkey1 = 40 and pkey2 = '4';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
! CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 10 and pkey2 = '1';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
! DROP TABLE pkeys;
! DROP TABLE fkeys;
! DROP TABLE fkeys2;
! -- -- I've disabled the funny_dup17 test because the new semantics
! -- -- of AFTER ROW triggers, which get now fired at the end of a
! -- -- query always, cause funny_dup17 to enter an endless loop.
! -- --
! -- --      Jan
! --
! -- create table dup17 (x int4);
! --
! -- create trigger dup17_before
! -- 	before insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! --
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! --
! -- drop trigger dup17_before on dup17;
! --
! -- create trigger dup17_after
! -- 	after insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! --
! -- DROP TABLE dup17;
! create sequence ttdummy_seq increment 10 start 0 minvalue 0;
! create table tttest (
! 	price_id	int4,
! 	price_val	int4,
! 	price_on	int4,
! 	price_off	int4 default 999999
! );
! create trigger ttdummy
! 	before delete or update on tttest
! 	for each row
! 	execute procedure
! 	ttdummy (price_on, price_off);
! create trigger ttserial
! 	before insert or update on tttest
! 	for each row
! 	execute procedure
! 	autoinc (price_on, ttdummy_seq);
! insert into tttest values (1, 1, null);
! insert into tttest values (2, 2, null);
! insert into tttest values (3, 3, 0);
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |    999999
!         3 |         3 |       30 |    999999
! (3 rows)
! 
! delete from tttest where price_id = 2;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         3 |         3 |       30 |    999999
!         2 |         2 |       20 |        40
! (3 rows)
! 
! -- what do we see ?
! -- get current prices
! select * from tttest where price_off = 999999;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         3 |         3 |       30 |    999999
! (2 rows)
! 
! -- change price for price_id == 3
! update tttest set price_val = 30 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |        30 |       50 |    999999
!         3 |         3 |       30 |        50
! (4 rows)
! 
! -- now we want to change pric_id in ALL tuples
! -- this gets us not what we need
! update tttest set price_id = 5 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |         3 |       30 |        50
!         5 |        30 |       60 |    999999
!         3 |        30 |       50 |        60
! (5 rows)
! 
! -- restore data as before last update:
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! delete from tttest where price_id = 5;
! update tttest set price_off = 999999 where price_val = 30;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |         3 |       30 |        50
!         3 |        30 |       50 |    999999
! (4 rows)
! 
! -- and try change price_id now!
! update tttest set price_id = 5 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         5 |         3 |       30 |        50
!         5 |        30 |       50 |    999999
! (4 rows)
! 
! -- isn't it what we need ?
! select set_ttdummy(1);
!  set_ttdummy 
! -------------
!            0
! (1 row)
! 
! -- we want to correct some "date"
! update tttest set price_on = -1 where price_id = 1;
! ERROR:  ttdummy (tttest): you cannot change price_on and/or price_off columns (use set_ttdummy)
! -- but this doesn't work
! -- try in this way
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! update tttest set price_on = -1 where price_id = 1;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         2 |         2 |       20 |        40
!         5 |         3 |       30 |        50
!         5 |        30 |       50 |    999999
!         1 |         1 |       -1 |    999999
! (4 rows)
! 
! -- isn't it what we need ?
! -- get price for price_id == 5 as it was @ "date" 35
! select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         5 |         3 |       30 |        50
! (1 row)
! 
! drop table tttest;
! drop sequence ttdummy_seq;
! --
! -- tests for per-statement triggers
! --
! CREATE TABLE log_table (tstamp timestamp default timeofday()::timestamp);
! CREATE TABLE main_table (a int, b int);
! COPY main_table (a,b) FROM stdin;
! CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS '
! BEGIN
! 	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
! 	RETURN NULL;
! END;';
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
! --
! -- if neither 'FOR EACH ROW' nor 'FOR EACH STATEMENT' was specified,
! -- CREATE TRIGGER should default to 'FOR EACH STATEMENT'
! --
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table
! EXECUTE PROCEDURE trigger_func('after_upd_stmt');
! CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
! INSERT INTO main_table DEFAULT VALUES;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! UPDATE main_table SET a = a + 1 WHERE b < 30;
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! -- UPDATE that effects zero rows should still call per-statement trigger
! UPDATE main_table SET a = a + 2 WHERE b > 100;
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! -- COPY should fire per-row and per-statement INSERT triggers
! COPY main_table (a, b) FROM stdin;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   6 | 10
!  21 | 20
!  30 | 40
!  31 | 10
!  50 | 35
!  50 | 60
!  81 | 15
!     |   
! (8 rows)
! 
! --
! -- test triggers with WHEN clause
! --
! CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
! CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
! CREATE TRIGGER insert_a AFTER INSERT ON main_table
! FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
! CREATE TRIGGER delete_a AFTER DELETE ON main_table
! FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
! CREATE TRIGGER insert_when BEFORE INSERT ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
! CREATE TRIGGER delete_when AFTER DELETE ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
! INSERT INTO main_table (a) VALUES (123), (456);
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! COPY main_table FROM stdin;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! DELETE FROM main_table WHERE a IN (123, 456);
! NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
! NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
! NOTICE:  trigger_func(delete_when) called: action = DELETE, when = AFTER, level = STATEMENT
! UPDATE main_table SET a = 50, b = 60;
! NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   6 | 10
!  21 | 20
!  30 | 40
!  31 | 10
!  50 | 35
!  50 | 60
!  81 | 15
!     |   
! (8 rows)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!                                                              pg_get_triggerdef                                                              
! --------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.a <> new.a) EXECUTE PROCEDURE trigger_func('modified_a')
! (1 row)
! 
! SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!                                                               pg_get_triggerdef                                                               
! ----------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
! (1 row)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
!                                                                       pg_get_triggerdef                                                                       
! --------------------------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.* IS DISTINCT FROM new.*) EXECUTE PROCEDURE trigger_func('modified_any')
! (1 row)
! 
! DROP TRIGGER modified_a ON main_table;
! DROP TRIGGER modified_any ON main_table;
! DROP TRIGGER insert_a ON main_table;
! DROP TRIGGER delete_a ON main_table;
! DROP TRIGGER insert_when ON main_table;
! DROP TRIGGER delete_when ON main_table;
! -- Test column-level triggers
! DROP TRIGGER after_upd_row_trig ON main_table;
! CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
! CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
! CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
! CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
! CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
! SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
!                                                              pg_get_triggerdef                                                             
! -------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
! (1 row)
! 
! UPDATE main_table SET a = 50;
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! UPDATE main_table SET b = 10;
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! --
! -- Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN
! --
! CREATE TABLE some_t (some_col boolean NOT NULL);
! CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$
! BEGIN
!   RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',
!     TG_ARGV[0], TG_OP, OLD, NEW;
!   RETURN NEW;
! END;
! $$ LANGUAGE plpgsql;
! CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW
!   EXECUTE PROCEDURE dummy_update_func('before');
! CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT OLD.some_col AND NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('aftera');
! CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('afterb');
! INSERT INTO some_t VALUES (TRUE);
! UPDATE some_t SET some_col = TRUE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (t)
! UPDATE some_t SET some_col = FALSE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (f)
! NOTICE:  dummy_update_func(afterb) called: action = UPDATE, old = (t), new = (f)
! UPDATE some_t SET some_col = TRUE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (f), new = (t)
! NOTICE:  dummy_update_func(aftera) called: action = UPDATE, old = (f), new = (t)
! DROP TABLE some_t;
! -- bogus cases
! CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
! ERROR:  duplicate trigger events specified at or near "ON"
! LINE 1: ...ER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_ta...
!                                                              ^
! CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
! ERROR:  column "a" specified more than once
! CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
! ERROR:  syntax error at or near "OF"
! LINE 1: CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
!                                                  ^
! CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_ins_old');
! ERROR:  INSERT trigger's WHEN condition cannot reference OLD values
! LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
!                            ^
! CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_del_new');
! ERROR:  DELETE trigger's WHEN condition cannot reference NEW values
! LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
!                                     ^
! CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (NEW.tableoid <> 0)
! EXECUTE PROCEDURE trigger_func('error_when_sys_column');
! ERROR:  BEFORE trigger's WHEN condition cannot reference NEW system columns
! LINE 2: FOR EACH ROW WHEN (NEW.tableoid <> 0)
!                            ^
! CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
! EXECUTE PROCEDURE trigger_func('error_stmt_when');
! ERROR:  statement trigger's WHEN condition cannot reference column values
! LINE 2: FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
!                                  ^
! -- check dependency restrictions
! ALTER TABLE main_table DROP COLUMN b;
! ERROR:  cannot drop table main_table column b because other objects depend on it
! DETAIL:  trigger after_upd_b_row_trig on table main_table depends on table main_table column b
! trigger after_upd_a_b_row_trig on table main_table depends on table main_table column b
! trigger after_upd_b_stmt_trig on table main_table depends on table main_table column b
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- this should succeed, but we'll roll it back to keep the triggers around
! begin;
! DROP TRIGGER after_upd_a_b_row_trig ON main_table;
! DROP TRIGGER after_upd_b_row_trig ON main_table;
! DROP TRIGGER after_upd_b_stmt_trig ON main_table;
! ALTER TABLE main_table DROP COLUMN b;
! rollback;
! -- Test enable/disable triggers
! create table trigtest (i serial primary key);
! -- test that disabling RI triggers works
! create table trigtest2 (i int references trigtest(i) on delete cascade);
! create function trigtest() returns trigger as $$
! begin
! 	raise notice '% % % %', TG_RELNAME, TG_OP, TG_WHEN, TG_LEVEL;
! 	return new;
! end;$$ language plpgsql;
! create trigger trigtest_b_row_tg before insert or update or delete on trigtest
! for each row execute procedure trigtest();
! create trigger trigtest_a_row_tg after insert or update or delete on trigtest
! for each row execute procedure trigtest();
! create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! insert into trigtest default values;
! NOTICE:  trigtest INSERT BEFORE STATEMENT
! NOTICE:  trigtest INSERT BEFORE ROW
! NOTICE:  trigtest INSERT AFTER ROW
! NOTICE:  trigtest INSERT AFTER STATEMENT
! alter table trigtest disable trigger trigtest_b_row_tg;
! insert into trigtest default values;
! NOTICE:  trigtest INSERT BEFORE STATEMENT
! NOTICE:  trigtest INSERT AFTER ROW
! NOTICE:  trigtest INSERT AFTER STATEMENT
! alter table trigtest disable trigger user;
! insert into trigtest default values;
! alter table trigtest enable trigger trigtest_a_stmt_tg;
! insert into trigtest default values;
! NOTICE:  trigtest INSERT AFTER STATEMENT
! insert into trigtest2 values(1);
! insert into trigtest2 values(2);
! delete from trigtest where i=2;
! NOTICE:  trigtest DELETE AFTER STATEMENT
! select * from trigtest2;
!  i 
! ---
!  1
! (1 row)
! 
! alter table trigtest disable trigger all;
! delete from trigtest where i=1;
! select * from trigtest2;
!  i 
! ---
!  1
! (1 row)
! 
! -- ensure we still insert, even when all triggers are disabled
! insert into trigtest default values;
! select *  from trigtest;
!  i 
! ---
!  3
!  4
!  5
! (3 rows)
! 
! drop table trigtest2;
! drop table trigtest;
! -- dump trigger data
! CREATE TABLE trigger_test (
!         i int,
!         v varchar
! );
! CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
! LANGUAGE plpgsql AS $$
! 
! declare
! 
! 	argstr text;
! 	relid text;
! 
! begin
! 
! 	relid := TG_relid::regclass;
! 
! 	-- plpgsql can't discover its trigger data in a hash like perl and python
! 	-- can, or by a sort of reflection like tcl can,
! 	-- so we have to hard code the names.
! 	raise NOTICE 'TG_NAME: %', TG_name;
! 	raise NOTICE 'TG_WHEN: %', TG_when;
! 	raise NOTICE 'TG_LEVEL: %', TG_level;
! 	raise NOTICE 'TG_OP: %', TG_op;
! 	raise NOTICE 'TG_RELID::regclass: %', relid;
! 	raise NOTICE 'TG_RELNAME: %', TG_relname;
! 	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name;
! 	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema;
! 	raise NOTICE 'TG_NARGS: %', TG_nargs;
! 
! 	argstr := '[';
! 	for i in 0 .. TG_nargs - 1 loop
! 		if i > 0 then
! 			argstr := argstr || ', ';
! 		end if;
! 		argstr := argstr || TG_argv[i];
! 	end loop;
! 	argstr := argstr || ']';
! 	raise NOTICE 'TG_ARGV: %', argstr;
! 
! 	if TG_OP != 'INSERT' then
! 		raise NOTICE 'OLD: %', OLD;
! 	end if;
! 
! 	if TG_OP != 'DELETE' then
! 		raise NOTICE 'NEW: %', NEW;
! 	end if;
! 
! 	if TG_OP = 'DELETE' then
! 		return OLD;
! 	else
! 		return NEW;
! 	end if;
! 
! end;
! $$;
! CREATE TRIGGER show_trigger_data_trig
! BEFORE INSERT OR UPDATE OR DELETE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
! insert into trigger_test values(1,'insert');
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: INSERT
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  NEW: (1,insert)
! update trigger_test set v = 'update' where i = 1;
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: UPDATE
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  OLD: (1,insert)
! NOTICE:  NEW: (1,update)
! delete from trigger_test;
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: DELETE
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  OLD: (1,update)
! DROP TRIGGER show_trigger_data_trig on trigger_test;
! DROP FUNCTION trigger_data();
! DROP TABLE trigger_test;
! --
! -- Test use of row comparisons on OLD/NEW
! --
! CREATE TABLE trigger_test (f1 int, f2 text, f3 text);
! -- this is the obvious (and wrong...) way to compare rows
! CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) = row(new.*) then
! 		raise notice 'row % not changed', new.f1;
! 	else
! 		raise notice 'row % changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! CREATE TRIGGER t
! BEFORE UPDATE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE mytrigger();
! INSERT INTO trigger_test VALUES(1, 'foo', 'bar');
! INSERT INTO trigger_test VALUES(2, 'baz', 'quux');
! UPDATE trigger_test SET f3 = 'bar';
! NOTICE:  row 1 not changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! -- this demonstrates that the above isn't really working as desired:
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! -- the right way when considering nulls is
! CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) is distinct from row(new.*) then
! 		raise notice 'row % changed', new.f1;
! 	else
! 		raise notice 'row % not changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! UPDATE trigger_test SET f3 = 'bar';
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 not changed
! NOTICE:  row 2 not changed
! DROP TABLE trigger_test;
! DROP FUNCTION mytrigger();
! -- Test snapshot management in serializable transactions involving triggers
! -- per bug report in 6bc73d4c0910042358k3d1adff3qa36f8df75198ecea@mail.gmail.com
! CREATE FUNCTION serializable_update_trig() RETURNS trigger LANGUAGE plpgsql AS
! $$
! declare
! 	rec record;
! begin
! 	new.description = 'updated in trigger';
! 	return new;
! end;
! $$;
! CREATE TABLE serializable_update_tab (
! 	id int,
! 	filler  text,
! 	description text
! );
! CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab
! 	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
! INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new'
! 	FROM generate_series(1, 50) a;
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE serializable_update_tab SET description = 'no no', id = 1 WHERE id = 1;
! COMMIT;
! SELECT description FROM serializable_update_tab WHERE id = 1;
!     description     
! --------------------
!  updated in trigger
! (1 row)
! 
! DROP TABLE serializable_update_tab;
! -- minimal update trigger
! CREATE TABLE min_updates_test (
! 	f1	text,
! 	f2 int,
! 	f3 int);
! CREATE TABLE min_updates_test_oids (
! 	f1	text,
! 	f2 int,
! 	f3 int) WITH OIDS;
! INSERT INTO min_updates_test VALUES ('a',1,2),('b','2',null);
! INSERT INTO min_updates_test_oids VALUES ('a',1,2),('b','2',null);
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test_oids
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! \set QUIET false
! UPDATE min_updates_test SET f1 = f1;
! UPDATE 0
! UPDATE min_updates_test SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! UPDATE min_updates_test_oids SET f1 = f1;
! UPDATE 0
! UPDATE min_updates_test_oids SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test_oids SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! \set QUIET true
! SELECT * FROM min_updates_test;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! SELECT * FROM min_updates_test_oids;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! DROP TABLE min_updates_test;
! DROP TABLE min_updates_test_oids;
! --
! -- Test triggers on views
! --
! CREATE VIEW main_view AS SELECT a, b FROM main_table;
! -- VIEW trigger function
! CREATE OR REPLACE FUNCTION view_trigger() RETURNS trigger
! LANGUAGE plpgsql AS $$
! declare
!     argstr text := '';
! begin
!     for i in 0 .. TG_nargs - 1 loop
!         if i > 0 then
!             argstr := argstr || ', ';
!         end if;
!         argstr := argstr || TG_argv[i];
!     end loop;
! 
!     raise notice '% % % % (%)', TG_RELNAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;
! 
!     if TG_LEVEL = 'ROW' then
!         if TG_OP = 'INSERT' then
!             raise NOTICE 'NEW: %', NEW;
!             INSERT INTO main_table VALUES (NEW.a, NEW.b);
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'UPDATE' then
!             raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
!             UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'DELETE' then
!             raise NOTICE 'OLD: %', OLD;
!             DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN OLD;
!         end if;
!     end if;
! 
!     RETURN NULL;
! end;
! $$;
! -- Before row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! -- After row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! -- Truncate triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have TRUNCATE triggers.
! CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have TRUNCATE triggers.
! -- INSTEAD OF triggers aren't allowed on tables
! CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! -- Don't support WHEN clauses with INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers cannot have WHEN conditions
! -- Don't support column-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers cannot have column lists
! -- Don't support statement-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers must be FOR EACH ROW
! -- Valid INSTEAD OF triggers
! CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! -- Valid BEFORE statement VIEW triggers
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
! CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
! CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
! -- Valid AFTER statement VIEW triggers
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
! CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
! \set QUIET false
! -- Insert into view using trigger
! INSERT INTO main_view VALUES (20, 30);
! NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
! NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
! NOTICE:  NEW: (20,30)
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
! INSERT 0 1
! INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
! NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
! NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
! NOTICE:  NEW: (21,31)
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
!  a  | b  
! ----+----
!  21 | 31
! (1 row)
! 
! INSERT 0 1
! -- Table trigger will prevent updates
! UPDATE main_view SET b = 31 WHERE a = 20;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (20,30), NEW: (20,31)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 0
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (21,31), NEW: (21,32)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
!  a | b 
! ---+---
! (0 rows)
! 
! UPDATE 0
! -- Remove table trigger to allow updates
! DROP TRIGGER before_upd_a_row_trig ON main_table;
! DROP TRIGGER
! UPDATE main_view SET b = 31 WHERE a = 20;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (20,30), NEW: (20,31)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 1
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (21,31), NEW: (21,32)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
!  a  | b  
! ----+----
!  21 | 32
! (1 row)
! 
! UPDATE 1
! -- Before and after stmt triggers should fire even when no rows are affected
! UPDATE main_view SET b = 0 WHERE false;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 0
! -- Delete from view using trigger
! DELETE FROM main_view WHERE a IN (20,21);
! NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (21,10)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (20,31)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (21,32)
! NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
! DELETE 3
! DELETE FROM main_view WHERE a = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (31,10)
! NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
!  a  | b  
! ----+----
!  31 | 10
! (1 row)
! 
! DELETE 1
! \set QUIET true
! -- Describe view should list triggers
! \d main_view
!    View "public.main_view"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
! Triggers:
!     after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt')
!     after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt')
!     after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt')
!     before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt')
!     before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt')
!     before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt')
!     instead_of_delete_trig INSTEAD OF DELETE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del')
!     instead_of_insert_trig INSTEAD OF INSERT ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins')
!     instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd')
! 
! -- Test dropping view triggers
! DROP TRIGGER instead_of_insert_trig ON main_view;
! DROP TRIGGER instead_of_delete_trig ON main_view;
! \d+ main_view
!                View "public.main_view"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
!  b      | integer |           | plain   | 
! View definition:
!  SELECT main_table.a,
!     main_table.b
!    FROM main_table;
! Triggers:
!     after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt')
!     after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt')
!     after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt')
!     before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt')
!     before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt')
!     before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt')
!     instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd')
! 
! DROP VIEW main_view;
! --
! -- Test triggers on a join view
! --
! CREATE TABLE country_table (
!     country_id        serial primary key,
!     country_name    text unique not null,
!     continent        text not null
! );
! INSERT INTO country_table (country_name, continent)
!     VALUES ('Japan', 'Asia'),
!            ('UK', 'Europe'),
!            ('USA', 'North America')
!     RETURNING *;
!  country_id | country_name |   continent   
! ------------+--------------+---------------
!           1 | Japan        | Asia
!           2 | UK           | Europe
!           3 | USA          | North America
! (3 rows)
! 
! CREATE TABLE city_table (
!     city_id        serial primary key,
!     city_name    text not null,
!     population    bigint,
!     country_id    int references country_table
! );
! CREATE VIEW city_view AS
!     SELECT city_id, city_name, population, country_name, continent
!     FROM city_table ci
!     LEFT JOIN country_table co ON co.country_id = ci.country_id;
! CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS NOT NULL then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
!     else
!         NEW.continent := NULL;
!     end if;
! 
!     if NEW.city_id IS NOT NULL then
!         INSERT INTO city_table
!             VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
!     else
!         INSERT INTO city_table(city_name, population, country_id)
!             VALUES(NEW.city_name, NEW.population, ctry_id)
!             RETURNING city_id INTO NEW.city_id;
!     end if;
! 
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_insert();
! CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
! begin
!     DELETE FROM city_table WHERE city_id = OLD.city_id;
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN OLD;
! end;
! $$;
! CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_delete();
! CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS DISTINCT FROM OLD.country_name then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
! 
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population,
!                               country_id = ctry_id
!             WHERE city_id = OLD.city_id;
!     else
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population
!             WHERE city_id = OLD.city_id;
!         NEW.continent := OLD.continent;
!     end if;
! 
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_update();
! \set QUIET false
! -- INSERT .. RETURNING
! INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |            |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        2 | London    |    7556900 |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
!  city_id |   city_name   | population | country_name |   continent   
! ---------+---------------+------------+--------------+---------------
!        3 | Washington DC |            | USA          | North America
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!   123456 | New York  |            |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! INSERT 0 1
! -- UPDATE .. RETURNING
! UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- error
! ERROR:  No such country: "Japon"
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no match
! UPDATE 0
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OK
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |            | Japan        | Asia
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |   13010279 | Japan        | Asia
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!   123456 | New York  |            | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
!  city_id | city_name | population | country_name |   continent   
! ---------+-----------+------------+--------------+---------------
!   123456 | New York  |    8391881 | USA          | North America
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
!     WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
!  city_id | city_name | population | country_name | continent | city_id | city_name  | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------+---------+------------+------------+--------------+-----------
!        2 | London    |    7556900 | UK           | Europe    |  234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! -- DELETE .. RETURNING
! DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! DELETE 1
! \set QUIET true
! -- read-only view with WHERE clause
! CREATE VIEW european_city_view AS
!     SELECT * FROM city_view WHERE continent = 'Europe';
! SELECT count(*) FROM european_city_view;
!  count 
! -------
!      1
! (1 row)
! 
! CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
! AS 'begin RETURN NULL; end';
! CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
! ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
! \set QUIET false
! INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
! INSERT 0 0
! UPDATE european_city_view SET population = 10000;
! UPDATE 0
! DELETE FROM european_city_view;
! DELETE 0
! \set QUIET true
! -- rules bypassing no-op triggers
! CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
! DO INSTEAD INSERT INTO city_view
! VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
! RETURNING *;
! CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
! DO INSTEAD UPDATE city_view SET
!     city_name = NEW.city_name,
!     population = NEW.population,
!     country_name = NEW.country_name
! WHERE city_id = OLD.city_id
! RETURNING NEW.*;
! CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
! DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
! \set QUIET false
! -- INSERT not limited by view's WHERE clause, but UPDATE AND DELETE are
! INSERT INTO european_city_view(city_name, country_name)
!     VALUES ('Cambridge', 'USA') RETURNING *;
!  city_id | city_name | population | country_name |   continent   
! ---------+-----------+------------+--------------+---------------
!        4 | Cambridge |            | USA          | North America
! (1 row)
! 
! INSERT 0 1
! UPDATE european_city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge';
! UPDATE 0
! DELETE FROM european_city_view WHERE city_name = 'Cambridge';
! DELETE 0
! -- UPDATE and DELETE via rule and trigger
! UPDATE city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |            | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE european_city_view SET population = 122800
!     WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |     122800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |     122800 | UK           | Europe
! (1 row)
! 
! DELETE 1
! -- join UPDATE test
! UPDATE city_view v SET population = 599657
!     FROM city_table ci, country_table co
!     WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'
!     AND v.city_id = ci.city_id AND v.country_name = co.country_name
!     RETURNING co.country_id, v.country_name,
!               v.city_id, v.city_name, v.population;
!  country_id | country_name | city_id |   city_name   | population 
! ------------+--------------+---------+---------------+------------
!           3 | USA          |       3 | Washington DC |     599657
! (1 row)
! 
! UPDATE 1
! \set QUIET true
! SELECT * FROM city_view;
!  city_id |   city_name   | population | country_name |   continent   
! ---------+---------------+------------+--------------+---------------
!        1 | Tokyo         |   13010279 | Japan        | Asia
!   123456 | New York      |    8391881 | USA          | North America
!        2 | London        |    7556900 | UK           | Europe
!        3 | Washington DC |     599657 | USA          | North America
! (4 rows)
! 
! DROP TABLE city_table CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view city_view
! drop cascades to view european_city_view
! DROP TABLE country_table;
! -- Test pg_trigger_depth()
! create table depth_a (id int not null primary key);
! create table depth_b (id int not null primary key);
! create table depth_c (id int not null primary key);
! create function depth_a_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   insert into depth_b values (new.id);
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_a_tr before insert on depth_a
!   for each row execute procedure depth_a_tf();
! create function depth_b_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   begin
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   exception
!     when sqlstate 'U9999' then
!       raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
!   end;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   end if;
!   return new;
! end;
! $$;
! create trigger depth_b_tr before insert on depth_b
!   for each row execute procedure depth_b_tf();
! create function depth_c_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     raise exception sqlstate 'U9999';
!   end if;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_c_tr before insert on depth_c
!   for each row execute procedure depth_c_tf();
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (1);
! NOTICE:  depth_a_tr: depth = 1
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  SQLSTATE = U9999: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 12 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! ERROR:  U9999
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 12 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (2);
! NOTICE:  depth_a_tr: depth = 1
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (2)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (2)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_a_tr: depth = 1
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! drop table depth_a, depth_b, depth_c;
! drop function depth_a_tf();
! drop function depth_b_tf();
! drop function depth_c_tf();
! --
! -- Test updates to rows during firing of BEFORE ROW triggers.
! -- As of 9.2, such cases should be rejected (see bug #6123).
! --
! create temp table parent (
!     aid int not null primary key,
!     val1 text,
!     val2 text,
!     val3 text,
!     val4 text,
!     bcnt int not null default 0);
! create temp table child (
!     bid int not null primary key,
!     aid int not null,
!     val1 text);
! create function parent_upd_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.val1 <> new.val1 then
!     new.val2 = new.val1;
!     delete from child where child.aid = new.aid and child.val1 = new.val1;
!   end if;
!   return new;
! end;
! $$;
! create trigger parent_upd_trig before update on parent
!   for each row execute procedure parent_upd_func();
! create function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger parent_del_trig before delete on parent
!   for each row execute procedure parent_del_func();
! create function child_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt + 1 where aid = new.aid;
!   return new;
! end;
! $$;
! create trigger child_ins_trig after insert on child
!   for each row execute procedure child_ins_func();
! create function child_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt - 1 where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger child_del_trig after delete on child
!   for each row execute procedure child_del_func();
! insert into parent values (1, 'a', 'a', 'a', 'a', 0);
! insert into child values (10, 1, 'b');
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! update parent set val1 = 'b' where aid = 1; -- should fail
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! delete from parent where aid = 1; -- should fail
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! -- replace the trigger function with one that restarts the deletion after
! -- having modified a child
! create or replace function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   if found then
!     delete from parent where aid = old.aid;
!     return null; -- cancel outer deletion
!   end if;
!   return old;
! end;
! $$;
! delete from parent where aid = 1;
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
! (0 rows)
! 
!  bid | aid | val1 
! -----+-----+------
! (0 rows)
! 
! drop table parent, child;
! drop function parent_upd_func();
! drop function parent_del_func();
! drop function child_ins_func();
! drop function child_del_func();
! -- similar case, but with a self-referencing FK so that parent and child
! -- rows can be affected by a single operation
! create temp table self_ref_trigger (
!     id int primary key,
!     parent int references self_ref_trigger,
!     data text,
!     nchildren int not null default 0
! );
! create function self_ref_trigger_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if new.parent is not null then
!     update self_ref_trigger set nchildren = nchildren + 1
!       where id = new.parent;
!   end if;
!   return new;
! end;
! $$;
! create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
!   for each row execute procedure self_ref_trigger_ins_func();
! create function self_ref_trigger_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.parent is not null then
!     update self_ref_trigger set nchildren = nchildren - 1
!       where id = old.parent;
!   end if;
!   return old;
! end;
! $$;
! create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
!   for each row execute procedure self_ref_trigger_del_func();
! insert into self_ref_trigger values (1, null, 'root');
! insert into self_ref_trigger values (2, 1, 'root child A');
! insert into self_ref_trigger values (3, 1, 'root child B');
! insert into self_ref_trigger values (4, 2, 'grandchild 1');
! insert into self_ref_trigger values (5, 3, 'grandchild 2');
! update self_ref_trigger set data = 'root!' where id = 1;
! select * from self_ref_trigger;
!  id | parent |     data     | nchildren 
! ----+--------+--------------+-----------
!   2 |      1 | root child A |         1
!   4 |      2 | grandchild 1 |         0
!   3 |      1 | root child B |         1
!   5 |      3 | grandchild 2 |         0
!   1 |        | root!        |         2
! (5 rows)
! 
! delete from self_ref_trigger;
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from self_ref_trigger;
!  id | parent |     data     | nchildren 
! ----+--------+--------------+-----------
!   2 |      1 | root child A |         1
!   4 |      2 | grandchild 1 |         0
!   3 |      1 | root child B |         1
!   5 |      3 | grandchild 2 |         0
!   1 |        | root!        |         2
! (5 rows)
! 
! drop table self_ref_trigger;
! drop function self_ref_trigger_ins_func();
! drop function self_ref_trigger_del_func();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/inherit.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/inherit.out	2015-01-10 10:11:46.079649449 +0300
***************
*** 1,1457 ****
! --
! -- Test inheritance features
! --
! CREATE TABLE a (aa TEXT);
! CREATE TABLE b (bb TEXT) INHERITS (a);
! CREATE TABLE c (cc TEXT) INHERITS (a);
! CREATE TABLE d (dd TEXT) INHERITS (b,c,a);
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "aa"
! INSERT INTO a(aa) VALUES('aaa');
! INSERT INTO a(aa) VALUES('aaaa');
! INSERT INTO a(aa) VALUES('aaaaa');
! INSERT INTO a(aa) VALUES('aaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaaa');
! INSERT INTO b(aa) VALUES('bbb');
! INSERT INTO b(aa) VALUES('bbbb');
! INSERT INTO b(aa) VALUES('bbbbb');
! INSERT INTO b(aa) VALUES('bbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbbb');
! INSERT INTO c(aa) VALUES('ccc');
! INSERT INTO c(aa) VALUES('cccc');
! INSERT INTO c(aa) VALUES('ccccc');
! INSERT INTO c(aa) VALUES('cccccc');
! INSERT INTO c(aa) VALUES('ccccccc');
! INSERT INTO c(aa) VALUES('cccccccc');
! INSERT INTO d(aa) VALUES('ddd');
! INSERT INTO d(aa) VALUES('dddd');
! INSERT INTO d(aa) VALUES('ddddd');
! INSERT INTO d(aa) VALUES('dddddd');
! INSERT INTO d(aa) VALUES('ddddddd');
! INSERT INTO d(aa) VALUES('dddddddd');
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | aaa
!  a       | aaaa
!  a       | aaaaa
!  a       | aaaaaa
!  a       | aaaaaaa
!  a       | aaaaaaaa
!  b       | bbb
!  b       | bbbb
!  b       | bbbbb
!  b       | bbbbbb
!  b       | bbbbbbb
!  b       | bbbbbbbb
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | ddd
!  d       | dddd
!  d       | ddddd
!  d       | dddddd
!  d       | ddddddd
!  d       | dddddddd
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | aaa
!  a       | aaaa
!  a       | aaaaa
!  a       | aaaaaa
!  a       | aaaaaaa
!  a       | aaaaaaaa
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='zzzz' WHERE aa='aaaa';
! UPDATE ONLY a SET aa='zzzzz' WHERE aa='aaaaa';
! UPDATE b SET aa='zzz' WHERE aa='aaa';
! UPDATE ONLY b SET aa='zzz' WHERE aa='aaa';
! UPDATE a SET aa='zzzzzz' WHERE aa LIKE 'aaa%';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  b       | bbb
!  b       | bbbb
!  b       | bbbbb
!  b       | bbbbbb
!  b       | bbbbbbb
!  b       | bbbbbbbb
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | ddd
!  d       | dddd
!  d       | ddddd
!  d       | dddddd
!  d       | ddddddd
!  d       | dddddddd
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |   aa   
! ---------+--------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! UPDATE b SET aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |   aa   
! ---------+--------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='new';
! DELETE FROM ONLY c WHERE aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa  
! ---------+-----
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
! (18 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa  | cc 
! ---------+-----+----
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (6 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa  
! ---------+-----
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! DELETE FROM a;
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- Confirm PRIMARY KEY adds NOT NULL constraint to child table
! CREATE TEMP TABLE z (b TEXT, PRIMARY KEY(aa, b)) inherits (a);
! INSERT INTO z VALUES (NULL, 'text'); -- should fail
! ERROR:  null value in column "aa" violates not-null constraint
! DETAIL:  Failing row contains (null, text).
! -- Check UPDATE with inherited target and an inherited source table
! create temp table foo(f1 int, f2 int);
! create temp table foo2(f3 int) inherits (foo);
! create temp table bar(f1 int, f2 int);
! create temp table bar2(f3 int) inherits (bar);
! insert into foo values(1,1);
! insert into foo values(3,3);
! insert into foo2 values(2,2,2);
! insert into foo2 values(3,3,3);
! insert into bar values(1,1);
! insert into bar values(2,2);
! insert into bar values(3,3);
! insert into bar values(4,4);
! insert into bar2 values(1,1,1);
! insert into bar2 values(2,2,2);
! insert into bar2 values(3,3,3);
! insert into bar2 values(4,4,4);
! update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
! select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
!  relname | f1 | f2  
! ---------+----+-----
!  bar     |  1 | 101
!  bar     |  2 | 102
!  bar     |  3 | 103
!  bar     |  4 |   4
!  bar2    |  1 | 101
!  bar2    |  2 | 102
!  bar2    |  3 | 103
!  bar2    |  4 |   4
! (8 rows)
! 
! -- Check UPDATE with inherited target and an appendrel subquery
! update bar set f2 = f2 + 100
! from
!   ( select f1 from foo union all select f1+3 from foo ) ss
! where bar.f1 = ss.f1;
! select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
!  relname | f1 | f2  
! ---------+----+-----
!  bar     |  1 | 201
!  bar     |  2 | 202
!  bar     |  3 | 203
!  bar     |  4 | 104
!  bar2    |  1 | 201
!  bar2    |  2 | 202
!  bar2    |  3 | 203
!  bar2    |  4 | 104
! (8 rows)
! 
! /* Test multiple inheritance of column defaults */
! CREATE TABLE firstparent (tomorrow date default now()::date + 1);
! CREATE TABLE secondparent (tomorrow date default  now() :: date  +  1);
! CREATE TABLE jointchild () INHERITS (firstparent, secondparent);  -- ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! CREATE TABLE thirdparent (tomorrow date default now()::date - 1);
! CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);  -- not ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! ERROR:  column "tomorrow" inherits conflicting default values
! HINT:  To resolve the conflict, specify a default explicitly.
! CREATE TABLE otherchild (tomorrow date default now())
!   INHERITS (firstparent, thirdparent);  -- ok, child resolves ambiguous default
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! NOTICE:  merging column "tomorrow" with inherited definition
! DROP TABLE firstparent, secondparent, jointchild, thirdparent, otherchild;
! -- Test changing the type of inherited columns
! insert into d values('test','one','two','three');
! alter table a alter column aa type integer using bit_length(aa);
! select * from d;
!  aa | bb  | cc  |  dd   
! ----+-----+-----+-------
!  32 | one | two | three
! (1 row)
! 
! -- Test non-inheritable parent constraints
! create table p1(ff1 int);
! alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
! alter table p1 add constraint p2chk check (ff1 > 10);
! -- connoinherit should be true for NO INHERIT constraint
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.connoinherit from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname = 'p1' order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | connoinherit 
! ---------+---------+---------+------------+-------------+--------------
!  p1      | p1chk   | c       | t          |           0 | t
!  p1      | p2chk   | c       | t          |           0 | f
! (2 rows)
! 
! -- Test that child does not inherit NO INHERIT constraints
! create table c1 () inherits (p1);
! \d p1
!       Table "public.p1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  ff1    | integer | 
! Check constraints:
!     "p1chk" CHECK (ff1 > 0) NO INHERIT
!     "p2chk" CHECK (ff1 > 10)
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d c1
!       Table "public.c1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  ff1    | integer | 
! Check constraints:
!     "p2chk" CHECK (ff1 > 10)
! Inherits: p1
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! -- Tests for casting between the rowtypes of parent and child
! -- tables. See the pgsql-hackers thread beginning Dec. 4/04
! create table base (i integer);
! create table derived () inherits (base);
! insert into derived (i) values (0);
! select derived::base from derived;
!  derived 
! ---------
!  (0)
! (1 row)
! 
! drop table derived;
! drop table base;
! create table p1(ff1 int);
! create table p2(f1 text);
! create function p2text(p2) returns text as 'select $1.f1' language sql;
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(123456789, 'hi', 42);
! select p2text(c1.*) from c1;
!  p2text 
! --------
!  hi
! (1 row)
! 
! drop function p2text(p2);
! drop table c1;
! drop table p2;
! drop table p1;
! CREATE TABLE ac (aa TEXT);
! alter table ac add constraint ac_check check (aa is not null);
! CREATE TABLE bc (bb TEXT) INHERITS (ac);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_check" of relation "bc"
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! -- try the unnamed-constraint case
! alter table ac add check (aa is not null);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname |   conname   | contype | conislocal | coninhcount |      consrc      
! ---------+-------------+---------+------------+-------------+------------------
!  ac      | ac_aa_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_aa_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_aa_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_aa_check" of relation "bc"
! alter table ac drop constraint ac_aa_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! alter table ac add constraint ac_check check (aa is not null);
! alter table bc no inherit ac;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (2 rows)
! 
! alter table bc drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (1 row)
! 
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0));
! create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging constraint "check_a" with inherited definition
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_a | c       | t          |           1 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
! (3 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0));
! create table bc (b int constraint check_b check (b <> 0));
! create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | f          |           1 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! alter table cc no inherit bc;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! drop table cc;
! drop table bc;
! drop table ac;
! create table p1(f1 int);
! create table p2(f2 int);
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(1,-1,2);
! alter table p2 add constraint cc check (f2>0);  -- fail
! ERROR:  check constraint "cc" is violated by some row
! alter table p2 add check (f2>0);  -- check it without a name, too
! ERROR:  check constraint "p2_f2_check" is violated by some row
! delete from c1;
! insert into c1 values(1,1,2);
! alter table p2 add check (f2>0);
! insert into c1 values(1,-1,2);  -- fail
! ERROR:  new row for relation "c1" violates check constraint "p2_f2_check"
! DETAIL:  Failing row contains (1, -1, 2).
! create table c2(f3 int) inherits(p1,p2);
! \d c2
!       Table "public.c2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | integer | 
!  f3     | integer | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: p1,
!           p2
! 
! create table c3 (f4 int) inherits(c1,c2);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "f2"
! NOTICE:  merging multiple inherited definitions of column "f3"
! \d c3
!       Table "public.c3"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | integer | 
!  f3     | integer | 
!  f4     | integer | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: c1,
!           c2
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table c1
! drop cascades to table c2
! drop cascades to table c3
! drop table p2 cascade;
! create table pp1 (f1 int);
! create table cc1 (f2 text, f3 int) inherits (pp1);
! alter table pp1 add column a1 int check (a1 > 0);
! \d cc1
!       Table "public.cc1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | text    | 
!  f3     | integer | 
!  a1     | integer | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1
! 
! create table cc2(f4 float) inherits(pp1,cc1);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "a1"
! \d cc2
!           Table "public.cc2"
!  Column |       Type       | Modifiers 
! --------+------------------+-----------
!  f1     | integer          | 
!  a1     | integer          | 
!  f2     | text             | 
!  f3     | integer          | 
!  f4     | double precision | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1,
!           cc1
! 
! alter table pp1 add column a2 int check (a2 > 0);
! NOTICE:  merging definition of column "a2" for child "cc2"
! NOTICE:  merging constraint "pp1_a2_check" with inherited definition
! \d cc2
!           Table "public.cc2"
!  Column |       Type       | Modifiers 
! --------+------------------+-----------
!  f1     | integer          | 
!  a1     | integer          | 
!  f2     | text             | 
!  f3     | integer          | 
!  f4     | double precision | 
!  a2     | integer          | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
!     "pp1_a2_check" CHECK (a2 > 0)
! Inherits: pp1,
!           cc1
! 
! drop table pp1 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table cc1
! drop cascades to table cc2
! -- Test for renaming in simple multiple inheritance
! CREATE TABLE inht1 (a int, b int);
! CREATE TABLE inhs1 (b int, c int);
! CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME a TO aa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! ALTER TABLE inhts RENAME aa TO aaa;      -- to be failed
! ERROR:  cannot rename inherited column "aa"
! ALTER TABLE inhts RENAME d TO dd;
! \d+ inhts
!                         Table "public.inhts"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aa     | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  c      | integer |           | plain   |              | 
!  dd     | integer |           | plain   |              | 
! Inherits: inht1,
!           inhs1
! 
! DROP TABLE inhts;
! -- Test for renaming in diamond inheritance
! CREATE TABLE inht2 (x int) INHERITS (inht1);
! CREATE TABLE inht3 (y int) INHERITS (inht1);
! CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aa TO aaa;
! \d+ inht4
!                         Table "public.inht4"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aaa    | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  x      | integer |           | plain   |              | 
!  y      | integer |           | plain   |              | 
!  z      | integer |           | plain   |              | 
! Inherits: inht2,
!           inht3
! 
! CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aaa TO aaaa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! \d+ inhts
!                         Table "public.inhts"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aaaa   | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  x      | integer |           | plain   |              | 
!  c      | integer |           | plain   |              | 
!  d      | integer |           | plain   |              | 
! Inherits: inht2,
!           inhs1
! 
! WITH RECURSIVE r AS (
!   SELECT 'inht1'::regclass AS inhrelid
! UNION ALL
!   SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparent
! )
! SELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected
!   FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits
!         WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e
!   JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal
!   ORDER BY a.attrelid::regclass::name, a.attnum;
!  attrelid | attname | attinhcount | expected 
! ----------+---------+-------------+----------
!  inht2    | aaaa    |           1 |        1
!  inht2    | b       |           1 |        1
!  inht3    | aaaa    |           1 |        1
!  inht3    | b       |           1 |        1
!  inht4    | aaaa    |           2 |        2
!  inht4    | b       |           2 |        2
!  inht4    | x       |           1 |        2
!  inht4    | y       |           1 |        2
!  inhts    | aaaa    |           1 |        1
!  inhts    | b       |           2 |        1
!  inhts    | x       |           1 |        1
!  inhts    | c       |           1 |        1
! (12 rows)
! 
! DROP TABLE inht1, inhs1 CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table inht2
! drop cascades to table inhts
! drop cascades to table inht3
! drop cascades to table inht4
! -- Test non-inheritable indices [UNIQUE, EXCLUDE] contraints
! CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
! CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
! \d+ test_constraints
!                         Table "public.test_constraints"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Indexes:
!     "test_constraints_val1_val2_key" UNIQUE CONSTRAINT, btree (val1, val2)
! Child tables: test_constraints_inh
! 
! ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
! \d+ test_constraints
!                         Table "public.test_constraints"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Child tables: test_constraints_inh
! 
! \d+ test_constraints_inh
!                       Table "public.test_constraints_inh"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Inherits: test_constraints
! 
! DROP TABLE test_constraints_inh;
! DROP TABLE test_constraints;
! CREATE TABLE test_ex_constraints (
!     c circle,
!     EXCLUDE USING gist (c WITH &&)
! );
! CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
! \d+ test_ex_constraints
!                  Table "public.test_ex_constraints"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Indexes:
!     "test_ex_constraints_c_excl" EXCLUDE USING gist (c WITH &&)
! Child tables: test_ex_constraints_inh
! 
! ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
! \d+ test_ex_constraints
!                  Table "public.test_ex_constraints"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Child tables: test_ex_constraints_inh
! 
! \d+ test_ex_constraints_inh
!                Table "public.test_ex_constraints_inh"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Inherits: test_ex_constraints
! 
! DROP TABLE test_ex_constraints_inh;
! DROP TABLE test_ex_constraints;
! -- Test non-inheritable foreign key contraints
! CREATE TABLE test_primary_constraints(id int PRIMARY KEY);
! CREATE TABLE test_foreign_constraints(id1 int REFERENCES test_primary_constraints(id));
! CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
! \d+ test_primary_constraints
!                Table "public.test_primary_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id     | integer | not null  | plain   |              | 
! Indexes:
!     "test_primary_constraints_pkey" PRIMARY KEY, btree (id)
! Referenced by:
!     TABLE "test_foreign_constraints" CONSTRAINT "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! 
! \d+ test_foreign_constraints
!                Table "public.test_foreign_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Foreign-key constraints:
!     "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! Child tables: test_foreign_constraints_inh
! 
! ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
! \d+ test_foreign_constraints
!                Table "public.test_foreign_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Child tables: test_foreign_constraints_inh
! 
! \d+ test_foreign_constraints_inh
!              Table "public.test_foreign_constraints_inh"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Inherits: test_foreign_constraints
! 
! DROP TABLE test_foreign_constraints_inh;
! DROP TABLE test_foreign_constraints;
! DROP TABLE test_primary_constraints;
! --
! -- Test parameterized append plans for inheritance trees
! --
! create temp table patest0 (id, x) as
!   select x, x from generate_series(0,1000) x;
! create temp table patest1() inherits (patest0);
! insert into patest1
!   select x, x from generate_series(0,1000) x;
! create temp table patest2() inherits (patest0);
! insert into patest2
!   select x, x from generate_series(0,1000) x;
! create index patest0i on patest0(id);
! create index patest1i on patest1(id);
! create index patest2i on patest2(id);
! analyze patest0;
! analyze patest1;
! analyze patest2;
! explain (costs off)
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using patest0i on patest0
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest1i on patest1
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest2i on patest2
!                Index Cond: (id = int4_tbl.f1)
! (10 rows)
! 
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop index patest2i;
! explain (costs off)
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using patest0i on patest0
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest1i on patest1
!                Index Cond: (id = int4_tbl.f1)
!          ->  Seq Scan on patest2
!                Filter: (int4_tbl.f1 = id)
! (10 rows)
! 
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop table patest0 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table patest1
! drop cascades to table patest2
! --
! -- Test merge-append plans for inheritance trees
! --
! create table matest0 (id serial primary key, name text);
! create table matest1 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest2 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest3 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create index matest0i on matest0 ((1-id));
! create index matest1i on matest1 ((1-id));
! -- create index matest2i on matest2 ((1-id));  -- intentionally missing
! create index matest3i on matest3 ((1-id));
! insert into matest1 (name) values ('Test 1');
! insert into matest1 (name) values ('Test 2');
! insert into matest2 (name) values ('Test 3');
! insert into matest2 (name) values ('Test 4');
! insert into matest3 (name) values ('Test 5');
! insert into matest3 (name) values ('Test 6');
! set enable_indexscan = off;  -- force use of seqscan/sort, so no merge
! explain (verbose, costs off) select * from matest0 order by 1-id;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Sort
!    Output: matest0.id, matest0.name, ((1 - matest0.id))
!    Sort Key: ((1 - matest0.id))
!    ->  Result
!          Output: matest0.id, matest0.name, (1 - matest0.id)
!          ->  Append
!                ->  Seq Scan on public.matest0
!                      Output: matest0.id, matest0.name
!                ->  Seq Scan on public.matest1
!                      Output: matest1.id, matest1.name
!                ->  Seq Scan on public.matest2
!                      Output: matest2.id, matest2.name
!                ->  Seq Scan on public.matest3
!                      Output: matest3.id, matest3.name
! (14 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                QUERY PLAN               
! ----------------------------------------
!  Aggregate
!    Output: min((1 - matest0.id))
!    ->  Append
!          ->  Seq Scan on public.matest0
!                Output: matest0.id
!          ->  Seq Scan on public.matest1
!                Output: matest1.id
!          ->  Seq Scan on public.matest2
!                Output: matest2.id
!          ->  Seq Scan on public.matest3
!                Output: matest3.id
! (11 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_indexscan;
! set enable_seqscan = off;  -- plan with fewest seqscans should be merge
! explain (verbose, costs off) select * from matest0 order by 1-id;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Merge Append
!    Sort Key: ((1 - matest0.id))
!    ->  Index Scan using matest0i on public.matest0
!          Output: matest0.id, matest0.name, (1 - matest0.id)
!    ->  Index Scan using matest1i on public.matest1
!          Output: matest1.id, matest1.name, (1 - matest1.id)
!    ->  Sort
!          Output: matest2.id, matest2.name, ((1 - matest2.id))
!          Sort Key: ((1 - matest2.id))
!          ->  Seq Scan on public.matest2
!                Output: matest2.id, matest2.name, (1 - matest2.id)
!    ->  Index Scan using matest3i on public.matest3
!          Output: matest3.id, matest3.name, (1 - matest3.id)
! (13 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Result
!    Output: $0
!    InitPlan 1 (returns $0)
!      ->  Limit
!            Output: ((1 - matest0.id))
!            ->  Result
!                  Output: ((1 - matest0.id))
!                  ->  Merge Append
!                        Sort Key: ((1 - matest0.id))
!                        ->  Index Scan using matest0i on public.matest0
!                              Output: matest0.id, (1 - matest0.id)
!                              Index Cond: ((1 - matest0.id) IS NOT NULL)
!                        ->  Index Scan using matest1i on public.matest1
!                              Output: matest1.id, (1 - matest1.id)
!                              Index Cond: ((1 - matest1.id) IS NOT NULL)
!                        ->  Sort
!                              Output: matest2.id, ((1 - matest2.id))
!                              Sort Key: ((1 - matest2.id))
!                              ->  Bitmap Heap Scan on public.matest2
!                                    Output: matest2.id, (1 - matest2.id)
!                                    Filter: ((1 - matest2.id) IS NOT NULL)
!                                    ->  Bitmap Index Scan on matest2_pkey
!                        ->  Index Scan using matest3i on public.matest3
!                              Output: matest3.id, (1 - matest3.id)
!                              Index Cond: ((1 - matest3.id) IS NOT NULL)
! (25 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_seqscan;
! drop table matest0 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table matest1
! drop cascades to table matest2
! drop cascades to table matest3
! --
! -- Test merge-append for UNION ALL append relations
! --
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! -- Check handling of duplicated, constant, or volatile targetlist items
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, thousand FROM tenk1
! ORDER BY thousand, tenthous;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: tenk1_1.thousand, tenk1_1.thousand
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1
! UNION ALL
! SELECT 42, 42, hundred FROM tenk1
! ORDER BY thousand, tenthous;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: (42), (42)
!          ->  Index Only Scan using tenk1_hundred on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, random()::integer FROM tenk1
! ORDER BY thousand, tenthous;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: tenk1_1.thousand, ((random())::integer)
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (6 rows)
! 
! -- Check min/max aggregate optimization
! explain (costs off)
! SELECT min(x) FROM
!   (SELECT unique1 AS x FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x FROM tenk1 b) s;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: a.unique1
!                  ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                        Index Cond: (unique1 IS NOT NULL)
!                  ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                        Index Cond: (unique2 IS NOT NULL)
! (9 rows)
! 
! explain (costs off)
! SELECT min(y) FROM
!   (SELECT unique1 AS x, unique1 AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: a.unique1
!                  ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                        Index Cond: (unique1 IS NOT NULL)
!                  ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                        Index Cond: (unique2 IS NOT NULL)
! (9 rows)
! 
! -- XXX planner doesn't recognize that index on unique2 is sufficiently sorted
! explain (costs off)
! SELECT x, y FROM
!   (SELECT thousand AS x, tenthous AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s
! ORDER BY x, y;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Merge Append
!    Sort Key: a.thousand, a.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1 a
!    ->  Sort
!          Sort Key: b.unique2, b.unique2
!          ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (6 rows)
! 
! -- exercise rescan code path via a repeatedly-evaluated subquery
! explain (costs off)
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Function Scan on generate_series g
!    SubPlan 1
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: ((d.d + g.i))
!                  ->  Sort
!                        Sort Key: ((d.d + g.i))
!                        ->  Function Scan on generate_series d
!                  ->  Sort
!                        Sort Key: ((d_1.d + g.i))
!                        ->  Function Scan on generate_series d_1
! (11 rows)
! 
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!             array             
! ------------------------------
!  {1,5,6,8,11,11,14,16,17,20}
!  {2,6,7,9,12,12,15,17,18,21}
!  {3,7,8,10,13,13,16,18,19,22}
! (3 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_table_like.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/create_table_like.out	2015-01-10 10:11:46.099649449 +0300
***************
*** 1,230 ****
! /* Test inheritance of structure (LIKE) */
! CREATE TABLE inhx (xx text DEFAULT 'text');
! /*
!  * Test double inheritance
!  *
!  * Ensure that defaults are NOT included unless
!  * INCLUDING DEFAULTS is specified
!  */
! CREATE TABLE ctla (aa TEXT);
! CREATE TABLE ctlb (bb TEXT) INHERITS (ctla);
! CREATE TABLE foo (LIKE nonexistent);
! ERROR:  relation "nonexistent" does not exist
! LINE 1: CREATE TABLE foo (LIKE nonexistent);
!                                ^
! CREATE TABLE inhe (ee text, LIKE inhx) inherits (ctlb);
! INSERT INTO inhe VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
! SELECT * FROM inhe; /* Columns aa, bb, xx value NULL, ee */
!    aa    |   bb    | ee |   xx    
! ---------+---------+----+---------
!  ee-col1 | ee-col2 |    | ee-col4
! (1 row)
! 
! SELECT * FROM inhx; /* Empty set since LIKE inherits structure only */
!  xx 
! ----
! (0 rows)
! 
! SELECT * FROM ctlb; /* Has ee entry */
!    aa    |   bb    
! ---------+---------
!  ee-col1 | ee-col2
! (1 row)
! 
! SELECT * FROM ctla; /* Has ee entry */
!    aa    
! ---------
!  ee-col1
! (1 row)
! 
! CREATE TABLE inhf (LIKE inhx, LIKE inhx); /* Throw error */
! ERROR:  column "xx" specified more than once
! CREATE TABLE inhf (LIKE inhx INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
! INSERT INTO inhf DEFAULT VALUES;
! SELECT * FROM inhf; /* Single entry with value 'text' */
!   xx  
! ------
!  text
! (1 row)
! 
! ALTER TABLE inhx add constraint foo CHECK (xx = 'text');
! ALTER TABLE inhx ADD PRIMARY KEY (xx);
! CREATE TABLE inhg (LIKE inhx); /* Doesn't copy constraint */
! INSERT INTO inhg VALUES ('foo');
! DROP TABLE inhg;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING CONSTRAINTS, y text); /* Copies constraints */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds -- Unique constraints not copied */
! INSERT INTO inhg VALUES ('x', 'foo',  'y');  /* fails due to constraint */
! ERROR:  new row for relation "inhg" violates check constraint "foo"
! DETAIL:  Failing row contains (x, foo, y).
! SELECT * FROM inhg; /* Two records with three columns in order x=x, xx=text, y=y */
!  x |  xx  | y 
! ---+------+---
!  x | text | y
!  x | text | y
! (2 rows)
! 
! DROP TABLE inhg;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text); /* copies indexes */
! INSERT INTO inhg VALUES (5, 10);
! INSERT INTO inhg VALUES (20, 10); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_pkey"
! DETAIL:  Key (xx)=(10) already exists.
! DROP TABLE inhg;
! /* Multiple primary keys creation should fail */
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x)); /* fails */
! ERROR:  multiple primary keys for table "inhg" are not allowed
! CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE);
! CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
! /* Ok to create multiple unique indexes */
! CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES);
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 5, 10);
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 10, 15);
! INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_x_key"
! DETAIL:  Key (x)=(15) already exists.
! DROP TABLE inhg;
! DROP TABLE inhz;
! -- including storage and comments
! CREATE TABLE ctlt1 (a text CHECK (length(a) > 2) PRIMARY KEY, b text);
! CREATE INDEX ctlt1_b_key ON ctlt1 (b);
! CREATE INDEX ctlt1_fnidx ON ctlt1 ((a || b));
! COMMENT ON COLUMN ctlt1.a IS 'A';
! COMMENT ON COLUMN ctlt1.b IS 'B';
! COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
! COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
! COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
! ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
! CREATE TABLE ctlt2 (c text);
! ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
! COMMENT ON COLUMN ctlt2.c IS 'C';
! CREATE TABLE ctlt3 (a text CHECK (length(a) < 5), c text);
! ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
! ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
! COMMENT ON COLUMN ctlt3.a IS 'A3';
! COMMENT ON COLUMN ctlt3.c IS 'C';
! COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
! CREATE TABLE ctlt4 (a text, c text);
! ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
! CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
! \d+ ctlt12_storage
!                    Table "public.ctlt12_storage"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | 
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | 
! 
! CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
! \d+ ctlt12_comments
!                   Table "public.ctlt12_comments"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | extended |              | A
!  b      | text |           | extended |              | B
!  c      | text |           | extended |              | C
! 
! CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging column "b" with inherited definition
! NOTICE:  merging constraint "ctlt1_a_check" with inherited definition
! \d+ ctlt1_inh
!                      Table "public.ctlt1_inh"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A
!  b      | text |           | extended |              | B
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! Inherits: ctlt1
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
!  description 
! -------------
!  t1_a_check
! (1 row)
! 
! CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
! NOTICE:  merging multiple inherited definitions of column "a"
! \d+ ctlt13_inh
!                      Table "public.ctlt13_inh"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | 
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | 
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1,
!           ctlt3
! 
! CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! \d+ ctlt13_like
!                     Table "public.ctlt13_like"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A3
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | C
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
!  description 
! -------------
!  t3_a_check
! (1 row)
! 
! CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
! \d+ ctlt_all
!                       Table "public.ctlt_all"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A
!  b      | text |           | extended |              | B
! Indexes:
!     "ctlt_all_pkey" PRIMARY KEY, btree (a)
!     "ctlt_all_b_idx" btree (b)
!     "ctlt_all_expr_idx" btree ((a || b))
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! 
! SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
!     relname     | objsubid | description 
! ----------------+----------+-------------
!  ctlt_all_b_idx |        0 | index b_key
!  ctlt_all_pkey  |        0 | index pkey
! (2 rows)
! 
! CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
! NOTICE:  merging multiple inherited definitions of column "a"
! ERROR:  inherited column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! ERROR:  column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
! NOTICE:  drop cascades to table inhe
! /* LIKE with other relation kinds */
! CREATE TABLE ctlt4 (a int, b text);
! CREATE SEQUENCE ctlseq1;
! CREATE TABLE ctlt10 (LIKE ctlseq1);  -- fail
! ERROR:  "ctlseq1" is not a table, view, materialized view, composite type, or foreign table
! LINE 1: CREATE TABLE ctlt10 (LIKE ctlseq1);
!                                   ^
! CREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
! CREATE TABLE ctlt11 (LIKE ctlv1);
! CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
! CREATE TYPE ctlty1 AS (a int, b text);
! CREATE TABLE ctlt12 (LIKE ctlty1);
! DROP SEQUENCE ctlseq1;
! DROP TYPE ctlty1;
! DROP VIEW ctlv1;
! DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
! NOTICE:  table "ctlt10" does not exist, skipping
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/typed_table.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/typed_table.out	2015-01-10 10:11:46.083649449 +0300
***************
*** 1,108 ****
! CREATE TABLE ttable1 OF nothing;
! ERROR:  type "nothing" does not exist
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! CREATE TABLE IF NOT EXISTS persons OF person_type;
! NOTICE:  relation "persons" already exists, skipping
! SELECT * FROM persons;
!  id | name 
! ----+------
! (0 rows)
! 
! \d persons
!     Table "public.persons"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  id     | integer | 
!  name   | text    | 
! Typed table of type: person_type
! 
! CREATE FUNCTION get_all_persons() RETURNS SETOF person_type
! LANGUAGE SQL
! AS $$
!     SELECT * FROM persons;
! $$;
! SELECT * FROM get_all_persons();
!  id | name 
! ----+------
! (0 rows)
! 
! -- certain ALTER TABLE operations on typed tables are not allowed
! ALTER TABLE persons ADD COLUMN comment text;
! ERROR:  cannot add column to typed table
! ALTER TABLE persons DROP COLUMN name;
! ERROR:  cannot drop column from typed table
! ALTER TABLE persons RENAME COLUMN id TO num;
! ERROR:  cannot rename column of typed table
! ALTER TABLE persons ALTER COLUMN name TYPE varchar;
! ERROR:  cannot alter column type of typed table
! CREATE TABLE stuff (id int);
! ALTER TABLE persons INHERIT stuff;
! ERROR:  cannot change inheritance of typed table
! CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL); -- error
! ERROR:  column "myname" does not exist
! CREATE TABLE persons2 OF person_type (
!     id WITH OPTIONS PRIMARY KEY,
!     UNIQUE (name)
! );
! \d persons2
!    Table "public.persons2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  id     | integer | not null
!  name   | text    | 
! Indexes:
!     "persons2_pkey" PRIMARY KEY, btree (id)
!     "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
! Typed table of type: person_type
! 
! CREATE TABLE persons3 OF person_type (
!     PRIMARY KEY (id),
!     name WITH OPTIONS DEFAULT ''
! );
! \d persons3
!        Table "public.persons3"
!  Column |  Type   |    Modifiers     
! --------+---------+------------------
!  id     | integer | not null
!  name   | text    | default ''::text
! Indexes:
!     "persons3_pkey" PRIMARY KEY, btree (id)
! Typed table of type: person_type
! 
! CREATE TABLE persons4 OF person_type (
!     name WITH OPTIONS NOT NULL,
!     name WITH OPTIONS DEFAULT ''  -- error, specified more than once
! );
! ERROR:  column "name" specified more than once
! DROP TYPE person_type RESTRICT;
! ERROR:  cannot drop type person_type because other objects depend on it
! DETAIL:  table persons depends on type person_type
! function get_all_persons() depends on type person_type
! table persons2 depends on type person_type
! table persons3 depends on type person_type
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TYPE person_type CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table persons
! drop cascades to function get_all_persons()
! drop cascades to table persons2
! drop cascades to table persons3
! CREATE TABLE persons5 OF stuff; -- only CREATE TYPE AS types may be used
! ERROR:  type stuff is not a composite type
! DROP TABLE stuff;
! -- implicit casting
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! INSERT INTO persons VALUES (1, 'test');
! CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
! SELECT id, namelen(persons) FROM persons;
!  id | namelen 
! ----+---------
!   1 |       4
! (1 row)
! 
! DROP TYPE person_type CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table persons
! drop cascades to function namelen(person_type)
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/vacuum.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/vacuum.out	2015-01-10 10:11:46.095649449 +0300
***************
*** 1,71 ****
! --
! -- VACUUM
! --
! CREATE TABLE vactst (i INT);
! INSERT INTO vactst VALUES (1);
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! SELECT * FROM vactst;
!  i 
! ---
!  0
! (1 row)
! 
! VACUUM FULL vactst;
! UPDATE vactst SET i = i + 1;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! VACUUM (FULL) vactst;
! DELETE FROM vactst;
! SELECT * FROM vactst;
!  i 
! ---
! (0 rows)
! 
! VACUUM (FULL, FREEZE) vactst;
! VACUUM (ANALYZE, FULL) vactst;
! CREATE TABLE vaccluster (i INT PRIMARY KEY);
! ALTER TABLE vaccluster CLUSTER ON vaccluster_pkey;
! INSERT INTO vaccluster SELECT * FROM vactst;
! CLUSTER vaccluster;
! VACUUM FULL pg_am;
! VACUUM FULL pg_class;
! VACUUM FULL pg_database;
! VACUUM FULL vaccluster;
! VACUUM FULL vactst;
! DROP TABLE vaccluster;
! DROP TABLE vactst;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/drop_if_exists.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/drop_if_exists.out	2015-01-10 10:11:46.095649449 +0300
***************
*** 1,298 ****
! --
! -- IF EXISTS tests
! --
! -- table (will be really dropped at the end)
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! DROP TABLE IF EXISTS test_exists;
! NOTICE:  table "test_exists" does not exist, skipping
! CREATE TABLE test_exists (a int, b text);
! -- view
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! DROP VIEW IF EXISTS test_view_exists;
! NOTICE:  view "test_view_exists" does not exist, skipping
! CREATE VIEW test_view_exists AS select * from test_exists;
! DROP VIEW IF EXISTS test_view_exists;
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! -- index
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! DROP INDEX IF EXISTS test_index_exists;
! NOTICE:  index "test_index_exists" does not exist, skipping
! CREATE INDEX test_index_exists on test_exists(a);
! DROP INDEX IF EXISTS test_index_exists;
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! -- sequence
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! NOTICE:  sequence "test_sequence_exists" does not exist, skipping
! CREATE SEQUENCE test_sequence_exists;
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! -- schema
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! DROP SCHEMA IF EXISTS test_schema_exists;
! NOTICE:  schema "test_schema_exists" does not exist, skipping
! CREATE SCHEMA test_schema_exists;
! DROP SCHEMA IF EXISTS test_schema_exists;
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! -- type
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! DROP TYPE IF EXISTS test_type_exists;
! NOTICE:  type "test_type_exists" does not exist, skipping
! CREATE type test_type_exists as (a int, b text);
! DROP TYPE IF EXISTS test_type_exists;
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! -- domain
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! DROP DOMAIN IF EXISTS test_domain_exists;
! NOTICE:  type "test_domain_exists" does not exist, skipping
! CREATE domain test_domain_exists as int not null check (value > 0);
! DROP DOMAIN IF EXISTS test_domain_exists;
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! ---
! --- role/user/group
! ---
! CREATE USER tu1;
! CREATE ROLE tr1;
! CREATE GROUP tg1;
! DROP USER tu2;
! ERROR:  role "tu2" does not exist
! DROP USER IF EXISTS tu1, tu2;
! NOTICE:  role "tu2" does not exist, skipping
! DROP USER tu1;
! ERROR:  role "tu1" does not exist
! DROP ROLE tr2;
! ERROR:  role "tr2" does not exist
! DROP ROLE IF EXISTS tr1, tr2;
! NOTICE:  role "tr2" does not exist, skipping
! DROP ROLE tr1;
! ERROR:  role "tr1" does not exist
! DROP GROUP tg2;
! ERROR:  role "tg2" does not exist
! DROP GROUP IF EXISTS tg1, tg2;
! NOTICE:  role "tg2" does not exist, skipping
! DROP GROUP tg1;
! ERROR:  role "tg1" does not exist
! -- collation
! DROP COLLATION IF EXISTS test_collation_exists;
! NOTICE:  collation "test_collation_exists" does not exist, skipping
! -- conversion
! DROP CONVERSION test_conversion_exists;
! ERROR:  conversion "test_conversion_exists" does not exist
! DROP CONVERSION IF EXISTS test_conversion_exists;
! NOTICE:  conversion "test_conversion_exists" does not exist, skipping
! CREATE CONVERSION test_conversion_exists
!     FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! DROP CONVERSION test_conversion_exists;
! -- text search parser
! DROP TEXT SEARCH PARSER test_tsparser_exists;
! ERROR:  text search parser "test_tsparser_exists" does not exist
! DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
! NOTICE:  text search parser "test_tsparser_exists" does not exist, skipping
! -- text search dictionary
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! ERROR:  text search dictionary "test_tsdict_exists" does not exist
! DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
! NOTICE:  text search dictionary "test_tsdict_exists" does not exist, skipping
! CREATE TEXT SEARCH DICTIONARY test_tsdict_exists (
!         Template=ispell,
!         DictFile=ispell_sample,
!         AffFile=ispell_sample
! );
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! -- test search template
! DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
! ERROR:  text search template "test_tstemplate_exists" does not exist
! DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
! NOTICE:  text search template "test_tstemplate_exists" does not exist, skipping
! -- text search configuration
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! ERROR:  text search configuration "test_tsconfig_exists" does not exist
! DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
! NOTICE:  text search configuration "test_tsconfig_exists" does not exist, skipping
! CREATE TEXT SEARCH CONFIGURATION test_tsconfig_exists (COPY=english);
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! -- extension
! DROP EXTENSION test_extension_exists;
! ERROR:  extension "test_extension_exists" does not exist
! DROP EXTENSION IF EXISTS test_extension_exists;
! NOTICE:  extension "test_extension_exists" does not exist, skipping
! -- functions
! DROP FUNCTION test_function_exists();
! ERROR:  function test_function_exists() does not exist
! DROP FUNCTION IF EXISTS test_function_exists();
! NOTICE:  function test_function_exists() does not exist, skipping
! DROP FUNCTION test_function_exists(int, text, int[]);
! ERROR:  function test_function_exists(integer, text, integer[]) does not exist
! DROP FUNCTION IF EXISTS test_function_exists(int, text, int[]);
! NOTICE:  function test_function_exists(pg_catalog.int4,text,pg_catalog.int4[]) does not exist, skipping
! -- aggregate
! DROP AGGREGATE test_aggregate_exists(*);
! ERROR:  aggregate test_aggregate_exists(*) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
! NOTICE:  aggregate test_aggregate_exists() does not exist, skipping
! DROP AGGREGATE test_aggregate_exists(int);
! ERROR:  aggregate test_aggregate_exists(integer) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
! NOTICE:  aggregate test_aggregate_exists(pg_catalog.int4) does not exist, skipping
! -- operator
! DROP OPERATOR @#@ (int, int);
! ERROR:  operator does not exist: integer @#@ integer
! DROP OPERATOR IF EXISTS @#@ (int, int);
! NOTICE:  operator @#@ does not exist, skipping
! CREATE OPERATOR @#@
!         (leftarg = int8, rightarg = int8, procedure = int8xor);
! DROP OPERATOR @#@ (int8, int8);
! -- language
! DROP LANGUAGE test_language_exists;
! ERROR:  language "test_language_exists" does not exist
! DROP LANGUAGE IF EXISTS test_language_exists;
! NOTICE:  language "test_language_exists" does not exist, skipping
! -- cast
! DROP CAST (text AS text);
! ERROR:  cast from type text to type text does not exist
! DROP CAST IF EXISTS (text AS text);
! NOTICE:  cast from type text to type text does not exist, skipping
! -- trigger
! DROP TRIGGER test_trigger_exists ON test_exists;
! ERROR:  trigger "test_trigger_exists" for table "test_exists" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
! NOTICE:  trigger "test_trigger_exists" for relation "test_exists" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE TRIGGER test_trigger_exists
!     BEFORE UPDATE ON test_exists
!     FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! DROP TRIGGER test_trigger_exists ON test_exists;
! -- rule
! DROP RULE test_rule_exists ON test_exists;
! ERROR:  rule "test_rule_exists" for relation "test_exists" does not exist
! DROP RULE IF EXISTS test_rule_exists ON test_exists;
! NOTICE:  rule "test_rule_exists" for relation "test_exists" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE RULE test_rule_exists AS ON INSERT TO test_exists
!     DO INSTEAD
!     INSERT INTO test_exists VALUES (NEW.a, NEW.b || NEW.a::text);
! DROP RULE test_rule_exists ON test_exists;
! -- foreign data wrapper
! DROP FOREIGN DATA WRAPPER test_fdw_exists;
! ERROR:  foreign-data wrapper "test_fdw_exists" does not exist
! DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
! NOTICE:  foreign-data wrapper "test_fdw_exists" does not exist, skipping
! -- foreign server
! DROP SERVER test_server_exists;
! ERROR:  server "test_server_exists" does not exist
! DROP SERVER IF EXISTS test_server_exists;
! NOTICE:  server "test_server_exists" does not exist, skipping
! -- operator class
! DROP OPERATOR CLASS test_operator_class USING btree;
! ERROR:  operator class "test_operator_class" does not exist for access method "btree"
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
! NOTICE:  operator class "test_operator_class" does not exist for access method "btree", skipping
! DROP OPERATOR CLASS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- operator family
! DROP OPERATOR FAMILY test_operator_family USING btree;
! ERROR:  operator family "test_operator_family" does not exist for access method "btree"
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
! NOTICE:  operator family "test_operator_family" does not exist for access method "btree", skipping
! DROP OPERATOR FAMILY test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- drop the table
! DROP TABLE IF EXISTS test_exists;
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! -- be tolerant with missing schemas, types, etc
! DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_type2);
! NOTICE:  type "no_such_type2" does not exist, skipping
! DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
! NOTICE:  type "no_such_type1" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP COLLATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CONVERSION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP DOMAIN IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS no_such_schema.foo();
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP INDEX IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP RULE IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP SEQUENCE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TYPE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/updatable_views.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/updatable_views.out	2015-01-10 10:11:46.083649449 +0300
***************
*** 1,2266 ****
! --
! -- UPDATABLE VIEWS
! --
! -- check that non-updatable views and columns are rejected with useful error
! -- messages
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl; -- DISTINCT not supported
! CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b; -- GROUP BY not supported
! CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0; -- HAVING not supported
! CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl; -- Aggregate functions not supported
! CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl; -- Window functions not supported
! CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl; -- Set ops not supported
! CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t; -- WITH not supported
! CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1; -- OFFSET not supported
! CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1; -- LIMIT not supported
! CREATE VIEW ro_view10 AS SELECT 1 AS a; -- No base relations
! CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2; -- Multiple base relations
! CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a); -- SRF in rangetable
! CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t; -- Subselect in rangetable
! CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl; -- System columns may be part of an updatable view
! CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl; -- Expression/function may be part of an updatable view
! CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl; -- Repeated column may be part of an updatable view
! CREATE VIEW ro_view17 AS SELECT * FROM ro_view1; -- Base relation not updatable
! CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a); -- VALUES in rangetable
! CREATE SEQUENCE seq;
! CREATE VIEW ro_view19 AS SELECT * FROM seq; -- View based on a sequence
! CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl; -- SRF in targetlist not supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  ro_view1   | NO
!  ro_view10  | NO
!  ro_view11  | NO
!  ro_view12  | NO
!  ro_view13  | NO
!  ro_view17  | NO
!  ro_view18  | NO
!  ro_view19  | NO
!  ro_view2   | NO
!  ro_view20  | NO
!  ro_view3   | NO
!  ro_view4   | NO
!  ro_view5   | NO
!  ro_view6   | NO
!  ro_view7   | NO
!  ro_view8   | NO
!  ro_view9   | NO
!  rw_view14  | YES
!  rw_view15  | YES
!  rw_view16  | YES
! (20 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  ro_view1   | NO           | NO
!  ro_view10  | NO           | NO
!  ro_view11  | NO           | NO
!  ro_view12  | NO           | NO
!  ro_view13  | NO           | NO
!  ro_view17  | NO           | NO
!  ro_view18  | NO           | NO
!  ro_view19  | NO           | NO
!  ro_view2   | NO           | NO
!  ro_view20  | NO           | NO
!  ro_view3   | NO           | NO
!  ro_view4   | NO           | NO
!  ro_view5   | NO           | NO
!  ro_view6   | NO           | NO
!  ro_view7   | NO           | NO
!  ro_view8   | NO           | NO
!  ro_view9   | NO           | NO
!  rw_view14  | YES          | YES
!  rw_view15  | YES          | YES
!  rw_view16  | YES          | YES
! (20 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name |  column_name  | is_updatable 
! ------------+---------------+--------------
!  ro_view1   | a             | NO
!  ro_view1   | b             | NO
!  ro_view10  | a             | NO
!  ro_view11  | a             | NO
!  ro_view11  | b             | NO
!  ro_view12  | a             | NO
!  ro_view13  | a             | NO
!  ro_view13  | b             | NO
!  ro_view17  | a             | NO
!  ro_view17  | b             | NO
!  ro_view18  | a             | NO
!  ro_view19  | sequence_name | NO
!  ro_view19  | last_value    | NO
!  ro_view19  | start_value   | NO
!  ro_view19  | increment_by  | NO
!  ro_view19  | max_value     | NO
!  ro_view19  | min_value     | NO
!  ro_view19  | cache_value   | NO
!  ro_view19  | log_cnt       | NO
!  ro_view19  | is_cycled     | NO
!  ro_view19  | is_called     | NO
!  ro_view2   | a             | NO
!  ro_view2   | b             | NO
!  ro_view20  | a             | NO
!  ro_view20  | b             | NO
!  ro_view20  | g             | NO
!  ro_view3   | ?column?      | NO
!  ro_view4   | count         | NO
!  ro_view5   | a             | NO
!  ro_view5   | rank          | NO
!  ro_view6   | a             | NO
!  ro_view6   | b             | NO
!  ro_view7   | a             | NO
!  ro_view7   | b             | NO
!  ro_view8   | a             | NO
!  ro_view8   | b             | NO
!  ro_view9   | a             | NO
!  ro_view9   | b             | NO
!  rw_view14  | ctid          | NO
!  rw_view14  | a             | YES
!  rw_view14  | b             | YES
!  rw_view15  | a             | YES
!  rw_view15  | upper         | NO
!  rw_view16  | a             | YES
!  rw_view16  | b             | YES
!  rw_view16  | aa            | YES
! (46 rows)
! 
! -- Read-only views
! DELETE FROM ro_view1;
! ERROR:  cannot delete from view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view2;
! ERROR:  cannot delete from view "ro_view2"
! DETAIL:  Views containing GROUP BY are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view3;
! ERROR:  cannot delete from view "ro_view3"
! DETAIL:  Views containing HAVING are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view4;
! ERROR:  cannot delete from view "ro_view4"
! DETAIL:  Views that return aggregate functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view5;
! ERROR:  cannot delete from view "ro_view5"
! DETAIL:  Views that return window functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view6;
! ERROR:  cannot delete from view "ro_view6"
! DETAIL:  Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view7 SET a=a+1;
! ERROR:  cannot update view "ro_view7"
! DETAIL:  Views containing WITH are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view8 SET a=a+1;
! ERROR:  cannot update view "ro_view8"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view9 SET a=a+1;
! ERROR:  cannot update view "ro_view9"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view10 SET a=a+1;
! ERROR:  cannot update view "ro_view10"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view11 SET a=a+1;
! ERROR:  cannot update view "ro_view11"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view12 SET a=a+1;
! ERROR:  cannot update view "ro_view12"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! INSERT INTO ro_view13 VALUES (3, 'Row 3');
! ERROR:  cannot insert into view "ro_view13"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! -- Partially updatable view
! INSERT INTO rw_view14 VALUES (null, 3, 'Row 3'); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view14 SET ctid=null WHERE a=3; -- should fail
! ERROR:  cannot update column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! UPDATE rw_view14 SET b='ROW 3' WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   3 | ROW 3
! (6 rows)
! 
! DELETE FROM rw_view14 WHERE a=3; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view15 VALUES (3, 'ROW 3'); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view15 (a) VALUES (3); -- should be OK
! ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
! INSERT INTO rw_view15 (a) VALUES (4); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper='ROW 3' WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper=DEFAULT WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET a=4 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   4 | Unspecified
! (6 rows)
! 
! DELETE FROM rw_view15 WHERE a=4; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view16 VALUES (3, 'Row 3', 3); -- should fail
! ERROR:  multiple assignments to same column "a"
! INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3; -- should fail
! ERROR:  multiple assignments to same column "a"
! UPDATE rw_view16 SET aa=-3 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!  -3 | Row 3
! (6 rows)
! 
! DELETE FROM rw_view16 WHERE a=-3; -- should be OK
! -- Read-only views
! INSERT INTO ro_view17 VALUES (3, 'ROW 3');
! ERROR:  cannot insert into view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! DELETE FROM ro_view18;
! ERROR:  cannot delete from view "ro_view18"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view19 SET max_value=1000;
! ERROR:  cannot update view "ro_view19"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view20 SET b=upper(b);
! ERROR:  cannot update view "ro_view20"
! DETAIL:  Views that return set-returning functions are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 16 other objects
! DETAIL:  drop cascades to view ro_view1
! drop cascades to view ro_view17
! drop cascades to view ro_view2
! drop cascades to view ro_view3
! drop cascades to view ro_view5
! drop cascades to view ro_view6
! drop cascades to view ro_view7
! drop cascades to view ro_view8
! drop cascades to view ro_view9
! drop cascades to view ro_view11
! drop cascades to view ro_view13
! drop cascades to view rw_view15
! drop cascades to view rw_view16
! drop cascades to view ro_view20
! drop cascades to view ro_view4
! drop cascades to view rw_view14
! DROP VIEW ro_view10, ro_view12, ro_view18;
! DROP SEQUENCE seq CASCADE;
! NOTICE:  drop cascades to view ro_view19
! -- simple updatable view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
! (2 rows)
! 
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! INSERT INTO rw_view1 (a) VALUES (4);
! UPDATE rw_view1 SET a=5 WHERE a=4;
! DELETE FROM rw_view1 WHERE b='Row 2';
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   3 | Row 3
!   5 | Unspecified
! (6 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a > 0) AND (a = 5))
! (3 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Delete on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a > 0) AND (a = 5))
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- view on top of view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
! CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | aaa         | YES
!  rw_view2   | bbb         | YES
! (2 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3');
! INSERT INTO rw_view2 (aaa) VALUES (4);
! SELECT * FROM rw_view2;
!  aaa |     bbb     
! -----+-------------
!    1 | Row 1
!    2 | Row 2
!    3 | Row 3
!    4 | Unspecified
! (4 rows)
! 
! UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
! DELETE FROM rw_view2 WHERE aaa=2;
! SELECT * FROM rw_view2;
!  aaa |  bbb  
! -----+-------
!    1 | Row 1
!    3 | Row 3
!    4 | Row 4
! (3 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (3 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Delete on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with rules
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | NO
!  rw_view2   | NO           | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1
!   DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
!  rw_view2   | a           | YES
!  rw_view2   | b           | YES
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
!  a |   b   
! ---+-------
!  3 | Row 3
! (1 row)
! 
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |     b     
! ---+-----------
!  1 | Row 1
!  2 | Row 2
!  3 | Row three
! (3 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Update on base_tbl
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (a = 2)
!          ->  Subquery Scan on rw_view1
!                Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                      Recheck Cond: (a > 0)
!                      ->  Bitmap Index Scan on base_tbl_pkey
!                            Index Cond: (a > 0)
! (10 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Delete on base_tbl
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (a = 2)
!          ->  Subquery Scan on rw_view1
!                Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                      Recheck Cond: (a > 0)
!                      ->  Bitmap Index Scan on base_tbl_pkey
!                            Index Cond: (a > 0)
! (10 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | YES                  | NO                   | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | YES                  | YES                  | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
!  a |   b   
! ---+-------
!  3 | Row 3
! (1 row)
! 
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |     b     
! ---+-----------
!  1 | Row 1
!  2 | Row 2
!  3 | Row three
! (3 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Update on rw_view1 rw_view1_1
!    ->  Subquery Scan on rw_view1
!          Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!          ->  Bitmap Heap Scan on base_tbl
!                Recheck Cond: (a > 0)
!                ->  Bitmap Index Scan on base_tbl_pkey
!                      Index Cond: (a > 0)
! (7 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Delete on rw_view1 rw_view1_1
!    ->  Subquery Scan on rw_view1
!          Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!          ->  Bitmap Heap Scan on base_tbl
!                Recheck Cond: (a > 0)
!                ->  Bitmap Index Scan on base_tbl_pkey
!                      Index Cond: (a > 0)
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! -- update using whole row from view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
! CREATE FUNCTION rw_view1_aa(x rw_view1)
!   RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!  rw_view1_aa |      bb       
! -------------+---------------
!            2 | Updated row 2
! (1 row)
! 
! SELECT * FROM base_tbl;
!  a  |       b       
! ----+---------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Updated row 2
! (5 rows)
! 
! EXPLAIN (costs off)
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: (a = 2)
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to function rw_view1_aa(rw_view1)
! -- permissions checks
! CREATE USER view_user1;
! CREATE USER view_user2;
! SET SESSION AUTHORIZATION view_user1;
! CREATE TABLE base_tbl(a int, b text, c float);
! INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
! CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
! GRANT SELECT ON base_tbl TO view_user2;
! GRANT SELECT ON rw_view1 TO view_user2;
! GRANT UPDATE (a,c) ON base_tbl TO view_user2;
! GRANT UPDATE (bb,cc) ON rw_view1 TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! SELECT * FROM base_tbl; -- ok
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
!  2 | Row 2 | 2
! (2 rows)
! 
! SELECT * FROM rw_view1; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! SELECT * FROM rw_view2; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE base_tbl SET a=a, c=c; -- ok
! UPDATE base_tbl SET b=b; -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
! UPDATE rw_view1 SET aa=aa; -- not allowed
! ERROR:  permission denied for relation rw_view1
! UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
! UPDATE rw_view2 SET bb=bb; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2; -- not allowed
! ERROR:  permission denied for relation base_tbl
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user1;
! GRANT INSERT, DELETE ON base_tbl TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
! INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
! DELETE FROM base_tbl WHERE a=1; -- ok
! DELETE FROM rw_view1 WHERE aa=2; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2 WHERE aa=2; -- ok
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  3 | Row 3 | 3
!  4 | Row 4 | 4
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user1;
! REVOKE INSERT, DELETE ON base_tbl FROM view_user2;
! GRANT INSERT, DELETE ON rw_view1 TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
! INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl WHERE a=3; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1 WHERE aa=3; -- ok
! DELETE FROM rw_view2 WHERE aa=4; -- not allowed
! ERROR:  permission denied for relation base_tbl
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  4 | Row 4 | 4
!  5 | Row 5 | 5
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP USER view_user1;
! DROP USER view_user2;
! -- column defaults
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! INSERT INTO base_tbl VALUES (3);
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
! INSERT INTO rw_view1 VALUES (4, 'Row 4');
! INSERT INTO rw_view1 (aa) VALUES (5);
! SELECT * FROM base_tbl;
!  a |      b       | c 
! ---+--------------+---
!  1 | Row 1        | 1
!  2 | Row 2        | 2
!  3 | Unspecified  | 3
!  4 | Row 4        | 4
!  5 | View default | 5
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- Table having triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=1;
!     RETURN NULL;
!   END IF;
!   RETURN NULL;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! select * from base_tbl;
!  a |   b   
! ---+-------
!  2 | Row 2
!  3 | Row 3
!  1 | Row 3
! (3 rows)
! 
! DROP VIEW rw_view1;
! DROP TRIGGER rw_view1_ins_trig on base_tbl;
! DROP FUNCTION rw_view1_trig_fn();
! DROP TABLE base_tbl;
! -- view with ORDER BY
! CREATE TABLE base_tbl (a int, b int);
! INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  3 | -3
!  1 |  2
!  4 |  5
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (7,-8);
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -8
!  3 | -3
!  1 |  2
!  4 |  5
! (4 rows)
! 
! EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Update on public.base_tbl
!    Output: base_tbl.a, base_tbl.b
!    ->  Seq Scan on public.base_tbl
!          Output: base_tbl.a, (base_tbl.b + 1), base_tbl.ctid
! (4 rows)
! 
! UPDATE rw_view1 SET b = b + 1 RETURNING *;
!  a | b  
! ---+----
!  1 |  3
!  4 |  6
!  3 | -2
!  7 | -7
! (4 rows)
! 
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -7
!  3 | -2
!  1 |  3
!  4 |  6
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- multiple array-column updates
! CREATE TABLE base_tbl (a int, arr int[]);
! INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
! UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
! SELECT * FROM rw_view1;
!  a |   arr   
! ---+---------
!  1 | {2}
!  3 | {42,77}
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- views with updatable and non-updatable columns
! CREATE TABLE base_tbl(a float);
! INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
! CREATE VIEW rw_view1 AS
!   SELECT ctid, sin(a) s, a, cos(a) c
!   FROM base_tbl
!   WHERE a != 0
!   ORDER BY abs(a);
! INSERT INTO rw_view1 VALUES (null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view1"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c; -- OK
!   a  |         s         |         c         
! -----+-------------------+-------------------
!  1.1 | 0.891207360061435 | 0.453596121425577
! (1 row)
! 
! UPDATE rw_view1 SET s = s WHERE a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s; -- OK
!          s         
! -------------------
!  0.867423225594017
! (1 row)
! 
! DELETE FROM rw_view1 WHERE a = 1.05; -- OK
! CREATE VIEW rw_view2 AS
!   SELECT s, c, s/c t, a base_a, ctid
!   FROM rw_view1;
! INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t; -- OK
!         t         
! ------------------
!  1.96475965724865
! (1 row)
! 
! UPDATE rw_view2 SET s = s WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET t = t WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1; -- OK
! DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t; -- OK
!  base_a |         s         |         c         |        t         
! --------+-------------------+-------------------+------------------
!    1.05 | 0.867423225594017 | 0.497571047891727 | 1.74331530998317
! (1 row)
! 
! CREATE VIEW rw_view3 AS
!   SELECT s, c, s/c t, ctid
!   FROM rw_view1;
! INSERT INTO rw_view3 VALUES (null, null, null, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view3"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view3(s) VALUES (null); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view3 SET s = s; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! DELETE FROM rw_view3 WHERE s = sin(0.1); -- should be OK
! SELECT * FROM base_tbl ORDER BY a;
!   a  
! -----
!  0.2
!  0.3
!  0.4
!  0.5
!  0.6
!  0.7
!  0.8
!  0.9
!    1
! (9 rows)
! 
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
!  rw_view3   | NO
! (3 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
!  rw_view3   | NO           | NO
! (3 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | ctid        | NO
!  rw_view1   | s           | NO
!  rw_view1   | a           | YES
!  rw_view1   | c           | NO
!  rw_view2   | s           | NO
!  rw_view2   | c           | NO
!  rw_view2   | t           | NO
!  rw_view2   | base_a      | YES
!  rw_view2   | ctid        | NO
!  rw_view3   | s           | NO
!  rw_view3   | c           | NO
!  rw_view3   | t           | NO
!  rw_view3   | ctid        | NO
! (13 rows)
! 
! SELECT events & 4 != 0 AS upd,
!        events & 8 != 0 AS ins,
!        events & 16 != 0 AS del
!   FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
!  upd | ins | del 
! -----+-----+-----
!  f   | f   | t
! (1 row)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- inheritance tests
! CREATE TABLE base_tbl_parent (a int);
! CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
! INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
! INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
! CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
! SELECT * FROM rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM ONLY rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM rw_view2 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
! (8 rows)
! 
! INSERT INTO rw_view1 VALUES (-100), (100);
! INSERT INTO rw_view2 VALUES (-200), (200);
! UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1); -- Should produce -10 and 10
! UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2); -- Should produce -20 and 20
! UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3); -- Should produce -30 only
! UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4); -- Should produce -40 only
! DELETE FROM rw_view1 WHERE a IN (-5, 5); -- Should delete -5 and 5
! DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6); -- Should delete -6 and 6
! DELETE FROM rw_view2 WHERE a IN (-7, 7); -- Should delete -7 only
! DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8); -- Should delete -8 only
! SELECT * FROM ONLY base_tbl_parent ORDER BY a;
!   a   
! ------
!  -200
!  -100
!   -40
!   -30
!   -20
!   -10
!   100
!   200
! (8 rows)
! 
! SELECT * FROM base_tbl_child ORDER BY a;
!  a  
! ----
!   3
!   4
!   7
!   8
!  10
!  20
! (6 rows)
! 
! DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- simple WITH CHECK OPTION
! CREATE TABLE base_tbl (a int, b int DEFAULT 10);
! INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view1
!                 View "public.rw_view1"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
!  b      | integer |           | plain   | 
! View definition:
!  SELECT base_tbl.a,
!     base_tbl.b
!    FROM base_tbl
!   WHERE base_tbl.a < base_tbl.b;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
!  table_catalog | table_schema | table_name |          view_definition           | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+------------------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a,               +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |     base_tbl.b                    +|              |              |                    |                      |                      | 
!                |              |            |    FROM base_tbl                  +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (base_tbl.a < base_tbl.b); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view1 VALUES(3,4); -- ok
! INSERT INTO rw_view1 VALUES(4,3); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (4, 3).
! INSERT INTO rw_view1 VALUES(5,null); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (5, null).
! UPDATE rw_view1 SET b = 5 WHERE a = 3; -- ok
! UPDATE rw_view1 SET b = -5 WHERE a = 3; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (3, -5).
! INSERT INTO rw_view1(a) VALUES (9); -- ok
! INSERT INTO rw_view1(a) VALUES (10); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, 10).
! SELECT * FROM base_tbl;
!  a | b  
! ---+----
!  1 |  2
!  2 |  3
!  1 | -1
!  3 |  5
!  9 | 10
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH LOCAL/CASCADED CHECK OPTION
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH CHECK OPTION; -- implicitly cascaded
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=cascaded
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-5).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (15); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (15).
! SELECT * FROM base_tbl;
!  a 
! ---
!  5
! (1 row)
! 
! UPDATE rw_view2 SET a = a - 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-5).
! UPDATE rw_view2 SET a = a + 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (15).
! CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (20).
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
! (2 rows)
! 
! ALTER VIEW rw_view1 SET (check_option=here); -- invalid
! ERROR:  invalid value for "check_option" option
! DETAIL:  Valid values are "local" and "cascaded".
! ALTER VIEW rw_view1 SET (check_option=local);
! INSERT INTO rw_view2 VALUES (-20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-20).
! INSERT INTO rw_view2 VALUES (30); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (30).
! ALTER VIEW rw_view2 RESET (check_option);
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (30); -- ok, but not in view
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
!   30
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- WITH CHECK OPTION with no local view qual
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
! CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
! SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
!  table_catalog | table_schema | table_name |      view_definition      | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+---------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM base_tbl;         |              |              |                    |                      |                      | 
!  regression    | public       | rw_view2   |  SELECT rw_view1.a       +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1         +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a > 0); |              |              |                    |                      |                      | 
!  regression    | public       | rw_view3   |  SELECT rw_view2.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view2;         |              |              |                    |                      |                      | 
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (-1); -- ok
! INSERT INTO rw_view1 VALUES (1); -- ok
! INSERT INTO rw_view2 VALUES (-2); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (2); -- ok
! INSERT INTO rw_view3 VALUES (-3); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-3).
! INSERT INTO rw_view3 VALUES (3); -- ok
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- WITH CHECK OPTION with scalar array ops
! CREATE TABLE base_tbl (a int, b int[]);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
!   WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]); -- ok
! INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1; -- ok
! UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (1, {-1,-2,3}).
! PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
! EXECUTE ins(2, ARRAY[1,2,3]); -- ok
! EXECUTE ins(10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! DEALLOCATE PREPARE ins;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with subquery
! CREATE TABLE base_tbl (a int);
! CREATE TABLE ref_tbl (a int PRIMARY KEY);
! INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
! CREATE VIEW rw_view1 AS
!   SELECT * FROM base_tbl b
!   WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
!   WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (5); -- ok
! INSERT INTO rw_view1 VALUES (15); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15).
! UPDATE rw_view1 SET a = a + 5; -- ok
! UPDATE rw_view1 SET a = a + 5; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15).
! EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Insert on base_tbl b
!    ->  Result
!          SubPlan 1
!            ->  Index Only Scan using ref_tbl_pkey on ref_tbl r
!                  Index Cond: (a = b.a)
!          SubPlan 2
!            ->  Seq Scan on ref_tbl r_1
! (7 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Update on base_tbl b
!    ->  Hash Semi Join
!          Hash Cond: (b.a = r.a)
!          ->  Seq Scan on base_tbl b
!          ->  Hash
!                ->  Seq Scan on ref_tbl r
!          SubPlan 1
!            ->  Index Only Scan using ref_tbl_pkey on ref_tbl r_1
!                  Index Cond: (a = b.a)
!          SubPlan 2
!            ->  Seq Scan on ref_tbl r_2
! (11 rows)
! 
! DROP TABLE base_tbl, ref_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with BEFORE trigger on base table
! CREATE TABLE base_tbl (a int, b int);
! CREATE FUNCTION base_tbl_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   NEW.b := 10;
!   RETURN NEW;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (5,0); -- ok
! INSERT INTO rw_view1 VALUES (15, 20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15, 10).
! UPDATE rw_view1 SET a = 20, b = 30; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (20, 10).
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! DROP FUNCTION base_tbl_trig_fn();
! -- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view
! CREATE TABLE base_tbl (a int, b int);
! CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, 10);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_trig
!   INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-5).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (50); -- ok, but not in view
! UPDATE rw_view2 SET a = a - 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-5).
! SELECT * FROM base_tbl;
!  a  | b  
! ----+----
!   5 | 10
!  50 | 10
! (2 rows)
! 
! -- Check option won't cascade down to base view with INSTEAD OF triggers
! ALTER VIEW rw_view2 SET (check_option=cascaded);
! INSERT INTO rw_view2 VALUES (100); -- ok, but not in view (doesn't fail rw_view1's check)
! UPDATE rw_view2 SET a = 200 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! SELECT * FROM base_tbl;
!   a  | b  
! -----+----
!   50 | 10
!  100 | 10
!  200 | 10
! (3 rows)
! 
! -- Neither local nor cascaded check options work with INSTEAD rules
! DROP TRIGGER rw_view1_trig ON rw_view1;
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view (doesn't fail rw_view2's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (20); -- ok, but not in view (doesn't fail rw_view1's check)
! UPDATE rw_view2 SET a = 30 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! UPDATE rw_view2 SET a = -5 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view2's check)
! SELECT * FROM base_tbl;
!   a  | b  
! -----+----
!   50 | 10
!  100 | 10
!  200 | 10
!  -10 | 10
!   20 | 10
!   30 | 10
!   -5 | 10
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (2,3); -- ok, but not in view (doesn't fail rw_view2's check)
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view
! CREATE TABLE base_tbl (person text, visibility text);
! INSERT INTO base_tbl VALUES ('Tom', 'public'),
!                             ('Dick', 'private'),
!                             ('Harry', 'public');
! CREATE VIEW rw_view1 AS
!   SELECT person FROM base_tbl WHERE visibility = 'public';
! CREATE FUNCTION snoop(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RAISE NOTICE 'snooped value: %', $1;
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql COST 0.000001;
! CREATE OR REPLACE FUNCTION leakproof(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
! SELECT * FROM rw_view1 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! ALTER VIEW rw_view1 SET (security_barrier = true);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view1 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
!                   QUERY PLAN                   
! -----------------------------------------------
!  Subquery Scan on rw_view1
!    Filter: snoop(rw_view1.person)
!    ->  Seq Scan on base_tbl
!          Filter: (visibility = 'public'::text)
! (4 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: snoop(base_tbl.person)
!          ->  Seq Scan on base_tbl base_tbl_2
!                Filter: (visibility = 'public'::text)
! (5 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Delete on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: (NOT snoop(base_tbl.person))
!          ->  Seq Scan on base_tbl base_tbl_2
!                Filter: (visibility = 'public'::text)
! (5 rows)
! 
! -- security barrier view on top of security barrier view
! CREATE VIEW rw_view2 WITH (security_barrier = true) AS
!   SELECT * FROM rw_view1 WHERE snoop(person);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view2 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view2 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view2 WHERE NOT snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
! EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Subquery Scan on rw_view2
!    Filter: snoop(rw_view2.person)
!    ->  Subquery Scan on rw_view1
!          Filter: snoop(rw_view1.person)
!          ->  Seq Scan on base_tbl
!                Filter: (visibility = 'public'::text)
! (6 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: snoop(base_tbl.person)
!          ->  Subquery Scan on base_tbl_2
!                Filter: snoop(base_tbl_2.person)
!                ->  Seq Scan on base_tbl base_tbl_3
!                      Filter: (visibility = 'public'::text)
! (7 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Delete on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: (NOT snoop(base_tbl.person))
!          ->  Subquery Scan on base_tbl_2
!                Filter: snoop(base_tbl_2.person)
!                ->  Seq Scan on base_tbl base_tbl_3
!                      Filter: (visibility = 'public'::text)
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view on top of table with rules
! CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
! INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
! CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
!   WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
!   DO INSTEAD
!     UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
! CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
!   DO INSTEAD
!     UPDATE base_tbl SET deleted = true WHERE id = old.id;
! CREATE VIEW rw_view1 WITH (security_barrier=true) AS
!   SELECT id, data FROM base_tbl WHERE NOT deleted;
! SELECT * FROM rw_view1;
!  id | data  
! ----+-------
!   1 | Row 1
! (1 row)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_1
!                Index Cond: (id = 1)
!          ->  Subquery Scan on base_tbl
!                Filter: snoop(base_tbl.data)
!                ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_2
!                      Index Cond: (id = 1)
!                      Filter: (NOT deleted)
! (9 rows)
! 
! DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
! NOTICE:  snooped value: Row 1
! EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Insert on base_tbl
!    InitPlan 1 (returns $0)
!      ->  Index Only Scan using base_tbl_pkey on base_tbl t
!            Index Cond: (id = 2)
!    ->  Result
!          One-Time Filter: ($0 IS NOT TRUE)
!  
!  Update on base_tbl
!    InitPlan 1 (returns $0)
!      ->  Index Only Scan using base_tbl_pkey on base_tbl t
!            Index Cond: (id = 2)
!    ->  Result
!          One-Time Filter: $0
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (id = 2)
! (15 rows)
! 
! INSERT INTO rw_view1 VALUES (2, 'New row 2');
! SELECT * FROM base_tbl;
!  id |   data    | deleted 
! ----+-----------+---------
!   1 | Row 1     | t
!   2 | New row 2 | f
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- security barrier view based on inheiritance set
! CREATE TABLE t1 (a int, b float, c text);
! CREATE INDEX t1_a_idx ON t1(a);
! INSERT INTO t1
! SELECT i,i,'t1' FROM generate_series(1,10) g(i);
! ANALYZE t1;
! CREATE TABLE t11 (d text) INHERITS (t1);
! CREATE INDEX t11_a_idx ON t11(a);
! INSERT INTO t11
! SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
! ANALYZE t11;
! CREATE TABLE t12 (e int[]) INHERITS (t1);
! CREATE INDEX t12_a_idx ON t12(a);
! INSERT INTO t12
! SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t12;
! CREATE TABLE t111 () INHERITS (t11, t12);
! NOTICE:  merging multiple inherited definitions of column "a"
! NOTICE:  merging multiple inherited definitions of column "b"
! NOTICE:  merging multiple inherited definitions of column "c"
! CREATE INDEX t111_a_idx ON t111(a);
! INSERT INTO t111
! SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t111;
! CREATE VIEW v1 WITH (security_barrier=true) AS
! SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
! FROM t1
! WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
! SELECT * FROM v1 WHERE a=3; -- should not see anything
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM v1 WHERE a=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  8 | 8 | t1   | t11d
!  8 | 8 | t11  | t11d
!  8 | 8 | t12  | t11d
!  8 | 8 | t111 | t11d
! (4 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
!                                         QUERY PLAN                                         
! -------------------------------------------------------------------------------------------
!  Update on public.t1 t1_4
!    ->  Subquery Scan on t1
!          Output: 100, t1.b, t1.c, t1.ctid
!          Filter: snoop(t1.a)
!          ->  Nested Loop Semi Join
!                Output: t1_5.ctid, t1_5.a, t1_5.b, t1_5.c
!                ->  Seq Scan on public.t1 t1_5
!                      Output: t1_5.ctid, t1_5.a, t1_5.b, t1_5.c
!                      Filter: ((t1_5.a > 5) AND (t1_5.a = 3) AND leakproof(t1_5.a))
!                ->  Append
!                      ->  Seq Scan on public.t12
!                            Output: t12.a
!                            Filter: (t12.a = 3)
!                      ->  Seq Scan on public.t111
!                            Output: t111.a
!                            Filter: (t111.a = 3)
!    ->  Subquery Scan on t1_1
!          Output: 100, t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
!          Filter: snoop(t1_1.a)
!          ->  Nested Loop Semi Join
!                Output: t11.ctid, t11.a, t11.b, t11.c, t11.d
!                ->  Seq Scan on public.t11
!                      Output: t11.ctid, t11.a, t11.b, t11.c, t11.d
!                      Filter: ((t11.a > 5) AND (t11.a = 3) AND leakproof(t11.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_1
!                            Output: t12_1.a
!                            Filter: (t12_1.a = 3)
!                      ->  Seq Scan on public.t111 t111_1
!                            Output: t111_1.a
!                            Filter: (t111_1.a = 3)
!    ->  Subquery Scan on t1_2
!          Output: 100, t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
!          Filter: snoop(t1_2.a)
!          ->  Nested Loop Semi Join
!                Output: t12_2.ctid, t12_2.a, t12_2.b, t12_2.c, t12_2.e
!                ->  Seq Scan on public.t12 t12_2
!                      Output: t12_2.ctid, t12_2.a, t12_2.b, t12_2.c, t12_2.e
!                      Filter: ((t12_2.a > 5) AND (t12_2.a = 3) AND leakproof(t12_2.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_3
!                            Output: t12_3.a
!                            Filter: (t12_3.a = 3)
!                      ->  Seq Scan on public.t111 t111_2
!                            Output: t111_2.a
!                            Filter: (t111_2.a = 3)
!    ->  Subquery Scan on t1_3
!          Output: 100, t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
!          Filter: snoop(t1_3.a)
!          ->  Nested Loop Semi Join
!                Output: t111_3.ctid, t111_3.a, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                ->  Seq Scan on public.t111 t111_3
!                      Output: t111_3.ctid, t111_3.a, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                      Filter: ((t111_3.a > 5) AND (t111_3.a = 3) AND leakproof(t111_3.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_4
!                            Output: t12_4.a
!                            Filter: (t12_4.a = 3)
!                      ->  Seq Scan on public.t111 t111_4
!                            Output: t111_4.a
!                            Filter: (t111_4.a = 3)
! (61 rows)
! 
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
! SELECT * FROM v1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM t1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c 
! ---+---+---
! (0 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
!                                         QUERY PLAN                                         
! -------------------------------------------------------------------------------------------
!  Update on public.t1 t1_4
!    ->  Subquery Scan on t1
!          Output: (t1.a + 1), t1.b, t1.c, t1.ctid
!          Filter: snoop(t1.a)
!          ->  Nested Loop Semi Join
!                Output: t1_5.a, t1_5.ctid, t1_5.b, t1_5.c
!                ->  Seq Scan on public.t1 t1_5
!                      Output: t1_5.a, t1_5.ctid, t1_5.b, t1_5.c
!                      Filter: ((t1_5.a > 5) AND (t1_5.a = 8) AND leakproof(t1_5.a))
!                ->  Append
!                      ->  Seq Scan on public.t12
!                            Output: t12.a
!                            Filter: (t12.a = 8)
!                      ->  Seq Scan on public.t111
!                            Output: t111.a
!                            Filter: (t111.a = 8)
!    ->  Subquery Scan on t1_1
!          Output: (t1_1.a + 1), t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
!          Filter: snoop(t1_1.a)
!          ->  Nested Loop Semi Join
!                Output: t11.a, t11.ctid, t11.b, t11.c, t11.d
!                ->  Seq Scan on public.t11
!                      Output: t11.a, t11.ctid, t11.b, t11.c, t11.d
!                      Filter: ((t11.a > 5) AND (t11.a = 8) AND leakproof(t11.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_1
!                            Output: t12_1.a
!                            Filter: (t12_1.a = 8)
!                      ->  Seq Scan on public.t111 t111_1
!                            Output: t111_1.a
!                            Filter: (t111_1.a = 8)
!    ->  Subquery Scan on t1_2
!          Output: (t1_2.a + 1), t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
!          Filter: snoop(t1_2.a)
!          ->  Nested Loop Semi Join
!                Output: t12_2.a, t12_2.ctid, t12_2.b, t12_2.c, t12_2.e
!                ->  Seq Scan on public.t12 t12_2
!                      Output: t12_2.a, t12_2.ctid, t12_2.b, t12_2.c, t12_2.e
!                      Filter: ((t12_2.a > 5) AND (t12_2.a = 8) AND leakproof(t12_2.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_3
!                            Output: t12_3.a
!                            Filter: (t12_3.a = 8)
!                      ->  Seq Scan on public.t111 t111_2
!                            Output: t111_2.a
!                            Filter: (t111_2.a = 8)
!    ->  Subquery Scan on t1_3
!          Output: (t1_3.a + 1), t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
!          Filter: snoop(t1_3.a)
!          ->  Nested Loop Semi Join
!                Output: t111_3.a, t111_3.ctid, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                ->  Seq Scan on public.t111 t111_3
!                      Output: t111_3.a, t111_3.ctid, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                      Filter: ((t111_3.a > 5) AND (t111_3.a = 8) AND leakproof(t111_3.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_4
!                            Output: t12_4.a
!                            Filter: (t12_4.a = 8)
!                      ->  Seq Scan on public.t111 t111_4
!                            Output: t111_4.a
!                            Filter: (t111_4.a = 8)
! (61 rows)
! 
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! SELECT * FROM v1 WHERE b=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  9 | 8 | t1   | t11d
!  9 | 8 | t11  | t11d
!  9 | 8 | t12  | t11d
!  9 | 8 | t111 | t11d
! (4 rows)
! 
! DELETE FROM v1 WHERE snoop(a) AND leakproof(a); -- should not delete everything, just where a>5
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! TABLE t1; -- verify all a<=5 are intact
!  a | b |  c   
! ---+---+------
!  1 | 1 | t1
!  2 | 2 | t1
!  3 | 3 | t1
!  4 | 4 | t1
!  5 | 5 | t1
!  1 | 1 | t11
!  2 | 2 | t11
!  3 | 3 | t11
!  4 | 4 | t11
!  5 | 5 | t11
!  1 | 1 | t12
!  2 | 2 | t12
!  3 | 3 | t12
!  4 | 4 | t12
!  5 | 5 | t12
!  1 | 1 | t111
!  2 | 2 | t111
!  3 | 3 | t111
!  4 | 4 | t111
!  5 | 5 | t111
! (20 rows)
! 
! DROP TABLE t1, t11, t12, t111 CASCADE;
! NOTICE:  drop cascades to view v1
! DROP FUNCTION snoop(anyelement);
! DROP FUNCTION leakproof(anyelement);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/sanity_check.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/sanity_check.out	2015-01-10 10:11:46.215649452 +0300
***************
*** 1,190 ****
! VACUUM;
! --
! -- sanity check, if we don't have indices the test will take years to
! -- complete.  But skip TOAST relations (since they will have varying
! -- names depending on the current OID counter) as well as temp tables
! -- of other backends (to avoid timing-dependent behavior).
! --
! -- temporarily disable fancy output, so catalog changes create less diff noise
! \a\t
! SELECT relname, relhasindex
!    FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
!    WHERE relkind = 'r' AND (nspname ~ '^pg_temp_') IS NOT TRUE
!    ORDER BY relname;
! a|f
! a_star|f
! abstime_tbl|f
! aggtest|f
! array_index_op_test|t
! array_op_test|f
! b|f
! b_star|f
! box_tbl|f
! bprime|f
! bt_f8_heap|t
! bt_i4_heap|t
! bt_name_heap|t
! bt_txt_heap|t
! c|f
! c_star|f
! char_tbl|f
! check2_tbl|f
! check_tbl|f
! circle_tbl|t
! city|f
! copy_tbl|f
! d|f
! d_star|f
! date_tbl|f
! default_tbl|f
! defaultexpr_tbl|f
! dept|f
! dupindexcols|t
! e_star|f
! emp|f
! equipment_r|f
! f_star|f
! fast_emp4000|t
! float4_tbl|f
! float8_tbl|f
! func_index_heap|t
! hash_f8_heap|t
! hash_i4_heap|t
! hash_name_heap|t
! hash_txt_heap|t
! hobbies_r|f
! ihighway|t
! inet_tbl|f
! inhf|f
! inhx|t
! insert_tbl|f
! int2_tbl|f
! int4_tbl|f
! int8_tbl|f
! interval_tbl|f
! iportaltest|f
! kd_point_tbl|t
! line_tbl|f
! log_table|f
! lseg_tbl|f
! main_table|f
! money_data|f
! num_data|f
! num_exp_add|t
! num_exp_div|t
! num_exp_ln|t
! num_exp_log10|t
! num_exp_mul|t
! num_exp_power_10_ln|t
! num_exp_sqrt|t
! num_exp_sub|t
! num_input_test|f
! num_result|f
! onek|t
! onek2|t
! path_tbl|f
! person|f
! pg_aggregate|t
! pg_am|t
! pg_amop|t
! pg_amproc|t
! pg_attrdef|t
! pg_attribute|t
! pg_auth_members|t
! pg_authid|t
! pg_cast|t
! pg_class|t
! pg_collation|t
! pg_constraint|t
! pg_conversion|t
! pg_database|t
! pg_db_role_setting|t
! pg_default_acl|t
! pg_depend|t
! pg_description|t
! pg_enum|t
! pg_event_trigger|t
! pg_extension|t
! pg_foreign_data_wrapper|t
! pg_foreign_server|t
! pg_foreign_table|t
! pg_index|t
! pg_inherits|t
! pg_language|t
! pg_largeobject|t
! pg_largeobject_metadata|t
! pg_namespace|t
! pg_opclass|t
! pg_operator|t
! pg_opfamily|t
! pg_pltemplate|t
! pg_proc|t
! pg_range|t
! pg_rewrite|t
! pg_rowsecurity|t
! pg_seclabel|t
! pg_shdepend|t
! pg_shdescription|t
! pg_shseclabel|t
! pg_statistic|t
! pg_tablespace|t
! pg_trigger|t
! pg_ts_config|t
! pg_ts_config_map|t
! pg_ts_dict|t
! pg_ts_parser|t
! pg_ts_template|t
! pg_type|t
! pg_user_mapping|t
! point_tbl|t
! polygon_tbl|t
! quad_point_tbl|t
! radix_text_tbl|t
! ramp|f
! real_city|f
! reltime_tbl|f
! road|t
! shighway|t
! slow_emp4000|f
! sql_features|f
! sql_implementation_info|f
! sql_languages|f
! sql_packages|f
! sql_parts|f
! sql_sizing|f
! sql_sizing_profiles|f
! stud_emp|f
! student|f
! tenk1|t
! tenk2|t
! test_range_excl|t
! test_range_gist|t
! test_range_spgist|t
! test_tsvector|f
! testjsonb|f
! text_tbl|f
! time_tbl|f
! timestamp_tbl|f
! timestamptz_tbl|f
! timetz_tbl|f
! tinterval_tbl|f
! varchar_tbl|f
! -- restore normal output mode
! \a\t
! --
! -- another sanity check: every system catalog that has OIDs should have
! -- a unique index on OID.  This ensures that the OIDs will be unique,
! -- even after the OID counter wraps around.
! -- We exclude non-system tables from the check by looking at nspname.
! --
! SELECT relname, nspname
! FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
! WHERE relhasoids
!     AND ((nspname ~ '^pg_') IS NOT FALSE)
!     AND NOT EXISTS (SELECT 1 FROM pg_index i WHERE indrelid = c.oid
!                     AND indkey[0] = -2 AND indnatts = 1
!                     AND indisunique AND indimmediate);
!  relname | nspname 
! ---------+---------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/errors.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/errors.out	2015-01-10 10:11:46.223649453 +0300
***************
*** 1,447 ****
! --
! -- ERRORS
! --
! -- bad in postquel, but ok in postsql
! select 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! --
! -- UNSUPPORTED STUFF
! -- doesn't work
! -- notify pg_class
! --
! --
! -- SELECT
! -- this used to be a syntax error, but now we allow an empty target list
! select;
! --
! (1 row)
! 
! -- no such relation
! select * from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: select * from nonesuch;
!                       ^
! -- bad name in target list
! select nonesuch from pg_database;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select nonesuch from pg_database;
!                ^
! -- empty distinct list isn't OK
! select distinct from pg_database;
! ERROR:  SELECT DISTINCT must have at least one column
! -- bad attribute name on lhs of operator
! select * from pg_database where nonesuch = pg_database.datname;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select * from pg_database where nonesuch = pg_database.datna...
!                                         ^
! -- bad attribute name on rhs of operator
! select * from pg_database where pg_database.datname = nonesuch;
! ERROR:  column "nonesuch" does not exist
! LINE 1: ...ect * from pg_database where pg_database.datname = nonesuch;
!                                                               ^
! -- bad attribute name in select distinct on
! select distinct on (foobar) * from pg_database;
! ERROR:  column "foobar" does not exist
! LINE 1: select distinct on (foobar) * from pg_database;
!                             ^
! --
! -- DELETE
! -- missing relation name (this had better not wildcard!)
! delete from;
! ERROR:  syntax error at or near ";"
! LINE 1: delete from;
!                    ^
! -- no such relation
! delete from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: delete from nonesuch;
!                     ^
! --
! -- DROP
! -- missing relation name (this had better not wildcard!)
! drop table;
! ERROR:  syntax error at or near ";"
! LINE 1: drop table;
!                   ^
! -- no such relation
! drop table nonesuch;
! ERROR:  table "nonesuch" does not exist
! --
! -- ALTER TABLE
! -- relation renaming
! -- missing relation name
! alter table rename;
! ERROR:  syntax error at or near ";"
! LINE 1: alter table rename;
!                           ^
! -- no such relation
! alter table nonesuch rename to newnonesuch;
! ERROR:  relation "nonesuch" does not exist
! -- no such relation
! alter table nonesuch rename to stud_emp;
! ERROR:  relation "nonesuch" does not exist
! -- conflict
! alter table stud_emp rename to aggtest;
! ERROR:  relation "aggtest" already exists
! -- self-conflict
! alter table stud_emp rename to stud_emp;
! ERROR:  relation "stud_emp" already exists
! -- attribute renaming
! -- no such relation
! alter table nonesuchrel rename column nonesuchatt to newnonesuchatt;
! ERROR:  relation "nonesuchrel" does not exist
! -- no such attribute
! alter table emp rename column nonesuchatt to newnonesuchatt;
! ERROR:  column "nonesuchatt" does not exist
! -- conflict
! alter table emp rename column salary to manager;
! ERROR:  column "manager" of relation "stud_emp" already exists
! -- conflict
! alter table emp rename column salary to oid;
! ERROR:  column name "oid" conflicts with a system column name
! --
! -- TRANSACTION STUFF
! -- not in a xact
! abort;
! WARNING:  there is no transaction in progress
! -- not in a xact
! end;
! WARNING:  there is no transaction in progress
! --
! -- CREATE AGGREGATE
! -- sfunc/finalfunc type disagreement
! create aggregate newavg2 (sfunc = int4pl,
! 			  basetype = int4,
! 			  stype = int4,
! 			  finalfunc = int2um,
! 			  initcond = '0');
! ERROR:  function int2um(integer) does not exist
! -- left out basetype
! create aggregate newcnt1 (sfunc = int4inc,
! 			  stype = int4,
! 			  initcond = '0');
! ERROR:  aggregate input type must be specified
! --
! -- DROP INDEX
! -- missing index name
! drop index;
! ERROR:  syntax error at or near ";"
! LINE 1: drop index;
!                   ^
! -- bad index name
! drop index 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop index 314159;
!                    ^
! -- no such index
! drop index nonesuch;
! ERROR:  index "nonesuch" does not exist
! --
! -- DROP AGGREGATE
! -- missing aggregate name
! drop aggregate;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate;
!                       ^
! -- missing aggregate type
! drop aggregate newcnt1;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate newcnt1;
!                               ^
! -- bad aggregate name
! drop aggregate 314159 (int);
! ERROR:  syntax error at or near "314159"
! LINE 1: drop aggregate 314159 (int);
!                        ^
! -- bad aggregate type
! drop aggregate newcnt (nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such aggregate
! drop aggregate nonesuch (int4);
! ERROR:  aggregate nonesuch(integer) does not exist
! -- no such aggregate for type
! drop aggregate newcnt (float4);
! ERROR:  aggregate newcnt(real) does not exist
! --
! -- DROP FUNCTION
! -- missing function name
! drop function ();
! ERROR:  syntax error at or near "("
! LINE 1: drop function ();
!                       ^
! -- bad function name
! drop function 314159();
! ERROR:  syntax error at or near "314159"
! LINE 1: drop function 314159();
!                       ^
! -- no such function
! drop function nonesuch();
! ERROR:  function nonesuch() does not exist
! --
! -- DROP TYPE
! -- missing type name
! drop type;
! ERROR:  syntax error at or near ";"
! LINE 1: drop type;
!                  ^
! -- bad type name
! drop type 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop type 314159;
!                   ^
! -- no such type
! drop type nonesuch;
! ERROR:  type "nonesuch" does not exist
! --
! -- DROP OPERATOR
! -- missing everything
! drop operator;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator;
!                      ^
! -- bad operator name
! drop operator equals;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator equals;
!                             ^
! -- missing type list
! drop operator ===;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator ===;
!                          ^
! -- missing parentheses
! drop operator int4, int4;
! ERROR:  syntax error at or near ","
! LINE 1: drop operator int4, int4;
!                           ^
! -- missing operator name
! drop operator (int4, int4);
! ERROR:  syntax error at or near "("
! LINE 1: drop operator (int4, int4);
!                       ^
! -- missing type list contents
! drop operator === ();
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator === ();
!                            ^
! -- no such operator
! drop operator === (int4);
! ERROR:  missing argument
! LINE 1: drop operator === (int4);
!                                ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such operator by that name
! drop operator === (int4, int4);
! ERROR:  operator does not exist: integer === integer
! -- no such type1
! drop operator = (nonesuch);
! ERROR:  missing argument
! LINE 1: drop operator = (nonesuch);
!                                  ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such type1
! drop operator = ( , int4);
! ERROR:  syntax error at or near ","
! LINE 1: drop operator = ( , int4);
!                           ^
! -- no such type1
! drop operator = (nonesuch, int4);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, );
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator = (int4, );
!                                ^
! --
! -- DROP RULE
! -- missing rule name
! drop rule;
! ERROR:  syntax error at or near ";"
! LINE 1: drop rule;
!                  ^
! -- bad rule name
! drop rule 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop rule 314159;
!                   ^
! -- no such rule
! drop rule nonesuch on noplace;
! ERROR:  relation "noplace" does not exist
! -- these postquel variants are no longer supported
! drop tuple rule nonesuch;
! ERROR:  syntax error at or near "tuple"
! LINE 1: drop tuple rule nonesuch;
!              ^
! drop instance rule nonesuch on noplace;
! ERROR:  syntax error at or near "instance"
! LINE 1: drop instance rule nonesuch on noplace;
!              ^
! drop rewrite rule nonesuch;
! ERROR:  syntax error at or near "rewrite"
! LINE 1: drop rewrite rule nonesuch;
!              ^
! --
! -- Check that division-by-zero is properly caught.
! --
! select 1/0;
! ERROR:  division by zero
! select 1::int8/0;
! ERROR:  division by zero
! select 1/0::int8;
! ERROR:  division by zero
! select 1::int2/0;
! ERROR:  division by zero
! select 1/0::int2;
! ERROR:  division by zero
! select 1::numeric/0;
! ERROR:  division by zero
! select 1/0::numeric;
! ERROR:  division by zero
! select 1::float8/0;
! ERROR:  division by zero
! select 1/0::float8;
! ERROR:  division by zero
! select 1::float4/0;
! ERROR:  division by zero
! select 1/0::float4;
! ERROR:  division by zero
! --
! -- Test psql's reporting of syntax error location
! --
! xxx;
! ERROR:  syntax error at or near "xxx"
! LINE 1: xxx;
!         ^
! CREATE foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: CREATE foo;
!                ^
! CREATE TABLE ;
! ERROR:  syntax error at or near ";"
! LINE 1: CREATE TABLE ;
!                      ^
! CREATE TABLE
! \g
! ERROR:  syntax error at end of input
! LINE 1: CREATE TABLE
!                     ^
! INSERT INTO foo VALUES(123) foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: INSERT INTO foo VALUES(123) foo;
!                                     ^
! INSERT INTO 123
! VALUES(123);
! ERROR:  syntax error at or near "123"
! LINE 1: INSERT INTO 123
!                     ^
! INSERT INTO foo
! VALUES(123) 123
! ;
! ERROR:  syntax error at or near "123"
! LINE 2: VALUES(123) 123
!                     ^
! -- with a tab
! CREATE TABLE foo
!   (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY,
! 	id3 INTEGER NOT NUL,
!    id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 3:  id3 INTEGER NOT NUL,
!                          ^
! -- long line to be truncated on the left
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right
! CREATE TABLE foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
! ERROR:  syntax error at or near "NUL"
! LINE 2: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- long line to be truncated on the left, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4
! UNIQUE
! NOT
! NULL,
! id5 TEXT
! UNIQUE
! NOT
! NULL)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 4: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 5: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways, many lines
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv INT4 UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 7: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- more than 10 lines...
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE
! NOT
! NULL
! ,
! idm
! INT4
! UNIQUE
! NOT
! NULL,
! idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv
! INT4
! UNIQUE
! NOT
! NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 16: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                               ^
! -- Check that stack depth detection mechanism works and
! -- max_stack_depth is not set too high
! create function infinite_recurse() returns int as
! 'select infinite_recurse()' language sql;
! \set VERBOSITY terse
! select infinite_recurse();
! ERROR:  stack depth limit exceeded
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select.out	2015-01-10 10:11:46.239649453 +0300
***************
*** 1,783 ****
! --
! -- SELECT
! --
! -- btree index
! -- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT * FROM onek
!    WHERE onek.unique1 < 10
!    ORDER BY onek.unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY stringu1 using <;
!  unique1 | stringu1 
! ---------+----------
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1d -2 +0nr -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using <, unique1 using >;
!  unique1 | string4 
! ---------+---------
!      999 | AAAAxx
!      995 | AAAAxx
!      983 | AAAAxx
!      982 | AAAAxx
!      981 | AAAAxx
!      998 | HHHHxx
!      997 | HHHHxx
!      993 | HHHHxx
!      990 | HHHHxx
!      986 | HHHHxx
!      996 | OOOOxx
!      991 | OOOOxx
!      988 | OOOOxx
!      987 | OOOOxx
!      985 | OOOOxx
!      994 | VVVVxx
!      992 | VVVVxx
!      989 | VVVVxx
!      984 | VVVVxx
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1dr -2 +0n -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using >, unique1 using <;
!  unique1 | string4 
! ---------+---------
!      984 | VVVVxx
!      989 | VVVVxx
!      992 | VVVVxx
!      994 | VVVVxx
!      985 | OOOOxx
!      987 | OOOOxx
!      988 | OOOOxx
!      991 | OOOOxx
!      996 | OOOOxx
!      986 | HHHHxx
!      990 | HHHHxx
!      993 | HHHHxx
!      997 | HHHHxx
!      998 | HHHHxx
!      981 | AAAAxx
!      982 | AAAAxx
!      983 | AAAAxx
!      995 | AAAAxx
!      999 | AAAAxx
! (19 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0nr -1 +1d -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >, string4 using <;
!  unique1 | string4 
! ---------+---------
!       19 | OOOOxx
!       18 | VVVVxx
!       17 | HHHHxx
!       16 | OOOOxx
!       15 | VVVVxx
!       14 | AAAAxx
!       13 | OOOOxx
!       12 | AAAAxx
!       11 | OOOOxx
!       10 | AAAAxx
!        9 | HHHHxx
!        8 | HHHHxx
!        7 | VVVVxx
!        6 | OOOOxx
!        5 | HHHHxx
!        4 | HHHHxx
!        3 | VVVVxx
!        2 | OOOOxx
!        1 | OOOOxx
!        0 | OOOOxx
! (20 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0n -1 +1dr -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using <, string4 using >;
!  unique1 | string4 
! ---------+---------
!        0 | OOOOxx
!        1 | OOOOxx
!        2 | OOOOxx
!        3 | VVVVxx
!        4 | HHHHxx
!        5 | HHHHxx
!        6 | OOOOxx
!        7 | VVVVxx
!        8 | HHHHxx
!        9 | HHHHxx
!       10 | AAAAxx
!       11 | OOOOxx
!       12 | AAAAxx
!       13 | OOOOxx
!       14 | AAAAxx
!       15 | VVVVxx
!       16 | OOOOxx
!       17 | HHHHxx
!       18 | VVVVxx
!       19 | OOOOxx
! (20 rows)
! 
! --
! -- test partial btree indexes
! --
! -- As of 7.2, planner probably won't pick an indexscan without stats,
! -- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
! -- followed by sort, because that could hide index ordering problems.
! --
! ANALYZE onek2;
! SET enable_seqscan TO off;
! SET enable_bitmapscan TO off;
! SET enable_sort TO off;
! --
! -- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!     WHERE onek2.unique1 < 20
!     ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!    WHERE onek2.unique1 > 980;
!  unique1 | stringu1 
! ---------+----------
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
! (19 rows)
! 
! RESET enable_seqscan;
! RESET enable_bitmapscan;
! RESET enable_sort;
! SELECT two, stringu1, ten, string4
!    INTO TABLE tmp
!    FROM onek;
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
! --
! -- SELECT name, age FROM person*; ??? check if different
! SELECT p.name, p.age FROM person* p;
!   name   | age 
! ---------+-----
!  mike    |  40
!  joe     |  20
!  sally   |  34
!  sandra  |  19
!  alex    |  30
!  sue     |  50
!  denise  |  24
!  sarah   |  88
!  teresa  |  38
!  nan     |  28
!  leah    |  68
!  wendy   |  78
!  melissa |  28
!  joan    |  18
!  mary    |   8
!  jane    |  58
!  liza    |  38
!  jean    |  28
!  jenifer |  38
!  juanita |  58
!  susan   |  78
!  zena    |  98
!  martie  |  88
!  chris   |  78
!  pat     |  18
!  zola    |  58
!  louise  |  98
!  edna    |  18
!  bertha  |  88
!  sumi    |  38
!  koko    |  88
!  gina    |  18
!  rean    |  48
!  sharon  |  78
!  paula   |  68
!  julie   |  68
!  belinda |  38
!  karen   |  48
!  carina  |  58
!  diane   |  18
!  esther  |  98
!  trudy   |  88
!  fanny   |   8
!  carmen  |  78
!  lita    |  25
!  pamela  |  48
!  sandy   |  38
!  trisha  |  88
!  uma     |  78
!  velma   |  68
!  sharon  |  25
!  sam     |  30
!  bill    |  20
!  fred    |  28
!  larry   |  60
!  jeff    |  23
!  cim     |  30
!  linda   |  19
! (58 rows)
! 
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
! -- sort +1nr -2
! --
! SELECT p.name, p.age FROM person* p ORDER BY age using >, name;
!   name   | age 
! ---------+-----
!  esther  |  98
!  louise  |  98
!  zena    |  98
!  bertha  |  88
!  koko    |  88
!  martie  |  88
!  sarah   |  88
!  trisha  |  88
!  trudy   |  88
!  carmen  |  78
!  chris   |  78
!  sharon  |  78
!  susan   |  78
!  uma     |  78
!  wendy   |  78
!  julie   |  68
!  leah    |  68
!  paula   |  68
!  velma   |  68
!  larry   |  60
!  carina  |  58
!  jane    |  58
!  juanita |  58
!  zola    |  58
!  sue     |  50
!  karen   |  48
!  pamela  |  48
!  rean    |  48
!  mike    |  40
!  belinda |  38
!  jenifer |  38
!  liza    |  38
!  sandy   |  38
!  sumi    |  38
!  teresa  |  38
!  sally   |  34
!  alex    |  30
!  cim     |  30
!  sam     |  30
!  fred    |  28
!  jean    |  28
!  melissa |  28
!  nan     |  28
!  lita    |  25
!  sharon  |  25
!  denise  |  24
!  jeff    |  23
!  bill    |  20
!  joe     |  20
!  linda   |  19
!  sandra  |  19
!  diane   |  18
!  edna    |  18
!  gina    |  18
!  joan    |  18
!  pat     |  18
!  fanny   |   8
!  mary    |   8
! (58 rows)
! 
! --
! -- Test some cases involving whole-row Var referencing a subquery
! --
! select foo from (select 1) as foo;
!  foo 
! -----
!  (1)
! (1 row)
! 
! select foo from (select null) as foo;
!  foo 
! -----
!  ()
! (1 row)
! 
! select foo from (select 'xyzzy',1,null) as foo;
!     foo     
! ------------
!  (xyzzy,1,)
! (1 row)
! 
! --
! -- Test VALUES lists
! --
! select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
!     WHERE onek.unique1 = v.i and onek.stringu1 = v.j;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
!      147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
!      931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
! (2 rows)
! 
! -- a more complex case
! -- looks like we're coding lisp :-)
! select * from onek,
!   (values ((select i from
!     (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
!     order by i asc limit 1))) bar (i)
!   where onek.unique1 = bar.i;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
! (1 row)
! 
! -- try VALUES in a subquery
! select * from onek
!     where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
!     order by unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!       20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
!       99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
! (3 rows)
! 
! -- VALUES is also legal as a standalone query or a set-operation member
! VALUES (1,2), (3,4+4), (7,77.7);
!  column1 | column2 
! ---------+---------
!        1 |       2
!        3 |       8
!        7 |    77.7
! (3 rows)
! 
! VALUES (1,2), (3,4+4), (7,77.7)
! UNION ALL
! SELECT 2+2, 57
! UNION ALL
! TABLE int8_tbl;
!      column1      |      column2      
! ------------------+-------------------
!                 1 |                 2
!                 3 |                 8
!                 7 |              77.7
!                 4 |                57
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (9 rows)
! 
! --
! -- Test ORDER BY options
! --
! CREATE TEMP TABLE foo (f1 int);
! INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 ASC;	-- same thing
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! -- check if indexscans do the right things
! CREATE INDEX fooi ON foo (f1);
! SET enable_sort = false;
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! --
! -- Test some corner cases that have been known to confuse the planner
! --
! -- ORDER BY on a constant doesn't really need any sorting
! SELECT 1 AS x ORDER BY x;
!  x 
! ---
!  1
! (1 row)
! 
! -- But ORDER BY on a set-valued expression does
! create function sillysrf(int) returns setof int as
!   'values (1),(10),(2),($1)' language sql immutable;
! select sillysrf(42);
!  sillysrf 
! ----------
!         1
!        10
!         2
!        42
! (4 rows)
! 
! select sillysrf(-1) order by 1;
!  sillysrf 
! ----------
!        -1
!         1
!         2
!        10
! (4 rows)
! 
! drop function sillysrf(int);
! -- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
! -- (see bug #5084)
! select * from (values (2),(null),(1)) v(k) where k = k order by k;
!  k 
! ---
!  1
!  2
! (2 rows)
! 
! select * from (values (2),(null),(1)) v(k) where k = k;
!  k 
! ---
!  2
!  1
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_into.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_into.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,96 ****
! --
! -- SELECT_INTO
! --
! SELECT *
!    INTO TABLE tmp1
!    FROM onek
!    WHERE onek.unique1 < 2;
! DROP TABLE tmp1;
! SELECT *
!    INTO TABLE tmp1
!    FROM onek2
!    WHERE onek2.unique1 < 2;
! DROP TABLE tmp1;
! --
! -- SELECT INTO and INSERT permission, if owner is not allowed to insert.
! --
! CREATE SCHEMA selinto_schema;
! CREATE USER selinto_user;
! ALTER DEFAULT PRIVILEGES FOR ROLE selinto_user
! 	  REVOKE INSERT ON TABLES FROM selinto_user;
! GRANT ALL ON SCHEMA selinto_schema TO public;
! SET SESSION AUTHORIZATION selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%';	-- Error
! ERROR:  permission denied for relation tmp1
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- Error
! ERROR:  permission denied for relation tmp2
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- Error
! ERROR:  permission denied for relation tmp3
! RESET SESSION AUTHORIZATION;
! ALTER DEFAULT PRIVILEGES FOR ROLE selinto_user
! 	  GRANT INSERT ON TABLES TO selinto_user;
! SET SESSION AUTHORIZATION selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%';	-- OK
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- OK
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- OK
! RESET SESSION AUTHORIZATION;
! DROP SCHEMA selinto_schema CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table selinto_schema.tmp1
! drop cascades to table selinto_schema.tmp2
! drop cascades to table selinto_schema.tmp3
! DROP USER selinto_user;
! --
! -- CREATE TABLE AS/SELECT INTO as last command in a SQL function
! -- have been known to cause problems
! --
! CREATE FUNCTION make_table() RETURNS VOID
! AS $$
!   CREATE TABLE created_table AS SELECT * FROM int8_tbl;
! $$ LANGUAGE SQL;
! SELECT make_table();
!  make_table 
! ------------
!  
! (1 row)
! 
! SELECT * FROM created_table;
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! DROP TABLE created_table;
! --
! -- Disallowed uses of SELECT ... INTO.  All should fail
! --
! DECLARE foo CURSOR FOR SELECT 1 INTO b;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: DECLARE foo CURSOR FOR SELECT 1 INTO b;
!                                              ^
! COPY (SELECT 1 INTO frak UNION SELECT 2) TO 'blob';
! ERROR:  COPY (SELECT INTO) is not supported
! SELECT * FROM (SELECT 1 INTO f) bar;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: SELECT * FROM (SELECT 1 INTO f) bar;
!                                      ^
! CREATE VIEW foo AS SELECT 1 INTO b;
! ERROR:  views must not contain SELECT INTO
! INSERT INTO b SELECT 1 INTO f;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: INSERT INTO b SELECT 1 INTO f;
!                                     ^
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_distinct.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_distinct.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,222 ****
! --
! -- SELECT_DISTINCT
! --
! --
! -- awk '{print $3;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT two FROM tmp ORDER BY 1;
!  two 
! -----
!    0
!    1
! (2 rows)
! 
! --
! -- awk '{print $5;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT ten FROM tmp ORDER BY 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! --
! -- awk '{print $16;}' onek.data | sort -d | uniq
! --
! SELECT DISTINCT string4 FROM tmp ORDER BY 1;
!  string4 
! ---------
!  AAAAxx
!  HHHHxx
!  OOOOxx
!  VVVVxx
! (4 rows)
! 
! --
! -- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
! -- sort +0n -1 +1d -2 +2n -3
! --
! SELECT DISTINCT two, string4, ten
!    FROM tmp
!    ORDER BY two using <, string4 using <, ten using <;
!  two | string4 | ten 
! -----+---------+-----
!    0 | AAAAxx  |   0
!    0 | AAAAxx  |   2
!    0 | AAAAxx  |   4
!    0 | AAAAxx  |   6
!    0 | AAAAxx  |   8
!    0 | HHHHxx  |   0
!    0 | HHHHxx  |   2
!    0 | HHHHxx  |   4
!    0 | HHHHxx  |   6
!    0 | HHHHxx  |   8
!    0 | OOOOxx  |   0
!    0 | OOOOxx  |   2
!    0 | OOOOxx  |   4
!    0 | OOOOxx  |   6
!    0 | OOOOxx  |   8
!    0 | VVVVxx  |   0
!    0 | VVVVxx  |   2
!    0 | VVVVxx  |   4
!    0 | VVVVxx  |   6
!    0 | VVVVxx  |   8
!    1 | AAAAxx  |   1
!    1 | AAAAxx  |   3
!    1 | AAAAxx  |   5
!    1 | AAAAxx  |   7
!    1 | AAAAxx  |   9
!    1 | HHHHxx  |   1
!    1 | HHHHxx  |   3
!    1 | HHHHxx  |   5
!    1 | HHHHxx  |   7
!    1 | HHHHxx  |   9
!    1 | OOOOxx  |   1
!    1 | OOOOxx  |   3
!    1 | OOOOxx  |   5
!    1 | OOOOxx  |   7
!    1 | OOOOxx  |   9
!    1 | VVVVxx  |   1
!    1 | VVVVxx  |   3
!    1 | VVVVxx  |   5
!    1 | VVVVxx  |   7
!    1 | VVVVxx  |   9
! (40 rows)
! 
! --
! -- awk '{print $2;}' person.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
! -- sort -n -r | uniq
! --
! SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
!  age 
! -----
!   98
!   88
!   78
!   68
!   60
!   58
!   50
!   48
!   40
!   38
!   34
!   30
!   28
!   25
!   24
!   23
!   20
!   19
!   18
!    8
! (20 rows)
! 
! --
! -- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
! -- very own regression file.
! --
! CREATE TEMP TABLE disttable (f1 integer);
! INSERT INTO DISTTABLE VALUES(1);
! INSERT INTO DISTTABLE VALUES(2);
! INSERT INTO DISTTABLE VALUES(3);
! INSERT INTO DISTTABLE VALUES(NULL);
! -- basic cases
! SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
!  f1 | not 2 
! ----+-------
!   1 | t
!   2 | f
!   3 | t
!     | t
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
!  f1 | false 
! ----+-------
!   1 | f
!   2 | f
!   3 | f
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! -- check that optimizer constant-folds it properly
! SELECT 1 IS DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT null IS DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! -- negated form
! SELECT 1 IS NOT DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT null IS NOT DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_distinct_on.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_distinct_on.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,75 ****
! --
! -- SELECT_DISTINCT_ON
! --
! SELECT DISTINCT ON (string4) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using >, ten using <;
!  string4 | two | ten 
! ---------+-----+-----
!  AAAAxx  |   1 |   1
!  HHHHxx  |   1 |   1
!  OOOOxx  |   1 |   1
!  VVVVxx  |   1 |   1
! (4 rows)
! 
! -- this will fail due to conflict of ordering requirements
! SELECT DISTINCT ON (string4, ten) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using <, ten using <;
! ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions
! LINE 1: SELECT DISTINCT ON (string4, ten) string4, two, ten
!                                      ^
! SELECT DISTINCT ON (string4, ten) string4, ten, two
!    FROM tmp
!    ORDER BY string4 using <, ten using >, two using <;
!  string4 | ten | two 
! ---------+-----+-----
!  AAAAxx  |   9 |   1
!  AAAAxx  |   8 |   0
!  AAAAxx  |   7 |   1
!  AAAAxx  |   6 |   0
!  AAAAxx  |   5 |   1
!  AAAAxx  |   4 |   0
!  AAAAxx  |   3 |   1
!  AAAAxx  |   2 |   0
!  AAAAxx  |   1 |   1
!  AAAAxx  |   0 |   0
!  HHHHxx  |   9 |   1
!  HHHHxx  |   8 |   0
!  HHHHxx  |   7 |   1
!  HHHHxx  |   6 |   0
!  HHHHxx  |   5 |   1
!  HHHHxx  |   4 |   0
!  HHHHxx  |   3 |   1
!  HHHHxx  |   2 |   0
!  HHHHxx  |   1 |   1
!  HHHHxx  |   0 |   0
!  OOOOxx  |   9 |   1
!  OOOOxx  |   8 |   0
!  OOOOxx  |   7 |   1
!  OOOOxx  |   6 |   0
!  OOOOxx  |   5 |   1
!  OOOOxx  |   4 |   0
!  OOOOxx  |   3 |   1
!  OOOOxx  |   2 |   0
!  OOOOxx  |   1 |   1
!  OOOOxx  |   0 |   0
!  VVVVxx  |   9 |   1
!  VVVVxx  |   8 |   0
!  VVVVxx  |   7 |   1
!  VVVVxx  |   6 |   0
!  VVVVxx  |   5 |   1
!  VVVVxx  |   4 |   0
!  VVVVxx  |   3 |   1
!  VVVVxx  |   2 |   0
!  VVVVxx  |   1 |   1
!  VVVVxx  |   0 |   0
! (40 rows)
! 
! -- bug #5049: early 8.4.x chokes on volatile DISTINCT ON clauses
! select distinct on (1) floor(random()) as r, f1 from int4_tbl order by 1,2;
!  r |     f1      
! ---+-------------
!  0 | -2147483647
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_implicit.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_implicit.out	2015-01-10 10:11:46.327649455 +0300
***************
*** 1,336 ****
! --
! -- SELECT_IMPLICIT
! -- Test cases for queries with ordering terms missing from the target list.
! -- This used to be called "junkfilter.sql".
! -- The parser uses the term "resjunk" to handle these cases.
! -- - thomas 1998-07-09
! --
! -- load test data
! CREATE TABLE test_missing_target (a int, b int, c char(8), d char);
! INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');
! INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');
! INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');
! --   w/ existing GROUP BY target
! SELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!  count 
! -------
!      2
!      2
!      2
!      1
!      1
!      2
! (6 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT test_missing_target.b, count(*)
!   FROM test_missing_target GROUP BY b ORDER BY b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT c FROM test_missing_target ORDER BY a;
!     c     
! ----------
!  XXXX    
!  ABAB    
!  ABAB    
!  BBBB    
!  BBBB    
!  bbbb    
!  cccc    
!  cccc    
!  CCCC    
!  CCCC    
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b desc;
!  count 
! -------
!      4
!      3
!      2
!      1
! (4 rows)
! 
! --   group using reference number
! SELECT count(*) FROM test_missing_target ORDER BY 1 desc;
!  count 
! -------
!     10
! (1 row)
! 
! --   order using reference number
! SELECT c, count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   group using reference number out of range
! --   failure expected
! SELECT c, count(*) FROM test_missing_target GROUP BY 3;
! ERROR:  GROUP BY position 3 is not in select list
! LINE 1: SELECT c, count(*) FROM test_missing_target GROUP BY 3;
!                                                              ^
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b ORDER BY b;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b ORDER BY b;
!                              ^
! --   order w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a, a FROM test_missing_target
! 	ORDER BY a;
!  a | a 
! ---+---
!  0 | 0
!  1 | 1
!  2 | 2
!  3 | 3
!  4 | 4
!  5 | 5
!  6 | 6
!  7 | 7
!  8 | 8
!  9 | 9
! (10 rows)
! 
! --   order expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         0 |        0
!         1 |        1
!         1 |        1
!         2 |        2
!         2 |        2
!         3 |        3
!         3 |        3
!         4 |        4
!         4 |        4
! (10 rows)
! 
! --   group expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	GROUP BY a/2 ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         1 |        1
!         2 |        2
!         3 |        3
!         4 |        4
! (5 rows)
! 
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(*) INTO TABLE test_missing_target2
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
! SELECT * FROM test_missing_target2;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --  Functions and expressions
! --   w/ existing GROUP BY target
! SELECT a%2, count(b) FROM test_missing_target
! GROUP BY test_missing_target.a%2
! ORDER BY test_missing_target.a%2;
!  ?column? | count 
! ----------+-------
!         0 |     5
!         1 |     5
! (2 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(c) FROM test_missing_target
! GROUP BY lower(test_missing_target.c)
! ORDER BY lower(test_missing_target.c);
!  count 
! -------
!      2
!      3
!      4
!      1
! (4 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(b) FROM test_missing_target GROUP BY b/2 ORDER BY b/2;
!  count 
! -------
!      1
!      5
!      4
! (3 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT lower(test_missing_target.c), count(c)
!   FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
!  lower | count 
! -------+-------
!  abab  |     2
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT a FROM test_missing_target ORDER BY upper(d);
!  a 
! ---
!  0
!  1
!  2
!  3
!  4
!  5
!  6
!  7
!  8
!  9
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(b) FROM test_missing_target
! 	GROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 desc;
!  count 
! -------
!      7
!      3
! (2 rows)
! 
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(x.a) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b/2 ORDER BY b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b/2 ORDER BY b/2;
!                                ^
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
!  ?column? | count 
! ----------+-------
!         0 |     1
!         1 |     5
!         2 |     4
! (3 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   failure expected due to ambiguous b in count(b)
! SELECT count(b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 1: SELECT count(b) FROM test_missing_target x, test_missing_tar...
!                      ^
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(x.b) INTO TABLE test_missing_target3
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
! SELECT * FROM test_missing_target3;
!  count 
! -------
!      1
!      5
!      4
! (3 rows)
! 
! --   Cleanup
! DROP TABLE test_missing_target;
! DROP TABLE test_missing_target2;
! DROP TABLE test_missing_target3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_having.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_having.out	2015-01-10 10:11:46.323649455 +0300
***************
*** 1,93 ****
! --
! -- SELECT_HAVING
! --
! -- load test data
! CREATE TABLE test_having (a int, b int, c char(8), d char);
! INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');
! INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');
! INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING count(*) = 1 ORDER BY b, c;
!  b |    c     
! ---+----------
!  1 | XXXX    
!  3 | bbbb    
! (2 rows)
! 
! -- HAVING is effectively equivalent to WHERE in this case
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
!  b |    c     
! ---+----------
!  3 | BBBB    
!  3 | bbbb    
! (2 rows)
! 
! SELECT lower(c), count(c) FROM test_having
! 	GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY lower(c);
!  lower | count 
! -------+-------
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (3 rows)
! 
! SELECT c, max(a) FROM test_having
! 	GROUP BY c HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY c;
!     c     | max 
! ----------+-----
!  XXXX     |   0
!  bbbb     |   5
! (2 rows)
! 
! -- test degenerate cases involving HAVING without GROUP BY
! -- Per SQL spec, these should generate 0 or 1 row, even without aggregates
! SELECT min(a), max(a) FROM test_having HAVING min(a) = max(a);
!  min | max 
! -----+-----
! (0 rows)
! 
! SELECT min(a), max(a) FROM test_having HAVING min(a) < max(a);
!  min | max 
! -----+-----
!    0 |   9
! (1 row)
! 
! -- errors: ungrouped column references
! SELECT a FROM test_having HAVING min(a) < max(a);
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a FROM test_having HAVING min(a) < max(a);
!                ^
! SELECT 1 AS one FROM test_having HAVING a > 1;
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT 1 AS one FROM test_having HAVING a > 1;
!                                                 ^
! -- the really degenerate case: need not scan table at all
! SELECT 1 AS one FROM test_having HAVING 1 > 2;
!  one 
! -----
! (0 rows)
! 
! SELECT 1 AS one FROM test_having HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! -- and just to prove that we aren't scanning the table:
! SELECT 1 AS one FROM test_having WHERE 1/a = 1 HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! DROP TABLE test_having;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/subselect.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/subselect.out	2015-01-10 10:11:46.299649454 +0300
***************
*** 1,823 ****
! --
! -- SUBSELECT
! --
! SELECT 1 AS one WHERE 1 IN (SELECT 1);
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
!  zero 
! ------
! (0 rows)
! 
! SELECT 1 AS zero WHERE 1 IN (SELECT 2);
!  zero 
! ------
! (0 rows)
! 
! -- Check grammar's handling of extra parens in assorted contexts
! SELECT * FROM (SELECT 1 AS x) ss;
!  x 
! ---
!  1
! (1 row)
! 
! SELECT * FROM ((SELECT 1 AS x)) ss;
!  x 
! ---
!  1
! (1 row)
! 
! (SELECT 2) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! ((SELECT 2)) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT ((SELECT 2) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (((SELECT 2)) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (SELECT ARRAY[1,2,3])[1];
!  array 
! -------
!      1
! (1 row)
! 
! SELECT ((SELECT ARRAY[1,2,3]))[2];
!  array 
! -------
!      2
! (1 row)
! 
! SELECT (((SELECT ARRAY[1,2,3])))[3];
!  array 
! -------
!      3
! (1 row)
! 
! -- Set up some simple test tables
! CREATE TABLE SUBSELECT_TBL (
!   f1 integer,
!   f2 integer,
!   f3 float
! );
! INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
! INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
! INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
! INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
! INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
! INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
! INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
! INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
! SELECT '' AS eight, * FROM SUBSELECT_TBL;
!  eight | f1 | f2 | f3 
! -------+----+----+----
!        |  1 |  2 |  3
!        |  2 |  3 |  4
!        |  3 |  4 |  5
!        |  1 |  1 |  1
!        |  2 |  2 |  2
!        |  3 |  3 |  3
!        |  6 |  7 |  8
!        |  8 |  9 |   
! (8 rows)
! 
! -- Uncorrelated subselects
! SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT 1);
!  two | Constant Select 
! -----+-----------------
!      |               1
!      |               1
! (2 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL);
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  2
!      |                  3
!      |                  1
!      |                  2
!      |                  3
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
!     f2 IN (SELECT f1 FROM SUBSELECT_TBL));
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  2
!      |                  3
!      |                  1
!      |                  2
!      |                  3
! (6 rows)
! 
! SELECT '' AS three, f1, f2
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                          WHERE f3 IS NOT NULL);
!  three | f1 | f2 
! -------+----+----
!        |  1 |  2
!        |  6 |  7
!        |  8 |  9
! (3 rows)
! 
! -- Correlated subselects
! SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            2
!      |                2 |            3
!      |                3 |            4
!      |                1 |            1
!      |                2 |            2
!      |                3 |            3
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN
!     (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3);
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                2 |            4
!      |                3 |            5
!      |                1 |            1
!      |                2 |            2
!      |                3 |            3
! (5 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
!                WHERE f2 = CAST(f3 AS integer));
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            3
!      |                2 |            4
!      |                3 |            5
!      |                6 |            8
! (4 rows)
! 
! SELECT '' AS five, f1 AS "Correlated Field"
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                      WHERE f3 IS NOT NULL);
!  five | Correlated Field 
! ------+------------------
!       |                2
!       |                3
!       |                1
!       |                2
!       |                3
! (5 rows)
! 
! --
! -- Use some existing tables in the regression test
! --
! SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
!   FROM SUBSELECT_TBL ss
!   WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
!                    WHERE f1 != ss.f1 AND f1 < 2147483647);
!  eight | Correlated Field | Second Field 
! -------+------------------+--------------
!        |                2 |            4
!        |                3 |            5
!        |                2 |            2
!        |                3 |            3
!        |                6 |            8
!        |                8 |             
! (6 rows)
! 
! select q1, float8(count(*)) / (select count(*) from int8_tbl)
! from int8_tbl group by q1 order by q1;
!         q1        | ?column? 
! ------------------+----------
!               123 |      0.4
!  4567890123456789 |      0.6
! (2 rows)
! 
! --
! -- Test cases to catch unpleasant interactions between IN-join processing
! -- and subquery pullup.
! --
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Test cases to check for overenthusiastic optimization of
! -- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
! -- Luca Pireddu and Michael Fuhr.
! --
! CREATE TEMP TABLE foo (id integer);
! CREATE TEMP TABLE bar (id1 integer, id2 integer);
! INSERT INTO foo VALUES (1);
! INSERT INTO bar VALUES (1, 1);
! INSERT INTO bar VALUES (2, 2);
! INSERT INTO bar VALUES (3, 1);
! -- These cases require an extra level of distinct-ing above subquery s
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
!                       SELECT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! -- These cases do not
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar UNION
!                       SELECT id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- Test case to catch problems with multiply nested sub-SELECTs not getting
! -- recalculated properly.  Per bug report from Didier Moens.
! --
! CREATE TABLE orderstest (
!     approver_ref integer,
!     po_ref integer,
!     ordercanceled boolean
! );
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 5, false);
! INSERT INTO orderstest VALUES (66, 6, false);
! INSERT INTO orderstest VALUES (66, 7, false);
! INSERT INTO orderstest VALUES (66, 1, true);
! INSERT INTO orderstest VALUES (66, 8, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (77, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! CREATE VIEW orders_view AS
! SELECT *,
! (SELECT CASE
!    WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
!  END) AS "Approved",
! (SELECT CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (SELECT CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (SELECT CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status",
! (CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status_OK"
! FROM orderstest ord;
! SELECT * FROM orders_view;
!  approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
! --------------+--------+---------------+----------+----------+-----------
!             1 |      1 | f             | ---      | ---      | ---
!            66 |      5 | f             | Approved | PO       | PO
!            66 |      6 | f             | Approved | PO       | PO
!            66 |      7 | f             | Approved | PO       | PO
!            66 |      1 | t             | Approved | Canceled | Canceled
!            66 |      8 | f             | Approved | PO       | PO
!            66 |      1 | f             | Approved | Approved | Approved
!            77 |      1 | f             | Approved | Approved | Approved
!             1 |      1 | f             | ---      | ---      | ---
!            66 |      1 | f             | Approved | Approved | Approved
!             1 |      1 | f             | ---      | ---      | ---
! (11 rows)
! 
! DROP TABLE orderstest cascade;
! NOTICE:  drop cascades to view orders_view
! --
! -- Test cases to catch situations where rule rewriter fails to propagate
! -- hasSubLinks flag correctly.  Per example from Kyle Bateman.
! --
! create temp table parts (
!     partnum     text,
!     cost        float8
! );
! create temp table shipped (
!     ttype       char(2),
!     ordnum      int4,
!     partnum     text,
!     value       float8
! );
! create temp view shipped_view as
!     select * from shipped where ttype = 'wt';
! create rule shipped_view_insert as on insert to shipped_view do instead
!     insert into shipped values('wt', new.ordnum, new.partnum, new.value);
! insert into parts (partnum, cost) values (1, 1234.56);
! insert into shipped_view (ordnum, partnum, value)
!     values (0, 1, (select cost from parts where partnum = '1'));
! select * from shipped_view;
!  ttype | ordnum | partnum |  value  
! -------+--------+---------+---------
!  wt    |      0 | 1       | 1234.56
! (1 row)
! 
! create rule shipped_view_update as on update to shipped_view do instead
!     update shipped set partnum = new.partnum, value = new.value
!         where ttype = new.ttype and ordnum = new.ordnum;
! update shipped_view set value = 11
!     from int4_tbl a join int4_tbl b
!       on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))
!     where ordnum = a.f1;
! select * from shipped_view;
!  ttype | ordnum | partnum | value 
! -------+--------+---------+-------
!  wt    |      0 | 1       |    11
! (1 row)
! 
! select f1, ss1 as relabel from
!     (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
!      from int4_tbl a) ss;
!      f1      |  relabel   
! -------------+------------
!            0 | 2147607103
!       123456 | 2147607103
!      -123456 | 2147483647
!   2147483647 | 2147483647
!  -2147483647 |          0
! (5 rows)
! 
! --
! -- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
! -- Per bug report from David Sanchez i Gregori.
! --
! select * from (
!   select max(unique1) from tenk1 as a
!   where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
! ) ss;
!  max  
! ------
!  9997
! (1 row)
! 
! select * from (
!   select min(unique1) from tenk1 as a
!   where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
! ) ss;
!  min 
! -----
!    0
! (1 row)
! 
! --
! -- Test that an IN implemented using a UniquePath does unique-ification
! -- with the right semantics, as per bug #4113.  (Unfortunately we have
! -- no simple way to ensure that this test case actually chooses that type
! -- of plan, but it does in releases 7.4-8.3.  Note that an ordering difference
! -- here might mean that some other plan type is being used, rendering the test
! -- pointless.)
! --
! create temp table numeric_table (num_col numeric);
! insert into numeric_table values (1), (1.000000000000000000001), (2), (3);
! create temp table float_table (float_col float8);
! insert into float_table values (1), (2), (3);
! select * from float_table
!   where float_col in (select num_col from numeric_table);
!  float_col 
! -----------
!          1
!          2
!          3
! (3 rows)
! 
! select * from numeric_table
!   where num_col in (select float_col from float_table);
!          num_col         
! -------------------------
!                        1
!  1.000000000000000000001
!                        2
!                        3
! (4 rows)
! 
! --
! -- Test case for bug #4290: bogus calculation of subplan param sets
! --
! create temp table ta (id int primary key, val int);
! insert into ta values(1,1);
! insert into ta values(2,2);
! create temp table tb (id int primary key, aval int);
! insert into tb values(1,1);
! insert into tb values(2,1);
! insert into tb values(3,2);
! insert into tb values(4,2);
! create temp table tc (id int primary key, aid int);
! insert into tc values(1,1);
! insert into tc values(2,2);
! select
!   ( select min(tb.id) from tb
!     where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
! from tc;
!  min_tb_id 
! -----------
!          1
!          3
! (2 rows)
! 
! --
! -- Test case for 8.3 "failed to locate grouping columns" bug
! --
! create temp table t1 (f1 numeric(14,0), f2 varchar(30));
! select * from
!   (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs
!    from t1 up) ss
! group by f1,f2,fs;
!  f1 | f2 | fs 
! ----+----+----
! (0 rows)
! 
! --
! -- Test case for bug #5514 (mishandling of whole-row Vars in subselects)
! --
! create temp table table_a(id integer);
! insert into table_a values (42);
! create temp view view_a as select * from table_a;
! select view_a from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select view_a) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (select view_a)) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (a.*)::text) from view_a a;
!   a   
! ------
!  (42)
! (1 row)
! 
! --
! -- Check that whole-row Vars reading the result of a subselect don't include
! -- any junk columns therein
! --
! select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! with q as (select max(f1) from int4_tbl group by f1 order by f1)
!   select q from q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! --
! -- Test case for sublinks pushed down into subselects via join alias expansion
! --
! select
!   (select sq1) as qq1
! from
!   (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy
!    from int8_tbl) sq0
!   join
!   int4_tbl i4 on dummy = i4.f1;
!  qq1 
! -----
! (0 rows)
! 
! --
! -- Test case for cross-type partial matching in hashed subplan (bug #7597)
! --
! create temp table outer_7597 (f1 int4, f2 int4);
! insert into outer_7597 values (0, 0);
! insert into outer_7597 values (1, 0);
! insert into outer_7597 values (0, null);
! insert into outer_7597 values (1, null);
! create temp table inner_7597(c1 int8, c2 int8);
! insert into inner_7597 values(0, null);
! select * from outer_7597 where (f1, f2) not in (select * from inner_7597);
!  f1 | f2 
! ----+----
!   1 |  0
!   1 |   
! (2 rows)
! 
! --
! -- Test case for premature memory release during hashing of subplan output
! --
! select '1'::text in (select '1'::name union all select '1'::name);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- Test case for planner bug with nested EXISTS handling
! --
! select a.thousand from tenk1 a, tenk1 b
! where a.thousand = b.thousand
!   and exists ( select 1 from tenk1 c where b.hundred = c.hundred
!                    and not exists ( select 1 from tenk1 d
!                                     where a.thousand = d.thousand ) );
!  thousand 
! ----------
! (0 rows)
! 
! --
! -- Check that nested sub-selects are not pulled up if they contain volatiles
! --
! explain (verbose, costs off)
!   select x, x from
!     (select (select now()) as x from (values(1),(2)) v(y)) ss;
!         QUERY PLAN         
! ---------------------------
!  Values Scan on "*VALUES*"
!    Output: $0, $1
!    InitPlan 1 (returns $0)
!      ->  Result
!            Output: now()
!    InitPlan 2 (returns $1)
!      ->  Result
!            Output: now()
! (8 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random()) as x from (values(1),(2)) v(y)) ss;
!             QUERY PLAN            
! ----------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: $0
!          InitPlan 1 (returns $0)
!            ->  Result
!                  Output: random()
! (7 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Values Scan on "*VALUES*"
!    Output: (SubPlan 1), (SubPlan 2)
!    SubPlan 1
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
!    SubPlan 2
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (10 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: (SubPlan 1)
!          SubPlan 1
!            ->  Result
!                  Output: random()
!                  One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (8 rows)
! 
! --
! -- Check we behave sanely in corner case of empty SELECT list (bug #8648)
! --
! create temp table nocolumns();
! select exists(select * from nocolumns);
!  exists 
! --------
!  f
! (1 row)
! 
! --
! -- Check sane behavior with nested IN SubLinks
! --
! explain (verbose, costs off)
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!                                                                                       QUERY PLAN                                                                                       
! ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Nested Loop Semi Join
!    Output: int4_tbl.f1
!    Join Filter: (CASE WHEN (hashed SubPlan 1) THEN int4_tbl.f1 ELSE NULL::integer END = b.ten)
!    ->  Seq Scan on public.int4_tbl
!          Output: int4_tbl.f1
!    ->  Seq Scan on public.tenk1 b
!          Output: b.unique1, b.unique2, b.two, b.four, b.ten, b.twenty, b.hundred, b.thousand, b.twothousand, b.fivethous, b.tenthous, b.odd, b.even, b.stringu1, b.stringu2, b.string4
!    SubPlan 1
!      ->  Index Only Scan using tenk1_unique1 on public.tenk1 a
!            Output: a.unique1
! (10 rows)
! 
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- Check for incorrect optimization when IN subquery contains a SRF
! --
! explain (verbose, costs off)
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Hash Join
!    Output: o.f1
!    Hash Cond: (o.f1 = "ANY_subquery".f1)
!    ->  Seq Scan on public.int4_tbl o
!          Output: o.f1
!    ->  Hash
!          Output: "ANY_subquery".f1, "ANY_subquery".g
!          ->  HashAggregate
!                Output: "ANY_subquery".f1, "ANY_subquery".g
!                Group Key: "ANY_subquery".f1, "ANY_subquery".g
!                ->  Subquery Scan on "ANY_subquery"
!                      Output: "ANY_subquery".f1, "ANY_subquery".g
!                      Filter: ("ANY_subquery".f1 = "ANY_subquery".g)
!                      ->  HashAggregate
!                            Output: i.f1, (generate_series(1, 2) / 10)
!                            Group Key: i.f1
!                            ->  Seq Scan on public.int4_tbl i
!                                  Output: i.f1
! (18 rows)
! 
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- check for over-optimization of whole-row Var referencing an Append plan
! --
! select (select q from
!          (select 1,2,3 where f1 > 0
!           union all
!           select 4,5,6.0 where f1 <= 0
!          ) q )
! from int4_tbl;
!      q     
! -----------
!  (4,5,6.0)
!  (1,2,3)
!  (4,5,6.0)
!  (1,2,3)
!  (4,5,6.0)
! (5 rows)
! 
! --
! -- Check that volatile quals aren't pushed down past a DISTINCT:
! -- nextval() should not be called more than the nominal number of times
! --
! create temp sequence ts1;
! select * from
!   (select distinct ten from tenk1) ss
!   where ten < 10 + nextval('ts1')
!   order by 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! select nextval('ts1');
!  nextval 
! ---------
!       11
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/union.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/union.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,712 ****
! --
! -- UNION (also INTERSECT, EXCEPT)
! --
! -- Simple UNION constructs
! SELECT 1 AS two UNION SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS two UNION ALL SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION ALL SELECT 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION SELECT 3;
!  three 
! -------
!      1
!      2
!      3
! (3 rows)
! 
! SELECT 1 AS two UNION SELECT 2 UNION SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2;
!  three 
! -------
!      1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION SELECT 2.2;
!  two 
! -----
!  1.1
!  2.2
! (2 rows)
! 
! -- Mixed types
! SELECT 1.1 AS two UNION SELECT 2;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION SELECT 2.2;
!  two 
! -----
!    1
!  2.2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1.0::float8;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1.1 AS two UNION ALL SELECT 2;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.0::float8 AS two UNION ALL SELECT 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3;
!  three 
! -------
!    1.1
!      2
!      3
! (3 rows)
! 
! SELECT 1.1::float8 AS two UNION SELECT 2 UNION SELECT 2.0::float8 ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2;
!  three 
! -------
!    1.1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2);
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! --
! -- Try testing from tables...
! --
! SELECT f1 AS five FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM FLOAT8_TBL
! ORDER BY 1;
!          five          
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
! (5 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM FLOAT8_TBL;
!           ten          
! -----------------------
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
! (10 rows)
! 
! SELECT f1 AS nine FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM INT4_TBL
! ORDER BY 1;
!          nine          
! -----------------------
!  -1.2345678901234e+200
!            -2147483647
!                -123456
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
!             2147483647
! (9 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM INT4_TBL;
!           ten          
! -----------------------
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
!                      0
!                 123456
!                -123456
!             2147483647
!            -2147483647
! (10 rows)
! 
! SELECT f1 AS five FROM FLOAT8_TBL
!   WHERE f1 BETWEEN -1e6 AND 1e6
! UNION
! SELECT f1 FROM INT4_TBL
!   WHERE f1 BETWEEN 0 AND 1000000;
!          five          
! -----------------------
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
! (5 rows)
! 
! SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL
! UNION
! SELECT f1 FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a   
!  ab  
!  abcd
! (3 rows)
! 
! SELECT f1 AS three FROM VARCHAR_TBL
! UNION
! SELECT CAST(f1 AS varchar) FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a
!  ab
!  abcd
! (3 rows)
! 
! SELECT f1 AS eight FROM VARCHAR_TBL
! UNION ALL
! SELECT f1 FROM CHAR_TBL;
!  eight 
! -------
!  a
!  ab
!  abcd
!  abcd
!  a
!  ab
!  abcd
!  abcd
! (8 rows)
! 
! SELECT f1 AS five FROM TEXT_TBL
! UNION
! SELECT f1 FROM VARCHAR_TBL
! UNION
! SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL
! ORDER BY 1;
!        five        
! -------------------
!  a
!  ab
!  abcd
!  doh!
!  hi de ho neighbor
! (5 rows)
! 
! --
! -- INTERSECT and EXCEPT
! --
! SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl;
!         q2        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl;
!         q2        
! ------------------
!  4567890123456789
!  4567890123456789
!               123
! (3 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
!   4567890123456789
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl;
!  q1 
! ----
! (0 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl;
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl;
!         q1        
! ------------------
!  4567890123456789
!  4567890123456789
!               123
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
! ERROR:  FOR NO KEY UPDATE is not allowed with UNION/INTERSECT/EXCEPT
! --
! -- Mixed types
! --
! SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl;
!  f1 
! ----
!   0
! (1 row)
! 
! SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;
!           f1           
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
! (4 rows)
! 
! --
! -- Operator precedence and (((((extra))))) parentheses
! --
! SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl;
!         q1         
! -------------------
!   4567890123456789
!                123
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl)));
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! (((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl))) UNION ALL SELECT q2 FROM int8_tbl;
!         q1         
! -------------------
!   4567890123456789
!                123
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));
!         q1         
! -------------------
!                123
!                123
!   4567890123456789
!   4567890123456789
!   4567890123456789
!  -4567890123456789
!                456
! (7 rows)
! 
! (((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! --
! -- Subqueries with ORDER BY & LIMIT clauses
! --
! -- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT
! SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl
! ORDER BY q2,q1;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!               123 |               456
! (2 rows)
! 
! -- This should fail, because q2 isn't a name of an EXCEPT output column
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;
! ERROR:  column "q2" does not exist
! LINE 1: ... int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1...
!                                                              ^
! HINT:  There is a column named "q2" in table "*SELECT* 2", but it cannot be referenced from this part of the query.
! -- But this should work:
! SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1)));
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! --
! -- New syntaxes (7.1) permit new tests
! --
! (((((select * from int8_tbl)))));
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! --
! -- Check handling of a case with unknown constants.  We don't guarantee
! -- an undecorated constant will work in all cases, but historically this
! -- usage has worked, so test we don't break it.
! --
! SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a
! UNION
! SELECT b.f1 FROM (SELECT f1 FROM varchar_tbl) b
! ORDER BY 1;
!   f1  
! ------
!  a
!  ab
!  abcd
!  test
! (4 rows)
! 
! -- This should fail, but it should produce an error cursor
! SELECT '3.4'::numeric UNION SELECT 'foo';
! ERROR:  invalid input syntax for type numeric: "foo"
! LINE 1: SELECT '3.4'::numeric UNION SELECT 'foo';
!                                            ^
! --
! -- Test that expression-index constraints can be pushed down through
! -- UNION or UNION ALL
! --
! CREATE TEMP TABLE t1 (a text, b text);
! CREATE INDEX t1_ab_idx on t1 ((a || b));
! CREATE TEMP TABLE t2 (ab text primary key);
! INSERT INTO t1 VALUES ('a', 'b'), ('x', 'y');
! INSERT INTO t2 VALUES ('ab'), ('xy');
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! explain (costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION ALL
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                  QUERY PLAN                  
! ---------------------------------------------
!  Append
!    ->  Index Scan using t1_ab_idx on t1
!          Index Cond: ((a || b) = 'ab'::text)
!    ->  Index Only Scan using t2_pkey on t2
!          Index Cond: (ab = 'ab'::text)
! (5 rows)
! 
! explain (costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                     QUERY PLAN                     
! ---------------------------------------------------
!  HashAggregate
!    Group Key: ((t1.a || t1.b))
!    ->  Append
!          ->  Index Scan using t1_ab_idx on t1
!                Index Cond: ((a || b) = 'ab'::text)
!          ->  Index Only Scan using t2_pkey on t2
!                Index Cond: (ab = 'ab'::text)
! (7 rows)
! 
! --
! -- Test that ORDER BY for UNION ALL can be pushed down to inheritance
! -- children.
! --
! CREATE TEMP TABLE t1c (b text, a text);
! ALTER TABLE t1c INHERIT t1;
! CREATE TEMP TABLE t2c (primary key (ab)) INHERITS (t2);
! INSERT INTO t1c VALUES ('v', 'w'), ('c', 'd'), ('m', 'n'), ('e', 'f');
! INSERT INTO t2c VALUES ('vw'), ('cd'), ('mn'), ('ef');
! CREATE INDEX t1c_ab_idx on t1c ((a || b));
! set enable_seqscan = on;
! set enable_indexonlyscan = off;
! explain (costs off)
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Limit
!    ->  Merge Append
!          Sort Key: ((t1.a || t1.b))
!          ->  Index Scan using t1_ab_idx on t1
!          ->  Index Scan using t1c_ab_idx on t1c
!          ->  Index Scan using t2_pkey on t2
!          ->  Index Scan using t2c_pkey on t2c
! (7 rows)
! 
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!  ab 
! ----
!  ab
!  ab
!  cd
!  dc
!  ef
!  fe
!  mn
!  nm
! (8 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
! -- This simpler variant of the above test has been observed to fail differently
! create table events (event_id int primary key);
! create table other_events (event_id int primary key);
! create table events_child () inherits (events);
! explain (costs off)
! select event_id
!  from (select event_id from events
!        union all
!        select event_id from other_events) ss
!  order by event_id;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Merge Append
!    Sort Key: events.event_id
!    ->  Index Scan using events_pkey on events
!    ->  Sort
!          Sort Key: events_child.event_id
!          ->  Seq Scan on events_child
!    ->  Index Scan using other_events_pkey on other_events
! (7 rows)
! 
! drop table events_child, events, other_events;
! reset enable_indexonlyscan;
! -- Test constraint exclusion of UNION ALL subqueries
! explain (costs off)
!  SELECT * FROM
!   (SELECT 1 AS t, * FROM tenk1 a
!    UNION ALL
!    SELECT 2 AS t, * FROM tenk1 b) c
!  WHERE t = 2;
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on tenk1 b
! (2 rows)
! 
! -- Test that we push quals into UNION sub-selects only when it's safe
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4;
!                  QUERY PLAN                 
! --------------------------------------------
!  Unique
!    ->  Sort
!          Sort Key: (1), (2)
!          ->  Append
!                ->  Result
!                ->  Result
!                      One-Time Filter: false
! (7 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4;
!  t | x 
! ---+---
!  1 | 2
! (1 row)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Sort
!    Sort Key: ss.x
!    ->  Subquery Scan on ss
!          Filter: (ss.x < 4)
!          ->  HashAggregate
!                Group Key: (1), (generate_series(1, 10))
!                ->  Append
!                      ->  Result
!                      ->  Result
! (9 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!  t | x 
! ---+---
!  1 | 1
!  1 | 2
!  1 | 3
! (3 rows)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on ss
!    Filter: (ss.x > 3)
!    ->  Unique
!          ->  Sort
!                Sort Key: (1), (((random() * 3::double precision))::integer)
!                ->  Append
!                      ->  Result
!                      ->  Result
! (8 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3;
!  t | x 
! ---+---
!  2 | 4
! (1 row)
! 
! -- Test proper handling of parameterized appendrel paths when the
! -- potential join qual is expensive
! create function expensivefunc(int) returns int
! language plpgsql immutable strict cost 10000
! as $$begin return $1; end$$;
! create temp table t3 as select generate_series(-1000,1000) as x;
! create index t3i on t3 (expensivefunc(x));
! analyze t3;
! explain (costs off)
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using t3i on t3 a
!                Index Cond: (expensivefunc(x) = int4_tbl.f1)
!          ->  Index Scan using t3i on t3 b
!                Index Cond: (expensivefunc(x) = int4_tbl.f1)
! (7 rows)
! 
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!  x | f1 
! ---+----
!  0 |  0
!  0 |  0
! (2 rows)
! 
! drop table t3;
! drop function expensivefunc(int);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/case.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/case.out	2015-01-10 10:11:46.323649455 +0300
***************
*** 1,303 ****
! --
! -- CASE
! -- Test the case statement
! --
! CREATE TABLE CASE_TBL (
!   i integer,
!   f double precision
! );
! CREATE TABLE CASE2_TBL (
!   i integer,
!   j integer
! );
! INSERT INTO CASE_TBL VALUES (1, 10.1);
! INSERT INTO CASE_TBL VALUES (2, 20.2);
! INSERT INTO CASE_TBL VALUES (3, -30.3);
! INSERT INTO CASE_TBL VALUES (4, NULL);
! INSERT INTO CASE2_TBL VALUES (1, -1);
! INSERT INTO CASE2_TBL VALUES (2, -2);
! INSERT INTO CASE2_TBL VALUES (3, -3);
! INSERT INTO CASE2_TBL VALUES (2, -4);
! INSERT INTO CASE2_TBL VALUES (1, NULL);
! INSERT INTO CASE2_TBL VALUES (NULL, -6);
! --
! -- Simplest examples without tables
! --
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!   END AS "Simple WHEN";
!  One | Simple WHEN 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '<NULL>' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!   END AS "Simple default";
!   One   | Simple default 
! --------+----------------
!  <NULL> |               
! (1 row)
! 
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!     ELSE 4
!   END AS "Simple ELSE";
!  One | Simple ELSE 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '4' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     ELSE 4
!   END AS "ELSE default";
!  One | ELSE default 
! -----+--------------
!  4   |            4
! (1 row)
! 
! SELECT '6' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     WHEN 4 < 5 THEN 6
!     ELSE 7
!   END AS "Two WHEN with default";
!  One | Two WHEN with default 
! -----+-----------------------
!  6   |                     6
! (1 row)
! 
! -- Constant-expression folding shouldn't evaluate unreachable subexpressions
! SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! -- However we do not currently suppress folding of potentially
! -- reachable subexpressions
! SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;
! ERROR:  division by zero
! -- Test for cases involving untyped literals in test expression
! SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;
!  case 
! ------
!     1
! (1 row)
! 
! --
! -- Examples of targets involving tables
! --
! SELECT '' AS "Five",
!   CASE
!     WHEN i >= 3 THEN i
!   END AS ">= 3 or Null"
!   FROM CASE_TBL;
!  Five | >= 3 or Null 
! ------+--------------
!       |             
!       |             
!       |            3
!       |            4
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN i >= 3 THEN (i + i)
!        ELSE i
!   END AS "Simplest Math"
!   FROM CASE_TBL;
!  Five | Simplest Math 
! ------+---------------
!       |             1
!       |             2
!       |             6
!       |             8
! (4 rows)
! 
! SELECT '' AS "Five", i AS "Value",
!   CASE WHEN (i < 0) THEN 'small'
!        WHEN (i = 0) THEN 'zero'
!        WHEN (i = 1) THEN 'one'
!        WHEN (i = 2) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL;
!  Five | Value | Category 
! ------+-------+----------
!       |     1 | one
!       |     2 | two
!       |     3 | big
!       |     4 | big
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN ((i < 0) or (i < 0)) THEN 'small'
!        WHEN ((i = 0) or (i = 0)) THEN 'zero'
!        WHEN ((i = 1) or (i = 1)) THEN 'one'
!        WHEN ((i = 2) or (i = 2)) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL;
!  Five | Category 
! ------+----------
!       | one
!       | two
!       | big
!       | big
! (4 rows)
! 
! --
! -- Examples of qualifications involving tables
! --
! --
! -- NULLIF() and COALESCE()
! -- Shorthand forms for typical CASE constructs
! --  defined in the SQL standard.
! --
! SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;
!  i | f 
! ---+---
!  4 |  
! (1 row)
! 
! SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;
!  i | f 
! ---+---
! (0 rows)
! 
! SELECT COALESCE(a.f, b.i, b.j)
!   FROM CASE_TBL a, CASE2_TBL b;
!  coalesce 
! ----------
!      10.1
!      20.2
!     -30.3
!         1
!      10.1
!      20.2
!     -30.3
!         2
!      10.1
!      20.2
!     -30.3
!         3
!      10.1
!      20.2
!     -30.3
!         2
!      10.1
!      20.2
!     -30.3
!         1
!      10.1
!      20.2
!     -30.3
!        -6
! (24 rows)
! 
! SELECT *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(a.f, b.i, b.j) = 2;
!  i | f | i | j  
! ---+---+---+----
!  4 |   | 2 | -2
!  4 |   | 2 | -4
! (2 rows)
! 
! SELECT '' AS Five, NULLIF(a.i,b.i) AS "NULLIF(a.i,b.i)",
!   NULLIF(b.i, 4) AS "NULLIF(b.i,4)"
!   FROM CASE_TBL a, CASE2_TBL b;
!  five | NULLIF(a.i,b.i) | NULLIF(b.i,4) 
! ------+-----------------+---------------
!       |                 |             1
!       |               2 |             1
!       |               3 |             1
!       |               4 |             1
!       |               1 |             2
!       |                 |             2
!       |               3 |             2
!       |               4 |             2
!       |               1 |             3
!       |               2 |             3
!       |                 |             3
!       |               4 |             3
!       |               1 |             2
!       |                 |             2
!       |               3 |             2
!       |               4 |             2
!       |                 |             1
!       |               2 |             1
!       |               3 |             1
!       |               4 |             1
!       |               1 |              
!       |               2 |              
!       |               3 |              
!       |               4 |              
! (24 rows)
! 
! SELECT '' AS "Two", *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(f,b.i) = 2;
!  Two | i | f | i | j  
! -----+---+---+---+----
!      | 4 |   | 2 | -2
!      | 4 |   | 2 | -4
! (2 rows)
! 
! --
! -- Examples of updates involving tables
! --
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 3 THEN (- i)
!                 ELSE (2 * i) END;
! SELECT * FROM CASE_TBL;
!  i  |   f   
! ----+-------
!   2 |  10.1
!   4 |  20.2
!  -3 | -30.3
!  -4 |      
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 2 THEN (2 * i)
!                 ELSE (3 * i) END;
! SELECT * FROM CASE_TBL;
!   i  |   f   
! -----+-------
!    4 |  10.1
!    8 |  20.2
!   -9 | -30.3
!  -12 |      
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN b.i >= 2 THEN (2 * j)
!                 ELSE (3 * j) END
!   FROM CASE2_TBL b
!   WHERE j = -CASE_TBL.i;
! SELECT * FROM CASE_TBL;
!   i  |   f   
! -----+-------
!    8 |  20.2
!   -9 | -30.3
!  -12 |      
!   -8 |  10.1
! (4 rows)
! 
! --
! -- Clean up
! --
! DROP TABLE CASE_TBL;
! DROP TABLE CASE2_TBL;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/join.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/join.out	2015-01-10 10:11:46.291649454 +0300
***************
*** 1,4341 ****
! --
! -- JOIN
! -- Test JOIN clauses
! --
! CREATE TABLE J1_TBL (
!   i integer,
!   j integer,
!   t text
! );
! CREATE TABLE J2_TBL (
!   i integer,
!   k integer
! );
! INSERT INTO J1_TBL VALUES (1, 4, 'one');
! INSERT INTO J1_TBL VALUES (2, 3, 'two');
! INSERT INTO J1_TBL VALUES (3, 2, 'three');
! INSERT INTO J1_TBL VALUES (4, 1, 'four');
! INSERT INTO J1_TBL VALUES (5, 0, 'five');
! INSERT INTO J1_TBL VALUES (6, 6, 'six');
! INSERT INTO J1_TBL VALUES (7, 7, 'seven');
! INSERT INTO J1_TBL VALUES (8, 8, 'eight');
! INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
! INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
! INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
! INSERT INTO J2_TBL VALUES (1, -1);
! INSERT INTO J2_TBL VALUES (2, 2);
! INSERT INTO J2_TBL VALUES (3, -3);
! INSERT INTO J2_TBL VALUES (2, 4);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (0, NULL);
! INSERT INTO J2_TBL VALUES (NULL, NULL);
! INSERT INTO J2_TBL VALUES (NULL, 0);
! --
! -- CORRELATION NAMES
! -- Make sure that table/column aliases are supported
! -- before diving into more complex join syntax.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS tx;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL tx;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS t1 (a, b, c);
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c);
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);
!  xxx | a | b |   c   | d | e  
! -----+---+---+-------+---+----
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 1 | -1
!      | 3 | 2 | three | 1 | -1
!      | 4 | 1 | four  | 1 | -1
!      | 5 | 0 | five  | 1 | -1
!      | 6 | 6 | six   | 1 | -1
!      | 7 | 7 | seven | 1 | -1
!      | 8 | 8 | eight | 1 | -1
!      | 0 |   | zero  | 1 | -1
!      |   |   | null  | 1 | -1
!      |   | 0 | zero  | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 2 | 3 | two   | 2 |  2
!      | 3 | 2 | three | 2 |  2
!      | 4 | 1 | four  | 2 |  2
!      | 5 | 0 | five  | 2 |  2
!      | 6 | 6 | six   | 2 |  2
!      | 7 | 7 | seven | 2 |  2
!      | 8 | 8 | eight | 2 |  2
!      | 0 |   | zero  | 2 |  2
!      |   |   | null  | 2 |  2
!      |   | 0 | zero  | 2 |  2
!      | 1 | 4 | one   | 3 | -3
!      | 2 | 3 | two   | 3 | -3
!      | 3 | 2 | three | 3 | -3
!      | 4 | 1 | four  | 3 | -3
!      | 5 | 0 | five  | 3 | -3
!      | 6 | 6 | six   | 3 | -3
!      | 7 | 7 | seven | 3 | -3
!      | 8 | 8 | eight | 3 | -3
!      | 0 |   | zero  | 3 | -3
!      |   |   | null  | 3 | -3
!      |   | 0 | zero  | 3 | -3
!      | 1 | 4 | one   | 2 |  4
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 2 |  4
!      | 4 | 1 | four  | 2 |  4
!      | 5 | 0 | five  | 2 |  4
!      | 6 | 6 | six   | 2 |  4
!      | 7 | 7 | seven | 2 |  4
!      | 8 | 8 | eight | 2 |  4
!      | 0 |   | zero  | 2 |  4
!      |   |   | null  | 2 |  4
!      |   | 0 | zero  | 2 |  4
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 0 |   
!      | 2 | 3 | two   | 0 |   
!      | 3 | 2 | three | 0 |   
!      | 4 | 1 | four  | 0 |   
!      | 5 | 0 | five  | 0 |   
!      | 6 | 6 | six   | 0 |   
!      | 7 | 7 | seven | 0 |   
!      | 8 | 8 | eight | 0 |   
!      | 0 |   | zero  | 0 |   
!      |   |   | null  | 0 |   
!      |   | 0 | zero  | 0 |   
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight |   |   
!      | 0 |   | zero  |   |   
!      |   |   | null  |   |   
!      |   | 0 | zero  |   |   
!      | 1 | 4 | one   |   |  0
!      | 2 | 3 | two   |   |  0
!      | 3 | 2 | three |   |  0
!      | 4 | 1 | four  |   |  0
!      | 5 | 0 | five  |   |  0
!      | 6 | 6 | six   |   |  0
!      | 7 | 7 | seven |   |  0
!      | 8 | 8 | eight |   |  0
!      | 0 |   | zero  |   |  0
!      |   |   | null  |   |  0
!      |   | 0 | zero  |   |  0
! (99 rows)
! 
! SELECT '' AS "xxx", t1.a, t2.e
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
!   WHERE t1.a = t2.d;
!  xxx | a | e  
! -----+---+----
!      | 0 |   
!      | 1 | -1
!      | 2 |  2
!      | 2 |  4
!      | 3 | -3
!      | 5 | -5
!      | 5 | -5
! (7 rows)
! 
! --
! -- CROSS JOIN
! -- Qualifications are not allowed on cross joins,
! -- which degenerate into a standard unqualified inner join.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL;
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 1 | -1
!      | 3 | 2 | three | 1 | -1
!      | 4 | 1 | four  | 1 | -1
!      | 5 | 0 | five  | 1 | -1
!      | 6 | 6 | six   | 1 | -1
!      | 7 | 7 | seven | 1 | -1
!      | 8 | 8 | eight | 1 | -1
!      | 0 |   | zero  | 1 | -1
!      |   |   | null  | 1 | -1
!      |   | 0 | zero  | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 2 | 3 | two   | 2 |  2
!      | 3 | 2 | three | 2 |  2
!      | 4 | 1 | four  | 2 |  2
!      | 5 | 0 | five  | 2 |  2
!      | 6 | 6 | six   | 2 |  2
!      | 7 | 7 | seven | 2 |  2
!      | 8 | 8 | eight | 2 |  2
!      | 0 |   | zero  | 2 |  2
!      |   |   | null  | 2 |  2
!      |   | 0 | zero  | 2 |  2
!      | 1 | 4 | one   | 3 | -3
!      | 2 | 3 | two   | 3 | -3
!      | 3 | 2 | three | 3 | -3
!      | 4 | 1 | four  | 3 | -3
!      | 5 | 0 | five  | 3 | -3
!      | 6 | 6 | six   | 3 | -3
!      | 7 | 7 | seven | 3 | -3
!      | 8 | 8 | eight | 3 | -3
!      | 0 |   | zero  | 3 | -3
!      |   |   | null  | 3 | -3
!      |   | 0 | zero  | 3 | -3
!      | 1 | 4 | one   | 2 |  4
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 2 |  4
!      | 4 | 1 | four  | 2 |  4
!      | 5 | 0 | five  | 2 |  4
!      | 6 | 6 | six   | 2 |  4
!      | 7 | 7 | seven | 2 |  4
!      | 8 | 8 | eight | 2 |  4
!      | 0 |   | zero  | 2 |  4
!      |   |   | null  | 2 |  4
!      |   | 0 | zero  | 2 |  4
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 0 |   
!      | 2 | 3 | two   | 0 |   
!      | 3 | 2 | three | 0 |   
!      | 4 | 1 | four  | 0 |   
!      | 5 | 0 | five  | 0 |   
!      | 6 | 6 | six   | 0 |   
!      | 7 | 7 | seven | 0 |   
!      | 8 | 8 | eight | 0 |   
!      | 0 |   | zero  | 0 |   
!      |   |   | null  | 0 |   
!      |   | 0 | zero  | 0 |   
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight |   |   
!      | 0 |   | zero  |   |   
!      |   |   | null  |   |   
!      |   | 0 | zero  |   |   
!      | 1 | 4 | one   |   |  0
!      | 2 | 3 | two   |   |  0
!      | 3 | 2 | three |   |  0
!      | 4 | 1 | four  |   |  0
!      | 5 | 0 | five  |   |  0
!      | 6 | 6 | six   |   |  0
!      | 7 | 7 | seven |   |  0
!      | 8 | 8 | eight |   |  0
!      | 0 |   | zero  |   |  0
!      |   |   | null  |   |  0
!      |   | 0 | zero  |   |  0
! (99 rows)
! 
! -- ambiguous column
! SELECT '' AS "xxx", i, k, t
!   FROM J1_TBL CROSS JOIN J2_TBL;
! ERROR:  column reference "i" is ambiguous
! LINE 1: SELECT '' AS "xxx", i, k, t
!                             ^
! -- resolve previous ambiguity by specifying the table name
! SELECT '' AS "xxx", t1.i, k, t
!   FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
!  xxx | i | k  |   t   
! -----+---+----+-------
!      | 1 | -1 | one
!      | 2 | -1 | two
!      | 3 | -1 | three
!      | 4 | -1 | four
!      | 5 | -1 | five
!      | 6 | -1 | six
!      | 7 | -1 | seven
!      | 8 | -1 | eight
!      | 0 | -1 | zero
!      |   | -1 | null
!      |   | -1 | zero
!      | 1 |  2 | one
!      | 2 |  2 | two
!      | 3 |  2 | three
!      | 4 |  2 | four
!      | 5 |  2 | five
!      | 6 |  2 | six
!      | 7 |  2 | seven
!      | 8 |  2 | eight
!      | 0 |  2 | zero
!      |   |  2 | null
!      |   |  2 | zero
!      | 1 | -3 | one
!      | 2 | -3 | two
!      | 3 | -3 | three
!      | 4 | -3 | four
!      | 5 | -3 | five
!      | 6 | -3 | six
!      | 7 | -3 | seven
!      | 8 | -3 | eight
!      | 0 | -3 | zero
!      |   | -3 | null
!      |   | -3 | zero
!      | 1 |  4 | one
!      | 2 |  4 | two
!      | 3 |  4 | three
!      | 4 |  4 | four
!      | 5 |  4 | five
!      | 6 |  4 | six
!      | 7 |  4 | seven
!      | 8 |  4 | eight
!      | 0 |  4 | zero
!      |   |  4 | null
!      |   |  4 | zero
!      | 1 | -5 | one
!      | 2 | -5 | two
!      | 3 | -5 | three
!      | 4 | -5 | four
!      | 5 | -5 | five
!      | 6 | -5 | six
!      | 7 | -5 | seven
!      | 8 | -5 | eight
!      | 0 | -5 | zero
!      |   | -5 | null
!      |   | -5 | zero
!      | 1 | -5 | one
!      | 2 | -5 | two
!      | 3 | -5 | three
!      | 4 | -5 | four
!      | 5 | -5 | five
!      | 6 | -5 | six
!      | 7 | -5 | seven
!      | 8 | -5 | eight
!      | 0 | -5 | zero
!      |   | -5 | null
!      |   | -5 | zero
!      | 1 |    | one
!      | 2 |    | two
!      | 3 |    | three
!      | 4 |    | four
!      | 5 |    | five
!      | 6 |    | six
!      | 7 |    | seven
!      | 8 |    | eight
!      | 0 |    | zero
!      |   |    | null
!      |   |    | zero
!      | 1 |    | one
!      | 2 |    | two
!      | 3 |    | three
!      | 4 |    | four
!      | 5 |    | five
!      | 6 |    | six
!      | 7 |    | seven
!      | 8 |    | eight
!      | 0 |    | zero
!      |   |    | null
!      |   |    | zero
!      | 1 |  0 | one
!      | 2 |  0 | two
!      | 3 |  0 | three
!      | 4 |  0 | four
!      | 5 |  0 | five
!      | 6 |  0 | six
!      | 7 |  0 | seven
!      | 8 |  0 | eight
!      | 0 |  0 | zero
!      |   |  0 | null
!      |   |  0 | zero
! (99 rows)
! 
! SELECT '' AS "xxx", ii, tt, kk
!   FROM (J1_TBL CROSS JOIN J2_TBL)
!     AS tx (ii, jj, tt, ii2, kk);
!  xxx | ii |  tt   | kk 
! -----+----+-------+----
!      |  1 | one   | -1
!      |  2 | two   | -1
!      |  3 | three | -1
!      |  4 | four  | -1
!      |  5 | five  | -1
!      |  6 | six   | -1
!      |  7 | seven | -1
!      |  8 | eight | -1
!      |  0 | zero  | -1
!      |    | null  | -1
!      |    | zero  | -1
!      |  1 | one   |  2
!      |  2 | two   |  2
!      |  3 | three |  2
!      |  4 | four  |  2
!      |  5 | five  |  2
!      |  6 | six   |  2
!      |  7 | seven |  2
!      |  8 | eight |  2
!      |  0 | zero  |  2
!      |    | null  |  2
!      |    | zero  |  2
!      |  1 | one   | -3
!      |  2 | two   | -3
!      |  3 | three | -3
!      |  4 | four  | -3
!      |  5 | five  | -3
!      |  6 | six   | -3
!      |  7 | seven | -3
!      |  8 | eight | -3
!      |  0 | zero  | -3
!      |    | null  | -3
!      |    | zero  | -3
!      |  1 | one   |  4
!      |  2 | two   |  4
!      |  3 | three |  4
!      |  4 | four  |  4
!      |  5 | five  |  4
!      |  6 | six   |  4
!      |  7 | seven |  4
!      |  8 | eight |  4
!      |  0 | zero  |  4
!      |    | null  |  4
!      |    | zero  |  4
!      |  1 | one   | -5
!      |  2 | two   | -5
!      |  3 | three | -5
!      |  4 | four  | -5
!      |  5 | five  | -5
!      |  6 | six   | -5
!      |  7 | seven | -5
!      |  8 | eight | -5
!      |  0 | zero  | -5
!      |    | null  | -5
!      |    | zero  | -5
!      |  1 | one   | -5
!      |  2 | two   | -5
!      |  3 | three | -5
!      |  4 | four  | -5
!      |  5 | five  | -5
!      |  6 | six   | -5
!      |  7 | seven | -5
!      |  8 | eight | -5
!      |  0 | zero  | -5
!      |    | null  | -5
!      |    | zero  | -5
!      |  1 | one   |   
!      |  2 | two   |   
!      |  3 | three |   
!      |  4 | four  |   
!      |  5 | five  |   
!      |  6 | six   |   
!      |  7 | seven |   
!      |  8 | eight |   
!      |  0 | zero  |   
!      |    | null  |   
!      |    | zero  |   
!      |  1 | one   |   
!      |  2 | two   |   
!      |  3 | three |   
!      |  4 | four  |   
!      |  5 | five  |   
!      |  6 | six   |   
!      |  7 | seven |   
!      |  8 | eight |   
!      |  0 | zero  |   
!      |    | null  |   
!      |    | zero  |   
!      |  1 | one   |  0
!      |  2 | two   |  0
!      |  3 | three |  0
!      |  4 | four  |  0
!      |  5 | five  |  0
!      |  6 | six   |  0
!      |  7 | seven |  0
!      |  8 | eight |  0
!      |  0 | zero  |  0
!      |    | null  |  0
!      |    | zero  |  0
! (99 rows)
! 
! SELECT '' AS "xxx", tx.ii, tx.jj, tx.kk
!   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
!     AS tx (ii, jj, tt, ii2, kk);
!  xxx | ii | jj | kk 
! -----+----+----+----
!      |  1 |  4 | -1
!      |  2 |  3 | -1
!      |  3 |  2 | -1
!      |  4 |  1 | -1
!      |  5 |  0 | -1
!      |  6 |  6 | -1
!      |  7 |  7 | -1
!      |  8 |  8 | -1
!      |  0 |    | -1
!      |    |    | -1
!      |    |  0 | -1
!      |  1 |  4 |  2
!      |  2 |  3 |  2
!      |  3 |  2 |  2
!      |  4 |  1 |  2
!      |  5 |  0 |  2
!      |  6 |  6 |  2
!      |  7 |  7 |  2
!      |  8 |  8 |  2
!      |  0 |    |  2
!      |    |    |  2
!      |    |  0 |  2
!      |  1 |  4 | -3
!      |  2 |  3 | -3
!      |  3 |  2 | -3
!      |  4 |  1 | -3
!      |  5 |  0 | -3
!      |  6 |  6 | -3
!      |  7 |  7 | -3
!      |  8 |  8 | -3
!      |  0 |    | -3
!      |    |    | -3
!      |    |  0 | -3
!      |  1 |  4 |  4
!      |  2 |  3 |  4
!      |  3 |  2 |  4
!      |  4 |  1 |  4
!      |  5 |  0 |  4
!      |  6 |  6 |  4
!      |  7 |  7 |  4
!      |  8 |  8 |  4
!      |  0 |    |  4
!      |    |    |  4
!      |    |  0 |  4
!      |  1 |  4 | -5
!      |  2 |  3 | -5
!      |  3 |  2 | -5
!      |  4 |  1 | -5
!      |  5 |  0 | -5
!      |  6 |  6 | -5
!      |  7 |  7 | -5
!      |  8 |  8 | -5
!      |  0 |    | -5
!      |    |    | -5
!      |    |  0 | -5
!      |  1 |  4 | -5
!      |  2 |  3 | -5
!      |  3 |  2 | -5
!      |  4 |  1 | -5
!      |  5 |  0 | -5
!      |  6 |  6 | -5
!      |  7 |  7 | -5
!      |  8 |  8 | -5
!      |  0 |    | -5
!      |    |    | -5
!      |    |  0 | -5
!      |  1 |  4 |   
!      |  2 |  3 |   
!      |  3 |  2 |   
!      |  4 |  1 |   
!      |  5 |  0 |   
!      |  6 |  6 |   
!      |  7 |  7 |   
!      |  8 |  8 |   
!      |  0 |    |   
!      |    |    |   
!      |    |  0 |   
!      |  1 |  4 |   
!      |  2 |  3 |   
!      |  3 |  2 |   
!      |  4 |  1 |   
!      |  5 |  0 |   
!      |  6 |  6 |   
!      |  7 |  7 |   
!      |  8 |  8 |   
!      |  0 |    |   
!      |    |    |   
!      |    |  0 |   
!      |  1 |  4 |  0
!      |  2 |  3 |  0
!      |  3 |  2 |  0
!      |  4 |  1 |  0
!      |  5 |  0 |  0
!      |  6 |  6 |  0
!      |  7 |  7 |  0
!      |  8 |  8 |  0
!      |  0 |    |  0
!      |    |    |  0
!      |    |  0 |  0
! (99 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
!  xxx | i | j |   t   | i | k  | i | k  
! -----+---+---+-------+---+----+---+----
!      | 1 | 4 | one   | 1 | -1 | 1 | -1
!      | 1 | 4 | one   | 1 | -1 | 2 |  2
!      | 1 | 4 | one   | 1 | -1 | 3 | -3
!      | 1 | 4 | one   | 1 | -1 | 2 |  4
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 | 0 |   
!      | 1 | 4 | one   | 1 | -1 |   |   
!      | 1 | 4 | one   | 1 | -1 |   |  0
!      | 2 | 3 | two   | 1 | -1 | 1 | -1
!      | 2 | 3 | two   | 1 | -1 | 2 |  2
!      | 2 | 3 | two   | 1 | -1 | 3 | -3
!      | 2 | 3 | two   | 1 | -1 | 2 |  4
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 | 0 |   
!      | 2 | 3 | two   | 1 | -1 |   |   
!      | 2 | 3 | two   | 1 | -1 |   |  0
!      | 3 | 2 | three | 1 | -1 | 1 | -1
!      | 3 | 2 | three | 1 | -1 | 2 |  2
!      | 3 | 2 | three | 1 | -1 | 3 | -3
!      | 3 | 2 | three | 1 | -1 | 2 |  4
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 | 0 |   
!      | 3 | 2 | three | 1 | -1 |   |   
!      | 3 | 2 | three | 1 | -1 |   |  0
!      | 4 | 1 | four  | 1 | -1 | 1 | -1
!      | 4 | 1 | four  | 1 | -1 | 2 |  2
!      | 4 | 1 | four  | 1 | -1 | 3 | -3
!      | 4 | 1 | four  | 1 | -1 | 2 |  4
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 | 0 |   
!      | 4 | 1 | four  | 1 | -1 |   |   
!      | 4 | 1 | four  | 1 | -1 |   |  0
!      | 5 | 0 | five  | 1 | -1 | 1 | -1
!      | 5 | 0 | five  | 1 | -1 | 2 |  2
!      | 5 | 0 | five  | 1 | -1 | 3 | -3
!      | 5 | 0 | five  | 1 | -1 | 2 |  4
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 | 0 |   
!      | 5 | 0 | five  | 1 | -1 |   |   
!      | 5 | 0 | five  | 1 | -1 |   |  0
!      | 6 | 6 | six   | 1 | -1 | 1 | -1
!      | 6 | 6 | six   | 1 | -1 | 2 |  2
!      | 6 | 6 | six   | 1 | -1 | 3 | -3
!      | 6 | 6 | six   | 1 | -1 | 2 |  4
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 | 0 |   
!      | 6 | 6 | six   | 1 | -1 |   |   
!      | 6 | 6 | six   | 1 | -1 |   |  0
!      | 7 | 7 | seven | 1 | -1 | 1 | -1
!      | 7 | 7 | seven | 1 | -1 | 2 |  2
!      | 7 | 7 | seven | 1 | -1 | 3 | -3
!      | 7 | 7 | seven | 1 | -1 | 2 |  4
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 | 0 |   
!      | 7 | 7 | seven | 1 | -1 |   |   
!      | 7 | 7 | seven | 1 | -1 |   |  0
!      | 8 | 8 | eight | 1 | -1 | 1 | -1
!      | 8 | 8 | eight | 1 | -1 | 2 |  2
!      | 8 | 8 | eight | 1 | -1 | 3 | -3
!      | 8 | 8 | eight | 1 | -1 | 2 |  4
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 | 0 |   
!      | 8 | 8 | eight | 1 | -1 |   |   
!      | 8 | 8 | eight | 1 | -1 |   |  0
!      | 0 |   | zero  | 1 | -1 | 1 | -1
!      | 0 |   | zero  | 1 | -1 | 2 |  2
!      | 0 |   | zero  | 1 | -1 | 3 | -3
!      | 0 |   | zero  | 1 | -1 | 2 |  4
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 | 0 |   
!      | 0 |   | zero  | 1 | -1 |   |   
!      | 0 |   | zero  | 1 | -1 |   |  0
!      |   |   | null  | 1 | -1 | 1 | -1
!      |   |   | null  | 1 | -1 | 2 |  2
!      |   |   | null  | 1 | -1 | 3 | -3
!      |   |   | null  | 1 | -1 | 2 |  4
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 | 0 |   
!      |   |   | null  | 1 | -1 |   |   
!      |   |   | null  | 1 | -1 |   |  0
!      |   | 0 | zero  | 1 | -1 | 1 | -1
!      |   | 0 | zero  | 1 | -1 | 2 |  2
!      |   | 0 | zero  | 1 | -1 | 3 | -3
!      |   | 0 | zero  | 1 | -1 | 2 |  4
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 | 0 |   
!      |   | 0 | zero  | 1 | -1 |   |   
!      |   | 0 | zero  | 1 | -1 |   |  0
!      | 1 | 4 | one   | 2 |  2 | 1 | -1
!      | 1 | 4 | one   | 2 |  2 | 2 |  2
!      | 1 | 4 | one   | 2 |  2 | 3 | -3
!      | 1 | 4 | one   | 2 |  2 | 2 |  4
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 | 0 |   
!      | 1 | 4 | one   | 2 |  2 |   |   
!      | 1 | 4 | one   | 2 |  2 |   |  0
!      | 2 | 3 | two   | 2 |  2 | 1 | -1
!      | 2 | 3 | two   | 2 |  2 | 2 |  2
!      | 2 | 3 | two   | 2 |  2 | 3 | -3
!      | 2 | 3 | two   | 2 |  2 | 2 |  4
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 | 0 |   
!      | 2 | 3 | two   | 2 |  2 |   |   
!      | 2 | 3 | two   | 2 |  2 |   |  0
!      | 3 | 2 | three | 2 |  2 | 1 | -1
!      | 3 | 2 | three | 2 |  2 | 2 |  2
!      | 3 | 2 | three | 2 |  2 | 3 | -3
!      | 3 | 2 | three | 2 |  2 | 2 |  4
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 | 0 |   
!      | 3 | 2 | three | 2 |  2 |   |   
!      | 3 | 2 | three | 2 |  2 |   |  0
!      | 4 | 1 | four  | 2 |  2 | 1 | -1
!      | 4 | 1 | four  | 2 |  2 | 2 |  2
!      | 4 | 1 | four  | 2 |  2 | 3 | -3
!      | 4 | 1 | four  | 2 |  2 | 2 |  4
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 | 0 |   
!      | 4 | 1 | four  | 2 |  2 |   |   
!      | 4 | 1 | four  | 2 |  2 |   |  0
!      | 5 | 0 | five  | 2 |  2 | 1 | -1
!      | 5 | 0 | five  | 2 |  2 | 2 |  2
!      | 5 | 0 | five  | 2 |  2 | 3 | -3
!      | 5 | 0 | five  | 2 |  2 | 2 |  4
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 | 0 |   
!      | 5 | 0 | five  | 2 |  2 |   |   
!      | 5 | 0 | five  | 2 |  2 |   |  0
!      | 6 | 6 | six   | 2 |  2 | 1 | -1
!      | 6 | 6 | six   | 2 |  2 | 2 |  2
!      | 6 | 6 | six   | 2 |  2 | 3 | -3
!      | 6 | 6 | six   | 2 |  2 | 2 |  4
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 | 0 |   
!      | 6 | 6 | six   | 2 |  2 |   |   
!      | 6 | 6 | six   | 2 |  2 |   |  0
!      | 7 | 7 | seven | 2 |  2 | 1 | -1
!      | 7 | 7 | seven | 2 |  2 | 2 |  2
!      | 7 | 7 | seven | 2 |  2 | 3 | -3
!      | 7 | 7 | seven | 2 |  2 | 2 |  4
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 | 0 |   
!      | 7 | 7 | seven | 2 |  2 |   |   
!      | 7 | 7 | seven | 2 |  2 |   |  0
!      | 8 | 8 | eight | 2 |  2 | 1 | -1
!      | 8 | 8 | eight | 2 |  2 | 2 |  2
!      | 8 | 8 | eight | 2 |  2 | 3 | -3
!      | 8 | 8 | eight | 2 |  2 | 2 |  4
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 | 0 |   
!      | 8 | 8 | eight | 2 |  2 |   |   
!      | 8 | 8 | eight | 2 |  2 |   |  0
!      | 0 |   | zero  | 2 |  2 | 1 | -1
!      | 0 |   | zero  | 2 |  2 | 2 |  2
!      | 0 |   | zero  | 2 |  2 | 3 | -3
!      | 0 |   | zero  | 2 |  2 | 2 |  4
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 | 0 |   
!      | 0 |   | zero  | 2 |  2 |   |   
!      | 0 |   | zero  | 2 |  2 |   |  0
!      |   |   | null  | 2 |  2 | 1 | -1
!      |   |   | null  | 2 |  2 | 2 |  2
!      |   |   | null  | 2 |  2 | 3 | -3
!      |   |   | null  | 2 |  2 | 2 |  4
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 | 0 |   
!      |   |   | null  | 2 |  2 |   |   
!      |   |   | null  | 2 |  2 |   |  0
!      |   | 0 | zero  | 2 |  2 | 1 | -1
!      |   | 0 | zero  | 2 |  2 | 2 |  2
!      |   | 0 | zero  | 2 |  2 | 3 | -3
!      |   | 0 | zero  | 2 |  2 | 2 |  4
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 | 0 |   
!      |   | 0 | zero  | 2 |  2 |   |   
!      |   | 0 | zero  | 2 |  2 |   |  0
!      | 1 | 4 | one   | 3 | -3 | 1 | -1
!      | 1 | 4 | one   | 3 | -3 | 2 |  2
!      | 1 | 4 | one   | 3 | -3 | 3 | -3
!      | 1 | 4 | one   | 3 | -3 | 2 |  4
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 | 0 |   
!      | 1 | 4 | one   | 3 | -3 |   |   
!      | 1 | 4 | one   | 3 | -3 |   |  0
!      | 2 | 3 | two   | 3 | -3 | 1 | -1
!      | 2 | 3 | two   | 3 | -3 | 2 |  2
!      | 2 | 3 | two   | 3 | -3 | 3 | -3
!      | 2 | 3 | two   | 3 | -3 | 2 |  4
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 | 0 |   
!      | 2 | 3 | two   | 3 | -3 |   |   
!      | 2 | 3 | two   | 3 | -3 |   |  0
!      | 3 | 2 | three | 3 | -3 | 1 | -1
!      | 3 | 2 | three | 3 | -3 | 2 |  2
!      | 3 | 2 | three | 3 | -3 | 3 | -3
!      | 3 | 2 | three | 3 | -3 | 2 |  4
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 | 0 |   
!      | 3 | 2 | three | 3 | -3 |   |   
!      | 3 | 2 | three | 3 | -3 |   |  0
!      | 4 | 1 | four  | 3 | -3 | 1 | -1
!      | 4 | 1 | four  | 3 | -3 | 2 |  2
!      | 4 | 1 | four  | 3 | -3 | 3 | -3
!      | 4 | 1 | four  | 3 | -3 | 2 |  4
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 | 0 |   
!      | 4 | 1 | four  | 3 | -3 |   |   
!      | 4 | 1 | four  | 3 | -3 |   |  0
!      | 5 | 0 | five  | 3 | -3 | 1 | -1
!      | 5 | 0 | five  | 3 | -3 | 2 |  2
!      | 5 | 0 | five  | 3 | -3 | 3 | -3
!      | 5 | 0 | five  | 3 | -3 | 2 |  4
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 | 0 |   
!      | 5 | 0 | five  | 3 | -3 |   |   
!      | 5 | 0 | five  | 3 | -3 |   |  0
!      | 6 | 6 | six   | 3 | -3 | 1 | -1
!      | 6 | 6 | six   | 3 | -3 | 2 |  2
!      | 6 | 6 | six   | 3 | -3 | 3 | -3
!      | 6 | 6 | six   | 3 | -3 | 2 |  4
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 | 0 |   
!      | 6 | 6 | six   | 3 | -3 |   |   
!      | 6 | 6 | six   | 3 | -3 |   |  0
!      | 7 | 7 | seven | 3 | -3 | 1 | -1
!      | 7 | 7 | seven | 3 | -3 | 2 |  2
!      | 7 | 7 | seven | 3 | -3 | 3 | -3
!      | 7 | 7 | seven | 3 | -3 | 2 |  4
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 | 0 |   
!      | 7 | 7 | seven | 3 | -3 |   |   
!      | 7 | 7 | seven | 3 | -3 |   |  0
!      | 8 | 8 | eight | 3 | -3 | 1 | -1
!      | 8 | 8 | eight | 3 | -3 | 2 |  2
!      | 8 | 8 | eight | 3 | -3 | 3 | -3
!      | 8 | 8 | eight | 3 | -3 | 2 |  4
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 | 0 |   
!      | 8 | 8 | eight | 3 | -3 |   |   
!      | 8 | 8 | eight | 3 | -3 |   |  0
!      | 0 |   | zero  | 3 | -3 | 1 | -1
!      | 0 |   | zero  | 3 | -3 | 2 |  2
!      | 0 |   | zero  | 3 | -3 | 3 | -3
!      | 0 |   | zero  | 3 | -3 | 2 |  4
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 | 0 |   
!      | 0 |   | zero  | 3 | -3 |   |   
!      | 0 |   | zero  | 3 | -3 |   |  0
!      |   |   | null  | 3 | -3 | 1 | -1
!      |   |   | null  | 3 | -3 | 2 |  2
!      |   |   | null  | 3 | -3 | 3 | -3
!      |   |   | null  | 3 | -3 | 2 |  4
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 | 0 |   
!      |   |   | null  | 3 | -3 |   |   
!      |   |   | null  | 3 | -3 |   |  0
!      |   | 0 | zero  | 3 | -3 | 1 | -1
!      |   | 0 | zero  | 3 | -3 | 2 |  2
!      |   | 0 | zero  | 3 | -3 | 3 | -3
!      |   | 0 | zero  | 3 | -3 | 2 |  4
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 | 0 |   
!      |   | 0 | zero  | 3 | -3 |   |   
!      |   | 0 | zero  | 3 | -3 |   |  0
!      | 1 | 4 | one   | 2 |  4 | 1 | -1
!      | 1 | 4 | one   | 2 |  4 | 2 |  2
!      | 1 | 4 | one   | 2 |  4 | 3 | -3
!      | 1 | 4 | one   | 2 |  4 | 2 |  4
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 | 0 |   
!      | 1 | 4 | one   | 2 |  4 |   |   
!      | 1 | 4 | one   | 2 |  4 |   |  0
!      | 2 | 3 | two   | 2 |  4 | 1 | -1
!      | 2 | 3 | two   | 2 |  4 | 2 |  2
!      | 2 | 3 | two   | 2 |  4 | 3 | -3
!      | 2 | 3 | two   | 2 |  4 | 2 |  4
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 | 0 |   
!      | 2 | 3 | two   | 2 |  4 |   |   
!      | 2 | 3 | two   | 2 |  4 |   |  0
!      | 3 | 2 | three | 2 |  4 | 1 | -1
!      | 3 | 2 | three | 2 |  4 | 2 |  2
!      | 3 | 2 | three | 2 |  4 | 3 | -3
!      | 3 | 2 | three | 2 |  4 | 2 |  4
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 | 0 |   
!      | 3 | 2 | three | 2 |  4 |   |   
!      | 3 | 2 | three | 2 |  4 |   |  0
!      | 4 | 1 | four  | 2 |  4 | 1 | -1
!      | 4 | 1 | four  | 2 |  4 | 2 |  2
!      | 4 | 1 | four  | 2 |  4 | 3 | -3
!      | 4 | 1 | four  | 2 |  4 | 2 |  4
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 | 0 |   
!      | 4 | 1 | four  | 2 |  4 |   |   
!      | 4 | 1 | four  | 2 |  4 |   |  0
!      | 5 | 0 | five  | 2 |  4 | 1 | -1
!      | 5 | 0 | five  | 2 |  4 | 2 |  2
!      | 5 | 0 | five  | 2 |  4 | 3 | -3
!      | 5 | 0 | five  | 2 |  4 | 2 |  4
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 | 0 |   
!      | 5 | 0 | five  | 2 |  4 |   |   
!      | 5 | 0 | five  | 2 |  4 |   |  0
!      | 6 | 6 | six   | 2 |  4 | 1 | -1
!      | 6 | 6 | six   | 2 |  4 | 2 |  2
!      | 6 | 6 | six   | 2 |  4 | 3 | -3
!      | 6 | 6 | six   | 2 |  4 | 2 |  4
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 | 0 |   
!      | 6 | 6 | six   | 2 |  4 |   |   
!      | 6 | 6 | six   | 2 |  4 |   |  0
!      | 7 | 7 | seven | 2 |  4 | 1 | -1
!      | 7 | 7 | seven | 2 |  4 | 2 |  2
!      | 7 | 7 | seven | 2 |  4 | 3 | -3
!      | 7 | 7 | seven | 2 |  4 | 2 |  4
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 | 0 |   
!      | 7 | 7 | seven | 2 |  4 |   |   
!      | 7 | 7 | seven | 2 |  4 |   |  0
!      | 8 | 8 | eight | 2 |  4 | 1 | -1
!      | 8 | 8 | eight | 2 |  4 | 2 |  2
!      | 8 | 8 | eight | 2 |  4 | 3 | -3
!      | 8 | 8 | eight | 2 |  4 | 2 |  4
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 | 0 |   
!      | 8 | 8 | eight | 2 |  4 |   |   
!      | 8 | 8 | eight | 2 |  4 |   |  0
!      | 0 |   | zero  | 2 |  4 | 1 | -1
!      | 0 |   | zero  | 2 |  4 | 2 |  2
!      | 0 |   | zero  | 2 |  4 | 3 | -3
!      | 0 |   | zero  | 2 |  4 | 2 |  4
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 | 0 |   
!      | 0 |   | zero  | 2 |  4 |   |   
!      | 0 |   | zero  | 2 |  4 |   |  0
!      |   |   | null  | 2 |  4 | 1 | -1
!      |   |   | null  | 2 |  4 | 2 |  2
!      |   |   | null  | 2 |  4 | 3 | -3
!      |   |   | null  | 2 |  4 | 2 |  4
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 | 0 |   
!      |   |   | null  | 2 |  4 |   |   
!      |   |   | null  | 2 |  4 |   |  0
!      |   | 0 | zero  | 2 |  4 | 1 | -1
!      |   | 0 | zero  | 2 |  4 | 2 |  2
!      |   | 0 | zero  | 2 |  4 | 3 | -3
!      |   | 0 | zero  | 2 |  4 | 2 |  4
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 | 0 |   
!      |   | 0 | zero  | 2 |  4 |   |   
!      |   | 0 | zero  | 2 |  4 |   |  0
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  | 5 | -5 |   |  0
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  | 5 | -5 |   |  0
!      | 1 | 4 | one   | 0 |    | 1 | -1
!      | 1 | 4 | one   | 0 |    | 2 |  2
!      | 1 | 4 | one   | 0 |    | 3 | -3
!      | 1 | 4 | one   | 0 |    | 2 |  4
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    | 0 |   
!      | 1 | 4 | one   | 0 |    |   |   
!      | 1 | 4 | one   | 0 |    |   |  0
!      | 2 | 3 | two   | 0 |    | 1 | -1
!      | 2 | 3 | two   | 0 |    | 2 |  2
!      | 2 | 3 | two   | 0 |    | 3 | -3
!      | 2 | 3 | two   | 0 |    | 2 |  4
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    | 0 |   
!      | 2 | 3 | two   | 0 |    |   |   
!      | 2 | 3 | two   | 0 |    |   |  0
!      | 3 | 2 | three | 0 |    | 1 | -1
!      | 3 | 2 | three | 0 |    | 2 |  2
!      | 3 | 2 | three | 0 |    | 3 | -3
!      | 3 | 2 | three | 0 |    | 2 |  4
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    | 0 |   
!      | 3 | 2 | three | 0 |    |   |   
!      | 3 | 2 | three | 0 |    |   |  0
!      | 4 | 1 | four  | 0 |    | 1 | -1
!      | 4 | 1 | four  | 0 |    | 2 |  2
!      | 4 | 1 | four  | 0 |    | 3 | -3
!      | 4 | 1 | four  | 0 |    | 2 |  4
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    | 0 |   
!      | 4 | 1 | four  | 0 |    |   |   
!      | 4 | 1 | four  | 0 |    |   |  0
!      | 5 | 0 | five  | 0 |    | 1 | -1
!      | 5 | 0 | five  | 0 |    | 2 |  2
!      | 5 | 0 | five  | 0 |    | 3 | -3
!      | 5 | 0 | five  | 0 |    | 2 |  4
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    | 0 |   
!      | 5 | 0 | five  | 0 |    |   |   
!      | 5 | 0 | five  | 0 |    |   |  0
!      | 6 | 6 | six   | 0 |    | 1 | -1
!      | 6 | 6 | six   | 0 |    | 2 |  2
!      | 6 | 6 | six   | 0 |    | 3 | -3
!      | 6 | 6 | six   | 0 |    | 2 |  4
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    | 0 |   
!      | 6 | 6 | six   | 0 |    |   |   
!      | 6 | 6 | six   | 0 |    |   |  0
!      | 7 | 7 | seven | 0 |    | 1 | -1
!      | 7 | 7 | seven | 0 |    | 2 |  2
!      | 7 | 7 | seven | 0 |    | 3 | -3
!      | 7 | 7 | seven | 0 |    | 2 |  4
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    | 0 |   
!      | 7 | 7 | seven | 0 |    |   |   
!      | 7 | 7 | seven | 0 |    |   |  0
!      | 8 | 8 | eight | 0 |    | 1 | -1
!      | 8 | 8 | eight | 0 |    | 2 |  2
!      | 8 | 8 | eight | 0 |    | 3 | -3
!      | 8 | 8 | eight | 0 |    | 2 |  4
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    | 0 |   
!      | 8 | 8 | eight | 0 |    |   |   
!      | 8 | 8 | eight | 0 |    |   |  0
!      | 0 |   | zero  | 0 |    | 1 | -1
!      | 0 |   | zero  | 0 |    | 2 |  2
!      | 0 |   | zero  | 0 |    | 3 | -3
!      | 0 |   | zero  | 0 |    | 2 |  4
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    | 0 |   
!      | 0 |   | zero  | 0 |    |   |   
!      | 0 |   | zero  | 0 |    |   |  0
!      |   |   | null  | 0 |    | 1 | -1
!      |   |   | null  | 0 |    | 2 |  2
!      |   |   | null  | 0 |    | 3 | -3
!      |   |   | null  | 0 |    | 2 |  4
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    | 0 |   
!      |   |   | null  | 0 |    |   |   
!      |   |   | null  | 0 |    |   |  0
!      |   | 0 | zero  | 0 |    | 1 | -1
!      |   | 0 | zero  | 0 |    | 2 |  2
!      |   | 0 | zero  | 0 |    | 3 | -3
!      |   | 0 | zero  | 0 |    | 2 |  4
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    | 0 |   
!      |   | 0 | zero  | 0 |    |   |   
!      |   | 0 | zero  | 0 |    |   |  0
!      | 1 | 4 | one   |   |    | 1 | -1
!      | 1 | 4 | one   |   |    | 2 |  2
!      | 1 | 4 | one   |   |    | 3 | -3
!      | 1 | 4 | one   |   |    | 2 |  4
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    | 0 |   
!      | 1 | 4 | one   |   |    |   |   
!      | 1 | 4 | one   |   |    |   |  0
!      | 2 | 3 | two   |   |    | 1 | -1
!      | 2 | 3 | two   |   |    | 2 |  2
!      | 2 | 3 | two   |   |    | 3 | -3
!      | 2 | 3 | two   |   |    | 2 |  4
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    | 0 |   
!      | 2 | 3 | two   |   |    |   |   
!      | 2 | 3 | two   |   |    |   |  0
!      | 3 | 2 | three |   |    | 1 | -1
!      | 3 | 2 | three |   |    | 2 |  2
!      | 3 | 2 | three |   |    | 3 | -3
!      | 3 | 2 | three |   |    | 2 |  4
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    | 0 |   
!      | 3 | 2 | three |   |    |   |   
!      | 3 | 2 | three |   |    |   |  0
!      | 4 | 1 | four  |   |    | 1 | -1
!      | 4 | 1 | four  |   |    | 2 |  2
!      | 4 | 1 | four  |   |    | 3 | -3
!      | 4 | 1 | four  |   |    | 2 |  4
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    | 0 |   
!      | 4 | 1 | four  |   |    |   |   
!      | 4 | 1 | four  |   |    |   |  0
!      | 5 | 0 | five  |   |    | 1 | -1
!      | 5 | 0 | five  |   |    | 2 |  2
!      | 5 | 0 | five  |   |    | 3 | -3
!      | 5 | 0 | five  |   |    | 2 |  4
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    | 0 |   
!      | 5 | 0 | five  |   |    |   |   
!      | 5 | 0 | five  |   |    |   |  0
!      | 6 | 6 | six   |   |    | 1 | -1
!      | 6 | 6 | six   |   |    | 2 |  2
!      | 6 | 6 | six   |   |    | 3 | -3
!      | 6 | 6 | six   |   |    | 2 |  4
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    | 0 |   
!      | 6 | 6 | six   |   |    |   |   
!      | 6 | 6 | six   |   |    |   |  0
!      | 7 | 7 | seven |   |    | 1 | -1
!      | 7 | 7 | seven |   |    | 2 |  2
!      | 7 | 7 | seven |   |    | 3 | -3
!      | 7 | 7 | seven |   |    | 2 |  4
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    | 0 |   
!      | 7 | 7 | seven |   |    |   |   
!      | 7 | 7 | seven |   |    |   |  0
!      | 8 | 8 | eight |   |    | 1 | -1
!      | 8 | 8 | eight |   |    | 2 |  2
!      | 8 | 8 | eight |   |    | 3 | -3
!      | 8 | 8 | eight |   |    | 2 |  4
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    | 0 |   
!      | 8 | 8 | eight |   |    |   |   
!      | 8 | 8 | eight |   |    |   |  0
!      | 0 |   | zero  |   |    | 1 | -1
!      | 0 |   | zero  |   |    | 2 |  2
!      | 0 |   | zero  |   |    | 3 | -3
!      | 0 |   | zero  |   |    | 2 |  4
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    | 0 |   
!      | 0 |   | zero  |   |    |   |   
!      | 0 |   | zero  |   |    |   |  0
!      |   |   | null  |   |    | 1 | -1
!      |   |   | null  |   |    | 2 |  2
!      |   |   | null  |   |    | 3 | -3
!      |   |   | null  |   |    | 2 |  4
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    | 0 |   
!      |   |   | null  |   |    |   |   
!      |   |   | null  |   |    |   |  0
!      |   | 0 | zero  |   |    | 1 | -1
!      |   | 0 | zero  |   |    | 2 |  2
!      |   | 0 | zero  |   |    | 3 | -3
!      |   | 0 | zero  |   |    | 2 |  4
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    | 0 |   
!      |   | 0 | zero  |   |    |   |   
!      |   | 0 | zero  |   |    |   |  0
!      | 1 | 4 | one   |   |  0 | 1 | -1
!      | 1 | 4 | one   |   |  0 | 2 |  2
!      | 1 | 4 | one   |   |  0 | 3 | -3
!      | 1 | 4 | one   |   |  0 | 2 |  4
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 | 0 |   
!      | 1 | 4 | one   |   |  0 |   |   
!      | 1 | 4 | one   |   |  0 |   |  0
!      | 2 | 3 | two   |   |  0 | 1 | -1
!      | 2 | 3 | two   |   |  0 | 2 |  2
!      | 2 | 3 | two   |   |  0 | 3 | -3
!      | 2 | 3 | two   |   |  0 | 2 |  4
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 | 0 |   
!      | 2 | 3 | two   |   |  0 |   |   
!      | 2 | 3 | two   |   |  0 |   |  0
!      | 3 | 2 | three |   |  0 | 1 | -1
!      | 3 | 2 | three |   |  0 | 2 |  2
!      | 3 | 2 | three |   |  0 | 3 | -3
!      | 3 | 2 | three |   |  0 | 2 |  4
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 | 0 |   
!      | 3 | 2 | three |   |  0 |   |   
!      | 3 | 2 | three |   |  0 |   |  0
!      | 4 | 1 | four  |   |  0 | 1 | -1
!      | 4 | 1 | four  |   |  0 | 2 |  2
!      | 4 | 1 | four  |   |  0 | 3 | -3
!      | 4 | 1 | four  |   |  0 | 2 |  4
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 | 0 |   
!      | 4 | 1 | four  |   |  0 |   |   
!      | 4 | 1 | four  |   |  0 |   |  0
!      | 5 | 0 | five  |   |  0 | 1 | -1
!      | 5 | 0 | five  |   |  0 | 2 |  2
!      | 5 | 0 | five  |   |  0 | 3 | -3
!      | 5 | 0 | five  |   |  0 | 2 |  4
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 | 0 |   
!      | 5 | 0 | five  |   |  0 |   |   
!      | 5 | 0 | five  |   |  0 |   |  0
!      | 6 | 6 | six   |   |  0 | 1 | -1
!      | 6 | 6 | six   |   |  0 | 2 |  2
!      | 6 | 6 | six   |   |  0 | 3 | -3
!      | 6 | 6 | six   |   |  0 | 2 |  4
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 | 0 |   
!      | 6 | 6 | six   |   |  0 |   |   
!      | 6 | 6 | six   |   |  0 |   |  0
!      | 7 | 7 | seven |   |  0 | 1 | -1
!      | 7 | 7 | seven |   |  0 | 2 |  2
!      | 7 | 7 | seven |   |  0 | 3 | -3
!      | 7 | 7 | seven |   |  0 | 2 |  4
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 | 0 |   
!      | 7 | 7 | seven |   |  0 |   |   
!      | 7 | 7 | seven |   |  0 |   |  0
!      | 8 | 8 | eight |   |  0 | 1 | -1
!      | 8 | 8 | eight |   |  0 | 2 |  2
!      | 8 | 8 | eight |   |  0 | 3 | -3
!      | 8 | 8 | eight |   |  0 | 2 |  4
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 | 0 |   
!      | 8 | 8 | eight |   |  0 |   |   
!      | 8 | 8 | eight |   |  0 |   |  0
!      | 0 |   | zero  |   |  0 | 1 | -1
!      | 0 |   | zero  |   |  0 | 2 |  2
!      | 0 |   | zero  |   |  0 | 3 | -3
!      | 0 |   | zero  |   |  0 | 2 |  4
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 | 0 |   
!      | 0 |   | zero  |   |  0 |   |   
!      | 0 |   | zero  |   |  0 |   |  0
!      |   |   | null  |   |  0 | 1 | -1
!      |   |   | null  |   |  0 | 2 |  2
!      |   |   | null  |   |  0 | 3 | -3
!      |   |   | null  |   |  0 | 2 |  4
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 | 0 |   
!      |   |   | null  |   |  0 |   |   
!      |   |   | null  |   |  0 |   |  0
!      |   | 0 | zero  |   |  0 | 1 | -1
!      |   | 0 | zero  |   |  0 | 2 |  2
!      |   | 0 | zero  |   |  0 | 3 | -3
!      |   | 0 | zero  |   |  0 | 2 |  4
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 | 0 |   
!      |   | 0 | zero  |   |  0 |   |   
!      |   | 0 | zero  |   |  0 |   |  0
! (891 rows)
! 
! --
! --
! -- Inner joins (equi-joins)
! --
! --
! --
! -- Inner joins (equi-joins) with USING clause
! -- The USING syntax changes the shape of the resulting table
! -- by including a column in the USING clause only once in the result.
! --
! -- Inner equi-join on specified column
! SELECT '' AS "xxx", *
!   FROM J1_TBL INNER JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! -- Same as above, slightly different syntax
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
!   ORDER BY a, d;
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
!   ORDER BY b, t1.a;
!  xxx | b | a |   c   | a 
! -----+---+---+-------+---
!      | 0 | 5 | five  |  
!      | 0 |   | zero  |  
!      | 2 | 3 | three | 2
!      | 4 | 1 | one   | 2
! (4 rows)
! 
! --
! -- NATURAL JOIN
! -- Inner equi-join on all columns with the same name
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL NATURAL JOIN J2_TBL;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);
!  xxx | a | b |  c   | d 
! -----+---+---+------+---
!      | 0 |   | zero |  
!      | 2 | 3 | two  | 2
!      | 4 | 1 | four | 2
! (3 rows)
! 
! -- mismatch number of columns
! -- currently, Postgres will fill in with underlying names
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
!  xxx | a | b |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! --
! -- Inner joins (equi-joins)
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 0 |   | zero  | 0 |   
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 2 |  2
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 3 | -3
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
!  xxx | i | j |  t   | i | k 
! -----+---+---+------+---+---
!      | 0 |   | zero |   | 0
!      | 2 | 3 | two  | 2 | 2
!      | 4 | 1 | four | 2 | 4
! (3 rows)
! 
! --
! -- Non-equi-joins
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
!  xxx | i | j |   t   | i | k 
! -----+---+---+-------+---+---
!      | 1 | 4 | one   | 2 | 2
!      | 2 | 3 | two   | 2 | 2
!      | 0 |   | zero  | 2 | 2
!      | 1 | 4 | one   | 2 | 4
!      | 2 | 3 | two   | 2 | 4
!      | 3 | 2 | three | 2 | 4
!      | 4 | 1 | four  | 2 | 4
!      | 0 |   | zero  | 2 | 4
!      | 0 |   | zero  |   | 0
! (9 rows)
! 
! --
! -- Outer joins
! -- Note that OUTER is a noise word
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |   
!      |   |   |       |  0
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |   
!      |   |   |       |  0
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
!  xxx | i | j | t | k 
! -----+---+---+---+---
! (0 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
!  xxx | i | j |  t  | k  
! -----+---+---+-----+----
!      | 1 | 4 | one | -1
! (1 row)
! 
! --
! -- More complicated constructs
! --
! --
! -- Multiway full join
! --
! CREATE TABLE t1 (name TEXT, n INTEGER);
! CREATE TABLE t2 (name TEXT, n INTEGER);
! CREATE TABLE t3 (name TEXT, n INTEGER);
! INSERT INTO t1 VALUES ( 'bb', 11 );
! INSERT INTO t2 VALUES ( 'bb', 12 );
! INSERT INTO t2 VALUES ( 'cc', 22 );
! INSERT INTO t2 VALUES ( 'ee', 42 );
! INSERT INTO t3 VALUES ( 'bb', 13 );
! INSERT INTO t3 VALUES ( 'cc', 23 );
! INSERT INTO t3 VALUES ( 'dd', 33 );
! SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
!  name | n  | n  | n  
! ------+----+----+----
!  bb   | 11 | 12 | 13
!  cc   |    | 22 | 23
!  dd   |    |    | 33
!  ee   |    | 42 |   
! (4 rows)
! 
! --
! -- Test interactions of join syntax and subqueries
! --
! -- Basic cases (we expect planner to pull up the subquery here)
! SELECT * FROM
! (SELECT * FROM t2) as s2
! INNER JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
! (2 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! LEFT JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  ee   | 42 |   
! (3 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! FULL JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  dd   |    | 33
!  ee   | 42 |   
! (4 rows)
! 
! -- Cases with non-nullable expressions in subquery results;
! -- make sure these go to null as expected
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
! (2 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL LEFT JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  ee   |   42 |    2 |      |     
! (3 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  dd   |      |      |   33 |    3
!  ee   |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL INNER JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
! (1 row)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL FULL JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
!  cc   |      |      |   22 |    2 |   23 |    3
!  dd   |      |      |      |      |   33 |    3
!  ee   |      |      |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2;
!  name | s1_n | s2_n | s3_n 
! ------+------+------+------
!  bb   |   11 |   12 |   13
!  cc   |      |   22 |   23
!  dd   |      |      |   33
!  ee   |      |   42 |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2;
!  name | s1_n | s2_n | s2_2 | s3_n 
! ------+------+------+------+------
!  bb   |   11 |   12 |    2 |   13
!  cc   |      |   22 |    2 |   23
!  dd   |      |      |      |   33
!  ee   |      |   42 |    2 |     
! (4 rows)
! 
! -- Test for propagation of nullability constraints into sub-joins
! create temp table x (x1 int, x2 int);
! insert into x values (1,11);
! insert into x values (2,22);
! insert into x values (3,null);
! insert into x values (4,44);
! insert into x values (5,null);
! create temp table y (y1 int, y2 int);
! insert into y values (1,111);
! insert into y values (2,222);
! insert into y values (3,333);
! insert into y values (4,null);
! select * from x;
!  x1 | x2 
! ----+----
!   1 | 11
!   2 | 22
!   3 |   
!   4 | 44
!   5 |   
! (5 rows)
! 
! select * from y;
!  y1 | y2  
! ----+-----
!   1 | 111
!   2 | 222
!   3 | 333
!   4 |    
! (4 rows)
! 
! select * from x left join y on (x1 = y1 and x2 is not null);
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |    |    
!   4 | 44 |  4 |    
!   5 |    |    |    
! (5 rows)
! 
! select * from x left join y on (x1 = y1 and y2 is not null);
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |  3 | 333
!   4 | 44 |    |    
!   5 |    |    |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |   5 |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and x2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and y2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |     |    
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and xx2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! -- these should NOT give the same answers as above
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (x2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (y2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (xx2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! --
! -- regression test: check for bug with propagation of implied equality
! -- to outside an IN
! --
! select count(*) from tenk1 a where unique1 in
!   (select unique1 from tenk1 b join tenk1 c using (unique1)
!    where b.unique2 = 42);
!  count 
! -------
!      1
! (1 row)
! 
! --
! -- regression test: check for failure to generate a plan with multiple
! -- degenerate IN clauses
! --
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! -- try that with GEQO too
! begin;
! set geqo = on;
! set geqo_threshold = 2;
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! rollback;
! --
! -- Clean up
! --
! DROP TABLE t1;
! DROP TABLE t2;
! DROP TABLE t3;
! DROP TABLE J1_TBL;
! DROP TABLE J2_TBL;
! -- Both DELETE and UPDATE allow the specification of additional tables
! -- to "join" against to determine which rows should be modified.
! CREATE TEMP TABLE t1 (a int, b int);
! CREATE TEMP TABLE t2 (a int, b int);
! CREATE TEMP TABLE t3 (x int, y int);
! INSERT INTO t1 VALUES (5, 10);
! INSERT INTO t1 VALUES (15, 20);
! INSERT INTO t1 VALUES (100, 100);
! INSERT INTO t1 VALUES (200, 1000);
! INSERT INTO t2 VALUES (200, 2000);
! INSERT INTO t3 VALUES (5, 20);
! INSERT INTO t3 VALUES (6, 7);
! INSERT INTO t3 VALUES (7, 8);
! INSERT INTO t3 VALUES (500, 100);
! DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
! SELECT * FROM t3;
!   x  |  y  
! -----+-----
!    6 |   7
!    7 |   8
!  500 | 100
! (3 rows)
! 
! DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
! SELECT * FROM t3;
!  x | y 
! ---+---
!  6 | 7
!  7 | 8
! (2 rows)
! 
! DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
! SELECT * FROM t3;
!  x | y 
! ---+---
! (0 rows)
! 
! -- Test join against inheritance tree
! create temp table t2a () inherits (t2);
! insert into t2a values (200, 2001);
! select * from t1 left join t2 on (t1.a = t2.a);
!   a  |  b   |  a  |  b   
! -----+------+-----+------
!    5 |   10 |     |     
!   15 |   20 |     |     
!  100 |  100 |     |     
!  200 | 1000 | 200 | 2000
!  200 | 1000 | 200 | 2001
! (5 rows)
! 
! --
! -- regression test for 8.1 merge right join bug
! --
! CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
! INSERT INTO tt1 VALUES (1, 11);
! INSERT INTO tt1 VALUES (2, NULL);
! CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
! INSERT INTO tt2 VALUES (21, 11);
! INSERT INTO tt2 VALUES (22, 11);
! set enable_hashjoin to off;
! set enable_nestloop to off;
! -- these should give the same results
! select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! reset enable_hashjoin;
! reset enable_nestloop;
! --
! -- regression test for 8.2 bug with improper re-ordering of left joins
! --
! create temp table tt3(f1 int, f2 text);
! insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
! create index tt3i on tt3(f1);
! analyze tt3;
! create temp table tt4(f1 int);
! insert into tt4 values (0),(1),(9999);
! analyze tt4;
! SELECT a.f1
! FROM tt4 a
! LEFT JOIN (
!         SELECT b.f1
!         FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
!         WHERE c.f1 IS NULL
! ) AS d ON (a.f1 = d.f1)
! WHERE d.f1 IS NULL;
!   f1  
! ------
!     0
!     1
!  9999
! (3 rows)
! 
! --
! -- regression test for problems of the sort depicted in bug #3494
! --
! create temp table tt5(f1 int, f2 int);
! create temp table tt6(f1 int, f2 int);
! insert into tt5 values(1, 10);
! insert into tt5 values(1, 11);
! insert into tt6 values(1, 9);
! insert into tt6 values(1, 2);
! insert into tt6 values(2, 9);
! select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;
!  f1 | f2 | f1 | f2 
! ----+----+----+----
!   1 | 10 |  1 |  9
! (1 row)
! 
! --
! -- regression test for problems of the sort depicted in bug #3588
! --
! create temp table xx (pkxx int);
! create temp table yy (pkyy int, pkxx int);
! insert into xx values (1);
! insert into xx values (2);
! insert into xx values (3);
! insert into yy values (101, 1);
! insert into yy values (201, 2);
! insert into yy values (301, NULL);
! select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
!        xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
! from yy
!      left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
!      left join xx xxa on yya.pkxx = xxa.pkxx
!      left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
!  yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
! ---------+---------+----------+----------+----------
!      101 |       1 |      101 |        1 |        1
!      201 |       2 |          |          |        1
!      301 |         |          |          |        1
! (3 rows)
! 
! --
! -- regression test for improper pushing of constants across outer-join clauses
! -- (as seen in early 8.2.x releases)
! --
! create temp table zt1 (f1 int primary key);
! create temp table zt2 (f2 int primary key);
! create temp table zt3 (f3 int primary key);
! insert into zt1 values(53);
! insert into zt2 values(53);
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zt1 on (f3 = f1)
! where f2 = 53;
!  f2 | f3 | f1 
! ----+----+----
!  53 |    |   
! (1 row)
! 
! create temp view zv1 as select *,'dummy'::text AS junk from zt1;
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zv1 on (f3 = f1)
! where f2 = 53;
!  f2 | f3 | f1 | junk 
! ----+----+----+------
!  53 |    |    | 
! (1 row)
! 
! --
! -- regression test for improper extraction of OR indexqual conditions
! -- (as seen in early 8.3.x releases)
! --
! select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
! from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
! where a.unique1 = 42 and
!       ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
!  unique2 | ten | tenthous | unique2 | hundred 
! ---------+-----+----------+---------+---------
! (0 rows)
! 
! --
! -- test proper positioning of one-time quals in EXISTS (8.4devel bug)
! --
! prepare foo(bool) as
!   select count(*) from tenk1 a left join tenk1 b
!     on (a.unique2 = b.unique1 and exists
!         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
! execute foo(true);
!  count 
! -------
!  10000
! (1 row)
! 
! execute foo(false);
!  count 
! -------
!  10000
! (1 row)
! 
! --
! -- test for sane behavior with noncanonical merge clauses, per bug #4926
! --
! begin;
! set enable_mergejoin = 1;
! set enable_hashjoin = 0;
! set enable_nestloop = 0;
! create temp table a (i integer);
! create temp table b (x integer, y integer);
! select * from a left join b on i = x and i = y and x = i;
!  i | x | y 
! ---+---+---
! (0 rows)
! 
! rollback;
! --
! -- test NULL behavior of whole-row Vars, per bug #5025
! --
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join
!   (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
!   on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! --
! -- test incorrect failure to NULL pulled-up subexpressions
! --
! begin;
! create temp table a (
!      code char not null,
!      constraint a_pk primary key (code)
! );
! create temp table b (
!      a char not null,
!      num integer not null,
!      constraint b_pk primary key (a, num)
! );
! create temp table c (
!      name char not null,
!      a char,
!      constraint c_pk primary key (name)
! );
! insert into a (code) values ('p');
! insert into a (code) values ('q');
! insert into b (a, num) values ('p', 1);
! insert into b (a, num) values ('p', 2);
! insert into c (name, a) values ('A', 'p');
! insert into c (name, a) values ('B', 'q');
! insert into c (name, a) values ('C', null);
! select c.name, ss.code, ss.b_cnt, ss.const
! from c left join
!   (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
!    from a left join
!      (select count(1) as cnt, b.a from b group by b.a) as b_grp
!      on a.code = b_grp.a
!   ) as ss
!   on (c.a = ss.code)
! order by c.name;
!  name | code | b_cnt | const 
! ------+------+-------+-------
!  A    | p    |     2 |    -1
!  B    | q    |     0 |    -1
!  C    |      |       |      
! (3 rows)
! 
! rollback;
! --
! -- test incorrect handling of placeholders that only appear in targetlists,
! -- per bug #6154
! --
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! -- test the path using join aliases, too
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is used as a nestloop parameter
! --
! EXPLAIN (COSTS OFF)
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!                                               QUERY PLAN                                               
! -------------------------------------------------------------------------------------------------------
!  Nested Loop
!    ->  Hash Full Join
!          Hash Cond: (COALESCE(a.q1, 0::bigint) = COALESCE(b.q2, (-1)::bigint))
!          ->  Seq Scan on int8_tbl a
!          ->  Hash
!                ->  Seq Scan on int8_tbl b
!    ->  Index Scan using tenk1_unique2 on tenk1 c
!          Index Cond: (unique2 = COALESCE((COALESCE(a.q1, 0::bigint)), (COALESCE(b.q2, (-1)::bigint))))
! (8 rows)
! 
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!  qq  | unique1 
! -----+---------
!  123 |    4596
!  123 |    4596
!  456 |    7318
! (3 rows)
! 
! --
! -- nested nestloops can require nested PlaceHolderVars
! --
! create temp table nt1 (
!   id int primary key,
!   a1 boolean,
!   a2 boolean
! );
! create temp table nt2 (
!   id int primary key,
!   nt1_id int,
!   b1 boolean,
!   b2 boolean,
!   foreign key (nt1_id) references nt1(id)
! );
! create temp table nt3 (
!   id int primary key,
!   nt2_id int,
!   c1 boolean,
!   foreign key (nt2_id) references nt2(id)
! );
! insert into nt1 values (1,true,true);
! insert into nt1 values (2,true,false);
! insert into nt1 values (3,false,false);
! insert into nt2 values (1,1,true,true);
! insert into nt2 values (2,2,true,false);
! insert into nt2 values (3,3,false,false);
! insert into nt3 values (1,1,true);
! insert into nt3 values (2,2,false);
! insert into nt3 values (3,3,true);
! explain (costs off)
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Nested Loop
!          ->  Index Scan using nt3_pkey on nt3
!                Index Cond: (id = 1)
!          ->  Index Scan using nt2_pkey on nt2
!                Index Cond: (id = nt3.nt2_id)
!    ->  Index Only Scan using nt1_pkey on nt1
!          Index Cond: (id = nt2.nt1_id)
!          Filter: (nt2.b1 AND (id IS NOT NULL))
! (9 rows)
! 
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is propagated into a subquery
! --
! explain (costs off)
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Sort
!    Sort Key: t1.q1, t1.q2
!    ->  Hash Left Join
!          Hash Cond: (t1.q2 = t2.q1)
!          Filter: (1 = (SubPlan 1))
!          ->  Seq Scan on int8_tbl t1
!          ->  Hash
!                ->  Seq Scan on int8_tbl t2
!          SubPlan 1
!            ->  Limit
!                  ->  Result
!                        One-Time Filter: ((42) IS NOT NULL)
!                        ->  Seq Scan on int8_tbl t3
! (13 rows)
! 
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!         q1        |        q2        |        x         | y  
! ------------------+------------------+------------------+----
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
! (8 rows)
! 
! --
! -- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
! --
! select * from int4_tbl a full join int4_tbl b on true;
!      f1      |     f1      
! -------------+-------------
!            0 |           0
!            0 |      123456
!            0 |     -123456
!            0 |  2147483647
!            0 | -2147483647
!       123456 |           0
!       123456 |      123456
!       123456 |     -123456
!       123456 |  2147483647
!       123456 | -2147483647
!      -123456 |           0
!      -123456 |      123456
!      -123456 |     -123456
!      -123456 |  2147483647
!      -123456 | -2147483647
!   2147483647 |           0
!   2147483647 |      123456
!   2147483647 |     -123456
!   2147483647 |  2147483647
!   2147483647 | -2147483647
!  -2147483647 |           0
!  -2147483647 |      123456
!  -2147483647 |     -123456
!  -2147483647 |  2147483647
!  -2147483647 | -2147483647
! (25 rows)
! 
! select * from int4_tbl a full join int4_tbl b on false;
!      f1      |     f1      
! -------------+-------------
!              |           0
!              |      123456
!              |     -123456
!              |  2147483647
!              | -2147483647
!            0 |            
!       123456 |            
!      -123456 |            
!   2147483647 |            
!  -2147483647 |            
! (10 rows)
! 
! --
! -- test for ability to use a cartesian join when necessary
! --
! explain (costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where q1 = thousand or q2 = thousand;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Bitmap Heap Scan on tenk1
!                Recheck Cond: ((q1.q1 = thousand) OR (q2.q2 = thousand))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (q1.q1 = thousand)
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (q2.q2 = thousand)
!    ->  Hash
!          ->  Seq Scan on int4_tbl
! (15 rows)
! 
! explain (costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where thousand = (q1 + q2);
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Bitmap Heap Scan on tenk1
!                Recheck Cond: (thousand = (q1.q1 + q2.q2))
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: (thousand = (q1.q1 + q2.q2))
!    ->  Hash
!          ->  Seq Scan on int4_tbl
! (12 rows)
! 
! --
! -- test extraction of restriction OR clauses from join OR clause
! -- (we used to only do this for indexable clauses)
! --
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
!                                            QUERY PLAN                                            
! -------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))
!    ->  Bitmap Heap Scan on tenk1 b
!          Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on tenk1_unique1
!                      Index Cond: (unique1 = 2)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
! (17 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))
!    ->  Seq Scan on tenk1 b
!          Filter: ((unique1 = 2) OR (ten = 4))
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
! (12 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or
!   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
!                                                       QUERY PLAN                                                      
! ----------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))
!    ->  Bitmap Heap Scan on tenk1 b
!          Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on tenk1_unique1
!                      Index Cond: (unique1 = 2)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 7)
! (19 rows)
! 
! --
! -- test placement of movable quals in a parameterized join tree
! --
! explain (costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten = t3.ten
! where t1.unique1 = 1;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Nested Loop Left Join
!    ->  Index Scan using tenk1_unique1 on tenk1 t1
!          Index Cond: (unique1 = 1)
!    ->  Nested Loop
!          Join Filter: (t1.ten = t3.ten)
!          ->  Bitmap Heap Scan on tenk1 t2
!                Recheck Cond: (t1.hundred = hundred)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (t1.hundred = hundred)
!          ->  Index Scan using tenk1_unique2 on tenk1 t3
!                Index Cond: (unique2 = t2.thousand)
! (11 rows)
! 
! explain (costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
! where t1.unique1 = 1;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Nested Loop Left Join
!    ->  Index Scan using tenk1_unique1 on tenk1 t1
!          Index Cond: (unique1 = 1)
!    ->  Nested Loop
!          Join Filter: ((t1.ten + t2.ten) = t3.ten)
!          ->  Bitmap Heap Scan on tenk1 t2
!                Recheck Cond: (t1.hundred = hundred)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (t1.hundred = hundred)
!          ->  Index Scan using tenk1_unique2 on tenk1 t3
!                Index Cond: (unique2 = t2.thousand)
! (11 rows)
! 
! explain (costs off)
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Aggregate
!    ->  Nested Loop Left Join
!          Join Filter: (a.unique2 = b.unique1)
!          ->  Nested Loop
!                ->  Nested Loop
!                      ->  Seq Scan on int4_tbl
!                      ->  Bitmap Heap Scan on tenk1 b
!                            Recheck Cond: (thousand = int4_tbl.f1)
!                            ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                  Index Cond: (thousand = int4_tbl.f1)
!                ->  Index Scan using tenk1_unique1 on tenk1 a
!                      Index Cond: (unique1 = b.unique2)
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                Index Cond: (thousand = a.thousand)
! (14 rows)
! 
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!  count 
! -------
!     10
! (1 row)
! 
! explain (costs off)
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Sort
!    Sort Key: b.unique1
!    ->  Nested Loop Left Join
!          ->  Seq Scan on int4_tbl i2
!          ->  Nested Loop Left Join
!                Join Filter: (b.unique1 = 42)
!                ->  Nested Loop
!                      ->  Nested Loop
!                            ->  Seq Scan on int4_tbl i1
!                            ->  Index Scan using tenk1_thous_tenthous on tenk1 b
!                                  Index Cond: ((thousand = i1.f1) AND (i2.f1 = tenthous))
!                      ->  Index Scan using tenk1_unique1 on tenk1 a
!                            Index Cond: (unique1 = b.unique2)
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                      Index Cond: (thousand = a.thousand)
! (15 rows)
! 
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!  unique1 
! ---------
!        0
!         
!         
!         
!         
! (5 rows)
! 
! explain (costs off)
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: ((COALESCE(tenk1.unique1, (-1)) + int8_tbl.q1) = 122)
!    ->  Seq Scan on int8_tbl
!    ->  Index Scan using tenk1_unique2 on tenk1
!          Index Cond: (int8_tbl.q2 = unique2)
! (5 rows)
! 
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!  unique1 | q1  | fault 
! ---------+-----+-------
!          | 123 |   122
! (1 row)
! 
! --
! -- test handling of potential equivalence clauses above outer joins
! --
! explain (costs off)
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: ((COALESCE(b.thousand, 123) = a.q1) AND (a.q1 = COALESCE(b.hundred, 123)))
!    ->  Seq Scan on int8_tbl a
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (a.q1 = unique2)
! (5 rows)
! 
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!  q1 | unique2 | thousand | hundred 
! ----+---------+----------+---------
! (0 rows)
! 
! explain (costs off)
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: (CASE WHEN (b.unique2 IS NULL) THEN a.f1 ELSE 0 END = 0)
!    ->  Seq Scan on int4_tbl a
!    ->  Index Only Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = a.f1)
! (5 rows)
! 
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!  f1 | unique2 | case 
! ----+---------+------
!   0 |       0 |    0
! (1 row)
! 
! --
! -- another case with equivalence clauses above outer joins (bug #8591)
! --
! explain (costs off)
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 = 5530 and coalesce(b.twothousand, a.twothousand) = 44;
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Nested Loop Left Join
!    ->  Nested Loop Left Join
!          Filter: (COALESCE(b.twothousand, a.twothousand) = 44)
!          ->  Index Scan using tenk1_unique2 on tenk1 a
!                Index Cond: (unique2 = 5530)
!          ->  Bitmap Heap Scan on tenk1 b
!                Recheck Cond: (thousand = a.unique1)
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: (thousand = a.unique1)
!    ->  Index Scan using tenk1_unique2 on tenk1 c
!          Index Cond: ((unique2 = COALESCE(b.twothousand, a.twothousand)) AND (unique2 = 44))
! (11 rows)
! 
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 = 5530 and coalesce(b.twothousand, a.twothousand) = 44;
!  unique1 | unique1 | unique1 | coalesce 
! ---------+---------+---------+----------
! (0 rows)
! 
! --
! -- check handling of join aliases when flattening multiple levels of subquery
! --
! explain (verbose, costs off)
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Nested Loop Left Join
!    Output: "*VALUES*".column1, i1.f1, (666)
!    Join Filter: ("*VALUES*".column1 = i1.f1)
!    ->  Values Scan on "*VALUES*"
!          Output: "*VALUES*".column1
!    ->  Materialize
!          Output: i1.f1, (666)
!          ->  Nested Loop Left Join
!                Output: i1.f1, 666
!                ->  Seq Scan on public.int4_tbl i1
!                      Output: i1.f1
!                ->  Index Only Scan using tenk1_unique2 on public.tenk1 i2
!                      Output: i2.unique2
!                      Index Cond: (i2.unique2 = i1.f1)
! (14 rows)
! 
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!  foo1_id | foo3_id | bug_field 
! ---------+---------+-----------
!        0 |       0 |       666
!        1 |         |          
! (2 rows)
! 
! --
! -- test ability to push constants through outer join clauses
! --
! explain (costs off)
!   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop Left Join
!    Join Filter: (a.f1 = b.unique2)
!    ->  Seq Scan on int4_tbl a
!          Filter: (f1 = 0)
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = 0)
! (6 rows)
! 
! explain (costs off)
!   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Merge Full Join
!    Merge Cond: (a.unique2 = b.unique2)
!    ->  Index Scan using tenk1_unique2 on tenk1 a
!          Index Cond: (unique2 = 42)
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = 42)
! (6 rows)
! 
! --
! -- test join removal
! --
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
! CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
! CREATE TEMP TABLE c (id int PRIMARY KEY);
! CREATE TEMP TABLE d (a int, b int);
! INSERT INTO a VALUES (0, 0), (1, NULL);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! INSERT INTO c VALUES (0), (1);
! INSERT INTO d VALUES (1,3), (2,2), (3,1);
! -- all three cases should be optimizable into a simple seqscan
! explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on a
! (1 row)
! 
! explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on b
! (1 row)
! 
! explain (costs off)
!   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
!   ON (a.b_id = b.id);
!   QUERY PLAN   
! ---------------
!  Seq Scan on a
! (1 row)
! 
! -- check optimization of outer join within another special join
! explain (costs off)
! select id from a where id in (
! 	select b.id from b left join c on b.id = c.id
! );
!          QUERY PLAN         
! ----------------------------
!  Hash Semi Join
!    Hash Cond: (a.id = b.id)
!    ->  Seq Scan on a
!    ->  Hash
!          ->  Seq Scan on b
! (5 rows)
! 
! -- check that join removal works for a left join when joining a subquery
! -- that is guaranteed to be unique by its GROUP BY clause
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id and d.b = s.c_id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id and d.b = s.c_id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- join removal is not possible when the GROUP BY contains a column that is
! -- not in the join condition
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Merge Left Join
!    Merge Cond: (d.a = s.id)
!    ->  Sort
!          Sort Key: d.a
!          ->  Seq Scan on d
!    ->  Sort
!          Sort Key: s.id
!          ->  Subquery Scan on s
!                ->  HashAggregate
!                      Group Key: b.id, b.c_id
!                      ->  Seq Scan on b
! (11 rows)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Merge Left Join
!    Merge Cond: (d.a = s.id)
!    ->  Sort
!          Sort Key: d.a
!          ->  Seq Scan on d
!    ->  Sort
!          Sort Key: s.id
!          ->  Subquery Scan on s
!                ->  HashAggregate
!                      Group Key: b.id, b.c_id
!                      ->  Seq Scan on b
! (11 rows)
! 
! -- check join removal works when uniqueness of the join condition is enforced
! -- by a UNION
! explain (costs off)
! select d.* from d left join (select id from a union select id from b) s
!   on d.a = s.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- check join removal with a cross-type comparison operator
! explain (costs off)
! select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
!   on i8.q1 = i4.f1;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on int8_tbl i8
! (1 row)
! 
! rollback;
! create temp table parent (k int primary key, pd int);
! create temp table child (k int unique, cd int);
! insert into parent values (1, 10), (2, 20), (3, 30);
! insert into child values (1, 100), (4, 400);
! -- this case is optimizable
! select p.* from parent p left join child c on (p.k = c.k);
!  k | pd 
! ---+----
!  1 | 10
!  2 | 20
!  3 | 30
! (3 rows)
! 
! explain (costs off)
!   select p.* from parent p left join child c on (p.k = c.k);
!       QUERY PLAN      
! ----------------------
!  Seq Scan on parent p
! (1 row)
! 
! -- this case is not
! select p.*, linked from parent p
!   left join (select c.*, true as linked from child c) as ss
!   on (p.k = ss.k);
!  k | pd | linked 
! ---+----+--------
!  1 | 10 | t
!  2 | 20 | 
!  3 | 30 | 
! (3 rows)
! 
! explain (costs off)
!   select p.*, linked from parent p
!     left join (select c.*, true as linked from child c) as ss
!     on (p.k = ss.k);
!            QUERY PLAN            
! ---------------------------------
!  Hash Left Join
!    Hash Cond: (p.k = c.k)
!    ->  Seq Scan on parent p
!    ->  Hash
!          ->  Seq Scan on child c
! (5 rows)
! 
! -- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (costs off)
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Result
!    One-Time Filter: false
!    ->  Index Scan using parent_pkey on parent p
!          Index Cond: (k = 1)
! (4 rows)
! 
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (costs off)
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- bug 5255: this is not optimizable by join removal
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY);
! CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
! INSERT INTO a VALUES (0), (1);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id | id 
! ----+------+----
!   1 |      |   
! (1 row)
! 
! SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id 
! ----+------
!   1 |     
! (1 row)
! 
! rollback;
! -- another join removal bug: this is not optimizable, either
! begin;
! create temp table innertab (id int8 primary key, dat1 int8);
! insert into innertab values(123, 42);
! SELECT * FROM
!     (SELECT 1 AS x) ss1
!   LEFT JOIN
!     (SELECT q1, q2, COALESCE(dat1, q1) AS y
!      FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
!   ON true;
!  x |        q1        |        q2         |        y         
! ---+------------------+-------------------+------------------
!  1 |              123 |               456 |              123
!  1 |              123 |  4567890123456789 |              123
!  1 | 4567890123456789 |               123 |               42
!  1 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  1 | 4567890123456789 | -4567890123456789 | 4567890123456789
! (5 rows)
! 
! rollback;
! -- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error
! ERROR:  column reference "f1" is ambiguous
! LINE 2: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
!                                                                     ^
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error
! ERROR:  invalid reference to FROM-clause entry for table "y"
! LINE 2: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
!                                                                   ^
! HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok
!  q1 | q2 | f1 | ff 
! ----+----+----+----
! (0 rows)
! 
! --
! -- Test LATERAL
! --
! select unique2, x.*
! from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl b
!    ->  Index Scan using tenk1_unique1 on tenk1 a
!          Index Cond: (unique1 = b.f1)
! (4 rows)
! 
! select unique2, x.*
! from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (unique1 = x.f1)
! (4 rows)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (unique1 = x.f1)
! (4 rows)
! 
! select unique2, x.*
! from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
!  unique2 |     f1      
! ---------+-------------
!     9998 |           0
!          |      123456
!          |     -123456
!          |  2147483647
!          | -2147483647
! (5 rows)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop Left Join
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (x.f1 = unique1)
! (4 rows)
! 
! -- check scoping of lateral versus parent references
! -- the first of these should return int8_tbl.q2, the second int8_tbl.q1
! select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |         r         
! ------------------+-------------------+-------------------
!               123 |               456 |               456
!               123 |  4567890123456789 |  4567890123456789
!  4567890123456789 |               123 |               123
!  4567890123456789 |  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789 | -4567890123456789
! (5 rows)
! 
! select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |        r         
! ------------------+-------------------+------------------
!               123 |               456 |              123
!               123 |  4567890123456789 |              123
!  4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789
! (5 rows)
! 
! -- lateral with function in FROM
! select count(*) from tenk1 a, lateral generate_series(1,two) g;
!  count 
! -------
!   5000
! (1 row)
! 
! explain (costs off)
!   select count(*) from tenk1 a, lateral generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! explain (costs off)
!   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! -- don't need the explicit LATERAL keyword for functions
! explain (costs off)
!   select count(*) from tenk1 a, generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! -- lateral with UNION ALL subselect
! explain (costs off)
!   select * from generate_series(100,200) g,
!     lateral (select * from int8_tbl a where g = q1 union all
!              select * from int8_tbl b where g = q2) ss;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop
!    ->  Function Scan on generate_series g
!    ->  Append
!          ->  Seq Scan on int8_tbl a
!                Filter: (g.g = q1)
!          ->  Seq Scan on int8_tbl b
!                Filter: (g.g = q2)
! (7 rows)
! 
! select * from generate_series(100,200) g,
!   lateral (select * from int8_tbl a where g = q1 union all
!            select * from int8_tbl b where g = q2) ss;
!   g  |        q1        |        q2        
! -----+------------------+------------------
!  123 |              123 |              456
!  123 |              123 | 4567890123456789
!  123 | 4567890123456789 |              123
! (3 rows)
! 
! -- lateral with VALUES
! explain (costs off)
!   select count(*) from tenk1 a,
!     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Aggregate
!    ->  Hash Join
!          Hash Cond: ("*VALUES*".column1 = b.unique2)
!          ->  Nested Loop
!                ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                ->  Values Scan on "*VALUES*"
!          ->  Hash
!                ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (8 rows)
! 
! select count(*) from tenk1 a,
!   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!  count 
! -------
!  10000
! (1 row)
! 
! -- lateral injecting a strange outer join condition
! explain (costs off)
!   select * from int8_tbl a,
!     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!       on x.q2 = ss.z;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int8_tbl a
!    ->  Hash Left Join
!          Hash Cond: (x.q2 = (a.q1))
!          ->  Seq Scan on int8_tbl x
!          ->  Hash
!                ->  Seq Scan on int4_tbl y
! (7 rows)
! 
! select * from int8_tbl a,
!   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!     on x.q2 = ss.z;
!         q1        |        q2         |        q1        |        q2         |        z         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |              123 |               456 |                 
!               123 |               456 |              123 |  4567890123456789 |                 
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |  4567890123456789 |                 
!               123 |               456 | 4567890123456789 | -4567890123456789 |                 
!               123 |  4567890123456789 |              123 |               456 |                 
!               123 |  4567890123456789 |              123 |  4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |               123 |              123 |               456 |                 
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |               123 |                 
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |  4567890123456789 |              123 |               456 |                 
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 | -4567890123456789 |              123 |               456 |                 
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789 |                 
! (57 rows)
! 
! -- lateral reference to a join alias variable
! select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (values(x)) ss2(y);
!       x      |     f1      |      y      
! -------------+-------------+-------------
!            0 |           0 |           0
!       123456 |      123456 |      123456
!      -123456 |     -123456 |     -123456
!   2147483647 |  2147483647 |  2147483647
!  -2147483647 | -2147483647 | -2147483647
! (5 rows)
! 
! select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! -- lateral references requiring pullup
! select * from (values(1)) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   1 |  1
!   1 |  2
!   1 |  3
!   1 |  4
! (4 rows)
! 
! select * from (select f1/1000000000 from int4_tbl) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   2 |  2
!   2 |  3
!   2 |  4
!  -2 | -2
!  -2 | -1
!  -2 |  0
!  -2 |  1
!  -2 |  2
!  -2 |  3
!  -2 |  4
! (25 rows)
! 
! select * from (values(1)) x(lb),
!   lateral (values(lb)) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
! (1 row)
! 
! select * from (values(1)) x(lb),
!   lateral (select lb from int4_tbl) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
! (5 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select x.* from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!               123 |  4567890123456789
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (10 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! create temp table dual();
! insert into dual default values;
! analyze dual;
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 from dual union all select x.q2,y.q2 from dual) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Seq Scan on public.int8_tbl b
!          Output: b.q1, b.q2, a.q2
!          Filter: (a.q2 = b.q1)
! (7 rows)
! 
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join
!   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, b.q2, (COALESCE(a.q2, 42::bigint))
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Seq Scan on public.int8_tbl b
!          Output: b.q1, b.q2, COALESCE(a.q2, 42::bigint)
!          Filter: (a.q2 = b.q1)
! (7 rows)
! 
! select * from
!   int8_tbl a left join
!   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! -- lateral can result in join conditions appearing below their
! -- real semantic level
! explain (verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
!                 QUERY PLAN                 
! -------------------------------------------
!  Hash Left Join
!    Output: i.f1, j.f1
!    Hash Cond: (i.f1 = j.f1)
!    ->  Seq Scan on public.int4_tbl i
!          Output: i.f1
!    ->  Hash
!          Output: j.f1
!          ->  Seq Scan on public.int2_tbl j
!                Output: j.f1
! (9 rows)
! 
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
!      f1      | f1 
! -------------+----
!            0 |  0
!       123456 |   
!      -123456 |   
!   2147483647 |   
!  -2147483647 |   
! (5 rows)
! 
! explain (verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
!              QUERY PLAN              
! -------------------------------------
!  Nested Loop Left Join
!    Output: i.f1, (COALESCE(i.*))
!    ->  Seq Scan on public.int4_tbl i
!          Output: i.f1, i.*
!    ->  Seq Scan on public.int2_tbl j
!          Output: j.f1, COALESCE(i.*)
!          Filter: (i.f1 = j.f1)
! (7 rows)
! 
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
!      f1      | coalesce 
! -------------+----------
!            0 | (0)
!       123456 | 
!      -123456 | 
!   2147483647 | 
!  -2147483647 | 
! (5 rows)
! 
! explain (verbose, costs off)
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    Output: a.f1, b.f1, c.q1, c.q2
!    ->  Seq Scan on public.int4_tbl a
!          Output: a.f1
!    ->  Hash Left Join
!          Output: b.f1, c.q1, c.q2
!          Hash Cond: (b.f1 = c.q1)
!          ->  Seq Scan on public.int4_tbl b
!                Output: b.f1
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!                      Filter: (a.f1 = c.q2)
! (14 rows)
! 
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!      f1      |     f1      | q1 | q2 
! -------------+-------------+----+----
!            0 |           0 |    |   
!            0 |      123456 |    |   
!            0 |     -123456 |    |   
!            0 |  2147483647 |    |   
!            0 | -2147483647 |    |   
!       123456 |           0 |    |   
!       123456 |      123456 |    |   
!       123456 |     -123456 |    |   
!       123456 |  2147483647 |    |   
!       123456 | -2147483647 |    |   
!      -123456 |           0 |    |   
!      -123456 |      123456 |    |   
!      -123456 |     -123456 |    |   
!      -123456 |  2147483647 |    |   
!      -123456 | -2147483647 |    |   
!   2147483647 |           0 |    |   
!   2147483647 |      123456 |    |   
!   2147483647 |     -123456 |    |   
!   2147483647 |  2147483647 |    |   
!   2147483647 | -2147483647 |    |   
!  -2147483647 |           0 |    |   
!  -2147483647 |      123456 |    |   
!  -2147483647 |     -123456 |    |   
!  -2147483647 |  2147483647 |    |   
!  -2147483647 | -2147483647 |    |   
! (25 rows)
! 
! -- lateral reference in a PlaceHolderVar evaluated at join level
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, c.q1, (LEAST(a.q1, b.q1, c.q1))
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Nested Loop
!          Output: b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)
!          Join Filter: (a.q2 = b.q1)
!          ->  Seq Scan on public.int8_tbl b
!                Output: b.q1, b.q2
!          ->  Materialize
!                Output: c.q1
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1
! (13 rows)
! 
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!         q1        |        q2         |       bq1        |       cq1        |      least       
! ------------------+-------------------+------------------+------------------+------------------
!               123 |               456 |                  |                  |                 
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                  |                 
! (42 rows)
! 
! -- case requiring nested PlaceHolderVars
! explain (verbose, costs off)
! select * from
!   int8_tbl c left join (
!     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select ss2.y) ss3;
!                                                                                   QUERY PLAN                                                                                  
! ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, 42::bigint)), d.q1, (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)))
!    ->  Hash Right Join
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, 42::bigint)), (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
!          Hash Cond: (d.q1 = c.q2)
!          ->  Nested Loop
!                Output: a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, 42::bigint)), (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
!                ->  Hash Left Join
!                      Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, 42::bigint))
!                      Hash Cond: (a.q2 = b.q1)
!                      ->  Seq Scan on public.int8_tbl a
!                            Output: a.q1, a.q2
!                      ->  Hash
!                            Output: b.q1, (COALESCE(b.q2, 42::bigint))
!                            ->  Seq Scan on public.int8_tbl b
!                                  Output: b.q1, COALESCE(b.q2, 42::bigint)
!                ->  Seq Scan on public.int8_tbl d
!                      Output: d.q1, COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!    ->  Result
!          Output: (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
! (24 rows)
! 
! -- case that breaks the old ph_may_need optimization
! explain (verbose, costs off)
! select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
!   int8_tbl c left join (
!     int8_tbl a left join
!       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
!        where q1 < f1) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select * from int4_tbl i where ss2.y > f1) ss3;
!                                                QUERY PLAN                                                
! ---------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
!    Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
!    ->  Hash Right Join
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!          Hash Cond: (d.q1 = c.q2)
!          ->  Nested Loop
!                Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!                ->  Hash Right Join
!                      Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
!                      Hash Cond: (b.q1 = a.q2)
!                      ->  Nested Loop
!                            Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
!                            Join Filter: (b.q1 < b2.f1)
!                            ->  Seq Scan on public.int8_tbl b
!                                  Output: b.q1, b.q2
!                            ->  Materialize
!                                  Output: b2.f1
!                                  ->  Seq Scan on public.int4_tbl b2
!                                        Output: b2.f1
!                      ->  Hash
!                            Output: a.q1, a.q2
!                            ->  Seq Scan on public.int8_tbl a
!                                  Output: a.q1, a.q2
!                ->  Seq Scan on public.int8_tbl d
!                      Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!    ->  Materialize
!          Output: i.f1
!          ->  Seq Scan on public.int4_tbl i
!                Output: i.f1
! (34 rows)
! 
! -- check processing of postponed quals (bug #9041)
! explain (verbose, costs off)
! select * from
!   (select 1 as x) x cross join (select 2 as y) y
!   left join lateral (
!     select * from (select 3 as z) z where z.z = x.x
!   ) zz on zz.z = y.y;
!                   QUERY PLAN                  
! ----------------------------------------------
!  Nested Loop Left Join
!    Output: (1), (2), (3)
!    Join Filter: (((3) = (1)) AND ((3) = (2)))
!    ->  Nested Loop
!          Output: (1), (2)
!          ->  Result
!                Output: 1
!          ->  Result
!                Output: 2
!    ->  Result
!          Output: 3
! (11 rows)
! 
! -- test some error cases where LATERAL should have been used but wasn't
! select f1,g from int4_tbl a, (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a, (select f1 as g) ss;
!                                              ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a, (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a, (select a.f1 as g) ss;
!                                              ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a cross join (select f1 as g) ss;
!                                                        ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
!                                                        ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! -- SQL:2008 says the left table is in scope but illegal to access here
! select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! -- check we complain about ambiguous table references
! select * from
!   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
! ERROR:  table reference "x" is ambiguous
! LINE 2: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
!                                                              ^
! -- LATERAL can be used to put an aggregate into the FROM clause of its query
! select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
! ERROR:  aggregate functions are not allowed in FROM clause of their own query level
! LINE 1: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
!                                                ^
! -- check behavior of LATERAL in UPDATE/DELETE
! create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
! -- error, can't do this:
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- can't do it even with LATERAL:
! update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- we might in future allow something like this, but for now it's an error:
! update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  table name "xx1" specified more than once
! -- also errors:
! delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/aggregates.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/aggregates.out	2015-01-10 10:11:46.303649454 +0300
***************
*** 1,1582 ****
! --
! -- AGGREGATES
! --
! SELECT avg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
!        avg_32        
! ---------------------
!  32.6666666666666667
! (1 row)
! 
! -- In 7.1, avg(float4) is computed using float8 arithmetic.
! -- Round the result to 3 digits to avoid platform-specific results.
! SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
!  avg_107_943 
! -------------
!      107.943
! (1 row)
! 
! SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
!  avg_3_4 
! ---------
!      3.4
! (1 row)
! 
! SELECT sum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT sum(a) AS sum_198 FROM aggtest;
!  sum_198 
! ---------
!      198
! (1 row)
! 
! SELECT sum(b) AS avg_431_773 FROM aggtest;
!  avg_431_773 
! -------------
!      431.773
! (1 row)
! 
! SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
!  avg_6_8 
! ---------
!      6.8
! (1 row)
! 
! SELECT max(four) AS max_3 FROM onek;
!  max_3 
! -------
!      3
! (1 row)
! 
! SELECT max(a) AS max_100 FROM aggtest;
!  max_100 
! ---------
!      100
! (1 row)
! 
! SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
!  max_324_78 
! ------------
!      324.78
! (1 row)
! 
! SELECT max(student.gpa) AS max_3_7 FROM student;
!  max_3_7 
! ---------
!      3.7
! (1 row)
! 
! SELECT stddev_pop(b) FROM aggtest;
!    stddev_pop    
! -----------------
!  131.10703231895
! (1 row)
! 
! SELECT stddev_samp(b) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389360803998
! (1 row)
! 
! SELECT var_pop(b) FROM aggtest;
!      var_pop      
! ------------------
!  17189.0539234823
! (1 row)
! 
! SELECT var_samp(b) FROM aggtest;
!      var_samp     
! ------------------
!  22918.7385646431
! (1 row)
! 
! SELECT stddev_pop(b::numeric) FROM aggtest;
!     stddev_pop    
! ------------------
!  131.107032862199
! (1 row)
! 
! SELECT stddev_samp(b::numeric) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389361431288
! (1 row)
! 
! SELECT var_pop(b::numeric) FROM aggtest;
!       var_pop       
! --------------------
!  17189.054065929769
! (1 row)
! 
! SELECT var_samp(b::numeric) FROM aggtest;
!       var_samp      
! --------------------
!  22918.738754573025
! (1 row)
! 
! -- population variance is defined for a single tuple, sample variance
! -- is not
! SELECT var_pop(1.0), var_samp(2.0);
!  var_pop | var_samp 
! ---------+----------
!        0 |         
! (1 row)
! 
! SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
!  stddev_pop | stddev_samp 
! ------------+-------------
!           0 |            
! (1 row)
! 
! -- verify correct results for null and NaN inputs
! select sum(null::int4) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::int8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::numeric) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::float8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select avg(null::int4) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::int8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::numeric) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::float8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select sum('NaN'::numeric) from generate_series(1,3);
!  sum 
! -----
!  NaN
! (1 row)
! 
! select avg('NaN'::numeric) from generate_series(1,3);
!  avg 
! -----
!  NaN
! (1 row)
! 
! -- SQL2003 binary aggregates
! SELECT regr_count(b, a) FROM aggtest;
!  regr_count 
! ------------
!           4
! (1 row)
! 
! SELECT regr_sxx(b, a) FROM aggtest;
!  regr_sxx 
! ----------
!      5099
! (1 row)
! 
! SELECT regr_syy(b, a) FROM aggtest;
!      regr_syy     
! ------------------
!  68756.2156939293
! (1 row)
! 
! SELECT regr_sxy(b, a) FROM aggtest;
!      regr_sxy     
! ------------------
!  2614.51582155004
! (1 row)
! 
! SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
!  regr_avgx |    regr_avgy     
! -----------+------------------
!       49.5 | 107.943152273074
! (1 row)
! 
! SELECT regr_r2(b, a) FROM aggtest;
!       regr_r2       
! --------------------
!  0.0194977982031803
! (1 row)
! 
! SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
!     regr_slope     |  regr_intercept  
! -------------------+------------------
!  0.512750700441271 | 82.5619926012309
! (1 row)
! 
! SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
!     covar_pop    |    covar_samp    
! -----------------+------------------
!  653.62895538751 | 871.505273850014
! (1 row)
! 
! SELECT corr(b, a) FROM aggtest;
!        corr        
! -------------------
!  0.139634516517873
! (1 row)
! 
! SELECT count(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT count(DISTINCT four) AS cnt_4 FROM onek;
!  cnt_4 
! -------
!      4
! (1 row)
! 
! select ten, count(*), sum(four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 | 100
!    1 |   100 | 200
!    2 |   100 | 100
!    3 |   100 | 200
!    4 |   100 | 100
!    5 |   100 | 200
!    6 |   100 | 100
!    7 |   100 | 200
!    8 |   100 | 100
!    9 |   100 | 200
! (10 rows)
! 
! select ten, count(four), sum(DISTINCT four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 |   2
!    1 |   100 |   4
!    2 |   100 |   2
!    3 |   100 |   4
!    4 |   100 |   2
!    5 |   100 |   4
!    6 |   100 |   2
!    7 |   100 |   4
!    8 |   100 |   2
!    9 |   100 |   4
! (10 rows)
! 
! -- user-defined aggregates
! SELECT newavg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT newsum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT newcnt(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT newcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT oldcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT sum2(q1,q2) FROM int8_tbl;
!        sum2        
! -------------------
!  18271560493827981
! (1 row)
! 
! -- test for outer-level aggregates
! -- this should work
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four);
!  ten | sum 
! -----+-----
!    0 |   2
!    2 |   2
!    4 |   2
!    6 |   2
!    8 |   2
! (5 rows)
! 
! -- this should fail because subquery has an agg of its own in WHERE
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b
!                where sum(distinct a.four + b.four) = b.four);
! ERROR:  aggregate functions are not allowed in WHERE
! LINE 4:                where sum(distinct a.four + b.four) = b.four)...
!                              ^
! -- Test handling of sublinks within outer-level aggregates.
! -- Per bug report from Daniel Grace.
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
! from tenk1 o;
!  max  
! ------
!  9999
! (1 row)
! 
! --
! -- test for bitwise integer aggregates
! --
! CREATE TEMPORARY TABLE bitwise_test(
!   i2 INT2,
!   i4 INT4,
!   i8 INT8,
!   i INTEGER,
!   x INT2,
!   y BIT(4)
! );
! -- empty case
! SELECT
!   BIT_AND(i2) AS "?",
!   BIT_OR(i4)  AS "?"
! FROM bitwise_test;
!  ? | ? 
! ---+---
!    |  
! (1 row)
! 
! COPY bitwise_test FROM STDIN NULL 'null';
! SELECT
!   BIT_AND(i2) AS "1",
!   BIT_AND(i4) AS "1",
!   BIT_AND(i8) AS "1",
!   BIT_AND(i)  AS "?",
!   BIT_AND(x)  AS "0",
!   BIT_AND(y)  AS "0100",
!   BIT_OR(i2)  AS "7",
!   BIT_OR(i4)  AS "7",
!   BIT_OR(i8)  AS "7",
!   BIT_OR(i)   AS "?",
!   BIT_OR(x)   AS "7",
!   BIT_OR(y)   AS "1101"
! FROM bitwise_test;
!  1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 
! ---+---+---+---+---+------+---+---+---+---+---+------
!  1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101
! (1 row)
! 
! --
! -- test boolean aggregates
! --
! -- first test all possible transition and final states
! SELECT
!   -- boolean and transitions
!   -- null because strict
!   booland_statefunc(NULL, NULL)  IS NULL AS "t",
!   booland_statefunc(TRUE, NULL)  IS NULL AS "t",
!   booland_statefunc(FALSE, NULL) IS NULL AS "t",
!   booland_statefunc(NULL, TRUE)  IS NULL AS "t",
!   booland_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- and actual computations
!   booland_statefunc(TRUE, TRUE) AS "t",
!   NOT booland_statefunc(TRUE, FALSE) AS "t",
!   NOT booland_statefunc(FALSE, TRUE) AS "t",
!   NOT booland_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! SELECT
!   -- boolean or transitions
!   -- null because strict
!   boolor_statefunc(NULL, NULL)  IS NULL AS "t",
!   boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
!   boolor_statefunc(FALSE, NULL) IS NULL AS "t",
!   boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
!   boolor_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- actual computations
!   boolor_statefunc(TRUE, TRUE) AS "t",
!   boolor_statefunc(TRUE, FALSE) AS "t",
!   boolor_statefunc(FALSE, TRUE) AS "t",
!   NOT boolor_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! CREATE TEMPORARY TABLE bool_test(
!   b1 BOOL,
!   b2 BOOL,
!   b3 BOOL,
!   b4 BOOL);
! -- empty case
! SELECT
!   BOOL_AND(b1)   AS "n",
!   BOOL_OR(b3)    AS "n"
! FROM bool_test;
!  n | n 
! ---+---
!    | 
! (1 row)
! 
! COPY bool_test FROM STDIN NULL 'null';
! SELECT
!   BOOL_AND(b1)     AS "f",
!   BOOL_AND(b2)     AS "t",
!   BOOL_AND(b3)     AS "f",
!   BOOL_AND(b4)     AS "n",
!   BOOL_AND(NOT b2) AS "f",
!   BOOL_AND(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   EVERY(b1)     AS "f",
!   EVERY(b2)     AS "t",
!   EVERY(b3)     AS "f",
!   EVERY(b4)     AS "n",
!   EVERY(NOT b2) AS "f",
!   EVERY(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   BOOL_OR(b1)      AS "t",
!   BOOL_OR(b2)      AS "t",
!   BOOL_OR(b3)      AS "f",
!   BOOL_OR(b4)      AS "n",
!   BOOL_OR(NOT b2)  AS "f",
!   BOOL_OR(NOT b3)  AS "t"
! FROM bool_test;
!  t | t | f | n | f | t 
! ---+---+---+---+---+---
!  t | t | f |   | f | t
! (1 row)
! 
! --
! -- Test cases that should be optimized into indexscans instead of
! -- the generic aggregate implementation.
! --
! -- Basic cases
! explain (costs off)
!   select min(unique1) from tenk1;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan using tenk1_unique1 on tenk1
!                  Index Cond: (unique1 IS NOT NULL)
! (5 rows)
! 
! select min(unique1) from tenk1;
!  min 
! -----
!    0
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: (unique1 IS NOT NULL)
! (5 rows)
! 
! select max(unique1) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 < 42;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 < 42;
!  max 
! -----
!   41
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 > 42;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 > 42000;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42000;
!  max 
! -----
!     
! (1 row)
! 
! -- multi-column index (uses tenk1_thous_tenthous)
! explain (costs off)
!   select max(tenthous) from tenk1 where thousand = 33;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
!                  Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (5 rows)
! 
! select max(tenthous) from tenk1 where thousand = 33;
!  max  
! ------
!  9033
! (1 row)
! 
! explain (costs off)
!   select min(tenthous) from tenk1 where thousand = 33;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                  Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (5 rows)
! 
! select min(tenthous) from tenk1 where thousand = 33;
!  min 
! -----
!   33
! (1 row)
! 
! -- check parameter propagation into an indexscan subquery
! explain (costs off)
!   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
!     from int4_tbl;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Seq Scan on int4_tbl
!    SubPlan 2
!      ->  Result
!            InitPlan 1 (returns $1)
!              ->  Limit
!                    ->  Index Only Scan using tenk1_unique1 on tenk1
!                          Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
! (7 rows)
! 
! select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
!   from int4_tbl;
!      f1      | gt 
! -------------+----
!            0 |  1
!       123456 |   
!      -123456 |  0
!   2147483647 |   
!  -2147483647 |  0
! (5 rows)
! 
! -- check some cases that were handled incorrectly in 8.3.0
! explain (costs off)
!   select distinct max(unique2) from tenk1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  HashAggregate
!    Group Key: $0
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select distinct max(unique2) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by 1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by 1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by max(unique2);
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by max(unique2);
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by max(unique2)+1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: (($0 + 1))
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by max(unique2)+1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: (generate_series(1, 3))
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!  max  | g 
! ------+---
!  9999 | 3
!  9999 | 2
!  9999 | 1
! (3 rows)
! 
! -- try it on an inheritance tree
! create table minmaxtest(f1 int);
! create table minmaxtest1() inherits (minmaxtest);
! create table minmaxtest2() inherits (minmaxtest);
! create table minmaxtest3() inherits (minmaxtest);
! create index minmaxtesti on minmaxtest(f1);
! create index minmaxtest1i on minmaxtest1(f1);
! create index minmaxtest2i on minmaxtest2(f1 desc);
! create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
! insert into minmaxtest values(11), (12);
! insert into minmaxtest1 values(13), (14);
! insert into minmaxtest2 values(15), (16);
! insert into minmaxtest3 values(17), (18);
! explain (costs off)
!   select min(f1), max(f1) from minmaxtest;
!                                           QUERY PLAN                                          
! ----------------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest.f1
!                  ->  Index Only Scan using minmaxtesti on minmaxtest
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest1i on minmaxtest1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest3i on minmaxtest3
!                        Index Cond: (f1 IS NOT NULL)
!    InitPlan 2 (returns $1)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest_1.f1
!                  ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
!                        Index Cond: (f1 IS NOT NULL)
! (25 rows)
! 
! select min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! -- DISTINCT doesn't do anything useful here, but it shouldn't fail
! explain (costs off)
!   select distinct min(f1), max(f1) from minmaxtest;
!                                           QUERY PLAN                                          
! ----------------------------------------------------------------------------------------------
!  HashAggregate
!    Group Key: $0, $1
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest.f1
!                  ->  Index Only Scan using minmaxtesti on minmaxtest
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest1i on minmaxtest1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest3i on minmaxtest3
!                        Index Cond: (f1 IS NOT NULL)
!    InitPlan 2 (returns $1)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest_1.f1
!                  ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
!                        Index Cond: (f1 IS NOT NULL)
!    ->  Result
! (27 rows)
! 
! select distinct min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! drop table minmaxtest cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table minmaxtest1
! drop cascades to table minmaxtest2
! drop cascades to table minmaxtest3
! -- check for correct detection of nested-aggregate errors
! select max(min(unique1)) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select max(min(unique1)) from tenk1;
!                    ^
! select (select max(min(unique1)) from int8_tbl) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
!                            ^
! --
! -- Test combinations of DISTINCT and/or ORDER BY
! --
! select array_agg(a order by b)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {3,4,2,1}
! (1 row)
! 
! select array_agg(a order by a)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! select array_agg(a order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {4,3,2,1}
! (1 row)
! 
! select array_agg(b order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {2,1,3,4}
! (1 row)
! 
! select array_agg(distinct a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a desc)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {NULL,3,2,1}
! (1 row)
! 
! select array_agg(distinct a order by a desc nulls last)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {3,2,1,NULL}
! (1 row)
! 
! -- multi-arg aggs, strict/nonstrict, distinct/order by
! select aggfstr(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! -- test specific code paths
! select aggfns(distinct a,a,c order by c using ~<~,a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by c using ~<~)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by a,c using ~<~,b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- check node I/O via view creation and usage, also deparsing logic
! create view agg_view1 as
!   select aggfns(a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c) AS aggfns                                                                            +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by b+1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY (v.b + 1)) AS aggfns                                                         +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,a,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                      aggfns                     
! ------------------------------------------------
!  {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.a, v.c ORDER BY v.b) AS aggfns                                                               +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by c using ~<~)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY v.c USING ~<~ NULLS LAST) AS aggfns                                          +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by a,c using ~<~,b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,2) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 2) i(i);
! (1 row)
! 
! drop view agg_view1;
! -- incorrect DISTINCT usage errors
! select aggfns(distinct a,b,c order by i)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by i)
!                                               ^
! select aggfns(distinct a,b,c order by a,b+1)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b+1)
!                                                 ^
! select aggfns(distinct a,b,c order by a,b,i,c)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
!                                                   ^
! select aggfns(distinct a,a,c order by a,b)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,a,c order by a,b)
!                                                 ^
! -- string_agg tests
! select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
!  string_agg 
! ------------
!  bbbbABcccc
! (1 row)
! 
! select string_agg(a,',') from (values(null),(null)) g(a);
!  string_agg 
! ------------
!  
! (1 row)
! 
! -- check some implicit casting cases, as per bug #5564
! select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
!                                                           ^
! select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
!                                                     ^
! select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! -- string_agg bytea tests
! create table bytea_test_table(v bytea);
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  
! (1 row)
! 
! insert into bytea_test_table values(decode('ff','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xff
! (1 row)
! 
! insert into bytea_test_table values(decode('aa','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, NULL) from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
!  string_agg 
! ------------
!  \xffeeaa
! (1 row)
! 
! drop table bytea_test_table;
! -- FILTER tests
! select min(unique1) filter (where unique1 > 100) from tenk1;
!  min 
! -----
!  101
! (1 row)
! 
! select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
! group by ten;
!  ten | sum 
! -----+-----
!    0 |    
!    1 |    
!    2 |    
!    3 |    
!    4 |    
!    5 |    
!    6 |    
!    7 |    
!    8 |    
!    9 |    
! (10 rows)
! 
! select ten, sum(distinct four) filter (where four > 10) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four);
!  ten | sum 
! -----+-----
!    0 |    
!    2 |    
!    4 |    
!    6 |    
!    8 |    
! (5 rows)
! 
! select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
! from (values ('a', 'b')) AS v(foo,bar);
!  max 
! -----
!  a
! (1 row)
! 
! -- outer reference in FILTER (PostgreSQL extension)
! select (select count(*)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select (select count(*) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
!  count 
! -------
!      2
! (1 row)
! 
! select (select count(inner_c) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
!      filter (where o.unique1 < 10))
! from tenk1 o;					-- outer query is aggregation query
!  max  
! ------
!  9998
! (1 row)
! 
! -- subquery in FILTER clause (PostgreSQL extension)
! select sum(unique1) FILTER (WHERE
!   unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
!  sum  
! ------
!  4950
! (1 row)
! 
! -- exercise lots of aggregate parts with FILTER
! select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!     generate_series(1,2) i;
!           aggfns           
! ---------------------------
!  {"(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- ordered-set aggregates
! select p, percentile_cont(p) within group (order by x::float8)
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
!   p   | percentile_cont 
! ------+-----------------
!     0 |               1
!   0.1 |             1.4
!  0.25 |               2
!   0.4 |             2.6
!   0.5 |               3
!   0.6 |             3.4
!  0.75 |               4
!   0.9 |             4.6
!     1 |               5
! (9 rows)
! 
! select p, percentile_cont(p order by p) within group (order by x)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
! LINE 1: select p, percentile_cont(p order by p) within group (order ...
!                                                 ^
! select p, sum() within group (order by x::float8)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
! LINE 1: select p, sum() within group (order by x::float8)  
!                   ^
! select p, percentile_cont(p,p)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
! LINE 1: select p, percentile_cont(p,p)  
!                   ^
! select percentile_cont(0.5) within group (order by b) from aggtest;
!  percentile_cont  
! ------------------
!  53.4485001564026
! (1 row)
! 
! select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
!  percentile_cont  |   sum   
! ------------------+---------
!  53.4485001564026 | 431.773
! (1 row)
! 
! select percentile_cont(0.5) within group (order by thousand) from tenk1;
!  percentile_cont 
! -----------------
!            499.5
! (1 row)
! 
! select percentile_disc(0.5) within group (order by thousand) from tenk1;
!  percentile_disc 
! -----------------
!              499
! (1 row)
! 
! select rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  rank 
! ------
!     5
! (1 row)
! 
! select cume_dist(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  cume_dist 
! -----------
!      0.875
! (1 row)
! 
! select percent_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
!  percent_rank 
! --------------
!           0.5
! (1 row)
! 
! select dense_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  dense_rank 
! ------------
!           3
! (1 row)
! 
! select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
! from tenk1;
!       percentile_disc       
! ----------------------------
!  {0,99,249,499,749,899,999}
! (1 row)
! 
! select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
! from tenk1;
!        percentile_cont       
! -----------------------------
!  {0,249.75,499.5,749.25,999}
! (1 row)
! 
! select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
! from tenk1;
!          percentile_disc         
! ---------------------------------
!  {{NULL,999,499},{749,249,NULL}}
! (1 row)
! 
! select percentile_cont(array[0,1,0.25,0.75,0.5,1]) within group (order by x)
! from generate_series(1,6) x;
!     percentile_cont    
! -----------------------
!  {1,6,2.25,4.75,3.5,6}
! (1 row)
! 
! select ten, mode() within group (order by string4) from tenk1 group by ten;
!  ten |  mode  
! -----+--------
!    0 | HHHHxx
!    1 | OOOOxx
!    2 | VVVVxx
!    3 | OOOOxx
!    4 | HHHHxx
!    5 | HHHHxx
!    6 | OOOOxx
!    7 | AAAAxx
!    8 | VVVVxx
!    9 | VVVVxx
! (10 rows)
! 
! select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
! from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
!  percentile_disc 
! -----------------
!  {fred,jill,jim}
! (1 row)
! 
! -- check collation propagates up in suitable cases:
! select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
!   from (values ('fred'),('jim')) v(x);
!  pg_collation_for 
! ------------------
!  "POSIX"
! (1 row)
! 
! -- ordered-set aggs created with CREATE AGGREGATE
! select test_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  test_rank 
! -----------
!          5
! (1 row)
! 
! select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
!  test_percentile_disc 
! ----------------------
!                   499
! (1 row)
! 
! -- ordered-set aggs can't use ungrouped vars in direct args:
! select rank(x) within group (order by x) from generate_series(1,5) x;
! ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: select rank(x) within group (order by x) from generate_serie...
!                     ^
! DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
! -- outer-level agg can't use a grouped arg of a lower level, either:
! select array(select percentile_disc(a) within group (order by x)
!                from (values (0.3),(0.7)) v(a) group by a)
!   from generate_series(1,5) g(x);
! ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
! LINE 1: select array(select percentile_disc(a) within group (order b...
!                                             ^
! -- agg in the direct args is a grouping violation, too:
! select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select rank(sum(x)) within group (order by x) from generate_...
!                     ^
! -- hypothetical-set type unification and argument-count failures:
! select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
! ERROR:  WITHIN GROUP types text and integer cannot be matched
! LINE 1: select rank(3) within group (order by x) from (values ('fred...
!                     ^
! select rank(3) within group (order by stringu1,stringu2) from tenk1;
! ERROR:  function rank(integer, name, name) does not exist
! LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
!                ^
! HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
! select rank('fred') within group (order by x) from generate_series(1,5) x;
! ERROR:  invalid input syntax for integer: "fred"
! LINE 1: select rank('fred') within group (order by x) from generate_...
!                     ^
! select rank('adam'::text collate "C") within group (order by x collate "POSIX")
!   from (values ('fred'),('jim')) v(x);
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
!                                                              ^
! -- hypothetical-set type unification successes:
! select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
!  rank 
! ------
!     1
! (1 row)
! 
! select rank('3') within group (order by x) from generate_series(1,5) x;
!  rank 
! ------
!     3
! (1 row)
! 
! -- divide by zero check
! select percent_rank(0) within group (order by x) from generate_series(1,0) x;
!  percent_rank 
! --------------
!             0
! (1 row)
! 
! -- deparse and multiple features:
! create view aggordview1 as
! select ten,
!        percentile_disc(0.5) within group (order by thousand) as p50,
!        percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
!        rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
!   from tenk1
!  group by ten order by ten;
! select pg_get_viewdef('aggordview1');
!                                                         pg_get_viewdef                                                         
! -------------------------------------------------------------------------------------------------------------------------------
!   SELECT tenk1.ten,                                                                                                           +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) AS p50,                                  +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) FILTER (WHERE (tenk1.hundred = 1)) AS px,+
!      rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY tenk1.hundred, tenk1.string4 DESC, tenk1.hundred) AS rank              +
!     FROM tenk1                                                                                                                +
!    GROUP BY tenk1.ten                                                                                                         +
!    ORDER BY tenk1.ten;
! (1 row)
! 
! select * from aggordview1 order by ten;
!  ten | p50 | px  | rank 
! -----+-----+-----+------
!    0 | 490 |     |  101
!    1 | 491 | 401 |  101
!    2 | 492 |     |  101
!    3 | 493 |     |  101
!    4 | 494 |     |  101
!    5 | 495 |     |   67
!    6 | 496 |     |    1
!    7 | 497 |     |    1
!    8 | 498 |     |    1
!    9 | 499 |     |    1
! (10 rows)
! 
! drop view aggordview1;
! -- variadic aggregates
! select least_agg(q1,q2) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
! select least_agg(variadic array[q1,q2]) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/transactions.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/transactions.out	2015-01-10 10:11:46.307649455 +0300
***************
*** 1,623 ****
! --
! -- TRANSACTIONS
! --
! BEGIN;
! SELECT *
!    INTO TABLE xacttest
!    FROM aggtest;
! INSERT INTO xacttest (a, b) VALUES (777, 777.777);
! END;
! -- should retrieve one value--
! SELECT a FROM xacttest WHERE a > 100;
!   a  
! -----
!  777
! (1 row)
! 
! BEGIN;
! CREATE TABLE disappear (a int4);
! DELETE FROM aggtest;
! -- should be empty
! SELECT * FROM aggtest;
!  a | b 
! ---+---
! (0 rows)
! 
! ABORT;
! -- should not exist
! SELECT oid FROM pg_class WHERE relname = 'disappear';
!  oid 
! -----
! (0 rows)
! 
! -- should have members again
! SELECT * FROM aggtest;
!   a  |    b    
! -----+---------
!   56 |     7.8
!  100 |  99.097
!    0 | 0.09561
!   42 |  324.78
! (4 rows)
! 
! -- Read-only tests
! CREATE TABLE writetest (a int);
! CREATE TEMPORARY TABLE temptest (a int);
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY, DEFERRABLE; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ WRITE; --fail
! ERROR:  transaction read-write mode must be set before any query
! COMMIT;
! BEGIN;
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! ROLLBACK TO SAVEPOINT x;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! SAVEPOINT y;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! RELEASE SAVEPOINT y;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! COMMIT;
! SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
! DROP TABLE writetest; -- fail
! ERROR:  cannot execute DROP TABLE in a read-only transaction
! INSERT INTO writetest VALUES (1); -- fail
! ERROR:  cannot execute INSERT in a read-only transaction
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! DELETE FROM temptest; -- ok
! UPDATE temptest SET a = 0 FROM writetest WHERE temptest.a = 1 AND writetest.a = temptest.a; -- ok
! PREPARE test AS UPDATE writetest SET a = 0; -- ok
! EXECUTE test; -- fail
! ERROR:  cannot execute UPDATE in a read-only transaction
! SELECT * FROM writetest, temptest; -- ok
!  a | a 
! ---+---
! (0 rows)
! 
! CREATE TABLE test AS SELECT * FROM writetest; -- fail
! ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
! START TRANSACTION READ WRITE;
! DROP TABLE writetest; -- ok
! COMMIT;
! -- Subtransactions, basic tests
! -- create & drop tables
! SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
! CREATE TABLE foobar (a int);
! BEGIN;
! 	CREATE TABLE foo (a int);
! 	SAVEPOINT one;
! 		DROP TABLE foo;
! 		CREATE TABLE bar (a int);
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE baz (a int);
! 	RELEASE SAVEPOINT two;
! 	drop TABLE foobar;
! 	CREATE TABLE barbaz (a int);
! COMMIT;
! -- should exist: barbaz, baz, foo
! SELECT * FROM foo;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM bar;		-- shouldn't exist
! ERROR:  relation "bar" does not exist
! LINE 1: SELECT * FROM bar;
!                       ^
! SELECT * FROM barbaz;	-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM baz;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! -- inserts
! BEGIN;
! 	INSERT INTO foo VALUES (1);
! 	SAVEPOINT one;
! 		INSERT into bar VALUES (1);
! ERROR:  relation "bar" does not exist
! LINE 1: INSERT into bar VALUES (1);
!                     ^
! 	ROLLBACK TO one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		INSERT into barbaz VALUES (1);
! 	RELEASE two;
! 	SAVEPOINT three;
! 		SAVEPOINT four;
! 			INSERT INTO foo VALUES (2);
! 		RELEASE SAVEPOINT four;
! 	ROLLBACK TO SAVEPOINT three;
! 	RELEASE SAVEPOINT three;
! 	INSERT INTO foo VALUES (3);
! COMMIT;
! SELECT * FROM foo;		-- should have 1 and 3
!  a 
! ---
!  1
!  3
! (2 rows)
! 
! SELECT * FROM barbaz;	-- should have 1
!  a 
! ---
!  1
! (1 row)
! 
! -- test whole-tree commit
! BEGIN;
! 	SAVEPOINT one;
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE savepoints (a int);
! 		SAVEPOINT three;
! 			INSERT INTO savepoints VALUES (1);
! 			SAVEPOINT four;
! 				INSERT INTO savepoints VALUES (2);
! 				SAVEPOINT five;
! 					INSERT INTO savepoints VALUES (3);
! 				ROLLBACK TO SAVEPOINT five;
! COMMIT;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree rollback
! BEGIN;
! 	SAVEPOINT one;
! 		DELETE FROM savepoints WHERE a=1;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		DELETE FROM savepoints WHERE a=1;
! 		SAVEPOINT three;
! 			DELETE FROM savepoints WHERE a=2;
! ROLLBACK;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree commit on an aborted subtransaction
! BEGIN;
! 	INSERT INTO savepoints VALUES (4);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (5);
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! COMMIT;
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (6);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (7);
! 	RELEASE SAVEPOINT one;
! 	INSERT INTO savepoints VALUES (8);
! COMMIT;
! -- rows 6 and 8 should have been created by the same xact
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=8;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- rows 6 and 7 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=7;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (9);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (10);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (11);
! COMMIT;
! SELECT a FROM savepoints WHERE a in (9, 10, 11);
!  a  
! ----
!   9
!  11
! (2 rows)
! 
! -- rows 9 and 11 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=9 AND b.a=11;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (12);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (13);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (14);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (15);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (16);
! 			SAVEPOINT three;
! 				INSERT INTO savepoints VALUES (17);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 12 AND 17;
!  a  
! ----
!  12
!  15
!  16
!  17
! (4 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (18);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (19);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (20);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (21);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (22);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 18 AND 22;
!  a  
! ----
!  18
!  22
! (2 rows)
! 
! DROP TABLE savepoints;
! -- only in a transaction block:
! SAVEPOINT one;
! ERROR:  SAVEPOINT can only be used in transaction blocks
! ROLLBACK TO SAVEPOINT one;
! ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
! RELEASE SAVEPOINT one;
! ERROR:  RELEASE SAVEPOINT can only be used in transaction blocks
! -- Only "rollback to" allowed in aborted state
! BEGIN;
!   SAVEPOINT one;
!   SELECT 0/0;
! ERROR:  division by zero
!   SAVEPOINT two;    -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   RELEASE SAVEPOINT one;      -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   ROLLBACK TO SAVEPOINT one;
!   SELECT 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! COMMIT;
! SELECT 1;			-- this should work
!  ?column? 
! ----------
!         1
! (1 row)
! 
! -- check non-transactional behavior of cursors
! BEGIN;
! 	DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!        0
!        1
!        2
!        3
!        4
!        5
!        6
!        7
!        8
!        9
! (10 rows)
! 
! 	ROLLBACK TO SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!       10
!       11
!       12
!       13
!       14
!       15
!       16
!       17
!       18
!       19
! (10 rows)
! 
! 	RELEASE SAVEPOINT one;
! 	FETCH 10 FROM c;
!  unique2 
! ---------
!       20
!       21
!       22
!       23
!       24
!       25
!       26
!       27
!       28
!       29
! (10 rows)
! 
! 	CLOSE c;
! 	DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT two;
! 		FETCH 10 FROM c;
! ERROR:  division by zero
! 	ROLLBACK TO SAVEPOINT two;
! 	-- c is now dead to the world ...
! 		FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! 	ROLLBACK TO SAVEPOINT two;
! 	RELEASE SAVEPOINT two;
! 	FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! COMMIT;
! --
! -- Check that "stable" functions are really stable.  They should not be
! -- able to see the partial results of the calling query.  (Ideally we would
! -- also check that they don't see commits of concurrent transactions, but
! -- that's a mite hard to do within the limitations of pg_regress.)
! --
! select * from xacttest;
!   a  |    b    
! -----+---------
!   56 |     7.8
!  100 |  99.097
!    0 | 0.09561
!   42 |  324.78
!  777 | 777.777
! (5 rows)
! 
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  787 |  99.097
!  787 |  324.78
!  787 | 777.777
! (5 rows)
! 
! rollback;
! -- But a volatile function can see the partial results of the calling query
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  797 |  99.097
!  807 |  324.78
!  817 | 777.777
! (5 rows)
! 
! rollback;
! -- Now the same test with plpgsql (since it depends on SPI which is different)
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  787 |  99.097
!  787 |  324.78
!  787 | 777.777
! (5 rows)
! 
! rollback;
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  797 |  99.097
!  807 |  324.78
!  817 | 777.777
! (5 rows)
! 
! rollback;
! -- test case for problems with dropping an open relation during abort
! BEGIN;
! 	savepoint x;
! 		CREATE TABLE koju (a INT UNIQUE);
! 		INSERT INTO koju VALUES (1);
! 		INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! 	rollback to x;
! 	CREATE TABLE koju (a INT UNIQUE);
! 	INSERT INTO koju VALUES (1);
! 	INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! ROLLBACK;
! DROP TABLE foo;
! DROP TABLE baz;
! DROP TABLE barbaz;
! -- test case for problems with revalidating an open relation during abort
! create function inverse(int) returns float8 as
! $$
! begin
!   analyze revalidate_bug;
!   return 1::float8/$1;
! exception
!   when division_by_zero then return 0;
! end$$ language plpgsql volatile;
! create table revalidate_bug (c float8 unique);
! insert into revalidate_bug values (1);
! insert into revalidate_bug values (inverse(0));
! drop table revalidate_bug;
! drop function inverse(int);
! -- verify that cursors created during an aborted subtransaction are
! -- closed, but that we do not rollback the effect of any FETCHs
! -- performed in the aborted subtransaction
! begin;
! savepoint x;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! declare foo cursor for select * from abc;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! rollback to x;
! -- should fail
! fetch from foo;
! ERROR:  cursor "foo" does not exist
! commit;
! begin;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! insert into abc values (15);
! declare foo cursor for select * from abc;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! savepoint x;
! fetch from foo;
!  a  
! ----
!  10
! (1 row)
! 
! rollback to x;
! fetch from foo;
!  a  
! ----
!  15
! (1 row)
! 
! abort;
! -- Test for successful cleanup of an aborted transaction at session exit.
! -- THIS MUST BE THE LAST TEST IN THIS FILE.
! begin;
! select 1/0;
! ERROR:  division by zero
! rollback to X;
! ERROR:  no such savepoint
! -- DO NOT ADD ANYTHING HERE.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/random.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/random.out	2015-01-10 10:11:46.291649454 +0300
***************
*** 1,52 ****
! --
! -- RANDOM
! -- Test the random function
! --
! -- count the number of tuples originally, should be 1000
! SELECT count(*) FROM onek;
!  count 
! -------
!   1000
! (1 row)
! 
! -- pick three random rows, they shouldn't match
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1);
!  random 
! --------
! (0 rows)
! 
! -- count roughly 1/10 of the tuples
! SELECT count(*) AS random INTO RANDOM_TBL
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- now test that they are different counts
! SELECT random, count(random) FROM RANDOM_TBL
!   GROUP BY random HAVING count(random) > 3;
!  random | count 
! --------+-------
! (0 rows)
! 
! SELECT AVG(random) FROM RANDOM_TBL
!   HAVING AVG(random) NOT BETWEEN 80 AND 120;
!  avg 
! -----
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/portals.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/portals.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,1287 ****
! --
! -- Cursor regression tests
! --
! BEGIN;
! DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH 2 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (2 rows)
! 
! FETCH 3 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (3 rows)
! 
! FETCH 4 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH 5 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH 6 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (6 rows)
! 
! FETCH 7 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
! (7 rows)
! 
! FETCH 8 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH 9 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH 10 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (10 rows)
! 
! FETCH 11 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
! (11 rows)
! 
! FETCH 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (12 rows)
! 
! FETCH 13 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
! (13 rows)
! 
! FETCH 14 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (14 rows)
! 
! FETCH 15 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
! (15 rows)
! 
! FETCH 16 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (16 rows)
! 
! FETCH 17 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
! (17 rows)
! 
! FETCH 18 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (18 rows)
! 
! FETCH 19 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
! (19 rows)
! 
! FETCH 20 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (20 rows)
! 
! FETCH 21 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
! (21 rows)
! 
! FETCH 22 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (22 rows)
! 
! FETCH 23 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
!     8020 |      22 |   0 |    0 |   0 |      0 |      20 |       20 |          20 |      3020 |     8020 |  40 |   41 | MWAAAA   | WAAAAA   | OOOOxx
! (23 rows)
! 
! FETCH backward 1 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (1 row)
! 
! FETCH backward 2 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (2 rows)
! 
! FETCH backward 3 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (3 rows)
! 
! FETCH backward 4 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH backward 5 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (5 rows)
! 
! FETCH backward 6 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (6 rows)
! 
! FETCH backward 7 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (7 rows)
! 
! FETCH backward 8 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH backward 9 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (9 rows)
! 
! FETCH backward 10 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (10 rows)
! 
! FETCH backward 11 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (11 rows)
! 
! FETCH backward 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (11 rows)
! 
! FETCH backward 13 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (10 rows)
! 
! FETCH backward 14 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH backward 15 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (8 rows)
! 
! FETCH backward 16 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (7 rows)
! 
! FETCH backward 17 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (6 rows)
! 
! FETCH backward 18 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH backward 19 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (4 rows)
! 
! FETCH backward 20 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (3 rows)
! 
! FETCH backward 21 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (2 rows)
! 
! FETCH backward 22 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH backward 23 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
! (0 rows)
! 
! CLOSE foo1;
! CLOSE foo2;
! CLOSE foo3;
! CLOSE foo4;
! CLOSE foo5;
! CLOSE foo6;
! CLOSE foo7;
! CLOSE foo8;
! CLOSE foo9;
! CLOSE foo10;
! CLOSE foo11;
! CLOSE foo12;
! -- leave some cursors open, to test that auto-close works.
! -- record this in the system view as well (don't query the time field there
! -- however)
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name  |                               statement                               | is_holdable | is_binary | is_scrollable 
! -------+-----------------------------------------------------------------------+-------------+-----------+---------------
!  foo13 | DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo14 | DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo15 | DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo16 | DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo17 | DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo18 | DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo19 | DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo20 | DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo21 | DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo22 | DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo23 | DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
! (11 rows)
! 
! END;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! --
! -- NO SCROLL disallows backward fetching
! --
! BEGIN;
! DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 FROM foo24;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH BACKWARD 1 FROM foo24; -- should fail
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! END;
! --
! -- Cursors outside transaction blocks
! --
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! BEGIN;
! DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! COMMIT;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (1 row)
! 
! FETCH BACKWARD FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! FETCH ABSOLUTE -1 FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     2968 |    9999 |   0 |    0 |   8 |      8 |      68 |      968 |         968 |      2968 |     2968 | 136 |  137 | EKAAAA   | PUOAAA   | VVVVxx
! (1 row)
! 
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name  |                           statement                            | is_holdable | is_binary | is_scrollable 
! -------+----------------------------------------------------------------+-------------+-----------+---------------
!  foo25 | DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2; | t           | f         | t
! (1 row)
! 
! CLOSE foo25;
! --
! -- ROLLBACK should close holdable cursors
! --
! BEGIN;
! DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
! ROLLBACK;
! -- should fail
! FETCH FROM foo26;
! ERROR:  cursor "foo26" does not exist
! --
! -- Parameterized DECLARE needs to insert param values into the cursor portal
! --
! BEGIN;
! CREATE FUNCTION declares_cursor(text)
!    RETURNS void
!    AS 'DECLARE c CURSOR FOR SELECT stringu1 FROM tenk1 WHERE stringu1 LIKE $1;'
!    LANGUAGE SQL;
! SELECT declares_cursor('AB%');
!  declares_cursor 
! -----------------
!  
! (1 row)
! 
! FETCH ALL FROM c;
!  stringu1 
! ----------
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
! (15 rows)
! 
! ROLLBACK;
! --
! -- Test behavior of both volatile and stable functions inside a cursor;
! -- in particular we want to see what happens during commit of a holdable
! -- cursor
! --
! create temp table tt1(f1 int);
! create function count_tt1_v() returns int8 as
! 'select count(*) from tt1' language sql volatile;
! create function count_tt1_s() returns int8 as
! 'select count(*) from tt1' language sql stable;
! begin;
! insert into tt1 values(1);
! declare c1 cursor for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! fetch all from c1;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           1
! (1 row)
! 
! rollback;
! begin;
! insert into tt1 values(1);
! declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! commit;
! delete from tt1;
! fetch all from c2;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           1
! (1 row)
! 
! drop function count_tt1_v();
! drop function count_tt1_s();
! -- Create a cursor with the BINARY option and check the pg_cursors view
! BEGIN;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  bc   | DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;                    | f           | t         | t
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (2 rows)
! 
! ROLLBACK;
! -- We should not see the portal that is created internally to
! -- implement EXECUTE in pg_cursors
! PREPARE cprep AS
!   SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
! EXECUTE cprep;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! -- test CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  c2
! (1 row)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! BEGIN;
! DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
! DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  foo1
!  foo2
! (2 rows)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! COMMIT;
! --
! -- Tests for updatable cursors
! --
! CREATE TEMP TABLE uctest(f1 int, f2 text);
! INSERT INTO uctest VALUES (1, 'one'), (2, 'two'), (3, 'three');
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check DELETE WHERE CURRENT
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! FETCH 2 FROM c1;
!  f1 | f2  
! ----+-----
!   1 | one
!   2 | two
! (2 rows)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! -- should show deletion
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   3 | three
! (2 rows)
! 
! -- cursor did not move
! FETCH ALL FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! -- cursor is insensitive
! MOVE BACKWARD ALL IN c1;
! FETCH ALL FROM c1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! COMMIT;
! -- should still see deletion
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   3 | three
! (2 rows)
! 
! -- Check UPDATE WHERE CURRENT; this time use FOR UPDATE
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = 8 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! COMMIT;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! -- Check repeated-update and update-then-delete cases
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! FETCH c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  13 | three
! (2 rows)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  23 | three
! (2 rows)
! 
! -- insensitive cursor should not show effects of updates or deletes
! FETCH RELATIVE 0 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! FETCH RELATIVE 0 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! ROLLBACK;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  13 | three
! (2 rows)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  23 | three
! (2 rows)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! --- sensitive cursors can't currently scroll back, so this is an error:
! FETCH RELATIVE 0 FROM c1;
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! ROLLBACK;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! -- Check inheritance cases
! CREATE TEMP TABLE ucchild () inherits (uctest);
! INSERT INTO ucchild values(100, 'hundred');
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!    3 | three
!    8 | one
!  100 | hundred
! (3 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH 1 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1  |   f2    
! -----+---------
!  100 | hundred
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1 | f2 
! ----+----
! (0 rows)
! 
! COMMIT;
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!   13 | three
!   18 | one
!  110 | hundred
! (3 rows)
! 
! -- Can update from a self-join, but only if FOR UPDATE says which to use
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  cursor "c1" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR UPDATE;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  cursor "c1" has multiple FOR UPDATE/SHARE references to table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR SHARE OF a;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!   13 | three
!   28 | one
!  110 | hundred
! (3 rows)
! 
! ROLLBACK;
! -- Check various error cases
! DELETE FROM uctest WHERE CURRENT OF c1;  -- fail, no such cursor
! ERROR:  cursor "c1" does not exist
! DECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF cx;  -- fail, can't use held cursor
! ERROR:  cursor "cx" is held from a previous transaction
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  cursor "c" does not have a FOR UPDATE/SHARE reference to table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
! DELETE FROM tenk1 WHERE CURRENT OF c;  -- fail, cursor is on a join
! ERROR:  cursor "c" is not a simply updatable scan of table "tenk1"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor is on aggregation
! ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF c1; -- fail, no current row
! ERROR:  cursor "c1" is not positioned on a row
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
! ERROR:  FOR UPDATE is not allowed with aggregate functions
! ROLLBACK;
! -- WHERE CURRENT OF may someday work with views, but today is not that day.
! -- For now, just make sure it errors out cleanly.
! CREATE TEMP VIEW ucview AS SELECT * FROM uctest;
! CREATE RULE ucrule AS ON DELETE TO ucview DO INSTEAD
!   DELETE FROM uctest WHERE f1 = OLD.f1;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM ucview;
! FETCH FROM c1;
!  f1 |  f2   
! ----+-------
!  13 | three
! (1 row)
! 
! DELETE FROM ucview WHERE CURRENT OF c1; -- fail, views not supported
! ERROR:  WHERE CURRENT OF on a view is not implemented
! ROLLBACK;
! -- Make sure snapshot management works okay, per bug report in
! -- 235395b90909301035v7228ce63q392931f15aa74b31@mail.gmail.com
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! CREATE TABLE cursor (a int);
! INSERT INTO cursor VALUES (1);
! DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
! UPDATE cursor SET a = 2;
! FETCH ALL FROM c1;
!  a 
! ---
! (0 rows)
! 
! COMMIT;
! DROP TABLE cursor;
! -- Check rewinding a cursor containing a stable function in LIMIT,
! -- per bug report in 8336843.9833.1399385291498.JavaMail.root@quick
! begin;
! create function nochange(int) returns int
!   as 'select $1 limit 1' language sql stable;
! declare c cursor for select * from int8_tbl limit nochange(3);
! fetch all from c;
!         q1        |        q2        
! ------------------+------------------
!               123 |              456
!               123 | 4567890123456789
!  4567890123456789 |              123
! (3 rows)
! 
! move backward all in c;
! fetch all from c;
!         q1        |        q2        
! ------------------+------------------
!               123 |              456
!               123 | 4567890123456789
!  4567890123456789 |              123
! (3 rows)
! 
! rollback;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/arrays.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/arrays.out	2015-01-10 10:11:46.287649454 +0300
***************
*** 1,1831 ****
! --
! -- ARRAYS
! --
! CREATE TABLE arrtest (
! 	a 			int2[],
! 	b 			int4[][][],
! 	c 			name[],
! 	d			text[][],
! 	e 			float8[],
! 	f			char(5)[],
! 	g			varchar(5)[]
! );
! --
! -- only the 'e' array is 0-based, the others are 1-based.
! --
! INSERT INTO arrtest (a[1:5], b[1:1][1:2][1:2], c, d, f, g)
!    VALUES ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}', '{}', '{}');
! UPDATE arrtest SET e[0] = '1.1';
! UPDATE arrtest SET e[1] = '2.2';
! INSERT INTO arrtest (f)
!    VALUES ('{"too long"}');
! ERROR:  value too long for type character(5)
! INSERT INTO arrtest (a, b[1:2][1:2], c, d, e, f, g)
!    VALUES ('{11,12,23}', '{{3,4},{4,5}}', '{"foobar"}',
!            '{{"elt1", "elt2"}}', '{"3.4", "6.7"}',
!            '{"abc","abcde"}', '{"abc","abcde"}');
! INSERT INTO arrtest (a, b[1:2], c, d[1:2])
!    VALUES ('{}', '{3,4}', '{foo,bar}', '{bar,foo}');
! SELECT * FROM arrtest;
!       a      |        b        |     c     |       d       |        e        |        f        |      g      
! -------------+-----------------+-----------+---------------+-----------------+-----------------+-------------
!  {1,2,3,4,5} | {{{0,0},{1,2}}} | {}        | {}            | [0:1]={1.1,2.2} | {}              | {}
!  {11,12,23}  | {{3,4},{4,5}}   | {foobar}  | {{elt1,elt2}} | {3.4,6.7}       | {"abc  ",abcde} | {abc,abcde}
!  {}          | {3,4}           | {foo,bar} | {bar,foo}     |                 |                 | 
! (3 rows)
! 
! SELECT arrtest.a[1],
!           arrtest.b[1][1][1],
!           arrtest.c[1],
!           arrtest.d[1][1],
!           arrtest.e[0]
!    FROM arrtest;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1], b[1][1][1], c[1], d[1][1], e[0]
!    FROM arrtest;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][1:2]
!    FROM arrtest;
!      a      |        b        |     c     |       d       
! ------------+-----------------+-----------+---------------
!  {1,2,3}    | {{{0,0},{1,2}}} | {}        | {}
!  {11,12,23} | {}              | {foobar}  | {{elt1,elt2}}
!  {}         | {}              | {foo,bar} | {}
! (3 rows)
! 
! SELECT array_ndims(a) AS a,array_ndims(b) AS b,array_ndims(c) AS c
!    FROM arrtest;
!  a | b | c 
! ---+---+---
!  1 | 3 |  
!  1 | 2 | 1
!    | 1 | 1
! (3 rows)
! 
! SELECT array_dims(a) AS a,array_dims(b) AS b,array_dims(c) AS c
!    FROM arrtest;
!    a   |        b        |   c   
! -------+-----------------+-------
!  [1:5] | [1:1][1:2][1:2] | 
!  [1:3] | [1:2][1:2]      | [1:1]
!        | [1:2]           | [1:2]
! (3 rows)
! 
! -- returns nothing
! SELECT *
!    FROM arrtest
!    WHERE a[1] < 5 and
!          c = '{"foobar"}'::_name;
!  a | b | c | d | e | f | g 
! ---+---+---+---+---+---+---
! (0 rows)
! 
! UPDATE arrtest
!   SET a[1:2] = '{16,25}'
!   WHERE NOT a = '{}'::_int2;
! UPDATE arrtest
!   SET b[1:1][1:1][1:2] = '{113, 117}',
!       b[1:1][1:2][2:2] = '{142, 147}'
!   WHERE array_dims(b) = '[1:1][1:2][1:2]';
! UPDATE arrtest
!   SET c[2:2] = '{"new_word"}'
!   WHERE array_dims(c) is not null;
! SELECT a,b,c FROM arrtest;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {}            | {3,4}                 | {foo,new_word}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][2:2]
!    FROM arrtest;
!      a      |           b           |         c         |    d     
! ------------+-----------------------+-------------------+----------
!  {16,25,3}  | {{{113,142},{1,147}}} | {}                | {}
!  {}         | {}                    | {foo,new_word}    | {}
!  {16,25,23} | {}                    | {foobar,new_word} | {{elt2}}
! (3 rows)
! 
! INSERT INTO arrtest(a) VALUES('{1,null,3}');
! SELECT a FROM arrtest;
!        a       
! ---------------
!  {16,25,3,4,5}
!  {}
!  {16,25,23}
!  {1,NULL,3}
! (4 rows)
! 
! UPDATE arrtest SET a[4] = NULL WHERE a[2] IS NULL;
! SELECT a FROM arrtest WHERE a[2] IS NULL;
!         a        
! -----------------
!  [4:4]={NULL}
!  {1,NULL,3,NULL}
! (2 rows)
! 
! DELETE FROM arrtest WHERE a[2] IS NULL AND b IS NULL;
! SELECT a,b,c FROM arrtest;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
!  [4:4]={NULL}  | {3,4}                 | {foo,new_word}
! (3 rows)
! 
! --
! -- test array extension
! --
! CREATE TEMP TABLE arrtest1 (i int[], t text[]);
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[2] = 22, t[2] = 'twenty-two';
! select * from arrtest1;
!        i       |             t              
! ---------------+----------------------------
!  {1,22,NULL,4} | {one,twenty-two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[5] = 5, t[5] = 'five';
! select * from arrtest1;
!         i        |                t                
! -----------------+---------------------------------
!  {1,22,NULL,4,5} | {one,twenty-two,NULL,four,five}
! (1 row)
! 
! update arrtest1 set i[8] = 8, t[8] = 'eight';
! select * from arrtest1;
!               i              |                        t                        
! -----------------------------+-------------------------------------------------
!  {1,22,NULL,4,5,NULL,NULL,8} | {one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0] = 0, t[0] = 'zero';
! select * from arrtest1;
!                   i                  |                             t                              
! -------------------------------------+------------------------------------------------------------
!  [0:8]={0,1,22,NULL,4,5,NULL,NULL,8} | [0:8]={zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[-3] = -3, t[-3] = 'minus-three';
! select * from arrtest1;
!                          i                         |                                         t                                         
! ---------------------------------------------------+-----------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,0,1,22,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
! select * from arrtest1;
!                           i                          |                                        t                                        
! -----------------------------------------------------+---------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
! select * from arrtest1;
!                                i                               |                                            t                                            
! ---------------------------------------------------------------+-----------------------------------------------------------------------------------------
!  [-3:10]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20} | [-3:10]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20}
! (1 row)
! 
! update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
! select * from arrtest1;
!                                    i                                   |                                                t                                                 
! -----------------------------------------------------------------------+--------------------------------------------------------------------------------------------------
!  [-3:12]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22} | [-3:12]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22}
! (1 row)
! 
! update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
! select * from arrtest1;
!                                             i                                            |                                                          t                                                          
! -----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-3:16]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-3:16]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
! select * from arrtest1;
!                                                 i                                                 |                                                          t                                                          
! --------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-5:16]={-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-5:16]={m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
! select * from arrtest1;
!                                                      i                                                     |                                                              t                                                               
! -----------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------
!  [-7:16]={-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-7:16]={m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
! select * from arrtest1;
!                                                                  i                                                                 |                                                                          t                                                                           
! -----------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------
!  [-12:16]={-22,NULL,-20,NULL,NULL,-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-12:16]={m22,NULL,m20,NULL,NULL,m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! delete from arrtest1;
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
! select * from arrtest1;
!            i            |             t              
! ------------------------+----------------------------
!  [0:5]={0,1,2,NULL,4,5} | [0:5]={z,p1,p2,NULL,p4,p5}
! (1 row)
! 
! --
! -- array expressions and operators
! --
! -- table creation and INSERTs
! CREATE TEMP TABLE arrtest2 (i integer ARRAY[4], f float8[], n numeric[], t text[], d timestamp[]);
! INSERT INTO arrtest2 VALUES(
!   ARRAY[[[113,142],[1,147]]],
!   ARRAY[1.1,1.2,1.3]::float8[],
!   ARRAY[1.1,1.2,1.3],
!   ARRAY[[['aaa','aab'],['aba','abb'],['aca','acb']],[['baa','bab'],['bba','bbb'],['bca','bcb']]],
!   ARRAY['19620326','19931223','19970117']::timestamp[]
! );
! -- some more test data
! CREATE TEMP TABLE arrtest_f (f0 int, f1 text, f2 float8);
! insert into arrtest_f values(1,'cat1',1.21);
! insert into arrtest_f values(2,'cat1',1.24);
! insert into arrtest_f values(3,'cat1',1.18);
! insert into arrtest_f values(4,'cat1',1.26);
! insert into arrtest_f values(5,'cat1',1.15);
! insert into arrtest_f values(6,'cat2',1.15);
! insert into arrtest_f values(7,'cat2',1.26);
! insert into arrtest_f values(8,'cat2',1.32);
! insert into arrtest_f values(9,'cat2',1.30);
! CREATE TEMP TABLE arrtest_i (f0 int, f1 text, f2 int);
! insert into arrtest_i values(1,'cat1',21);
! insert into arrtest_i values(2,'cat1',24);
! insert into arrtest_i values(3,'cat1',18);
! insert into arrtest_i values(4,'cat1',26);
! insert into arrtest_i values(5,'cat1',15);
! insert into arrtest_i values(6,'cat2',15);
! insert into arrtest_i values(7,'cat2',26);
! insert into arrtest_i values(8,'cat2',32);
! insert into arrtest_i values(9,'cat2',30);
! -- expressions
! SELECT t.f[1][3][1] AS "131", t.f[2][2][1] AS "221" FROM (
!   SELECT ARRAY[[[111,112],[121,122],[131,132]],[[211,212],[221,122],[231,232]]] AS f
! ) AS t;
!  131 | 221 
! -----+-----
!  131 | 221
! (1 row)
! 
! SELECT ARRAY[[[[[['hello'],['world']]]]]];
!            array           
! ---------------------------
!  {{{{{{hello},{world}}}}}}
! (1 row)
! 
! SELECT ARRAY[ARRAY['hello'],ARRAY['world']];
!        array       
! -------------------
!  {{hello},{world}}
! (1 row)
! 
! SELECT ARRAY(select f2 from arrtest_f order by f2) AS "ARRAY";
!                      ARRAY                     
! -----------------------------------------------
!  {1.15,1.15,1.18,1.21,1.24,1.26,1.26,1.3,1.32}
! (1 row)
! 
! -- with nulls
! SELECT '{1,null,3}'::int[];
!     int4    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! SELECT ARRAY[1,NULL,3];
!    array    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! -- functions
! SELECT array_append(array[42], 6) AS "{42,6}";
!  {42,6} 
! --------
!  {42,6}
! (1 row)
! 
! SELECT array_prepend(6, array[42]) AS "{6,42}";
!  {6,42} 
! --------
!  {6,42}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[3,4]) AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
!  {{3,4},{5,6},{1,2}} 
! ---------------------
!  {{3,4},{5,6},{1,2}}
! (1 row)
! 
! -- operators
! SELECT a FROM arrtest WHERE b = ARRAY[[[113,142],[1,147]]];
!        a       
! ---------------
!  {16,25,3,4,5}
! (1 row)
! 
! SELECT NOT ARRAY[1.1,1.2,1.3] = ARRAY[1.1,1.2,1.3] AS "FALSE";
!  FALSE 
! -------
!  f
! (1 row)
! 
! SELECT ARRAY[1,2] || 3 AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] AS "{0,1,2}";
!  {0,1,2} 
! ---------
!  {0,1,2}
! (1 row)
! 
! SELECT ARRAY[1,2] || ARRAY[3,4] AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT ARRAY[[['hello','world']]] || ARRAY[[['happy','birthday']]] AS "ARRAY";
!                 ARRAY                 
! --------------------------------------
!  {{{hello,world}},{{happy,birthday}}}
! (1 row)
! 
! SELECT ARRAY[[1,2],[3,4]] || ARRAY[5,6] AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT ARRAY[0,0] || ARRAY[1,1] || ARRAY[2,2] AS "{0,0,1,1,2,2}";
!  {0,0,1,1,2,2} 
! ---------------
!  {0,0,1,1,2,2}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] || 3 AS "{0,1,2,3}";
!  {0,1,2,3} 
! -----------
!  {0,1,2,3}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (11 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
!  seqno |       i       |                                                             t                                                              
! -------+---------------+----------------------------------------------------------------------------------------------------------------------------
!     40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    101 | {}            | {}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE i = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |  i   |                                 t                                  
! -------+------+--------------------------------------------------------------------
!     79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
!  seqno |         i          |                                                     t                                                     
! -------+--------------------+-----------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
!     45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!    101 | {}                 | {}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! -- array casts
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] is of (float8[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] AS "{{a,bc},{def,hijk}}";
!  {{a,bc},{def,hijk}} 
! ---------------------
!  {{a,bc},{def,hijk}}
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] is of (varchar[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT CAST(ARRAY[[[[[['a','bb','ccc']]]]]] as text[]) as "{{{{{{a,bb,ccc}}}}}}";
!  {{{{{{a,bb,ccc}}}}}} 
! ----------------------
!  {{{{{{a,bb,ccc}}}}}}
! (1 row)
! 
! -- scalar op any/all (array)
! select 33 = any ('{1,2,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = any ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all ('{1,2,33}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 >= all ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- boundary cases
! select null::int >= all ('{1,2,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int >= all ('{}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select null::int >= any ('{}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- cross-datatype
! select 33.4 = any (array[1,2,3]);
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33.4 > all (array[1,2,3]);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- errors
! select 33 * any ('{1,2,3}');
! ERROR:  op ANY/ALL (array) requires operator to yield boolean
! LINE 1: select 33 * any ('{1,2,3}');
!                   ^
! select 33 * any (44);
! ERROR:  op ANY/ALL (array) requires array on right side
! LINE 1: select 33 * any (44);
!                   ^
! -- nulls
! select 33 = any (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = any ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = all ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = all ('{1,null,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = all ('{33,null,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- test indexes on arrays
! create temp table arr_tbl (f1 int[] unique);
! insert into arr_tbl values ('{1,2,3}');
! insert into arr_tbl values ('{1,2}');
! -- failure expected:
! insert into arr_tbl values ('{1,2,3}');
! ERROR:  duplicate key value violates unique constraint "arr_tbl_f1_key"
! DETAIL:  Key (f1)=({1,2,3}) already exists.
! insert into arr_tbl values ('{2,3,4}');
! insert into arr_tbl values ('{1,5,3}');
! insert into arr_tbl values ('{1,2,10}');
! set enable_seqscan to off;
! set enable_bitmapscan to off;
! select * from arr_tbl where f1 > '{1,2,3}' and f1 <= '{1,5,3}';
!     f1    
! ----------
!  {1,2,10}
!  {1,5,3}
! (2 rows)
! 
! select * from arr_tbl where f1 >= '{1,2,3}' and f1 < '{1,5,3}';
!     f1    
! ----------
!  {1,2,3}
!  {1,2,10}
! (2 rows)
! 
! -- note: if above selects don't produce the expected tuple order,
! -- then you didn't get an indexscan plan, and something is busted.
! reset enable_seqscan;
! reset enable_bitmapscan;
! -- test [not] (like|ilike) (any|all) (...)
! select 'foo' like any (array['%a', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like any (array['%a', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' like all (array['f%', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like all (array['f%', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' not like any (array['%a', '%b']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' not like all (array['%a', '%o']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' ilike any (array['%A', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' ilike all (array['F%', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- General array parser tests
! --
! -- none of the following should be accepted
! select '{{1,{2}},{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,{2}},{2,3}}"
! LINE 1: select '{{1,{2}},{2,3}}'::text[];
!                ^
! select '{{},{}}'::text[];
! ERROR:  malformed array literal: "{{},{}}"
! LINE 1: select '{{},{}}'::text[];
!                ^
! select E'{{1,2},\\{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,2},\{2,3}}"
! LINE 1: select E'{{1,2},\\{2,3}}'::text[];
!                ^
! select '{{"1 2" x},{3}}'::text[];
! ERROR:  malformed array literal: "{{"1 2" x},{3}}"
! LINE 1: select '{{"1 2" x},{3}}'::text[];
!                ^
! select '{}}'::text[];
! ERROR:  malformed array literal: "{}}"
! LINE 1: select '{}}'::text[];
!                ^
! select '{ }}'::text[];
! ERROR:  malformed array literal: "{ }}"
! LINE 1: select '{ }}'::text[];
!                ^
! select array[];
! ERROR:  cannot determine type of empty array
! LINE 1: select array[];
!                ^
! HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
! -- none of the above should be accepted
! -- all of the following should be accepted
! select '{}'::text[];
!  text 
! ------
!  {}
! (1 row)
! 
! select '{{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}'::text[];
!                      text                      
! -----------------------------------------------
!  {{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}
! (1 row)
! 
! select '{0 second  ,0 second}'::interval[];
!    interval    
! ---------------
!  {"@ 0","@ 0"}
! (1 row)
! 
! select '{ { "," } , { 3 } }'::text[];
!     text     
! -------------
!  {{","},{3}}
! (1 row)
! 
! select '  {   {  "  0 second  "   ,  0 second  }   }'::text[];
!              text              
! -------------------------------
!  {{"  0 second  ","0 second"}}
! (1 row)
! 
! select '{
!            0 second,
!            @ 1 hour @ 42 minutes @ 20 seconds
!          }'::interval[];
!               interval              
! ------------------------------------
!  {"@ 0","@ 1 hour 42 mins 20 secs"}
! (1 row)
! 
! select array[]::text[];
!  array 
! -------
!  {}
! (1 row)
! 
! select '[0:1]={1.1,2.2}'::float8[];
!      float8      
! -----------------
!  [0:1]={1.1,2.2}
! (1 row)
! 
! -- all of the above should be accepted
! -- tests for array aggregates
! CREATE TEMP TABLE arraggtest ( f1 INT[], f2 TEXT[][], f3 FLOAT[]);
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3,4}','{{grey,red},{blue,blue}}','{1.6, 0.0}');
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3}','{{grey,red},{grey,blue}}','{1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!     max    |   min   |           max            |           min            |   max   |  min  
! -----------+---------+--------------------------+--------------------------+---------+-------
!  {1,2,3,4} | {1,2,3} | {{grey,red},{grey,blue}} | {{grey,red},{blue,blue}} | {1.6,0} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{3,3,2,4,5,6}','{{white,yellow},{pink,orange}}','{2.1,3.3,1.8,1.7,1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |           min            |          max          |  min  
! ---------------+---------+--------------------------------+--------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{grey,red},{blue,blue}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{2}','{{black,red},{green,orange}}','{1.6,2.2,2.6,0.4}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{4,2,6,7,8,1}','{{red},{black},{purple},{blue},{blue}}',NULL);
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{}','{{pink,white,blue,red,grey,orange}}','{2.1,1.87,1.4,2.2}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      | min |              max               |             min              |          max          |  min  
! ---------------+-----+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {}  | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! -- A few simple tests for arrays of composite types
! create type comptype as (f1 int, f2 text);
! create table comptable (c1 comptype, c2 comptype[]);
! -- XXX would like to not have to specify row() construct types here ...
! insert into comptable
!   values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
! -- check that implicitly named array type _comptype isn't a problem
! create type _comptype as enum('fooey');
! select * from comptable;
!    c1    |          c2           
! ---------+-----------------------
!  (1,foo) | {"(2,bar)","(3,baz)"}
! (1 row)
! 
! select c2[2].f2 from comptable;
!  f2  
! -----
!  baz
! (1 row)
! 
! drop type _comptype;
! drop table comptable;
! drop type comptype;
! create or replace function unnest1(anyarray)
! returns setof anyelement as $$
! select $1[s] from generate_subscripts($1,1) g(s);
! $$ language sql immutable;
! create or replace function unnest2(anyarray)
! returns setof anyelement as $$
! select $1[s1][s2] from generate_subscripts($1,1) g1(s1),
!                    generate_subscripts($1,2) g2(s2);
! $$ language sql immutable;
! select * from unnest1(array[1,2,3]);
!  unnest1 
! ---------
!        1
!        2
!        3
! (3 rows)
! 
! select * from unnest2(array[[1,2,3],[4,5,6]]);
!  unnest2 
! ---------
!        1
!        2
!        3
!        4
!        5
!        6
! (6 rows)
! 
! drop function unnest1(anyarray);
! drop function unnest2(anyarray);
! select array_fill(null::integer, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::integer, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(7, array[3,3],array[2,2]);
!               array_fill              
! --------------------------------------
!  [2:4][2:4]={{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill(7, array[3,3]);
!         array_fill         
! ---------------------------
!  {{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! -- raise exception
! select array_fill(1, null, array[2,2]);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[2,2], null);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[3,3], array[1,1,1]);
! ERROR:  wrong number of array subscripts
! DETAIL:  Low bound array has different size than dimensions array.
! select array_fill(1, array[1,2,null]);
! ERROR:  dimension values cannot be null
! select string_to_array('1|2|3', '|');
!  string_to_array 
! -----------------
!  {1,2,3}
! (1 row)
! 
! select string_to_array('1|2|3|', '|');
!  string_to_array 
! -----------------
!  {1,2,3,""}
! (1 row)
! 
! select string_to_array('1||2|3||', '||');
!  string_to_array 
! -----------------
!  {1,2|3,""}
! (1 row)
! 
! select string_to_array('1|2|3', '');
!  string_to_array 
! -----------------
!  {1|2|3}
! (1 row)
! 
! select string_to_array('', '|');
!  string_to_array 
! -----------------
!  {}
! (1 row)
! 
! select string_to_array('1|2|3', NULL);
!  string_to_array 
! -----------------
!  {1,|,2,|,3}
! (1 row)
! 
! select string_to_array(NULL, '|') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select string_to_array('abc', '');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', '', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('abc', ',');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', ',', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',');
!  string_to_array 
! -----------------
!  {1,2,3,4,"",6}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',', '');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select string_to_array('1,2,3,4,*,6', ',', '*');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select array_to_string(NULL::int4[], ',') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_to_string('{}'::int4[], ',');
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',');
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
!  array_to_string 
! -----------------
!  1,2,3,4,*,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], NULL);
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(string_to_array('1|2|3', '|'), '|');
!  array_to_string 
! -----------------
!  1|2|3
! (1 row)
! 
! select array_length(array[1,2,3], 1);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 0);
!  array_length 
! --------------
!              
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 1);
!  array_length 
! --------------
!             2
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 2);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 3);
!  array_length 
! --------------
!              
! (1 row)
! 
! select cardinality(NULL::int[]);
!  cardinality 
! -------------
!             
! (1 row)
! 
! select cardinality('{}'::int[]);
!  cardinality 
! -------------
!            0
! (1 row)
! 
! select cardinality(array[1,2,3]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('[2:4]={5,6,7}'::int[]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('{{1,2}}'::int[]);
!  cardinality 
! -------------
!            2
! (1 row)
! 
! select cardinality('{{1,2},{3,4},{5,6}}'::int[]);
!  cardinality 
! -------------
!            6
! (1 row)
! 
! select cardinality('{{{1,9},{5,6}},{{2,3},{3,4}}}'::int[]);
!  cardinality 
! -------------
!            8
! (1 row)
! 
! select array_agg(unique1) from (select unique1 from tenk1 where unique1 < 15 order by unique1) ss;
!               array_agg               
! --------------------------------------
!  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14}
! (1 row)
! 
! select array_agg(ten) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!             array_agg            
! ---------------------------------
!  {0,1,2,3,4,5,6,7,8,9,0,1,2,3,4}
! (1 row)
! 
! select array_agg(nullif(ten, 4)) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!                array_agg               
! ---------------------------------------
!  {0,1,2,3,NULL,5,6,7,8,9,0,1,2,3,NULL}
! (1 row)
! 
! select array_agg(unique1) from tenk1 where unique1 < -15;
!  array_agg 
! -----------
!  
! (1 row)
! 
! select unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select * from unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select unnest(array[1,2,3,4.5]::float8[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,4.5]::numeric[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]);
!  unnest 
! --------
!       1
!       2
!       3
!        
!       4
!        
!        
!       5
!       6
! (9 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
!  unnest 
! --------
!  1
!  2
!  3
!  
!  4
!  
!  
!  5
!  6
! (9 rows)
! 
! select abs(unnest(array[1,2,null,-3]));
!  abs 
! -----
!    1
!    2
!     
!    3
! (4 rows)
! 
! select array_remove(array[1,2,2,3], 2);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array[1,2,2,3], 5);
!  array_remove 
! --------------
!  {1,2,2,3}
! (1 row)
! 
! select array_remove(array[1,NULL,NULL,3], NULL);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array['A','CC','D','C','RR'], 'RR');
!  array_remove 
! --------------
!  {A,CC,D,C}
! (1 row)
! 
! select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowed
! ERROR:  removing elements from multidimensional arrays is not supported
! select array_remove(array['X','X','X'], 'X') = '{}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,3);
!  array_replace 
! ---------------
!  {1,2,3,4}
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,NULL);
!  array_replace 
! ---------------
!  {1,2,NULL,4}
! (1 row)
! 
! select array_replace(array[1,2,NULL,4,NULL],NULL,5);
!  array_replace 
! ---------------
!  {1,2,5,4,5}
! (1 row)
! 
! select array_replace(array['A','B','DD','B'],'B','CC');
!  array_replace 
! ---------------
!  {A,CC,DD,CC}
! (1 row)
! 
! select array_replace(array[1,NULL,3],NULL,NULL);
!  array_replace 
! ---------------
!  {1,NULL,3}
! (1 row)
! 
! select array_replace(array['AB',NULL,'CDE'],NULL,'12');
!  array_replace 
! ---------------
!  {AB,12,CDE}
! (1 row)
! 
! -- Insert/update on a column that is array of composite
! create temp table t1 (f1 int8_tbl[]);
! insert into t1 (f1[5].q1) values(42);
! select * from t1;
!        f1        
! -----------------
!  [5:5]={"(42,)"}
! (1 row)
! 
! update t1 set f1[5].q2 = 43;
! select * from t1;
!         f1         
! -------------------
!  [5:5]={"(42,43)"}
! (1 row)
! 
! -- Check that arrays of composites are safely detoasted when needed
! create temp table src (f1 text);
! insert into src
!   select string_agg(random()::text,'') from generate_series(1,10000);
! create type textandtext as (c1 text, c2 text);
! create temp table dest (f1 textandtext[]);
! insert into dest select array[row(f1,f1)::textandtext] from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! delete from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! truncate table src;
! drop table src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! drop table dest;
! drop type textandtext;
! -- Tests for polymorphic-array form of width_bucket()
! -- this exercises the varwidth and float8 code paths
! SELECT
!     op,
!     width_bucket(op::numeric, ARRAY[1, 3, 5, 10.0]::numeric[]) AS wb_n1,
!     width_bucket(op::numeric, ARRAY[0, 5.5, 9.99]::numeric[]) AS wb_n2,
!     width_bucket(op::numeric, ARRAY[-6, -5, 2.0]::numeric[]) AS wb_n3,
!     width_bucket(op::float8, ARRAY[1, 3, 5, 10.0]::float8[]) AS wb_f1,
!     width_bucket(op::float8, ARRAY[0, 5.5, 9.99]::float8[]) AS wb_f2,
!     width_bucket(op::float8, ARRAY[-6, -5, 2.0]::float8[]) AS wb_f3
! FROM (VALUES
!   (-5.2),
!   (-0.0000000001),
!   (0.000000000001),
!   (1),
!   (1.99999999999999),
!   (2),
!   (2.00000000000001),
!   (3),
!   (4),
!   (4.5),
!   (5),
!   (5.5),
!   (6),
!   (7),
!   (8),
!   (9),
!   (9.99999999999999),
!   (10),
!   (10.0000000000001)
! ) v(op);
!         op        | wb_n1 | wb_n2 | wb_n3 | wb_f1 | wb_f2 | wb_f3 
! ------------------+-------+-------+-------+-------+-------+-------
!              -5.2 |     0 |     0 |     1 |     0 |     0 |     1
!     -0.0000000001 |     0 |     0 |     2 |     0 |     0 |     2
!    0.000000000001 |     0 |     1 |     2 |     0 |     1 |     2
!                 1 |     1 |     1 |     2 |     1 |     1 |     2
!  1.99999999999999 |     1 |     1 |     2 |     1 |     1 |     2
!                 2 |     1 |     1 |     3 |     1 |     1 |     3
!  2.00000000000001 |     1 |     1 |     3 |     1 |     1 |     3
!                 3 |     2 |     1 |     3 |     2 |     1 |     3
!                 4 |     2 |     1 |     3 |     2 |     1 |     3
!               4.5 |     2 |     1 |     3 |     2 |     1 |     3
!                 5 |     3 |     1 |     3 |     3 |     1 |     3
!               5.5 |     3 |     2 |     3 |     3 |     2 |     3
!                 6 |     3 |     2 |     3 |     3 |     2 |     3
!                 7 |     3 |     2 |     3 |     3 |     2 |     3
!                 8 |     3 |     2 |     3 |     3 |     2 |     3
!                 9 |     3 |     2 |     3 |     3 |     2 |     3
!  9.99999999999999 |     3 |     3 |     3 |     3 |     3 |     3
!                10 |     4 |     3 |     3 |     4 |     3 |     3
!  10.0000000000001 |     4 |     3 |     3 |     4 |     3 |     3
! (19 rows)
! 
! -- ensure float8 path handles NaN properly
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 9, 'NaN', 'NaN']::float8[]) AS wb
! FROM (VALUES
!   (-5.2::float8),
!   (4::float8),
!   (77::float8),
!   ('NaN'::float8)
! ) v(op);
!   op  | wb 
! ------+----
!  -5.2 |  0
!     4 |  2
!    77 |  3
!   NaN |  5
! (4 rows)
! 
! -- these exercise the generic fixed-width code path
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 5, 10]) AS wb_1
! FROM generate_series(0,11) as op;
!  op | wb_1 
! ----+------
!   0 |    0
!   1 |    1
!   2 |    1
!   3 |    2
!   4 |    2
!   5 |    3
!   6 |    3
!   7 |    3
!   8 |    3
!   9 |    3
!  10 |    4
!  11 |    4
! (12 rows)
! 
! SELECT width_bucket(now(),
!                     array['yesterday', 'today', 'tomorrow']::timestamptz[]);
!  width_bucket 
! --------------
!             2
! (1 row)
! 
! -- corner cases
! SELECT width_bucket(5, ARRAY[3]);
!  width_bucket 
! --------------
!             1
! (1 row)
! 
! SELECT width_bucket(5, '{}');
!  width_bucket 
! --------------
!             0
! (1 row)
! 
! -- error cases
! SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
! ERROR:  function width_bucket(text, integer[]) does not exist
! LINE 1: SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT width_bucket(5, ARRAY[3, 4, NULL]);
! ERROR:  thresholds array must not contain NULLs
! SELECT width_bucket(5, ARRAY[ARRAY[1, 2], ARRAY[3, 4]]);
! ERROR:  thresholds must be one-dimensional array
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/btree_index.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/btree_index.out	2015-01-10 10:11:46.287649454 +0300
***************
*** 1,152 ****
! --
! -- BTREE_INDEX
! -- test retrieval of min/max keys for each index
! --
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno < 1;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno >= 9999;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno = 4500;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno < '1'::name;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno >= '9999'::name;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno = '4500'::name;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno < '1'::text;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno >= '9999'::text;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno = '4500'::text;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno < '1'::float8;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno >= '9999'::float8;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno = '4500'::float8;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! --
! -- Check correct optimization of LIKE (special index operator support)
! -- for both indexscan and bitmapscan cases
! --
! set enable_seqscan to false;
! set enable_indexscan to true;
! set enable_bitmapscan to false;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! set enable_indexscan to false;
! set enable_bitmapscan to true;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! --
! -- Test B-tree page deletion. In particular, deleting a non-leaf page.
! --
! -- First create a tree that's at least four levels deep. The text inserted
! -- is long and poorly compressible. That way only a few index tuples fit on
! -- each page, allowing us to get a tall tree with fewer pages.
! create table btree_tall_tbl(id int4, t text);
! create index btree_tall_idx on btree_tall_tbl (id, t) with (fillfactor = 10);
! insert into btree_tall_tbl
!   select g, g::text || '_' ||
!           (select string_agg(md5(i::text), '_') from generate_series(1, 50) i)
! from generate_series(1, 100) g;
! -- Delete most entries, and vacuum. This causes page deletions.
! delete from btree_tall_tbl where id < 950;
! vacuum btree_tall_tbl;
! --
! -- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
! -- WAL record type). This happens when a "fast root" page is split.
! --
! -- The vacuum above should've turned the leaf page into a fast root. We just
! -- need to insert some rows to cause the fast root page to split.
! insert into btree_tall_tbl (id, t)
!   select g, repeat('x', 100) from generate_series(1, 500) g;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/hash_index.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/hash_index.out	2015-01-10 10:11:46.307649455 +0300
***************
*** 1,198 ****
! --
! -- HASH_INDEX
! -- grep 843938989 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 843938989;
!  seqno |  random   
! -------+-----------
!     15 | 843938989
! (1 row)
! 
! --
! -- hash index
! -- grep 66766766 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 66766766;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1505703298 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '1505703298'::name;
!  seqno |   random   
! -------+------------
!   9838 | 1505703298
! (1 row)
! 
! --
! -- hash index
! -- grep 7777777 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '7777777'::name;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1351610853 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '1351610853'::text;
!  seqno |   random   
! -------+------------
!   5677 | 1351610853
! (1 row)
! 
! --
! -- hash index
! -- grep 111111112222222233333333 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '111111112222222233333333'::text;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 444705537 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '444705537'::float8;
!  seqno |  random   
! -------+-----------
!   7853 | 444705537
! (1 row)
! 
! --
! -- hash index
! -- grep 88888888 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '88888888'::float8;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep '^90[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --    WHERE x = 90;
! --
! -- hash index
! -- grep '^1000[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --    WHERE x = 1000;
! --
! -- HASH
! --
! UPDATE hash_i4_heap
!    SET random = 1
!    WHERE hash_i4_heap.seqno = 1492;
! SELECT h.seqno AS i1492, h.random AS i1
!    FROM hash_i4_heap h
!    WHERE h.random = 1;
!  i1492 | i1 
! -------+----
!   1492 |  1
! (1 row)
! 
! UPDATE hash_i4_heap
!    SET seqno = 20000
!    WHERE hash_i4_heap.random = 1492795354;
! SELECT h.seqno AS i20000
!    FROM hash_i4_heap h
!    WHERE h.random = 1492795354;
!  i20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_name_heap
!    SET random = '0123456789abcdef'::name
!    WHERE hash_name_heap.seqno = 6543;
! SELECT h.seqno AS i6543, h.random AS c0_to_f
!    FROM hash_name_heap h
!    WHERE h.random = '0123456789abcdef'::name;
!  i6543 |     c0_to_f      
! -------+------------------
!   6543 | 0123456789abcdef
! (1 row)
! 
! UPDATE hash_name_heap
!    SET seqno = 20000
!    WHERE hash_name_heap.random = '76652222'::name;
! --
! -- this is the row we just replaced; index scan should return zero rows
! --
! SELECT h.seqno AS emptyset
!    FROM hash_name_heap h
!    WHERE h.random = '76652222'::name;
!  emptyset 
! ----------
! (0 rows)
! 
! UPDATE hash_txt_heap
!    SET random = '0123456789abcdefghijklmnop'::text
!    WHERE hash_txt_heap.seqno = 4002;
! SELECT h.seqno AS i4002, h.random AS c0_to_p
!    FROM hash_txt_heap h
!    WHERE h.random = '0123456789abcdefghijklmnop'::text;
!  i4002 |          c0_to_p           
! -------+----------------------------
!   4002 | 0123456789abcdefghijklmnop
! (1 row)
! 
! UPDATE hash_txt_heap
!    SET seqno = 20000
!    WHERE hash_txt_heap.random = '959363399'::text;
! SELECT h.seqno AS t20000
!    FROM hash_txt_heap h
!    WHERE h.random = '959363399'::text;
!  t20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET random = '-1234.1234'::float8
!    WHERE hash_f8_heap.seqno = 8906;
! SELECT h.seqno AS i8096, h.random AS f1234_1234
!    FROM hash_f8_heap h
!    WHERE h.random = '-1234.1234'::float8;
!  i8096 | f1234_1234 
! -------+------------
!   8906 | -1234.1234
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET seqno = 20000
!    WHERE hash_f8_heap.random = '488912369'::float8;
! SELECT h.seqno AS f20000
!    FROM hash_f8_heap h
!    WHERE h.random = '488912369'::float8;
!  f20000 
! --------
!   20000
! (1 row)
! 
! -- UPDATE hash_ovfl_heap
! --    SET x = 1000
! --   WHERE x = 90;
! -- this vacuums the index as well
! -- VACUUM hash_ovfl_heap;
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --   WHERE x = 90;
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --  WHERE x = 1000;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/update.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/update.out	2015-01-10 10:11:46.315649455 +0300
***************
*** 1,150 ****
! --
! -- UPDATE syntax tests
! --
! CREATE TABLE update_test (
!     a   INT DEFAULT 10,
!     b   INT,
!     c   TEXT
! );
! INSERT INTO update_test VALUES (5, 10, 'foo');
! INSERT INTO update_test(b, a) VALUES (15, 10);
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!   5 | 10 | foo
!  10 | 15 | 
! (2 rows)
! 
! UPDATE update_test SET a = DEFAULT, b = DEFAULT;
! SELECT * FROM update_test;
!  a  | b |  c  
! ----+---+-----
!  10 |   | foo
!  10 |   | 
! (2 rows)
! 
! -- aliases for the UPDATE target table
! UPDATE update_test AS t SET b = 10 WHERE t.a = 10;
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!  10 | 10 | foo
!  10 | 10 | 
! (2 rows)
! 
! UPDATE update_test t SET b = t.b + 10 WHERE t.a = 10;
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!  10 | 20 | foo
!  10 | 20 | 
! (2 rows)
! 
! --
! -- Test VALUES in FROM
! --
! UPDATE update_test SET a=v.i FROM (VALUES(100, 20)) AS v(i, j)
!   WHERE update_test.b = v.j;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
! (2 rows)
! 
! --
! -- Test multiple-set-clause syntax
! --
! INSERT INTO update_test SELECT a,b+1,c FROM update_test;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
!  100 | 21 | foo
!  100 | 21 | 
! (4 rows)
! 
! UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
! SELECT * FROM update_test;
!   a  | b  |   c   
! -----+----+-------
!  100 | 20 | 
!  100 | 21 | 
!   10 | 31 | bugle
!   10 | 32 | bugle
! (4 rows)
! 
! UPDATE update_test SET (c,b) = ('car', a+b), a = a + 1 WHERE a = 10;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | 
!  100 | 21 | 
!   11 | 41 | car
!   11 | 42 | car
! (4 rows)
! 
! -- fail, multi assignment to same column:
! UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
! ERROR:  multiple assignments to same column "b"
! -- uncorrelated sub-select:
! UPDATE update_test
!   SET (b,a) = (select a,b from update_test where b = 41 and c = 'car')
!   WHERE a = 100 AND b = 20;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 21 | 
!   11 | 41 | car
!   11 | 42 | car
!   41 | 11 | 
! (4 rows)
! 
! -- correlated sub-select:
! UPDATE update_test o
!   SET (b,a) = (select a+1,b from update_test i
!                where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
! SELECT * FROM update_test;
!  a  |  b  |  c  
! ----+-----+-----
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
!  11 |  42 | 
! (4 rows)
! 
! -- fail, multiple rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test);
! ERROR:  more than one row returned by a subquery used as an expression
! -- set to null if no rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)
!   WHERE a = 11;
! SELECT * FROM update_test;
!  a  |  b  |  c  
! ----+-----+-----
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
!     |     | 
! (4 rows)
! 
! -- if an alias for the target table is specified, don't allow references
! -- to the original table name
! UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
! ERROR:  invalid reference to FROM-clause entry for table "update_test"
! LINE 1: UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a...
!                                         ^
! HINT:  Perhaps you meant to reference the table alias "t".
! -- Make sure that we can update to a TOASTed value.
! UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
! SELECT a, b, char_length(c) FROM update_test;
!  a  |  b  | char_length 
! ----+-----+-------------
!  21 | 101 |            
!     |     |            
!  41 |  12 |       10000
!  42 |  12 |       10000
! (4 rows)
! 
! DROP TABLE update_test;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/namespace.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/namespace.out	2015-01-10 10:11:46.319649455 +0300
***************
*** 1,71 ****
! --
! -- Regression tests for schemas (namespaces)
! --
! CREATE SCHEMA test_schema_1
!        CREATE UNIQUE INDEX abc_a_idx ON abc (a)
!        CREATE VIEW abc_view AS
!               SELECT a+1 AS a, b+1 AS b FROM abc
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! -- verify that the objects were created
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      5
! (1 row)
! 
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! SELECT * FROM test_schema_1.abc;
!  a | b 
! ---+---
!  1 |  
!  2 |  
!  3 |  
! (3 rows)
! 
! SELECT * FROM test_schema_1.abc_view;
!  a | b 
! ---+---
!  2 |  
!  3 |  
!  4 |  
! (3 rows)
! 
! ALTER SCHEMA test_schema_1 RENAME TO test_schema_renamed;
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      0
! (1 row)
! 
! -- test IF NOT EXISTS cases
! CREATE SCHEMA test_schema_renamed; -- fail, already exists
! ERROR:  schema "test_schema_renamed" already exists
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed; -- ok with notice
! NOTICE:  schema "test_schema_renamed" already exists, skipping
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed -- fail, disallowed
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! ERROR:  CREATE SCHEMA IF NOT EXISTS cannot include schema elements
! LINE 2:        CREATE TABLE abc (
!                ^
! DROP SCHEMA test_schema_renamed CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table test_schema_renamed.abc
! drop cascades to view test_schema_renamed.abc_view
! -- verify that the objects were dropped
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_renamed');
!  count 
! -------
!      0
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/prepared_xacts.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/prepared_xacts.out	2015-01-10 10:11:46.311649455 +0300
***************
*** 1,254 ****
! --
! -- PREPARED TRANSACTIONS (two-phase commit)
! --
! -- We can't readily test persistence of prepared xacts within the
! -- regression script framework, unfortunately.  Note that a crash
! -- isn't really needed ... stopping and starting the postmaster would
! -- be enough, but we can't even do that here.
! -- create a simple table that we'll use in the tests
! CREATE TABLE pxtest1 (foobar VARCHAR(10));
! INSERT INTO pxtest1 VALUES ('aaa');
! -- Test PREPARE TRANSACTION
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'bbb' WHERE foobar = 'aaa';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  bbb
! (1 row)
! 
! PREPARE TRANSACTION 'foo1';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! -- Test pg_prepared_xacts system view
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo1
! (1 row)
! 
! -- Test ROLLBACK PREPARED
! ROLLBACK PREPARED 'foo1';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Test COMMIT PREPARED
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! INSERT INTO pxtest1 VALUES ('ddd');
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! PREPARE TRANSACTION 'foo2';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! COMMIT PREPARED 'foo2';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- Test duplicate gids
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'eee' WHERE foobar = 'ddd';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  eee
! (2 rows)
! 
! PREPARE TRANSACTION 'foo3';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo3
! (1 row)
! 
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! INSERT INTO pxtest1 VALUES ('fff');
! -- This should fail, because the gid foo3 is already in use
! PREPARE TRANSACTION 'foo3';
! ERROR:  transaction identifier "foo3" is already in use
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! ROLLBACK PREPARED 'foo3';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- Test serialization failure (SSI)
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'eee' WHERE foobar = 'ddd';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  eee
! (2 rows)
! 
! PREPARE TRANSACTION 'foo4';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo4
! (1 row)
! 
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- This should fail, because the two transactions have a write-skew anomaly
! INSERT INTO pxtest1 VALUES ('fff');
! ERROR:  could not serialize access due to read/write dependencies among transactions
! DETAIL:  Reason code: Canceled on identification as a pivot, during write.
! HINT:  The transaction might succeed if retried.
! PREPARE TRANSACTION 'foo5';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo4
! (1 row)
! 
! ROLLBACK PREPARED 'foo4';
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Clean up
! DROP TABLE pxtest1;
! -- Test subtransactions
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
!   CREATE TABLE pxtest2 (a int);
!   INSERT INTO pxtest2 VALUES (1);
!   SAVEPOINT a;
!     INSERT INTO pxtest2 VALUES (2);
!   ROLLBACK TO a;
!   SAVEPOINT b;
!   INSERT INTO pxtest2 VALUES (3);
! PREPARE TRANSACTION 'regress-one';
! CREATE TABLE pxtest3(fff int);
! -- Test shared invalidation
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
!   DROP TABLE pxtest3;
!   CREATE TABLE pxtest4 (a int);
!   INSERT INTO pxtest4 VALUES (1);
!   INSERT INTO pxtest4 VALUES (2);
!   DECLARE foo CURSOR FOR SELECT * FROM pxtest4;
!   -- Fetch 1 tuple, keeping the cursor open
!   FETCH 1 FROM foo;
!  a 
! ---
!  1
! (1 row)
! 
! PREPARE TRANSACTION 'regress-two';
! -- No such cursor
! FETCH 1 FROM foo;
! ERROR:  cursor "foo" does not exist
! -- Table doesn't exist, the creation hasn't been committed yet
! SELECT * FROM pxtest2;
! ERROR:  relation "pxtest2" does not exist
! LINE 1: SELECT * FROM pxtest2;
!                       ^
! -- There should be two prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-one
!  regress-two
! (2 rows)
! 
! -- pxtest3 should be locked because of the pending DROP
! set statement_timeout to 2000;
! SELECT * FROM pxtest3;
! ERROR:  canceling statement due to statement timeout
! reset statement_timeout;
! -- Disconnect, we will continue testing in a different backend
! \c -
! -- There should still be two prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-one
!  regress-two
! (2 rows)
! 
! -- pxtest3 should still be locked because of the pending DROP
! set statement_timeout to 2000;
! SELECT * FROM pxtest3;
! ERROR:  canceling statement due to statement timeout
! reset statement_timeout;
! -- Commit table creation
! COMMIT PREPARED 'regress-one';
! \d pxtest2
!     Table "public.pxtest2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
! 
! SELECT * FROM pxtest2;
!  a 
! ---
!  1
!  3
! (2 rows)
! 
! -- There should be one prepared transaction
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-two
! (1 row)
! 
! -- Commit table drop
! COMMIT PREPARED 'regress-two';
! SELECT * FROM pxtest3;
! ERROR:  relation "pxtest3" does not exist
! LINE 1: SELECT * FROM pxtest3;
!                       ^
! -- There should be no prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Clean up
! DROP TABLE pxtest2;
! DROP TABLE pxtest3;  -- will still be there if prepared xacts are disabled
! ERROR:  table "pxtest3" does not exist
! DROP TABLE pxtest4;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/delete.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/delete.out	2015-01-10 10:11:46.287649454 +0300
***************
*** 1,33 ****
! CREATE TABLE delete_test (
!     id SERIAL PRIMARY KEY,
!     a INT,
!     b text
! );
! INSERT INTO delete_test (a) VALUES (10);
! INSERT INTO delete_test (a, b) VALUES (50, repeat('x', 10000));
! INSERT INTO delete_test (a) VALUES (100);
! -- allow an alias to be specified for DELETE's target table
! DELETE FROM delete_test AS dt WHERE dt.a > 75;
! -- if an alias is specified, don't allow the original table name
! -- to be referenced
! DELETE FROM delete_test dt WHERE delete_test.a > 25;
! ERROR:  invalid reference to FROM-clause entry for table "delete_test"
! LINE 1: DELETE FROM delete_test dt WHERE delete_test.a > 25;
!                                          ^
! HINT:  Perhaps you meant to reference the table alias "dt".
! SELECT id, a, char_length(b) FROM delete_test;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
!   2 | 50 |       10000
! (2 rows)
! 
! -- delete a row with a TOASTed value
! DELETE FROM delete_test WHERE a > 25;
! SELECT id, a, char_length(b) FROM delete_test;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
! (1 row)
! 
! DROP TABLE delete_test;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/brin.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/brin.out	2015-01-10 10:11:46.671649463 +0300
***************
*** 1,182 ****
! CREATE TABLE brintest (byteacol bytea,
! 	charcol "char",
! 	namecol name,
! 	int8col bigint,
! 	int2col smallint,
! 	int4col integer,
! 	textcol text,
! 	oidcol oid,
! 	tidcol tid,
! 	float4col real,
! 	float8col double precision,
! 	macaddrcol macaddr,
! 	inetcol inet,
! 	bpcharcol character,
! 	datecol date,
! 	timecol time without time zone,
! 	timestampcol timestamp without time zone,
! 	timestamptzcol timestamp with time zone,
! 	intervalcol interval,
! 	timetzcol time with time zone,
! 	bitcol bit(10),
! 	varbitcol bit varying(16),
! 	numericcol numeric,
! 	uuidcol uuid,
! 	lsncol pg_lsn
! ) WITH (fillfactor=10);
! INSERT INTO brintest SELECT
! 	repeat(stringu1, 42)::bytea,
! 	substr(stringu1, 1, 1)::"char",
! 	stringu1::name, 142857 * tenthous,
! 	thousand,
! 	twothousand,
! 	repeat(stringu1, 42),
! 	unique1::oid,
! 	format('(%s,%s)', tenthous, twenty)::tid,
! 	(four + 1.0)/(hundred+1),
! 	odd::float8 / (tenthous + 1),
! 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
! 	inet '10.2.3.4' + tenthous,
! 	substr(stringu1, 1, 1)::bpchar,
! 	date '1995-08-15' + tenthous,
! 	time '01:20:30' + thousand * interval '18.5 second',
! 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
! 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
! 	justify_days(justify_hours(tenthous * interval '12 minutes')),
! 	timetz '01:30:20' + hundred * interval '15 seconds',
! 	thousand::bit(10),
! 	tenthous::bit(16)::varbit,
! 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
! 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
! 	format('%s/%s%s', odd, even, tenthous)::pg_lsn
! FROM tenk1 LIMIT 5;
! -- throw in some NULL-only tuples too
! INSERT INTO brintest SELECT NULL FROM tenk1 LIMIT 25;
! CREATE INDEX brinidx ON brintest USING brin (
! 	byteacol,
! 	charcol,
! 	namecol,
! 	int8col,
! 	int2col,
! 	int4col,
! 	textcol,
! 	oidcol,
! 	tidcol,
! 	float4col,
! 	float8col,
! 	macaddrcol,
! 	inetcol,
! 	bpcharcol,
! 	datecol,
! 	timecol,
! 	timestampcol,
! 	timestamptzcol,
! 	intervalcol,
! 	timetzcol,
! 	bitcol,
! 	varbitcol,
! 	numericcol,
! 	uuidcol,
! 	lsncol
! ) with (pages_per_range = 1);
! BEGIN;
! CREATE TABLE brinopers (colname name, op text[], value text[],
! 	check (cardinality(op) = cardinality(value)));
! INSERT INTO brinopers VALUES ('byteacol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAAA, AAAAAA, AAAAAA}');
! INSERT INTO brinopers VALUES ('charcol', '{>, >=, =, <=, <}', '{Z, Z, A, A, A}');
! INSERT INTO brinopers VALUES ('namecol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAAA, AAAAAA, AAAAAA}');
! INSERT INTO brinopers VALUES ('int8col', '{>, >=, =, <=, <}', '{1428427143, 1428427143, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('int2col', '{>, >=, =, <=, <}', '{999, 999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('int4col', '{>, >=, =, <=, <}', '{1999, 1999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('textcol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAA, AAAAA, AAAAA}');
! INSERT INTO brinopers VALUES ('oidcol', '{>, >=, =, <=, <}', '{9999, 9999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('tidcol', '{>, >=, =, <=, <}', '{"(9999,19)", "(9999,19)", "(0,0)", "(0,0)", "(0,0)"}');
! INSERT INTO brinopers VALUES ('float4col', '{>, >=, =, <=, <}', '{1, 1, 0.0103093, 0.0103093, 0.0103093}');
! INSERT INTO brinopers VALUES ('float8col', '{>, >=, =, <=, <}', '{1.98, 1.98, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('inetcol', '{>, >=, =, <=, <}', '{10.2.42.19, 10.2.42.19, 10.2.3.4, 10.2.3.4, 10.2.3.4}');
! INSERT INTO brinopers VALUES ('bpcharcol', '{>, >=, =, <=, <}', '{Z, Z, A, A, A}');
! INSERT INTO brinopers VALUES ('datecol', '{>, >=, =, <=, <}', '{2022-12-30, 2022-12-30, 1995-08-15, 1995-08-15, 1995-08-15}');
! INSERT INTO brinopers VALUES ('timecol', '{>, >=, =, <=, <}', '{06:28:31.5, 06:28:31.5, 01:20:30, 01:20:30, 01:20:30}');
! INSERT INTO brinopers VALUES ('timestampcol', '{>, >=, =, <=, <}', '{1984-01-20 22:42:21, 1984-01-20 22:42:21, 1942-07-23 03:05:09, 1942-07-23 03:05:09, 1942-07-23 03:05:09}');
! INSERT INTO brinopers VALUES ('timestamptzcol', '{>, >=, =, <=, <}', '{1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03, 1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04}');
! INSERT INTO brinopers VALUES ('intervalcol', '{>, >=, =, <=, <}', '{2 mons 23 days 07:48:00, 2 mons 23 days 07:48:00, 00:00:00, 00:00:00, 00:00:00}');
! INSERT INTO brinopers VALUES ('timetzcol', '{>, >=, =, <=, <}', '{01:55:05-03, 01:55:05-03, 01:30:20-03, 01:30:20-03, 01:30:20-03}');
! INSERT INTO brinopers VALUES ('numericcol', '{>, >=, =, <=, <}', '{99470151.9, 99470151.9, 0.00, 0.01, 0.01}');
! INSERT INTO brinopers VALUES ('macaddrcol', '{>, >=, =, <=, <}', '{ff:fe:00:00:00:00, ff:fe:00:00:00:00, 00:00:01:00:00:00, 00:00:01:00:00:00, 00:00:01:00:00:00}');
! INSERT INTO brinopers VALUES ('bitcol', '{>, >=, =, <=, <}', '{1111111000, 1111111000, 0000000010, 0000000010, 0000000010}');
! INSERT INTO brinopers VALUES ('varbitcol', '{>, >=, =, <=, <}', '{1111111111111000, 1111111111111000, 0000000000000100, 0000000000000100, 0000000000000100}');
! INSERT INTO brinopers VALUES ('uuidcol', '{>, >=, =, <=, <}', '{99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998, 00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040005}');
! INSERT INTO brinopers VALUES ('lsncol', '{>, >=, =, <=, <, IS, IS NOT}', '{198/1999799, 198/1999799, 30/312815, 0/1200, 0/1200, NULL, NULL}');
! COMMIT;
! DO $x$
! DECLARE
!         r record;
!         tabname text;
!         tabname_ss text;
! 		count int;
! 		query text;
! 		plan text;
! BEGIN
!         FOR r IN SELECT row_number() OVER (), colname, oper, value[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP
!                 tabname := format('qry_%s', r.row_number);
!                 tabname_ss := tabname || '_ss';
! 				query = format($y$INSERT INTO %s SELECT ctid FROM brintest WHERE %s %s %L $y$,
!                         tabname, r.colname, r.oper, r.value);
! 				-- run the query using the brin index
!                 SET enable_seqscan = 0;
!                 SET enable_bitmapscan = 1;
!                 EXECUTE format('create temp table %s (tid tid) ON COMMIT DROP', tabname);
!                 EXECUTE query;
! 
! 				-- run the query using a seqscan
!                 SET enable_seqscan = 1;
!                 SET enable_bitmapscan = 0;
! 				query = format($y$INSERT INTO %s SELECT ctid FROM brintest WHERE %s %s %L $y$,
!                         tabname_ss, r.colname, r.oper, r.value);
!                 EXECUTE format('create temp table %s (tid tid) ON COMMIT DROP', tabname_ss);
!                 EXECUTE query;
! 
! 				-- make sure both return the same results
!                 EXECUTE format('SELECT * from %s EXCEPT ALL SELECT * FROM %s', tabname, tabname_ss);
! 				GET DIAGNOSTICS count = ROW_COUNT;
!                 IF count <> 0 THEN RAISE EXCEPTION 'something not right in %: count %', r, count; END IF;
!                 EXECUTE format('SELECT * from %s EXCEPT ALL SELECT * FROM %s', tabname_ss, tabname);
! 				GET DIAGNOSTICS count = ROW_COUNT;
!                 IF count <> 0 THEN RAISE EXCEPTION 'something not right in %: count %', r, count; END IF;
!         end loop;
! end;
! $x$;
! INSERT INTO brintest SELECT
! 	repeat(stringu1, 42)::bytea,
! 	substr(stringu1, 1, 1)::"char",
! 	stringu1::name, 142857 * tenthous,
! 	thousand,
! 	twothousand,
! 	repeat(stringu1, 42),
! 	unique1::oid,
! 	format('(%s,%s)', tenthous, twenty)::tid,
! 	(four + 1.0)/(hundred+1),
! 	odd::float8 / (tenthous + 1),
! 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
! 	inet '10.2.3.4' + tenthous,
! 	substr(stringu1, 1, 1)::bpchar,
! 	date '1995-08-15' + tenthous,
! 	time '01:20:30' + thousand * interval '18.5 second',
! 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
! 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
! 	justify_days(justify_hours(tenthous * interval '12 minutes')),
! 	timetz '01:30:20' + hundred * interval '15 seconds',
! 	thousand::bit(10),
! 	tenthous::bit(16)::varbit,
! 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
! 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
! 	format('%s/%s%s', odd, even, tenthous)::pg_lsn
! FROM tenk1 LIMIT 5 OFFSET 5;
! SELECT brin_summarize_new_values('brinidx'::regclass);
!  brin_summarize_new_values 
! ---------------------------
!                          5
! (1 row)
! 
! UPDATE brintest SET int8col = int8col * int4col;
! UPDATE brintest SET textcol = '' WHERE textcol IS NOT NULL;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/gin.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/gin.out	2015-01-10 10:11:46.667649463 +0300
***************
*** 1,23 ****
! --
! -- Test GIN indexes.
! --
! -- There are other tests to test different GIN opclassed. This is for testing
! -- GIN itself.
! -- Create and populate a test table with a GIN index.
! create table gin_test_tbl(i int4[]);
! create index gin_test_idx on gin_test_tbl using gin (i) with (fastupdate = on);
! insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
! insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
! vacuum gin_test_tbl; -- flush the fastupdate buffers
! -- Test vacuuming
! delete from gin_test_tbl where i @> array[2];
! vacuum gin_test_tbl;
! -- Disable fastupdate, and do more insertions. With fastupdate enabled, most
! -- insertions (by flushing the list pages) cause page splits. Without
! -- fastupdate, we get more churn in the GIN data leaf pages, and exercise the
! -- recompression codepaths.
! alter index gin_test_idx set (fastupdate = off);
! insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 1000) g;
! insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
! delete from gin_test_tbl where i @> array[2];
! vacuum gin_test_tbl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/gist.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/gist.out	2015-01-10 10:11:46.671649463 +0300
***************
*** 1,19 ****
! --
! -- Test GiST indexes.
! --
! -- There are other tests to test different GiST opclasses. This is for
! -- testing GiST code itself. Vacuuming in particular.
! create table gist_point_tbl(id int4, p point);
! create index gist_pointidx on gist_point_tbl using gist(p);
! -- Insert enough data to create a tree that's a couple of levels deep.
! insert into gist_point_tbl (id, p)
! select g,        point(g*10, g*10) from generate_series(1, 10000) g;
! insert into gist_point_tbl (id, p)
! select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
! -- To test vacuum, delete some entries from all over the index.
! delete from gist_point_tbl where id % 2 = 1;
! -- And also delete some concentration of values. (GiST doesn't currently
! -- attempt to delete pages even when they become empty, but if it did, this
! -- would exercise it)
! delete from gist_point_tbl where id < 10000;
! vacuum gist_point_tbl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/spgist.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/spgist.out	2015-01-10 10:11:46.659649463 +0300
***************
*** 1,39 ****
! --
! -- Test SP-GiST indexes.
! --
! -- There are other tests to test different SP-GiST opclasses. This is for
! -- testing SP-GiST code itself.
! create table spgist_point_tbl(id int4, p point);
! create index spgist_point_idx on spgist_point_tbl using spgist(p);
! -- Test vacuum-root operation. It gets invoked when the root is also a leaf,
! -- i.e. the index is very small.
! insert into spgist_point_tbl (id, p)
! select g, point(g*10, g*10) from generate_series(1, 10) g;
! delete from spgist_point_tbl where id < 5;
! vacuum spgist_point_tbl;
! -- Insert more data, to make the index a few levels deep.
! insert into spgist_point_tbl (id, p)
! select g,      point(g*10, g*10) from generate_series(1, 10000) g;
! insert into spgist_point_tbl (id, p)
! select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
! -- To test vacuum, delete some entries from all over the index.
! delete from spgist_point_tbl where id % 2 = 1;
! -- And also delete some concentration of values. (SP-GiST doesn't currently
! -- attempt to delete pages even when they become empty, but if it did, this
! -- would exercise it)
! delete from spgist_point_tbl where id < 10000;
! vacuum spgist_point_tbl;
! -- The point opclass's choose method only uses the spgMatchNode action,
! -- so the other actions are not tested by the above. Create an index using
! -- text opclass, which uses the others actions.
! create table spgist_text_tbl(id int4, t text);
! create index spgist_text_idx on spgist_text_tbl using spgist(t);
! insert into spgist_text_tbl (id, t)
! select g, 'f' || repeat('o', 100) || g from generate_series(1, 10000) g
! union all
! select g, 'baaaaaaaaaaaaaar' || g from generate_series(1, 1000) g;
! -- Do a lot of insertions that have to split an existing node. Hopefully
! -- one of these will cause the page to run out of space, causing the inner
! -- tuple to be moved to another page.
! insert into spgist_text_tbl (id, t)
! select -g, 'f' || repeat('o', 100-g) || 'surprise' from generate_series(1, 100) g;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/privileges.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/privileges.out	2015-01-10 10:11:46.651649463 +0300
***************
*** 1,1509 ****
! --
! -- Test access privileges
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when users/groups don't exist
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS regressgroup1;
! DROP ROLE IF EXISTS regressgroup2;
! DROP ROLE IF EXISTS regressuser1;
! DROP ROLE IF EXISTS regressuser2;
! DROP ROLE IF EXISTS regressuser3;
! DROP ROLE IF EXISTS regressuser4;
! DROP ROLE IF EXISTS regressuser5;
! DROP ROLE IF EXISTS regressuser6;
! SELECT lo_unlink(oid) FROM pg_largeobject_metadata;
!  lo_unlink 
! -----------
! (0 rows)
! 
! RESET client_min_messages;
! -- test proper begins here
! CREATE USER regressuser1;
! CREATE USER regressuser2;
! CREATE USER regressuser3;
! CREATE USER regressuser4;
! CREATE USER regressuser5;
! CREATE USER regressuser5;	-- duplicate
! ERROR:  role "regressuser5" already exists
! CREATE GROUP regressgroup1;
! CREATE GROUP regressgroup2 WITH USER regressuser1, regressuser2;
! ALTER GROUP regressgroup1 ADD USER regressuser4;
! ALTER GROUP regressgroup2 ADD USER regressuser2;	-- duplicate
! NOTICE:  role "regressuser2" is already a member of role "regressgroup2"
! ALTER GROUP regressgroup2 DROP USER regressuser2;
! GRANT regressgroup2 TO regressuser4 WITH ADMIN OPTION;
! -- test owner privileges
! SET SESSION AUTHORIZATION regressuser1;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser1 | regressuser1
! (1 row)
! 
! CREATE TABLE atest1 ( a int, b text );
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! INSERT INTO atest1 VALUES (1, 'one');
! DELETE FROM atest1;
! UPDATE atest1 SET a = 1 WHERE b = 'blech';
! TRUNCATE atest1;
! BEGIN;
! LOCK atest1 IN ACCESS EXCLUSIVE MODE;
! COMMIT;
! REVOKE ALL ON atest1 FROM PUBLIC;
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! GRANT ALL ON atest1 TO regressuser2;
! GRANT SELECT ON atest1 TO regressuser3, regressuser4;
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
! GRANT SELECT ON atest2 TO regressuser2;
! GRANT UPDATE ON atest2 TO regressuser3;
! GRANT INSERT ON atest2 TO regressuser4;
! GRANT TRUNCATE ON atest2 TO regressuser5;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser2 | regressuser2
! (1 row)
! 
! -- try various combinations of queries on atest1 and atest2
! SELECT * FROM atest1; -- ok
!  a | b 
! ---+---
! (0 rows)
! 
! SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
! (0 rows)
! 
! INSERT INTO atest1 VALUES (2, 'two'); -- ok
! INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
! UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
! UPDATE atest2 SET col2 = NOT col2; -- fail
! ERROR:  permission denied for relation atest2
! SELECT * FROM atest1 FOR UPDATE; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest2
! DELETE FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! TRUNCATE atest2; -- fail
! ERROR:  permission denied for relation atest2
! BEGIN;
! LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
! ERROR:  permission denied for relation atest2
! COMMIT;
! COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for relation atest2
! GRANT ALL ON atest1 TO PUBLIC; -- fail
! WARNING:  no privileges were granted for "atest1"
! -- checks in subquery, both ok
! SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
!  a | b 
! ---+---
! (0 rows)
! 
! SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
!  col1 | col2 
! ------+------
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser3;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser3 | regressuser3
! (1 row)
! 
! SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 VALUES (2, 'two'); -- fail
! ERROR:  permission denied for relation atest1
! INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
! ERROR:  permission denied for relation atest1
! UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
! ERROR:  permission denied for relation atest1
! UPDATE atest2 SET col2 = NULL; -- ok
! UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
! ERROR:  permission denied for relation atest2
! UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- ok
! SELECT * FROM atest1 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest1
! SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest2
! DELETE FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! TRUNCATE atest2; -- fail
! ERROR:  permission denied for relation atest2
! BEGIN;
! LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
! COMMIT;
! COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for relation atest2
! -- checks in subquery, both fail
! SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
! ERROR:  permission denied for relation atest2
! SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
! ERROR:  permission denied for relation atest2
! SET SESSION AUTHORIZATION regressuser4;
! COPY atest2 FROM stdin; -- ok
! SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! -- groups
! SET SESSION AUTHORIZATION regressuser3;
! CREATE TABLE atest3 (one int, two int, three int);
! GRANT DELETE ON atest3 TO GROUP regressgroup2;
! SET SESSION AUTHORIZATION regressuser1;
! SELECT * FROM atest3; -- fail
! ERROR:  permission denied for relation atest3
! DELETE FROM atest3; -- ok
! -- views
! SET SESSION AUTHORIZATION regressuser3;
! CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
! /* The next *should* fail, but it's not implemented that way yet. */
! CREATE VIEW atestv2 AS SELECT * FROM atest2;
! CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
! /* Empty view is a corner case that failed in 9.2. */
! CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
! SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for relation atest2
! GRANT SELECT ON atestv1, atestv3 TO regressuser4;
! GRANT SELECT ON atestv2 TO regressuser2;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for relation atestv2
! SELECT * FROM atestv3; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! SELECT * FROM atestv0; -- fail
! ERROR:  permission denied for relation atestv0
! -- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
! select * from
!   ((select a.q1 as x from int8_tbl a offset 0)
!    union all
!    (select b.q2 as x from int8_tbl b offset 0)) ss
! where false;
! ERROR:  permission denied for relation int8_tbl
! set constraint_exclusion = on;
! select * from
!   ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
!    union all
!    (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
! where x < 0;
! ERROR:  permission denied for relation int8_tbl
! reset constraint_exclusion;
! CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
! SELECT * FROM atestv4; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! GRANT SELECT ON atestv4 TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! -- Two complex cases:
! SELECT * FROM atestv3; -- fail
! ERROR:  permission denied for relation atestv3
! SELECT * FROM atestv4; -- ok (even though regressuser2 cannot access underlying atestv3)
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
!  bar  | t
! (1 row)
! 
! SELECT * FROM atestv2; -- fail (even though regressuser2 can access underlying atest2)
! ERROR:  permission denied for relation atest2
! -- Test column level permissions
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atest5 (one int, two int, three int);
! CREATE TABLE atest6 (one int, two int, blue int);
! GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regressuser4;
! GRANT ALL (one) ON atest5 TO regressuser3;
! INSERT INTO atest5 VALUES (1,2,3);
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! SELECT one FROM atest5; -- ok
!  one 
! -----
!    1
! (1 row)
! 
! COPY atest5 (one) TO stdout; -- ok
! 1
! SELECT two FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (two) TO stdout; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest5 FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (one,two) TO stdout; -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5; -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
! ERROR:  permission denied for relation atest5
! SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5 WHERE two = 2; -- fail
! ERROR:  permission denied for relation atest5
! SELECT * FROM atest1, atest5; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest1.* FROM atest1, atest5; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
! SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
! SELECT one, two FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT (one,two) ON atest6 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT (two) ON atest5 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
!  one | two 
! -----+-----
! (0 rows)
! 
! -- test column-level privileges for INSERT and UPDATE
! INSERT INTO atest5 (two) VALUES (3); -- ok
! COPY atest5 FROM stdin; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (two) FROM stdin; -- ok
! INSERT INTO atest5 (three) VALUES (4); -- fail
! ERROR:  permission denied for relation atest5
! INSERT INTO atest5 VALUES (5,5,5); -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET three = 10; -- ok
! UPDATE atest5 SET one = 8; -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET three = 5, one = 2; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! REVOKE ALL (one) ON atest5 FROM regressuser4;
! GRANT SELECT (one,two,blue) ON atest6 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET one = 1; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
! COPY atest6 TO stdout; -- ok
! -- test column-level privileges when involved with DELETE
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 ADD COLUMN three integer;
! GRANT DELETE ON atest5 TO regressuser3;
! GRANT SELECT (two) ON atest5 TO regressuser3;
! REVOKE ALL (one) ON atest5 FROM regressuser3;
! GRANT SELECT (one) ON atest5 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT atest6 FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 DROP COLUMN three;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
! SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
!  one 
! -----
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 DROP COLUMN two;
! REVOKE SELECT (one,blue) ON atest6 FROM regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SELECT 1 FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SET SESSION AUTHORIZATION regressuser3;
! DELETE FROM atest5 WHERE one = 1; -- fail
! ERROR:  permission denied for relation atest5
! DELETE FROM atest5 WHERE two = 2; -- ok
! -- check inheritance cases
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS;
! CREATE TABLE atestp2 (fx int, fy int) WITH OIDS;
! CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
! GRANT SELECT(fx,fy,oid) ON atestp2 TO regressuser2;
! GRANT SELECT(fx) ON atestc TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT fx FROM atestp2; -- ok
!  fx 
! ----
! (0 rows)
! 
! SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
! SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
! SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
! SELECT fy FROM atestc; -- fail
! ERROR:  permission denied for relation atestc
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT(fy,oid) ON atestc TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT fx FROM atestp2; -- still ok
!  fx 
! ----
! (0 rows)
! 
! SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
! SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
! SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
! -- privileges on functions, languages
! -- switch to superuser
! \c -
! REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
! GRANT USAGE ON LANGUAGE sql TO regressuser1; -- ok
! GRANT USAGE ON LANGUAGE c TO PUBLIC; -- fail
! ERROR:  language "c" is not trusted
! HINT:  Only superusers can use untrusted languages.
! SET SESSION AUTHORIZATION regressuser1;
! GRANT USAGE ON LANGUAGE sql TO regressuser2; -- fail
! WARNING:  no privileges were granted for "sql"
! CREATE FUNCTION testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
! CREATE FUNCTION testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
! REVOKE ALL ON FUNCTION testfunc1(int), testfunc2(int) FROM PUBLIC;
! GRANT EXECUTE ON FUNCTION testfunc1(int), testfunc2(int) TO regressuser2;
! GRANT USAGE ON FUNCTION testfunc1(int) TO regressuser3; -- semantic error
! ERROR:  invalid privilege type USAGE for function
! GRANT ALL PRIVILEGES ON FUNCTION testfunc1(int) TO regressuser4;
! GRANT ALL PRIVILEGES ON FUNCTION testfunc_nosuch(int) TO regressuser4;
! ERROR:  function testfunc_nosuch(integer) does not exist
! CREATE FUNCTION testfunc4(boolean) RETURNS text
!   AS 'select col1 from atest2 where col2 = $1;'
!   LANGUAGE sql SECURITY DEFINER;
! GRANT EXECUTE ON FUNCTION testfunc4(boolean) TO regressuser3;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT testfunc1(5), testfunc2(5); -- ok
!  testfunc1 | testfunc2 
! -----------+-----------
!         10 |        15
! (1 row)
! 
! CREATE FUNCTION testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
! ERROR:  permission denied for language sql
! SET SESSION AUTHORIZATION regressuser3;
! SELECT testfunc1(5); -- fail
! ERROR:  permission denied for function testfunc1
! SELECT col1 FROM atest2 WHERE col2 = true; -- fail
! ERROR:  permission denied for relation atest2
! SELECT testfunc4(true); -- ok
!  testfunc4 
! -----------
!  bar
! (1 row)
! 
! SET SESSION AUTHORIZATION regressuser4;
! SELECT testfunc1(5); -- ok
!  testfunc1 
! -----------
!         10
! (1 row)
! 
! DROP FUNCTION testfunc1(int); -- fail
! ERROR:  must be owner of function testfunc1
! \c -
! DROP FUNCTION testfunc1(int); -- ok
! -- restore to sanity
! GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
! -- privileges on types
! -- switch to superuser
! \c -
! CREATE TYPE testtype1 AS (a int, b text);
! REVOKE USAGE ON TYPE testtype1 FROM PUBLIC;
! GRANT USAGE ON TYPE testtype1 TO regressuser2;
! GRANT USAGE ON TYPE _testtype1 TO regressuser2; -- fail
! ERROR:  cannot set privileges of array types
! HINT:  Set the privileges of the element type instead.
! GRANT USAGE ON DOMAIN testtype1 TO regressuser2; -- fail
! ERROR:  "testtype1" is not a domain
! CREATE DOMAIN testdomain1 AS int;
! REVOKE USAGE on DOMAIN testdomain1 FROM PUBLIC;
! GRANT USAGE ON DOMAIN testdomain1 TO regressuser2;
! GRANT USAGE ON TYPE testdomain1 TO regressuser2; -- ok
! SET SESSION AUTHORIZATION regressuser1;
! -- commands that should fail
! CREATE AGGREGATE testagg1a(testdomain1) (sfunc = int4_sum, stype = bigint);
! ERROR:  permission denied for type testdomain1
! CREATE DOMAIN testdomain2a AS testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE DOMAIN testdomain3a AS int;
! CREATE FUNCTION castfunc(int) RETURNS testdomain3a AS $$ SELECT $1::testdomain3a $$ LANGUAGE SQL;
! CREATE CAST (testdomain1 AS testdomain3a) WITH FUNCTION castfunc(int);
! ERROR:  permission denied for type testdomain1
! DROP FUNCTION castfunc(int) CASCADE;
! DROP DOMAIN testdomain3a;
! CREATE FUNCTION testfunc5a(a testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! ERROR:  permission denied for type testdomain1
! CREATE FUNCTION testfunc6a(b int) RETURNS testdomain1 LANGUAGE SQL AS $$ SELECT $1::testdomain1 $$;
! ERROR:  permission denied for type testdomain1
! CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = testdomain1, RIGHTARG = testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test5a (a int, b testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test6a OF testtype1;
! ERROR:  permission denied for type testtype1
! CREATE TABLE test10a (a int[], b testtype1[]);
! ERROR:  permission denied for type testtype1
! CREATE TABLE test9a (a int, b int);
! ALTER TABLE test9a ADD COLUMN c testdomain1;
! ERROR:  permission denied for type testdomain1
! ALTER TABLE test9a ALTER COLUMN b TYPE testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE TYPE test7a AS (a int, b testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TYPE test8a AS (a int, b int);
! ALTER TYPE test8a ADD ATTRIBUTE c testdomain1;
! ERROR:  permission denied for type testdomain1
! ALTER TYPE test8a ALTER ATTRIBUTE b TYPE testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test11a AS (SELECT 1::testdomain1 AS a);
! ERROR:  permission denied for type testdomain1
! REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
! ERROR:  permission denied for type testtype1
! SET SESSION AUTHORIZATION regressuser2;
! -- commands that should succeed
! CREATE AGGREGATE testagg1b(testdomain1) (sfunc = int4_sum, stype = bigint);
! CREATE DOMAIN testdomain2b AS testdomain1;
! CREATE DOMAIN testdomain3b AS int;
! CREATE FUNCTION castfunc(int) RETURNS testdomain3b AS $$ SELECT $1::testdomain3b $$ LANGUAGE SQL;
! CREATE CAST (testdomain1 AS testdomain3b) WITH FUNCTION castfunc(int);
! WARNING:  cast will be ignored because the source data type is a domain
! CREATE FUNCTION testfunc5b(a testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! CREATE FUNCTION testfunc6b(b int) RETURNS testdomain1 LANGUAGE SQL AS $$ SELECT $1::testdomain1 $$;
! CREATE OPERATOR !! (PROCEDURE = testfunc5b, RIGHTARG = testdomain1);
! CREATE TABLE test5b (a int, b testdomain1);
! CREATE TABLE test6b OF testtype1;
! CREATE TABLE test10b (a int[], b testtype1[]);
! CREATE TABLE test9b (a int, b int);
! ALTER TABLE test9b ADD COLUMN c testdomain1;
! ALTER TABLE test9b ALTER COLUMN b TYPE testdomain1;
! CREATE TYPE test7b AS (a int, b testdomain1);
! CREATE TYPE test8b AS (a int, b int);
! ALTER TYPE test8b ADD ATTRIBUTE c testdomain1;
! ALTER TYPE test8b ALTER ATTRIBUTE b TYPE testdomain1;
! CREATE TABLE test11b AS (SELECT 1::testdomain1 AS a);
! REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
! WARNING:  no privileges could be revoked for "testtype1"
! \c -
! DROP AGGREGATE testagg1b(testdomain1);
! DROP DOMAIN testdomain2b;
! DROP OPERATOR !! (NONE, testdomain1);
! DROP FUNCTION testfunc5b(a testdomain1);
! DROP FUNCTION testfunc6b(b int);
! DROP TABLE test5b;
! DROP TABLE test6b;
! DROP TABLE test9b;
! DROP TABLE test10b;
! DROP TYPE test7b;
! DROP TYPE test8b;
! DROP CAST (testdomain1 AS testdomain3b);
! DROP FUNCTION castfunc(int) CASCADE;
! DROP DOMAIN testdomain3b;
! DROP TABLE test11b;
! DROP TYPE testtype1; -- ok
! DROP DOMAIN testdomain1; -- ok
! -- truncate
! SET SESSION AUTHORIZATION regressuser5;
! TRUNCATE atest2; -- ok
! TRUNCATE atest3; -- fail
! ERROR:  permission denied for relation atest3
! -- has_table_privilege function
! -- bad-input checks
! select has_table_privilege(NULL,'pg_authid','select');
!  has_table_privilege 
! ---------------------
!  
! (1 row)
! 
! select has_table_privilege('pg_shad','select');
! ERROR:  relation "pg_shad" does not exist
! select has_table_privilege('nosuchuser','pg_authid','select');
! ERROR:  role "nosuchuser" does not exist
! select has_table_privilege('pg_authid','sel');
! ERROR:  unrecognized privilege type: "sel"
! select has_table_privilege(-999999,'pg_authid','update');
! ERROR:  role with OID 4293967297 does not exist
! select has_table_privilege(1,'select');
!  has_table_privilege 
! ---------------------
!  
! (1 row)
! 
! -- superuser
! \c -
! select has_table_privilege(current_user,'pg_authid','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'pg_authid','insert');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_authid','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_authid','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- 'rule' privilege no longer exists, but for backwards compatibility
! -- has_table_privilege still recognizes the keyword and says FALSE
! select has_table_privilege(current_user,t1.oid,'rule')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_authid') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'pg_authid') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','update');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','delete');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','truncate');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- non-superuser
! SET SESSION AUTHORIZATION regressuser3;
! select has_table_privilege(current_user,'pg_class','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'pg_class','insert');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_class','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_class','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_class') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'pg_class') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','update');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','delete');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','truncate');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,'atest1','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'atest1','insert');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'atest1','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'atest1','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'atest1') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'atest1') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','update');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','delete');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','truncate');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! -- Grant options
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atest4 (a int);
! GRANT SELECT ON atest4 TO regressuser2 WITH GRANT OPTION;
! GRANT UPDATE ON atest4 TO regressuser2;
! GRANT SELECT ON atest4 TO GROUP regressgroup1 WITH GRANT OPTION;
! SET SESSION AUTHORIZATION regressuser2;
! GRANT SELECT ON atest4 TO regressuser3;
! GRANT UPDATE ON atest4 TO regressuser3; -- fail
! WARNING:  no privileges were granted for "atest4"
! SET SESSION AUTHORIZATION regressuser1;
! REVOKE SELECT ON atest4 FROM regressuser3; -- does nothing
! SELECT has_table_privilege('regressuser3', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! REVOKE SELECT ON atest4 FROM regressuser2; -- fail
! ERROR:  dependent privileges exist
! HINT:  Use CASCADE to revoke them too.
! REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regressuser2 CASCADE; -- ok
! SELECT has_table_privilege('regressuser2', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser3', 'atest4', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- Admin options
! SET SESSION AUTHORIZATION regressuser4;
! CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
! 	'GRANT regressgroup2 TO regressuser5';
! GRANT regressgroup2 TO regressuser5; -- ok: had ADMIN OPTION
! SET ROLE regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE suspended privilege
! ERROR:  must have admin option on role "regressgroup2"
! SET SESSION AUTHORIZATION regressuser1;
! GRANT regressgroup2 TO regressuser5; -- fails: no ADMIN OPTION
! ERROR:  must have admin option on role "regressgroup2"
! SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
! NOTICE:  role "regressuser5" is already a member of role "regressgroup2"
! CONTEXT:  SQL function "dogrant_ok" statement 1
!  dogrant_ok 
! ------------
!  
! (1 row)
! 
! SET ROLE regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE did not help
! ERROR:  must have admin option on role "regressgroup2"
! SET SESSION AUTHORIZATION regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- ok: a role can self-admin
! NOTICE:  role "regressuser5" is already a member of role "regressgroup2"
! CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
! 	'GRANT regressgroup2 TO regressuser5';
! SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
! ERROR:  must have admin option on role "regressgroup2"
! CONTEXT:  SQL function "dogrant_fails" statement 1
! DROP FUNCTION dogrant_fails();
! SET SESSION AUTHORIZATION regressuser4;
! DROP FUNCTION dogrant_ok();
! REVOKE regressgroup2 FROM regressuser5;
! -- has_sequence_privilege tests
! \c -
! CREATE SEQUENCE x_seq;
! GRANT USAGE on x_seq to regressuser2;
! SELECT has_sequence_privilege('regressuser1', 'atest1', 'SELECT');
! ERROR:  "atest1" is not a sequence
! SELECT has_sequence_privilege('regressuser1', 'x_seq', 'INSERT');
! ERROR:  unrecognized privilege type: "INSERT"
! SELECT has_sequence_privilege('regressuser1', 'x_seq', 'SELECT');
!  has_sequence_privilege 
! ------------------------
!  f
! (1 row)
! 
! SET SESSION AUTHORIZATION regressuser2;
! SELECT has_sequence_privilege('x_seq', 'USAGE');
!  has_sequence_privilege 
! ------------------------
!  t
! (1 row)
! 
! -- largeobject privilege tests
! \c -
! SET SESSION AUTHORIZATION regressuser1;
! SELECT lo_create(1001);
!  lo_create 
! -----------
!       1001
! (1 row)
! 
! SELECT lo_create(1002);
!  lo_create 
! -----------
!       1002
! (1 row)
! 
! SELECT lo_create(1003);
!  lo_create 
! -----------
!       1003
! (1 row)
! 
! SELECT lo_create(1004);
!  lo_create 
! -----------
!       1004
! (1 row)
! 
! SELECT lo_create(1005);
!  lo_create 
! -----------
!       1005
! (1 row)
! 
! GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
! GRANT SELECT ON LARGE OBJECT 1003 TO regressuser2;
! GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regressuser2;
! GRANT ALL ON LARGE OBJECT 1005 TO regressuser2;
! GRANT SELECT ON LARGE OBJECT 1005 TO regressuser2 WITH GRANT OPTION;
! GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;	-- to be failed
! ERROR:  invalid privilege type INSERT for large object
! GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;	-- to be failed
! ERROR:  role "nosuchuser" does not exist
! GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;	-- to be failed
! ERROR:  large object 999 does not exist
! \c -
! SET SESSION AUTHORIZATION regressuser2;
! SELECT lo_create(2001);
!  lo_create 
! -----------
!       2001
! (1 row)
! 
! SELECT lo_create(2002);
!  lo_create 
! -----------
!       2002
! (1 row)
! 
! SELECT loread(lo_open(1001, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT loread(lo_open(1003, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT loread(lo_open(1004, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1003
! SELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! GRANT SELECT ON LARGE OBJECT 1005 TO regressuser3;
! GRANT UPDATE ON LARGE OBJECT 1006 TO regressuser3;	-- to be denied
! ERROR:  large object 1006 does not exist
! REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
! GRANT ALL ON LARGE OBJECT 2001 TO regressuser3;
! SELECT lo_unlink(1001);		-- to be denied
! ERROR:  must be owner of large object 1001
! SELECT lo_unlink(2002);
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! \c -
! -- confirm ACL setting
! SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata;
!  oid  |  ownername   |                                          lomacl                                          
! ------+--------------+------------------------------------------------------------------------------------------
!  1002 | regressuser1 | 
!  1001 | regressuser1 | {regressuser1=rw/regressuser1,=rw/regressuser1}
!  1003 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=r/regressuser1}
!  1004 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=rw/regressuser1}
!  1005 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=r*w/regressuser1,regressuser3=r/regressuser2}
!  2001 | regressuser2 | {regressuser2=rw/regressuser2,regressuser3=rw/regressuser2}
! (6 rows)
! 
! SET SESSION AUTHORIZATION regressuser3;
! SELECT loread(lo_open(1001, x'40000'::int), 32);
!    loread   
! ------------
!  \x61626364
! (1 row)
! 
! SELECT loread(lo_open(1003, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1003
! SELECT loread(lo_open(1005, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);	-- to be denied
! ERROR:  permission denied for large object 1005
! SELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! -- compatibility mode in largeobject permission
! \c -
! SET lo_compat_privileges = false;	-- default setting
! SET SESSION AUTHORIZATION regressuser4;
! SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lo_unlink(1002);					-- to be denied
! ERROR:  must be owner of large object 1002
! SELECT lo_export(1001, '/dev/null');			-- to be denied
! ERROR:  must be superuser to use server-side lo_export()
! HINT:  Anyone can use the client-side lo_export() provided by libpq.
! \c -
! SET lo_compat_privileges = true;	-- compatibility mode
! SET SESSION AUTHORIZATION regressuser4;
! SELECT loread(lo_open(1002, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! SELECT lo_unlink(1002);
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! SELECT lo_export(1001, '/dev/null');			-- to be denied
! ERROR:  must be superuser to use server-side lo_export()
! HINT:  Anyone can use the client-side lo_export() provided by libpq.
! -- don't allow unpriv users to access pg_largeobject contents
! \c -
! SELECT * FROM pg_largeobject LIMIT 0;
!  loid | pageno | data 
! ------+--------+------
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser1;
! SELECT * FROM pg_largeobject LIMIT 0;			-- to be denied
! ERROR:  permission denied for relation pg_largeobject
! -- test default ACLs
! \c -
! CREATE SCHEMA testns;
! GRANT ALL ON SCHEMA testns TO regressuser1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT SELECT ON TABLES TO public;
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regressuser1;
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regressuser1;
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES FOR ROLE regressuser1 REVOKE EXECUTE ON FUNCTIONS FROM public;
! SET ROLE regressuser1;
! CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
! SELECT has_function_privilege('regressuser2', 'testns.foo()', 'EXECUTE'); -- no
!  has_function_privilege 
! ------------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON FUNCTIONS to public;
! DROP FUNCTION testns.foo();
! CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
! SELECT has_function_privilege('regressuser2', 'testns.foo()', 'EXECUTE'); -- yes
!  has_function_privilege 
! ------------------------
!  t
! (1 row)
! 
! DROP FUNCTION testns.foo();
! ALTER DEFAULT PRIVILEGES FOR ROLE regressuser1 REVOKE USAGE ON TYPES FROM public;
! CREATE DOMAIN testns.testdomain1 AS int;
! SELECT has_type_privilege('regressuser2', 'testns.testdomain1', 'USAGE'); -- no
!  has_type_privilege 
! --------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
! DROP DOMAIN testns.testdomain1;
! CREATE DOMAIN testns.testdomain1 AS int;
! SELECT has_type_privilege('regressuser2', 'testns.testdomain1', 'USAGE'); -- yes
!  has_type_privilege 
! --------------------
!  t
! (1 row)
! 
! DROP DOMAIN testns.testdomain1;
! RESET ROLE;
! SELECT count(*)
!   FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
!   WHERE nspname = 'testns';
!  count 
! -------
!      3
! (1 row)
! 
! DROP SCHEMA testns CASCADE;
! NOTICE:  drop cascades to table testns.acltest1
! SELECT d.*     -- check that entries went away
!   FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
!   WHERE nspname IS NULL AND defaclnamespace != 0;
!  defaclrole | defaclnamespace | defaclobjtype | defaclacl 
! ------------+-----------------+---------------+-----------
! (0 rows)
! 
! -- Grant on all objects of given type in a schema
! \c -
! CREATE SCHEMA testns;
! CREATE TABLE testns.t1 (f1 int);
! CREATE TABLE testns.t2 (f1 int);
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! GRANT ALL ON ALL TABLES IN SCHEMA testns TO regressuser1;
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.t2', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regressuser1;
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.t2', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! CREATE FUNCTION testns.testfunc(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
! SELECT has_function_privilege('regressuser1', 'testns.testfunc(int)', 'EXECUTE'); -- true by default
!  has_function_privilege 
! ------------------------
!  t
! (1 row)
! 
! REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
! SELECT has_function_privilege('regressuser1', 'testns.testfunc(int)', 'EXECUTE'); -- false
!  has_function_privilege 
! ------------------------
!  f
! (1 row)
! 
! SET client_min_messages TO 'warning';
! DROP SCHEMA testns CASCADE;
! RESET client_min_messages;
! -- Change owner of the schema & and rename of new schema owner
! \c -
! CREATE ROLE schemauser1 superuser login;
! CREATE ROLE schemauser2 superuser login;
! SET SESSION ROLE schemauser1;
! CREATE SCHEMA testns;
! SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
!  nspname |   rolname   
! ---------+-------------
!  testns  | schemauser1
! (1 row)
! 
! ALTER SCHEMA testns OWNER TO schemauser2;
! ALTER ROLE schemauser2 RENAME TO schemauser_renamed;
! SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
!  nspname |      rolname       
! ---------+--------------------
!  testns  | schemauser_renamed
! (1 row)
! 
! set session role schemauser_renamed;
! SET client_min_messages TO 'warning';
! DROP SCHEMA testns CASCADE;
! RESET client_min_messages;
! -- clean up
! \c -
! DROP ROLE schemauser1;
! DROP ROLE schemauser_renamed;
! -- test that dependent privileges are revoked (or not) properly
! \c -
! set session role regressuser1;
! create table dep_priv_test (a int);
! grant select on dep_priv_test to regressuser2 with grant option;
! grant select on dep_priv_test to regressuser3 with grant option;
! set session role regressuser2;
! grant select on dep_priv_test to regressuser4 with grant option;
! set session role regressuser3;
! grant select on dep_priv_test to regressuser4 with grant option;
! set session role regressuser4;
! grant select on dep_priv_test to regressuser5;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1     +|                   | 
!         |               |       | regressuser4=r*/regressuser2     +|                   | 
!         |               |       | regressuser4=r*/regressuser3     +|                   | 
!         |               |       | regressuser5=r/regressuser4       |                   | 
! (1 row)
! 
! set session role regressuser2;
! revoke select on dep_priv_test from regressuser4 cascade;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1     +|                   | 
!         |               |       | regressuser4=r*/regressuser3     +|                   | 
!         |               |       | regressuser5=r/regressuser4       |                   | 
! (1 row)
! 
! set session role regressuser3;
! revoke select on dep_priv_test from regressuser4 cascade;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1      |                   | 
! (1 row)
! 
! set session role regressuser1;
! drop table dep_priv_test;
! -- clean up
! \c
! drop sequence x_seq;
! DROP FUNCTION testfunc2(int);
! DROP FUNCTION testfunc4(boolean);
! DROP VIEW atestv0;
! DROP VIEW atestv1;
! DROP VIEW atestv2;
! -- this should cascade to drop atestv4
! DROP VIEW atestv3 CASCADE;
! NOTICE:  drop cascades to view atestv4
! -- this should complain "does not exist"
! DROP VIEW atestv4;
! ERROR:  view "atestv4" does not exist
! DROP TABLE atest1;
! DROP TABLE atest2;
! DROP TABLE atest3;
! DROP TABLE atest4;
! DROP TABLE atest5;
! DROP TABLE atest6;
! DROP TABLE atestc;
! DROP TABLE atestp1;
! DROP TABLE atestp2;
! SELECT lo_unlink(oid) FROM pg_largeobject_metadata;
!  lo_unlink 
! -----------
!          1
!          1
!          1
!          1
!          1
! (5 rows)
! 
! DROP GROUP regressgroup1;
! DROP GROUP regressgroup2;
! -- these are needed to clean up permissions
! REVOKE USAGE ON LANGUAGE sql FROM regressuser1;
! DROP OWNED BY regressuser1;
! DROP USER regressuser1;
! DROP USER regressuser2;
! DROP USER regressuser3;
! DROP USER regressuser4;
! DROP USER regressuser5;
! DROP USER regressuser6;
! ERROR:  role "regressuser6" does not exist
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/security_label.out	2015-01-10 10:11:34.243649159 +0300
--- /home/orion/postgres/src/test/regress/results/security_label.out	2015-01-10 10:11:46.675649464 +0300
***************
*** 1,123 ****
! --
! -- Test for facilities of security label
! --
! -- initial setups
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS seclabel_user1;
! DROP ROLE IF EXISTS seclabel_user2;
! DROP TABLE IF EXISTS seclabel_tbl1;
! DROP TABLE IF EXISTS seclabel_tbl2;
! DROP TABLE IF EXISTS seclabel_tbl3;
! CREATE USER seclabel_user1 WITH CREATEROLE;
! CREATE USER seclabel_user2;
! CREATE TABLE seclabel_tbl1 (a int, b text);
! CREATE TABLE seclabel_tbl2 (x int, y text);
! CREATE VIEW seclabel_view1 AS SELECT * FROM seclabel_tbl2;
! CREATE FUNCTION seclabel_four() RETURNS integer AS $$SELECT 4$$ language sql;
! CREATE DOMAIN seclabel_domain AS text;
! ALTER TABLE seclabel_tbl1 OWNER TO seclabel_user1;
! ALTER TABLE seclabel_tbl2 OWNER TO seclabel_user2;
! RESET client_min_messages;
! --
! -- Test of SECURITY LABEL statement without a plugin
! --
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';		-- fail
! ERROR:  security label provider "dummy" is not loaded
! SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';		-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS 'classified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL FOR 'dummy' ON ROLE seclabel_user1 IS 'classified';		-- fail
! ERROR:  security label provider "dummy" is not loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS '...invalid label...';		-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON ROLE seclabel_user3 IS 'unclassified';			-- fail
! ERROR:  no security label providers have been loaded
! -- Load dummy external security provider
! LOAD '/home/orion/postgres/src/test/regress/dummy_seclabel.so';
! --
! -- Test of SECURITY LABEL statement with a plugin
! --
! SET SESSION AUTHORIZATION seclabel_user1;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- OK
! SECURITY LABEL ON COLUMN seclabel_tbl1.a IS 'unclassified';		-- OK
! SECURITY LABEL ON COLUMN seclabel_tbl1 IS 'unclassified';	-- fail
! ERROR:  column name must be qualified
! SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';	-- fail
! ERROR:  '...invalid label...' is not a valid security label
! SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'unclassified';	-- OK
! SECURITY LABEL FOR 'unknown_seclabel' ON TABLE seclabel_tbl1 IS 'classified';	-- fail
! ERROR:  security label provider "unknown_seclabel" is not loaded
! SECURITY LABEL ON TABLE seclabel_tbl2 IS 'unclassified';	-- fail (not owner)
! ERROR:  must be owner of relation seclabel_tbl2
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'secret';		-- fail (not superuser)
! ERROR:  only superuser can set 'secret' label
! SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';	-- fail (not found)
! ERROR:  relation "seclabel_tbl3" does not exist
! SET SESSION AUTHORIZATION seclabel_user2;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'unclassified';		-- fail
! ERROR:  must be owner of relation seclabel_tbl1
! SECURITY LABEL ON TABLE seclabel_tbl2 IS 'classified';			-- OK
! --
! -- Test for shared database object
! --
! SET SESSION AUTHORIZATION seclabel_user1;
! SECURITY LABEL ON ROLE seclabel_user1 IS 'classified';			-- OK
! SECURITY LABEL ON ROLE seclabel_user1 IS '...invalid label...';	-- fail
! ERROR:  '...invalid label...' is not a valid security label
! SECURITY LABEL FOR 'dummy' ON ROLE seclabel_user2 IS 'unclassified';	-- OK
! SECURITY LABEL FOR 'unknown_seclabel' ON ROLE seclabel_user1 IS 'unclassified';	-- fail
! ERROR:  security label provider "unknown_seclabel" is not loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS 'secret';	-- fail (not superuser)
! ERROR:  only superuser can set 'secret' label
! SECURITY LABEL ON ROLE seclabel_user3 IS 'unclassified';	-- fail (not found)
! ERROR:  role "seclabel_user3" does not exist
! SET SESSION AUTHORIZATION seclabel_user2;
! SECURITY LABEL ON ROLE seclabel_user2 IS 'unclassified';	-- fail (not privileged)
! ERROR:  must have CREATEROLE privilege
! RESET SESSION AUTHORIZATION;
! --
! -- Test for various types of object
! --
! RESET SESSION AUTHORIZATION;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'top secret';			-- OK
! SECURITY LABEL ON VIEW seclabel_view1 IS 'classified';			-- OK
! SECURITY LABEL ON FUNCTION seclabel_four() IS 'classified';		-- OK
! SECURITY LABEL ON DOMAIN seclabel_domain IS 'classified';		-- OK
! CREATE SCHEMA seclabel_test;
! SECURITY LABEL ON SCHEMA seclabel_test IS 'unclassified';		-- OK
! SELECT objtype, objname, provider, label FROM pg_seclabels
! 	ORDER BY objtype, objname;
!  objtype  |     objname     | provider |    label     
! ----------+-----------------+----------+--------------
!  column   | seclabel_tbl1.a | dummy    | unclassified
!  domain   | seclabel_domain | dummy    | classified
!  function | seclabel_four() | dummy    | classified
!  role     | seclabel_user1  | dummy    | classified
!  role     | seclabel_user2  | dummy    | unclassified
!  schema   | seclabel_test   | dummy    | unclassified
!  table    | seclabel_tbl1   | dummy    | top secret
!  table    | seclabel_tbl2   | dummy    | classified
!  view     | seclabel_view1  | dummy    | classified
! (9 rows)
! 
! -- clean up objects
! DROP FUNCTION seclabel_four();
! DROP DOMAIN seclabel_domain;
! DROP VIEW seclabel_view1;
! DROP TABLE seclabel_tbl1;
! DROP TABLE seclabel_tbl2;
! DROP USER seclabel_user1;
! DROP USER seclabel_user2;
! DROP SCHEMA seclabel_test;
! -- make sure we don't have any leftovers
! SELECT objtype, objname, provider, label FROM pg_seclabels
! 	ORDER BY objtype, objname;
!  objtype | objname | provider | label 
! ---------+---------+----------+-------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/collate.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/collate.out	2015-01-10 10:11:46.663649463 +0300
***************
*** 1,650 ****
! /*
!  * This test is intended to pass on all platforms supported by Postgres.
!  * We can therefore only assume that the default, C, and POSIX collations
!  * are available --- and since the regression tests are often run in a
!  * C-locale database, these may well all have the same behavior.  But
!  * fortunately, the system doesn't know that and will treat them as
!  * incompatible collations.  It is therefore at least possible to test
!  * parser behaviors such as collation conflict resolution.  This test will,
!  * however, be more revealing when run in a database with non-C locale,
!  * since any departure from C sorting behavior will show as a failure.
!  */
! CREATE SCHEMA collate_tests;
! SET search_path = collate_tests;
! CREATE TABLE collate_test1 (
!     a int,
!     b text COLLATE "C" NOT NULL
! );
! \d collate_test1
!   Table "collate_tests.collate_test1"
!  Column |  Type   |     Modifiers      
! --------+---------+--------------------
!  a      | integer | 
!  b      | text    | collate C not null
! 
! CREATE TABLE collate_test_fail (
!     a int COLLATE "C",
!     b text
! );
! ERROR:  collations are not supported by type integer
! LINE 2:     a int COLLATE "C",
!                   ^
! CREATE TABLE collate_test_like (
!     LIKE collate_test1
! );
! \d collate_test_like
! Table "collate_tests.collate_test_like"
!  Column |  Type   |     Modifiers      
! --------+---------+--------------------
!  a      | integer | 
!  b      | text    | collate C not null
! 
! CREATE TABLE collate_test2 (
!     a int,
!     b text COLLATE "POSIX"
! );
! INSERT INTO collate_test1 VALUES (1, 'abc'), (2, 'Abc'), (3, 'bbc'), (4, 'ABD');
! INSERT INTO collate_test2 SELECT * FROM collate_test1;
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc';
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b >= 'abc' COLLATE "C";
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc' COLLATE "C";
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "POSIX"; -- fail
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: ...* FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "P...
!                                                              ^
! CREATE DOMAIN testdomain_p AS text COLLATE "POSIX";
! CREATE DOMAIN testdomain_i AS int COLLATE "POSIX"; -- fail
! ERROR:  collations are not supported by type integer
! CREATE TABLE collate_test4 (
!     a int,
!     b testdomain_p
! );
! INSERT INTO collate_test4 SELECT * FROM collate_test1;
! SELECT a, b FROM collate_test4 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! CREATE TABLE collate_test5 (
!     a int,
!     b testdomain_p COLLATE "C"
! );
! INSERT INTO collate_test5 SELECT * FROM collate_test1;
! SELECT a, b FROM collate_test5 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test2 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- star expansion
! SELECT * FROM collate_test1 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT * FROM collate_test2 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- constant expression folding
! SELECT 'bbc' COLLATE "C" > 'Abc' COLLATE "C" AS "true";
!  true 
! ------
!  t
! (1 row)
! 
! SELECT 'bbc' COLLATE "POSIX" < 'Abc' COLLATE "POSIX" AS "false";
!  false 
! -------
!  f
! (1 row)
! 
! -- upper/lower
! CREATE TABLE collate_test10 (
!     a int,
!     x text COLLATE "C",
!     y text COLLATE "POSIX"
! );
! INSERT INTO collate_test10 VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
! SELECT a, lower(x), lower(y), upper(x), upper(y), initcap(x), initcap(y) FROM collate_test10;
!  a | lower | lower | upper | upper | initcap | initcap 
! ---+-------+-------+-------+-------+---------+---------
!  1 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
!  2 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
! (2 rows)
! 
! SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
!  a |  x  |  y  
! ---+-----+-----
!  1 | hij | hij
!  2 | HIJ | HIJ
! (2 rows)
! 
! -- backwards parsing
! CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
! CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
! CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "POSIX") FROM collate_test10;
! SELECT table_name, view_definition FROM information_schema.views
!   WHERE table_name LIKE 'collview%' ORDER BY 1;
!  table_name |                               view_definition                                
! ------------+------------------------------------------------------------------------------
!  collview1  |  SELECT collate_test1.a,                                                    +
!             |     collate_test1.b                                                         +
!             |    FROM collate_test1                                                       +
!             |   WHERE ((collate_test1.b COLLATE "C") >= 'bbc'::text);
!  collview2  |  SELECT collate_test1.a,                                                    +
!             |     collate_test1.b                                                         +
!             |    FROM collate_test1                                                       +
!             |   ORDER BY (collate_test1.b COLLATE "C");
!  collview3  |  SELECT collate_test10.a,                                                   +
!             |     lower(((collate_test10.x || collate_test10.x) COLLATE "POSIX")) AS lower+
!             |    FROM collate_test10;
! (3 rows)
! 
! -- collation propagation in various expression types
! SELECT a, coalesce(b, 'foo') FROM collate_test1 ORDER BY 2;
!  a | coalesce 
! ---+----------
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, coalesce(b, 'foo') FROM collate_test2 ORDER BY 2;
!  a | coalesce 
! ---+----------
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, lower(coalesce(x, 'foo')), lower(coalesce(y, 'foo')) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, b, greatest(b, 'CCC') FROM collate_test1 ORDER BY 3;
!  a |  b  | greatest 
! ---+-----+----------
!  2 | Abc | CCC
!  4 | ABD | CCC
!  1 | abc | abc
!  3 | bbc | bbc
! (4 rows)
! 
! SELECT a, b, greatest(b, 'CCC') FROM collate_test2 ORDER BY 3;
!  a |  b  | greatest 
! ---+-----+----------
!  2 | Abc | CCC
!  4 | ABD | CCC
!  1 | abc | abc
!  3 | bbc | bbc
! (4 rows)
! 
! SELECT a, x, y, lower(greatest(x, 'foo')), lower(greatest(y, 'foo')) FROM collate_test10;
!  a |  x  |  y  | lower | lower 
! ---+-----+-----+-------+-------
!  1 | hij | hij | hij   | hij
!  2 | HIJ | HIJ | foo   | foo
! (2 rows)
! 
! SELECT a, nullif(b, 'abc') FROM collate_test1 ORDER BY 2;
!  a | nullif 
! ---+--------
!  4 | ABD
!  2 | Abc
!  3 | bbc
!  1 | 
! (4 rows)
! 
! SELECT a, nullif(b, 'abc') FROM collate_test2 ORDER BY 2;
!  a | nullif 
! ---+--------
!  4 | ABD
!  2 | Abc
!  3 | bbc
!  1 | 
! (4 rows)
! 
! SELECT a, lower(nullif(x, 'foo')), lower(nullif(y, 'foo')) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test1 ORDER BY 2;
!  a |  b   
! ---+------
!  4 | ABD
!  2 | Abc
!  1 | abcd
!  3 | bbc
! (4 rows)
! 
! SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test2 ORDER BY 2;
!  a |  b   
! ---+------
!  4 | ABD
!  2 | Abc
!  1 | abcd
!  3 | bbc
! (4 rows)
! 
! CREATE DOMAIN testdomain AS text;
! SELECT a, b::testdomain FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b::testdomain FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b::testdomain_p FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, lower(x::testdomain), lower(y::testdomain) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT min(b), max(b) FROM collate_test1;
!  min | max 
! -----+-----
!  ABD | bbc
! (1 row)
! 
! SELECT min(b), max(b) FROM collate_test2;
!  min | max 
! -----+-----
!  ABD | bbc
! (1 row)
! 
! SELECT array_agg(b ORDER BY b) FROM collate_test1;
!      array_agg     
! -------------------
!  {ABD,Abc,abc,bbc}
! (1 row)
! 
! SELECT array_agg(b ORDER BY b) FROM collate_test2;
!      array_agg     
! -------------------
!  {ABD,Abc,abc,bbc}
! (1 row)
! 
! -- In aggregates, ORDER BY expressions don't affect aggregate's collation
! SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;  -- fail
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM col...
!                                            ^
! SELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
!  array_agg 
! -----------
!  {HIJ,hij}
! (1 row)
! 
! SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
!  array_agg 
! -----------
!  {2,1}
! (1 row)
! 
! SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT array_agg(a ORDER BY x||y) FROM collate_test10;
!                                        ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  4 | ABD
!  2 | Abc
!  2 | Abc
!  1 | abc
!  1 | abc
!  3 | bbc
!  3 | bbc
! (8 rows)
! 
! SELECT a, b FROM collate_test2 UNION SELECT a, b FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test2 WHERE a < 4 INTERSECT SELECT a, b FROM collate_test2 WHERE a > 1 ORDER BY 2;
!  a |  b  
! ---+-----
!  2 | Abc
!  3 | bbc
! (2 rows)
! 
! SELECT a, b FROM collate_test2 EXCEPT SELECT a, b FROM collate_test2 WHERE a < 2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  3 | bbc
! (3 rows)
! 
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  could not determine which collation to use for string comparison
! HINT:  Use the COLLATE clause to set the collation explicitly.
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- ok
!  a |  b  
! ---+-----
!  1 | abc
!  2 | Abc
!  3 | bbc
!  4 | ABD
!  1 | abc
!  2 | Abc
!  3 | bbc
!  4 | ABD
! (8 rows)
! 
! SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collat...
!                                                        ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- ok
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: ...ELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM col...
!                                                              ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM colla...
!                                                         ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- fail
! ERROR:  no collation was derived for column "b" with collatable type text
! HINT:  Use the COLLATE clause to set the collation explicitly.
! -- ideally this would be a parse-time error, but for now it must be run-time:
! select x < y from collate_test10; -- fail
! ERROR:  could not determine which collation to use for string comparison
! HINT:  Use the COLLATE clause to set the collation explicitly.
! select x || y from collate_test10; -- ok, because || is not collation aware
!  ?column? 
! ----------
!  hijhij
!  HIJHIJ
! (2 rows)
! 
! select x, y from collate_test10 order by x || y; -- not so ok
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: select x, y from collate_test10 order by x || y;
!                                                       ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! -- collation mismatch between recursive and non-recursive term
! WITH RECURSIVE foo(x) AS
!    (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
!    UNION ALL
!    SELECT (x || 'c') COLLATE "POSIX" FROM foo WHERE length(x) < 10)
! SELECT * FROM foo;
! ERROR:  recursive query "foo" column 1 has collation "C" in non-recursive term but collation "POSIX" overall
! LINE 2:    (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
!                    ^
! HINT:  Use the COLLATE clause to set the collation of the non-recursive term.
! SELECT a, b, a < b as lt FROM
!   (VALUES ('a', 'B'), ('A', 'b' COLLATE "C")) v(a,b);
!  a | b | lt 
! ---+---+----
!  a | B | f
!  A | b | t
! (2 rows)
! 
! -- casting
! SELECT CAST('42' AS text COLLATE "C");
! ERROR:  syntax error at or near "COLLATE"
! LINE 1: SELECT CAST('42' AS text COLLATE "C");
!                                  ^
! SELECT a, CAST(b AS varchar) FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, CAST(b AS varchar) FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- polymorphism
! SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
!  unnest 
! --------
!  ABD
!  Abc
!  abc
!  bbc
! (4 rows)
! 
! SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
!  unnest 
! --------
!  ABD
!  Abc
!  abc
!  bbc
! (4 rows)
! 
! CREATE FUNCTION dup (anyelement) RETURNS anyelement
!     AS 'select $1' LANGUAGE sql;
! SELECT a, dup(b) FROM collate_test1 ORDER BY 2;
!  a | dup 
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, dup(b) FROM collate_test2 ORDER BY 2;
!  a | dup 
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- indexes
! CREATE INDEX collate_test1_idx1 ON collate_test1 (b);
! CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "POSIX");
! CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "POSIX")); -- this is different grammatically
! CREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
! CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "POSIX"); -- fail
! ERROR:  collations are not supported by type integer
! CREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "POSIX")); -- fail
! ERROR:  collations are not supported by type integer
! LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "P...
!                                                              ^
! SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
!       relname       |                                           pg_get_indexdef                                           
! --------------------+-----------------------------------------------------------------------------------------------------
!  collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
!  collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "POSIX")
!  collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "POSIX")
!  collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
! (4 rows)
! 
! -- foreign keys
! -- force indexes and mergejoins to be used for FK checking queries,
! -- else they might not exercise collation-dependent operators
! SET enable_seqscan TO 0;
! SET enable_hashjoin TO 0;
! SET enable_nestloop TO 0;
! CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
! INSERT INTO collate_test20 VALUES ('foo'), ('bar');
! CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
! INSERT INTO collate_test21 VALUES ('foo'), ('bar');
! INSERT INTO collate_test21 VALUES ('baz'); -- fail
! ERROR:  insert or update on table "collate_test21" violates foreign key constraint "collate_test21_f2_fkey"
! DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
! CREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
! INSERT INTO collate_test22 VALUES ('foo'), ('bar'), ('baz');
! ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- fail
! ERROR:  insert or update on table "collate_test22" violates foreign key constraint "collate_test22_f2_fkey"
! DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
! DELETE FROM collate_test22 WHERE f2 = 'baz';
! ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20;
! RESET enable_seqscan;
! RESET enable_hashjoin;
! RESET enable_nestloop;
! -- 9.1 bug with useless COLLATE in an expression subject to length coercion
! CREATE TEMP TABLE vctable (f1 varchar(25));
! INSERT INTO vctable VALUES ('foo' COLLATE "C");
! SELECT collation for ('foo'); -- unknown type - null
!  pg_collation_for 
! ------------------
!  
! (1 row)
! 
! SELECT collation for ('foo'::text);
!  pg_collation_for 
! ------------------
!  "default"
! (1 row)
! 
! SELECT collation for ((SELECT a FROM collate_test1 LIMIT 1)); -- non-collatable type - error
! ERROR:  collations are not supported by type integer
! SELECT collation for ((SELECT b FROM collate_test1 LIMIT 1));
!  pg_collation_for 
! ------------------
!  "C"
! (1 row)
! 
! --
! -- Clean up.  Many of these table names will be re-used if the user is
! -- trying to run any platform-specific collation tests later, so we
! -- must get rid of them.
! --
! DROP SCHEMA collate_tests CASCADE;
! NOTICE:  drop cascades to 15 other objects
! DETAIL:  drop cascades to table collate_test1
! drop cascades to table collate_test_like
! drop cascades to table collate_test2
! drop cascades to type testdomain_p
! drop cascades to table collate_test4
! drop cascades to table collate_test5
! drop cascades to table collate_test10
! drop cascades to view collview1
! drop cascades to view collview2
! drop cascades to view collview3
! drop cascades to type testdomain
! drop cascades to function dup(anyelement)
! drop cascades to table collate_test20
! drop cascades to table collate_test21
! drop cascades to table collate_test22
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/matview.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/matview.out	2015-01-10 10:11:46.659649463 +0300
***************
*** 1,516 ****
! -- create a table to use as a basis for views and materialized views in various combinations
! CREATE TABLE t (id int NOT NULL PRIMARY KEY, type text NOT NULL, amt numeric NOT NULL);
! INSERT INTO t VALUES
!   (1, 'x', 2),
!   (2, 'x', 3),
!   (3, 'y', 5),
!   (4, 'y', 7),
!   (5, 'z', 11);
! -- we want a view based on the table, too, since views present additional challenges
! CREATE VIEW tv AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type;
! SELECT * FROM tv ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! -- create a materialized view with no data, and confirm correct behavior
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tm AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type WITH NO DATA;
!      QUERY PLAN      
! ---------------------
!  HashAggregate
!    Group Key: type
!    ->  Seq Scan on t
! (3 rows)
! 
! CREATE MATERIALIZED VIEW tm AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type WITH NO DATA;
! SELECT relispopulated FROM pg_class WHERE oid = 'tm'::regclass;
!  relispopulated 
! ----------------
!  f
! (1 row)
! 
! SELECT * FROM tm;
! ERROR:  materialized view "tm" has not been populated
! HINT:  Use the REFRESH MATERIALIZED VIEW command.
! REFRESH MATERIALIZED VIEW tm;
! SELECT relispopulated FROM pg_class WHERE oid = 'tm'::regclass;
!  relispopulated 
! ----------------
!  t
! (1 row)
! 
! CREATE UNIQUE INDEX tm_type ON tm (type);
! SELECT * FROM tm;
!  type | totamt 
! ------+--------
!  y    |     12
!  z    |     11
!  x    |      5
! (3 rows)
! 
! -- create various views
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tvm AS SELECT * FROM tv ORDER BY type;
!         QUERY PLAN         
! ---------------------------
!  Sort
!    Sort Key: t.type
!    ->  HashAggregate
!          Group Key: t.type
!          ->  Seq Scan on t
! (5 rows)
! 
! CREATE MATERIALIZED VIEW tvm AS SELECT * FROM tv ORDER BY type;
! SELECT * FROM tvm;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! CREATE MATERIALIZED VIEW tmm AS SELECT sum(totamt) AS grandtot FROM tm;
! CREATE MATERIALIZED VIEW tvmm AS SELECT sum(totamt) AS grandtot FROM tvm;
! CREATE UNIQUE INDEX tvmm_expr ON tvmm ((grandtot > 0));
! CREATE UNIQUE INDEX tvmm_pred ON tvmm (grandtot) WHERE grandtot < 0;
! CREATE VIEW tvv AS SELECT sum(totamt) AS grandtot FROM tv;
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tvvm AS SELECT * FROM tvv;
!         QUERY PLAN         
! ---------------------------
!  Aggregate
!    ->  HashAggregate
!          Group Key: t.type
!          ->  Seq Scan on t
! (4 rows)
! 
! CREATE MATERIALIZED VIEW tvvm AS SELECT * FROM tvv;
! CREATE VIEW tvvmv AS SELECT * FROM tvvm;
! CREATE MATERIALIZED VIEW bb AS SELECT * FROM tvvmv;
! CREATE INDEX aa ON bb (grandtot);
! -- check that plans seem reasonable
! \d+ tvm
!                     Materialized view "public.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! \d+ tvm
!                     Materialized view "public.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! \d+ tvvm
!                     Materialized view "public.tvvm"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! View definition:
!  SELECT tvv.grandtot
!    FROM tvv;
! 
! \d+ bb
!                      Materialized view "public.bb"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! Indexes:
!     "aa" btree (grandtot)
! View definition:
!  SELECT tvvmv.grandtot
!    FROM tvvmv;
! 
! -- test schema behavior
! CREATE SCHEMA mvschema;
! ALTER MATERIALIZED VIEW tvm SET SCHEMA mvschema;
! \d+ tvm
! \d+ tvmm
!                     Materialized view "public.tvmm"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! Indexes:
!     "tvmm_expr" UNIQUE, btree ((grandtot > 0::numeric))
!     "tvmm_pred" UNIQUE, btree (grandtot) WHERE grandtot < 0::numeric
! View definition:
!  SELECT sum(tvm.totamt) AS grandtot
!    FROM mvschema.tvm;
! 
! SET search_path = mvschema, public;
! \d+ tvm
!                    Materialized view "mvschema.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! -- modify the underlying table data
! INSERT INTO t VALUES (6, 'z', 13);
! -- confirm pre- and post-refresh contents of fairly simple materialized views
! SELECT * FROM tm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! SELECT * FROM tvm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! REFRESH MATERIALIZED VIEW CONCURRENTLY tm;
! REFRESH MATERIALIZED VIEW tvm;
! SELECT * FROM tm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     24
! (3 rows)
! 
! SELECT * FROM tvm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     24
! (3 rows)
! 
! RESET search_path;
! -- confirm pre- and post-refresh contents of nested materialized views
! EXPLAIN (costs off)
!   SELECT * FROM tmm;
!    QUERY PLAN    
! -----------------
!  Seq Scan on tmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvmm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvvm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvvm
! (1 row)
! 
! SELECT * FROM tmm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! SELECT * FROM tvmm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! SELECT * FROM tvvm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! REFRESH MATERIALIZED VIEW tmm;
! REFRESH MATERIALIZED VIEW CONCURRENTLY tvmm;
! ERROR:  cannot refresh materialized view "public.tvmm" concurrently
! HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
! REFRESH MATERIALIZED VIEW tvmm;
! REFRESH MATERIALIZED VIEW tvvm;
! EXPLAIN (costs off)
!   SELECT * FROM tmm;
!    QUERY PLAN    
! -----------------
!  Seq Scan on tmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvmm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvvm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvvm
! (1 row)
! 
! SELECT * FROM tmm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! SELECT * FROM tvmm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! SELECT * FROM tvvm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! -- test diemv when the mv does not exist
! DROP MATERIALIZED VIEW IF EXISTS no_such_mv;
! NOTICE:  materialized view "no_such_mv" does not exist, skipping
! -- make sure invalid comination of options is prohibited
! REFRESH MATERIALIZED VIEW CONCURRENTLY tvmm WITH NO DATA;
! ERROR:  CONCURRENTLY and WITH NO DATA options cannot be used together
! -- no tuple locks on materialized views
! SELECT * FROM tvvm FOR SHARE;
! ERROR:  cannot lock rows in materialized view "tvvm"
! -- test join of mv and view
! SELECT type, m.totamt AS mtot, v.totamt AS vtot FROM tm m LEFT JOIN tv v USING (type) ORDER BY type;
!  type | mtot | vtot 
! ------+------+------
!  x    |    5 |    5
!  y    |   12 |   12
!  z    |   24 |   24
! (3 rows)
! 
! -- make sure that dependencies are reported properly when they block the drop
! DROP TABLE t;
! ERROR:  cannot drop table t because other objects depend on it
! DETAIL:  view tv depends on table t
! view tvv depends on view tv
! materialized view tvvm depends on view tvv
! view tvvmv depends on materialized view tvvm
! materialized view bb depends on view tvvmv
! materialized view mvschema.tvm depends on view tv
! materialized view tvmm depends on materialized view mvschema.tvm
! materialized view tm depends on table t
! materialized view tmm depends on materialized view tm
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- make sure dependencies are dropped and reported
! -- and make sure that transactional behavior is correct on rollback
! -- incidentally leaving some interesting materialized views for pg_dump testing
! BEGIN;
! DROP TABLE t CASCADE;
! NOTICE:  drop cascades to 9 other objects
! DETAIL:  drop cascades to view tv
! drop cascades to view tvv
! drop cascades to materialized view tvvm
! drop cascades to view tvvmv
! drop cascades to materialized view bb
! drop cascades to materialized view mvschema.tvm
! drop cascades to materialized view tvmm
! drop cascades to materialized view tm
! drop cascades to materialized view tmm
! ROLLBACK;
! -- some additional tests not using base tables
! CREATE VIEW v_test1 AS SELECT 1 moo;
! CREATE VIEW v_test2 AS SELECT moo, 2*moo FROM v_test1 UNION ALL SELECT moo, 3*moo FROM v_test1;
! \d+ v_test2
!                  View "public.v_test2"
!   Column  |  Type   | Modifiers | Storage | Description 
! ----------+---------+-----------+---------+-------------
!  moo      | integer |           | plain   | 
!  ?column? | integer |           | plain   | 
! View definition:
!  SELECT v_test1.moo,
!     2 * v_test1.moo
!    FROM v_test1
! UNION ALL
!  SELECT v_test1.moo,
!     3 * v_test1.moo
!    FROM v_test1;
! 
! CREATE MATERIALIZED VIEW mv_test2 AS SELECT moo, 2*moo FROM v_test2 UNION ALL SELECT moo, 3*moo FROM v_test2;
! \d+ mv_test2
!                   Materialized view "public.mv_test2"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  moo      | integer |           | plain   |              | 
!  ?column? | integer |           | plain   |              | 
! View definition:
!  SELECT v_test2.moo,
!     2 * v_test2.moo
!    FROM v_test2
! UNION ALL
!  SELECT v_test2.moo,
!     3 * v_test2.moo
!    FROM v_test2;
! 
! CREATE MATERIALIZED VIEW mv_test3 AS SELECT * FROM mv_test2 WHERE moo = 12345;
! SELECT relispopulated FROM pg_class WHERE oid = 'mv_test3'::regclass;
!  relispopulated 
! ----------------
!  t
! (1 row)
! 
! DROP VIEW v_test1 CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view v_test2
! drop cascades to materialized view mv_test2
! drop cascades to materialized view mv_test3
! -- test that vacuum does not make empty matview look unpopulated
! CREATE TABLE hoge (i int);
! INSERT INTO hoge VALUES (generate_series(1,100000));
! CREATE MATERIALIZED VIEW hogeview AS SELECT * FROM hoge WHERE i % 2 = 0;
! CREATE INDEX hogeviewidx ON hogeview (i);
! DELETE FROM hoge;
! REFRESH MATERIALIZED VIEW hogeview;
! SELECT * FROM hogeview WHERE i < 10;
!  i 
! ---
! (0 rows)
! 
! VACUUM ANALYZE hogeview;
! SELECT * FROM hogeview WHERE i < 10;
!  i 
! ---
! (0 rows)
! 
! DROP TABLE hoge CASCADE;
! NOTICE:  drop cascades to materialized view hogeview
! -- test that duplicate values on unique index prevent refresh
! CREATE TABLE foo(a, b) AS VALUES(1, 10);
! CREATE MATERIALIZED VIEW mv AS SELECT * FROM foo;
! CREATE UNIQUE INDEX ON mv(a);
! INSERT INTO foo SELECT * FROM foo;
! REFRESH MATERIALIZED VIEW mv;
! ERROR:  could not create unique index "mv_a_idx"
! DETAIL:  Key (a)=(1) is duplicated.
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv;
! ERROR:  new data for "mv" contains duplicate rows without any null columns
! DETAIL:  Row: (1,10)
! DROP TABLE foo CASCADE;
! NOTICE:  drop cascades to materialized view mv
! -- make sure that all columns covered by unique indexes works
! CREATE TABLE foo(a, b, c) AS VALUES(1, 2, 3);
! CREATE MATERIALIZED VIEW mv AS SELECT * FROM foo;
! CREATE UNIQUE INDEX ON mv (a);
! CREATE UNIQUE INDEX ON mv (b);
! CREATE UNIQUE INDEX on mv (c);
! INSERT INTO foo VALUES(2, 3, 4);
! INSERT INTO foo VALUES(3, 4, 5);
! REFRESH MATERIALIZED VIEW mv;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv;
! DROP TABLE foo CASCADE;
! NOTICE:  drop cascades to materialized view mv
! -- allow subquery to reference unpopulated matview if WITH NO DATA is specified
! CREATE MATERIALIZED VIEW mv1 AS SELECT 1 AS col1 WITH NO DATA;
! CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1
!   WHERE col1 = (SELECT LEAST(col1) FROM mv1) WITH NO DATA;
! DROP MATERIALIZED VIEW mv1 CASCADE;
! NOTICE:  drop cascades to materialized view mv2
! -- make sure that types with unusual equality tests work
! CREATE TABLE boxes (id serial primary key, b box);
! INSERT INTO boxes (b) VALUES
!   ('(32,32),(31,31)'),
!   ('(2.0000004,2.0000004),(1,1)'),
!   ('(1.9999996,1.9999996),(1,1)');
! CREATE MATERIALIZED VIEW boxmv AS SELECT * FROM boxes;
! CREATE UNIQUE INDEX boxmv_id ON boxmv (id);
! UPDATE boxes SET b = '(2,2),(1,1)' WHERE id = 2;
! REFRESH MATERIALIZED VIEW CONCURRENTLY boxmv;
! SELECT * FROM boxmv ORDER BY id;
!  id |              b              
! ----+-----------------------------
!   1 | (32,32),(31,31)
!   2 | (2,2),(1,1)
!   3 | (1.9999996,1.9999996),(1,1)
! (3 rows)
! 
! DROP TABLE boxes CASCADE;
! NOTICE:  drop cascades to materialized view boxmv
! -- make sure that column names are handled correctly
! CREATE TABLE v (i int, j int);
! CREATE MATERIALIZED VIEW mv_v (ii) AS SELECT i, j AS jj FROM v;
! ALTER TABLE v RENAME COLUMN i TO x;
! INSERT INTO v values (1, 2);
! CREATE UNIQUE INDEX mv_v_ii ON mv_v (ii);
! REFRESH MATERIALIZED VIEW mv_v;
! UPDATE v SET j = 3 WHERE x = 1;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv_v;
! SELECT * FROM v;
!  x | j 
! ---+---
!  1 | 3
! (1 row)
! 
! SELECT * FROM mv_v;
!  ii | jj 
! ----+----
!   1 |  3
! (1 row)
! 
! DROP TABLE v CASCADE;
! NOTICE:  drop cascades to materialized view mv_v
! -- make sure that matview rows can be referenced as source rows (bug #9398)
! CREATE TABLE v AS SELECT generate_series(1,10) AS a;
! CREATE MATERIALIZED VIEW mv_v AS SELECT a FROM v WHERE a <= 5;
! DELETE FROM v WHERE EXISTS ( SELECT * FROM mv_v WHERE mv_v.a = v.a );
! SELECT * FROM v;
!  a  
! ----
!   6
!   7
!   8
!   9
!  10
! (5 rows)
! 
! SELECT * FROM mv_v;
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
! DROP TABLE v CASCADE;
! NOTICE:  drop cascades to materialized view mv_v
! -- make sure running as superuser works when MV owned by another role (bug #11208)
! CREATE ROLE user_dw;
! SET ROLE user_dw;
! CREATE TABLE foo_data AS SELECT i, md5(random()::text)
!   FROM generate_series(1, 10) i;
! CREATE MATERIALIZED VIEW mv_foo AS SELECT * FROM foo_data;
! CREATE UNIQUE INDEX ON mv_foo (i);
! RESET ROLE;
! REFRESH MATERIALIZED VIEW mv_foo;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv_foo;
! DROP OWNED BY user_dw CASCADE;
! DROP ROLE user_dw;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/lock.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/lock.out	2015-01-10 10:11:46.675649464 +0300
***************
*** 1,70 ****
! --
! -- Test the LOCK statement
! --
! -- Setup
! CREATE SCHEMA lock_schema1;
! SET search_path = lock_schema1;
! CREATE TABLE lock_tbl1 (a BIGINT);
! CREATE VIEW lock_view1 AS SELECT 1;
! CREATE ROLE regress_rol_lock1;
! ALTER ROLE regress_rol_lock1 SET search_path = lock_schema1;
! GRANT USAGE ON SCHEMA lock_schema1 TO regress_rol_lock1;
! -- Try all valid lock options; also try omitting the optional TABLE keyword.
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE;
! LOCK lock_tbl1 IN ROW SHARE MODE;
! LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN SHARE MODE;
! LOCK lock_tbl1 IN SHARE ROW EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE;
! ROLLBACK;
! -- Try using NOWAIT along with valid options.
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ROW SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE ROW EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_view1 IN EXCLUSIVE MODE;   -- Will fail; can't lock a non-table
! ERROR:  "lock_view1" is not a table
! ROLLBACK;
! -- Verify that we can lock a table with inheritance children.
! CREATE TABLE lock_tbl2 (b BIGINT) INHERITS (lock_tbl1);
! CREATE TABLE lock_tbl3 () INHERITS (lock_tbl2);
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
! ROLLBACK;
! -- Verify that we can't lock a child table just because we have permission
! -- on the parent, but that we can lock the parent only.
! GRANT UPDATE ON TABLE lock_tbl1 TO regress_rol_lock1;
! SET ROLE regress_rol_lock1;
! BEGIN;
! LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
! ERROR:  permission denied for relation lock_tbl2
! ROLLBACK;
! BEGIN;
! LOCK TABLE ONLY lock_tbl1;
! ROLLBACK;
! RESET ROLE;
! --
! -- Clean up
! --
! DROP VIEW lock_view1;
! DROP TABLE lock_tbl3;
! DROP TABLE lock_tbl2;
! DROP TABLE lock_tbl1;
! DROP SCHEMA lock_schema1 CASCADE;
! DROP ROLE regress_rol_lock1;
! -- atomic ops tests
! RESET search_path;
! SELECT test_atomic_ops();
!  test_atomic_ops 
! -----------------
!  t
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/replica_identity.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/replica_identity.out	2015-01-10 10:11:46.651649463 +0300
***************
*** 1,184 ****
! CREATE TABLE test_replica_identity (
!        id serial primary key,
!        keya text not null,
!        keyb text not null,
!        nonkey text,
!        CONSTRAINT test_replica_identity_unique_defer UNIQUE (keya, keyb) DEFERRABLE,
!        CONSTRAINT test_replica_identity_unique_nondefer UNIQUE (keya, keyb)
! );
! CREATE TABLE test_replica_identity_othertable (id serial primary key);
! CREATE INDEX test_replica_identity_keyab ON test_replica_identity (keya, keyb);
! CREATE UNIQUE INDEX test_replica_identity_keyab_key ON test_replica_identity (keya, keyb);
! CREATE UNIQUE INDEX test_replica_identity_nonkey ON test_replica_identity (keya, nonkey);
! CREATE INDEX test_replica_identity_hash ON test_replica_identity USING hash (nonkey);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE UNIQUE INDEX test_replica_identity_expr ON test_replica_identity (keya, keyb, (3));
! CREATE UNIQUE INDEX test_replica_identity_partial ON test_replica_identity (keya, keyb) WHERE keyb != '3';
! -- default is 'd'/DEFAULT for user created tables
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! -- but 'none' for system tables
! SELECT relreplident FROM pg_class WHERE oid = 'pg_class'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! SELECT relreplident FROM pg_class WHERE oid = 'pg_constraint'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! ----
! -- Make sure we detect ineligible indexes
! ----
! -- fail, not unique
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab;
! ERROR:  cannot use non-unique index "test_replica_identity_keyab" as replica identity
! -- fail, not a candidate key, nullable column
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_nonkey;
! ERROR:  index "test_replica_identity_nonkey" cannot be used as replica identity because column "nonkey" is nullable
! -- fail, hash indexes cannot do uniqueness
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_hash;
! ERROR:  cannot use non-unique index "test_replica_identity_hash" as replica identity
! -- fail, expression index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_expr;
! ERROR:  cannot use expression index "test_replica_identity_expr" as replica identity
! -- fail, partial index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_partial;
! ERROR:  cannot use partial index "test_replica_identity_partial" as replica identity
! -- fail, not our index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey;
! ERROR:  "test_replica_identity_othertable_pkey" is not an index for table "test_replica_identity"
! -- fail, deferrable
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer;
! ERROR:  cannot use non-immediate index "test_replica_identity_unique_defer" as replica identity
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! ----
! -- Make sure index cases succeeed
! ----
! -- succeed, primary key
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_pkey;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  i
! (1 row)
! 
! \d test_replica_identity
!                          Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              
! --------+---------+--------------------------------------------------------------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass)
!  keya   | text    | not null
!  keyb   | text    | not null
!  nonkey | text    | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id) REPLICA IDENTITY
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! 
! -- succeed, nondeferrable unique constraint over nonullable cols
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_nondefer;
! -- succeed unique index over nonnullable cols
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  i
! (1 row)
! 
! \d test_replica_identity
!                          Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              
! --------+---------+--------------------------------------------------------------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass)
!  keya   | text    | not null
!  keyb   | text    | not null
!  nonkey | text    | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id)
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb) REPLICA IDENTITY
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! 
! SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
!  count 
! -------
!      1
! (1 row)
! 
! ----
! -- Make sure non index cases work
! ----
! ALTER TABLE test_replica_identity REPLICA IDENTITY DEFAULT;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
!  count 
! -------
!      0
! (1 row)
! 
! ALTER TABLE test_replica_identity REPLICA IDENTITY FULL;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  f
! (1 row)
! 
! \d+ test_replica_identity
!                                              Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              | Storage  | Stats target | Description 
! --------+---------+--------------------------------------------------------------------+----------+--------------+-------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass) | plain    |              | 
!  keya   | text    | not null                                                           | extended |              | 
!  keyb   | text    | not null                                                           | extended |              | 
!  nonkey | text    |                                                                    | extended |              | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id)
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! Replica Identity: FULL
! 
! ALTER TABLE test_replica_identity REPLICA IDENTITY NOTHING;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! DROP TABLE test_replica_identity;
! DROP TABLE test_replica_identity_othertable;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rowsecurity.out	2014-11-21 01:48:04.351429000 +0300
--- /home/orion/postgres/src/test/regress/results/rowsecurity.out	2015-01-10 10:11:46.647649463 +0300
***************
*** 1,2236 ****
! --
! -- Test of Row-level security feature
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when users/groups don't exist
! SET client_min_messages TO 'warning';
! DROP USER IF EXISTS rls_regress_user0;
! DROP USER IF EXISTS rls_regress_user1;
! DROP USER IF EXISTS rls_regress_user2;
! DROP USER IF EXISTS rls_regress_exempt_user;
! DROP ROLE IF EXISTS rls_regress_group1;
! DROP ROLE IF EXISTS rls_regress_group2;
! DROP SCHEMA IF EXISTS rls_regress_schema CASCADE;
! RESET client_min_messages;
! -- initial setup
! CREATE USER rls_regress_user0;
! CREATE USER rls_regress_user1;
! CREATE USER rls_regress_user2;
! CREATE USER rls_regress_exempt_user BYPASSRLS;
! CREATE ROLE rls_regress_group1 NOLOGIN;
! CREATE ROLE rls_regress_group2 NOLOGIN;
! GRANT rls_regress_group1 TO rls_regress_user1;
! GRANT rls_regress_group2 TO rls_regress_user2;
! CREATE SCHEMA rls_regress_schema;
! GRANT ALL ON SCHEMA rls_regress_schema to public;
! SET search_path = rls_regress_schema;
! -- setup of malicious function
! CREATE OR REPLACE FUNCTION f_leak(text) RETURNS bool
!     COST 0.0000001 LANGUAGE plpgsql
!     AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END';
! GRANT EXECUTE ON FUNCTION f_leak(text) TO public;
! -- BASIC Row-Level Security Scenario
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE uaccount (
!     pguser      name primary key,
!     seclv       int
! );
! GRANT SELECT ON uaccount TO public;
! INSERT INTO uaccount VALUES
!     ('rls_regress_user0', 99),
!     ('rls_regress_user1', 1),
!     ('rls_regress_user2', 2),
!     ('rls_regress_user3', 3);
! CREATE TABLE category (
!     cid        int primary key,
!     cname      text
! );
! GRANT ALL ON category TO public;
! INSERT INTO category VALUES
!     (11, 'novel'),
!     (22, 'science fiction'),
!     (33, 'technology'),
!     (44, 'manga');
! CREATE TABLE document (
!     did         int primary key,
!     cid         int references category(cid),
!     dlevel      int not null,
!     dauthor     name,
!     dtitle      text
! );
! GRANT ALL ON document TO public;
! INSERT INTO document VALUES
!     ( 1, 11, 1, 'rls_regress_user1', 'my first novel'),
!     ( 2, 11, 2, 'rls_regress_user1', 'my second novel'),
!     ( 3, 22, 2, 'rls_regress_user1', 'my science fiction'),
!     ( 4, 44, 1, 'rls_regress_user1', 'my first manga'),
!     ( 5, 44, 2, 'rls_regress_user1', 'my second manga'),
!     ( 6, 22, 1, 'rls_regress_user2', 'great science fiction'),
!     ( 7, 33, 2, 'rls_regress_user2', 'great technology book'),
!     ( 8, 44, 1, 'rls_regress_user2', 'great manga');
! ALTER TABLE document ENABLE ROW LEVEL SECURITY;
! -- user's security level must be higher than or equal to document's
! CREATE POLICY p1 ON document
!     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
! -- viewpoint from rls_regress_user1
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (4 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel        | novel
!   44 |   4 |      1 | rls_regress_user1 | my first manga        | manga
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (4 rows)
! 
! -- viewpoint from rls_regress_user2
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (8 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel        | novel
!   11 |   2 |      2 | rls_regress_user1 | my second novel       | novel
!   22 |   3 |      2 | rls_regress_user1 | my science fiction    | science fiction
!   44 |   4 |      1 | rls_regress_user1 | my first manga        | manga
!   44 |   5 |      2 | rls_regress_user1 | my second manga       | manga
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   33 |   7 |      2 | rls_regress_user2 | great technology book | technology
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (8 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on document
!    Filter: f_leak(document.dtitle)
!    ->  Seq Scan on document document_1
!          Filter: (dlevel <= $0)
!          InitPlan 1 (returns $0)
!            ->  Index Scan using uaccount_pkey on uaccount
!                  Index Cond: (pguser = "current_user"())
! (7 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (category.cid = document.cid)
!    ->  Seq Scan on category
!    ->  Hash
!          ->  Subquery Scan on document
!                Filter: f_leak(document.dtitle)
!                ->  Seq Scan on document document_1
!                      Filter: (dlevel <= $0)
!                      InitPlan 1 (returns $0)
!                        ->  Index Scan using uaccount_pkey on uaccount
!                              Index Cond: (pguser = "current_user"())
! (11 rows)
! 
! -- only owner can change row-level security
! ALTER POLICY p1 ON document USING (true);    --fail
! ERROR:  must be owner of relation document
! DROP POLICY p1 ON document;                  --fail
! ERROR:  must be owner of relation document
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p1 ON document USING (dauthor = current_user);
! -- viewpoint from rls_regress_user1 again
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
!  did | cid | dlevel |      dauthor      |       dtitle       
! -----+-----+--------+-------------------+--------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
! (5 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
!  cid | did | dlevel |      dauthor      |       dtitle       |      cname      
! -----+-----+--------+-------------------+--------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel     | novel
!   11 |   2 |      2 | rls_regress_user1 | my second novel    | novel
!   22 |   3 |      2 | rls_regress_user1 | my science fiction | science fiction
!   44 |   4 |      1 | rls_regress_user1 | my first manga     | manga
!   44 |   5 |      2 | rls_regress_user1 | my second manga    | manga
! (5 rows)
! 
! -- viewpoint from rls_regres_user2 again
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (3 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   33 |   7 |      2 | rls_regress_user2 | great technology book | technology
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                   QUERY PLAN                  
! ----------------------------------------------
!  Subquery Scan on document
!    Filter: f_leak(document.dtitle)
!    ->  Seq Scan on document document_1
!          Filter: (dauthor = "current_user"())
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Nested Loop
!    ->  Subquery Scan on document
!          Filter: f_leak(document.dtitle)
!          ->  Seq Scan on document document_1
!                Filter: (dauthor = "current_user"())
!    ->  Index Scan using category_pkey on category
!          Index Cond: (cid = document.cid)
! (7 rows)
! 
! -- interaction of FK/PK constraints
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY p2 ON category
!     USING (CASE WHEN current_user = 'rls_regress_user1' THEN cid IN (11, 33)
!            WHEN current_user = 'rls_regress_user2' THEN cid IN (22, 44)
!            ELSE false END);
! ALTER TABLE category ENABLE ROW LEVEL SECURITY;
! -- cannot delete PK referenced by invisible FK
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid;
!  did | cid | dlevel |      dauthor      |       dtitle       | cid |   cname    
! -----+-----+--------+-------------------+--------------------+-----+------------
!    2 |  11 |      2 | rls_regress_user1 | my second novel    |  11 | novel
!    1 |  11 |      1 | rls_regress_user1 | my first novel     |  11 | novel
!      |     |        |                   |                    |  33 | technology
!    5 |  44 |      2 | rls_regress_user1 | my second manga    |     | 
!    4 |  44 |      1 | rls_regress_user1 | my first manga     |     | 
!    3 |  22 |      2 | rls_regress_user1 | my science fiction |     | 
! (6 rows)
! 
! DELETE FROM category WHERE cid = 33;    -- fails with FK violation
! ERROR:  update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
! DETAIL:  Key (cid)=(33) is still referenced from table "document".
! -- can insert FK referencing invisible PK
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid;
!  did | cid | dlevel |      dauthor      |        dtitle         | cid |      cname      
! -----+-----+--------+-------------------+-----------------------+-----+-----------------
!    6 |  22 |      1 | rls_regress_user2 | great science fiction |  22 | science fiction
!    8 |  44 |      1 | rls_regress_user2 | great manga           |  44 | manga
!    7 |  33 |      2 | rls_regress_user2 | great technology book |     | 
! (3 rows)
! 
! INSERT INTO document VALUES (10, 33, 1, current_user, 'hoge');
! -- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
! SET SESSION AUTHORIZATION rls_regress_user1;
! INSERT INTO document VALUES (8, 44, 1, 'rls_regress_user1', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't see
! ERROR:  duplicate key value violates unique constraint "document_pkey"
! DETAIL:  Key (did)=(8) already exists.
! SELECT * FROM document WHERE did = 8; -- and confirm we can't see it
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! -- database superuser does bypass RLS policy when enabled
! RESET SESSION AUTHORIZATION;
! SET row_security TO ON;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- database superuser does not bypass RLS policy when FORCE enabled.
! RESET SESSION AUTHORIZATION;
! SET row_security TO FORCE;
! SELECT * FROM document;
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! SELECT * FROM category;
!  cid | cname 
! -----+-------
! (0 rows)
! 
! -- database superuser does bypass RLS policy when disabled
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- database non-superuser with bypass privilege can bypass RLS policy when disabled
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- RLS policy applies to table owner when FORCE enabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO FORCE;
! SELECT * FROM document;
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! SELECT * FROM category;
!  cid | cname 
! -----+-------
! (0 rows)
! 
! -- RLS policy does not apply to table owner when RLS enabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- RLS policy does not apply to table owner when RLS disabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! --
! -- Table inheritance and RLS policy
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! CREATE TABLE t1 (a int, junk1 text, b text) WITH OIDS;
! ALTER TABLE t1 DROP COLUMN junk1;    -- just a disturbing factor
! GRANT ALL ON t1 TO public;
! COPY t1 FROM stdin WITH (oids);
! CREATE TABLE t2 (c float) INHERITS (t1);
! COPY t2 FROM stdin WITH (oids);
! CREATE TABLE t3 (c text, b text, a int) WITH OIDS;
! ALTER TABLE t3 INHERIT t1;
! COPY t3(a,b,c) FROM stdin WITH (oids);
! CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0); -- be even number
! CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1); -- be odd number
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM t1;
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Subquery Scan on t1
!    Filter: f_leak(t1.b)
!    ->  Append
!          ->  Seq Scan on t1 t1_1
!                Filter: ((a % 2) = 0)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (9 rows)
! 
! -- reference to system column
! SELECT oid, * FROM t1;
!  oid | a |  b  
! -----+---+-----
!  102 | 2 | bbb
!  104 | 4 | ddd
!  202 | 2 | bcd
!  204 | 4 | def
!  302 | 2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! -- reference to whole-row reference
! SELECT *, t1 FROM t1;
!  a |  b  |   t1    
! ---+-----+---------
!  2 | bbb | (2,bbb)
!  4 | ddd | (4,ddd)
!  2 | bcd | (2,bcd)
!  4 | def | (4,def)
!  2 | yyy | (2,yyy)
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! -- for share/update lock
! SELECT * FROM t1 FOR SHARE;
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  LockRows
!    ->  Subquery Scan on t1
!          ->  LockRows
!                ->  Result
!                      ->  Append
!                            ->  Seq Scan on t1 t1_1
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t2
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t3
!                                  Filter: ((a % 2) = 0)
! (11 rows)
! 
! SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  LockRows
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  LockRows
!                ->  Result
!                      ->  Append
!                            ->  Seq Scan on t1 t1_1
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t2
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t3
!                                  Filter: ((a % 2) = 0)
! (12 rows)
! 
! -- superuser is allowed to bypass RLS checks
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! -- non-superuser with bypass privilege can bypass RLS policy when disabled
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! ----- Dependencies -----
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! CREATE TABLE dependee (x integer, y integer);
! CREATE TABLE dependent (x integer, y integer);
! CREATE POLICY d1 ON dependent FOR ALL
!     TO PUBLIC
!     USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
! DROP TABLE dependee; -- Should fail without CASCADE due to dependency on row-security qual?
! ERROR:  cannot drop table dependee because other objects depend on it
! DETAIL:  policy d1 on table dependent depends on table dependee
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TABLE dependee CASCADE;
! NOTICE:  drop cascades to policy d1 on table dependent
! EXPLAIN (COSTS OFF) SELECT * FROM dependent; -- After drop, should be unqualified
!       QUERY PLAN       
! -----------------------
!  Seq Scan on dependent
! (1 row)
! 
! -----   RECURSION    ----
! --
! -- Simple recursion
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE rec1 (x integer, y integer);
! CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
! ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1; -- fail, direct recursion
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE rec2 (a integer, b integer);
! ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
! CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
! ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion via views
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rec1v AS SELECT * FROM rec1;
! CREATE VIEW rec2v AS SELECT * FROM rec2;
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
! ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion via views
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion via .s.b views
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! DROP VIEW rec1v, rec2v CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to policy r1 on table rec1
! drop cascades to policy r2 on table rec2
! CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1;
! CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2;
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
! CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion via s.b. views
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- recursive RLS and VIEWs in policy
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE s1 (a int, b text);
! INSERT INTO s1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
! CREATE TABLE s2 (x int, y text);
! INSERT INTO s2 (SELECT x, md5(x::text) FROM generate_series(-6,6) x);
! GRANT SELECT ON s1, s2 TO rls_regress_user1;
! CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
! CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
! CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
! ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW v2 AS SELECT * FROM s2 WHERE y like '%af%';
! SELECT * FROM s1 WHERE f_leak(b); -- fail (infinite recursion)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! INSERT INTO s1 VALUES (1, 'foo'); -- fail (infinite recursion)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! SET SESSION AUTHORIZATION rls_regress_user0;
! DROP POLICY p3 on s1;
! ALTER POLICY p2 ON s2 USING (x % 2 = 0);
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- OK
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
!  a |                b                 
! ---+----------------------------------
!  2 | c81e728d9d4c2f636f067f89cc14862c
!  4 | a87ff679a2f3e71d9181a67b7542122c
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on s1
!    Filter: f_leak(s1.b)
!    ->  Hash Join
!          Hash Cond: (s1_1.a = s2.x)
!          ->  Seq Scan on s1 s1_1
!          ->  Hash
!                ->  HashAggregate
!                      Group Key: s2.x
!                      ->  Subquery Scan on s2
!                            Filter: (s2.y ~~ '%2f%'::text)
!                            ->  Seq Scan on s2 s2_1
!                                  Filter: ((x % 2) = 0)
! (12 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p1 ON s1 USING (a in (select x from v2)); -- using VIEW in RLS policy
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- OK
! NOTICE:  f_leak => 0267aaf632e87a63288a08331f22c7c3
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
!  a  |                b                 
! ----+----------------------------------
!  -4 | 0267aaf632e87a63288a08331f22c7c3
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on s1
!    Filter: f_leak(s1.b)
!    ->  Hash Join
!          Hash Cond: (s1_1.a = s2.x)
!          ->  Seq Scan on s1 s1_1
!          ->  Hash
!                ->  HashAggregate
!                      Group Key: s2.x
!                      ->  Subquery Scan on s2
!                            Filter: (s2.y ~~ '%af%'::text)
!                            ->  Seq Scan on s2 s2_1
!                                  Filter: ((x % 2) = 0)
! (12 rows)
! 
! SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
!  xx | x  |                y                 
! ----+----+----------------------------------
!  -6 | -6 | 596a3d04481816330f07e4f97510c28f
!  -4 | -4 | 0267aaf632e87a63288a08331f22c7c3
!   2 |  2 | c81e728d9d4c2f636f067f89cc14862c
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Subquery Scan on s2
!    Filter: (s2.y ~~ '%28%'::text)
!    ->  Seq Scan on s2 s2_1
!          Filter: ((x % 2) = 0)
!    SubPlan 1
!      ->  Limit
!            ->  Subquery Scan on s1
!                  ->  Nested Loop Semi Join
!                        Join Filter: (s1_1.a = s2_2.x)
!                        ->  Seq Scan on s1 s1_1
!                        ->  Materialize
!                              ->  Subquery Scan on s2_2
!                                    Filter: (s2_2.y ~~ '%af%'::text)
!                                    ->  Seq Scan on s2 s2_3
!                                          Filter: ((x % 2) = 0)
! (15 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- fail (infinite recursion via view)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! -- prepared statement with rls_regress_user0 privilege
! PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
! EXECUTE p1(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p1(2);
!                   QUERY PLAN                  
! ----------------------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a <= 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t2
!          Filter: ((a <= 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t3
!          Filter: ((a <= 2) AND ((a % 2) = 0))
! (7 rows)
! 
! -- superuser is allowed to bypass RLS checks
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! -- plan cache should be invalidated
! EXECUTE p1(2);
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  1 | abc
!  2 | bcd
!  1 | xxx
!  2 | yyy
! (6 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p1(2);
!         QUERY PLAN        
! --------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: (a <= 2)
!    ->  Seq Scan on t2
!          Filter: (a <= 2)
!    ->  Seq Scan on t3
!          Filter: (a <= 2)
! (7 rows)
! 
! PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
! EXECUTE p2(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p2(2);
!        QUERY PLAN        
! -------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: (a = 2)
!    ->  Seq Scan on t2
!          Filter: (a = 2)
!    ->  Seq Scan on t3
!          Filter: (a = 2)
! (7 rows)
! 
! -- also, case when privilege switch from superuser
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! EXECUTE p2(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p2(2);
!                  QUERY PLAN                  
! ---------------------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a = 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t2
!          Filter: ((a = 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t3
!          Filter: ((a = 2) AND ((a % 2) = 0))
! (7 rows)
! 
! --
! -- UPDATE / DELETE and Row-level security
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Update on t1 t1_3
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_4
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_1
!          Filter: f_leak(t1_1.b)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_2
!          Filter: f_leak(t1_2.b)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (13 rows)
! 
! UPDATE t1 SET b = b || b WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
! EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Update on t1 t1_1
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_2
!                Filter: ((a % 2) = 0)
! (5 rows)
! 
! UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
! NOTICE:  f_leak => bbbbbb
! NOTICE:  f_leak => dddddd
! -- returning clause with system column
! UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
! (2 rows)
! 
! UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  a |      b      
! ---+-------------
!  2 | bbbbbb_updt
!  4 | dddddd_updt
!  2 | bcdbcd
!  4 | defdef
!  2 | yyyyyy
! (5 rows)
! 
! UPDATE t1 SET b = b WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
!  202 | 2 | bcdbcd      | (2,bcdbcd)
!  204 | 4 | defdef      | (4,defdef)
!  302 | 2 | yyyyyy      | (2,yyyyyy)
! (5 rows)
! 
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1;
!  a |      b      
! ---+-------------
!  1 | aaa
!  3 | ccc
!  2 | bbbbbb_updt
!  4 | dddddd_updt
!  1 | abc
!  3 | cde
!  2 | bcdbcd
!  4 | defdef
!  1 | xxx
!  3 | zzz
!  2 | yyyyyy
! (11 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Delete on t1 t1_1
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_2
!                Filter: ((a % 2) = 0)
! (5 rows)
! 
! EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Delete on t1 t1_3
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_4
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_1
!          Filter: f_leak(t1_1.b)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_2
!          Filter: f_leak(t1_2.b)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (13 rows)
! 
! DELETE FROM only t1 WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
! (2 rows)
! 
! DELETE FROM t1 WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  oid | a |   b    |     t1     
! -----+---+--------+------------
!  202 | 2 | bcdbcd | (2,bcdbcd)
!  204 | 4 | defdef | (4,defdef)
!  302 | 2 | yyyyyy | (2,yyyyyy)
! (3 rows)
! 
! --
! -- ROLE/GROUP
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE z1 (a int, b text);
! GRANT SELECT ON z1 TO rls_regress_group1, rls_regress_group2,
!     rls_regress_user1, rls_regress_user2;
! INSERT INTO z1 VALUES
!     (1, 'aaa'),
!     (2, 'bbb'),
!     (3, 'ccc'),
!     (4, 'ddd');
! CREATE POLICY p1 ON z1 TO rls_regress_group1 USING (a % 2 = 0);
! CREATE POLICY p2 ON z1 TO rls_regress_group2 USING (a % 2 = 1);
! ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET ROLE rls_regress_group1;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => ccc
!  a |  b  
! ---+-----
!  1 | aaa
!  3 | ccc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 1)
! (4 rows)
! 
! SET ROLE rls_regress_group2;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => ccc
!  a |  b  
! ---+-----
!  1 | aaa
!  3 | ccc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 1)
! (4 rows)
! 
! --
! -- Views should follow policy for view owner.
! --
! -- View and Table owner are the same.
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
! GRANT SELECT ON rls_view TO rls_regress_user1;
! -- Query as role that is not owner of view or table.  Should return all records.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!      QUERY PLAN      
! ---------------------
!  Seq Scan on z1
!    Filter: f_leak(b)
! (2 rows)
! 
! -- Query as view/table owner.  Should return all records.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!      QUERY PLAN      
! ---------------------
!  Seq Scan on z1
!    Filter: f_leak(b)
! (2 rows)
! 
! DROP VIEW rls_view;
! -- View and Table owners are different.
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
! GRANT SELECT ON rls_view TO rls_regress_user0;
! -- Query as role that is not owner of view but is owner of table.
! -- Should return records based on view owner policies.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! -- Query as role that is not owner of table but is owner of view.
! -- Should return records based on view owner policies.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! -- Query as role that is not the owner of the table or view without permissions.
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM rls_view; --fail - permission denied.
! ERROR:  permission denied for relation rls_view
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view; --fail - permission denied.
! ERROR:  permission denied for relation rls_view
! -- Query as role that is not the owner of the table or view with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! GRANT SELECT ON rls_view TO rls_regress_user2;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! DROP VIEW rls_view;
! --
! -- Command specific
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE x1 (a int, b text, c text);
! GRANT ALL ON x1 TO PUBLIC;
! INSERT INTO x1 VALUES
!     (1, 'abc', 'rls_regress_user1'),
!     (2, 'bcd', 'rls_regress_user1'),
!     (3, 'cde', 'rls_regress_user2'),
!     (4, 'def', 'rls_regress_user2'),
!     (5, 'efg', 'rls_regress_user1'),
!     (6, 'fgh', 'rls_regress_user1'),
!     (7, 'fgh', 'rls_regress_user2'),
!     (8, 'fgh', 'rls_regress_user2');
! CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
! CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
! CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
! CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
! CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
! ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => efg
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => fgh
!  a |  b  |         c         
! ---+-----+-------------------
!  1 | abc | rls_regress_user1
!  2 | bcd | rls_regress_user1
!  4 | def | rls_regress_user2
!  5 | efg | rls_regress_user1
!  6 | fgh | rls_regress_user1
!  8 | fgh | rls_regress_user2
! (6 rows)
! 
! UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => efg
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => fgh
!  a |    b     |         c         
! ---+----------+-------------------
!  1 | abc_updt | rls_regress_user1
!  2 | bcd_updt | rls_regress_user1
!  4 | def_updt | rls_regress_user2
!  5 | efg_updt | rls_regress_user1
!  6 | fgh_updt | rls_regress_user1
!  8 | fgh_updt | rls_regress_user2
! (6 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => bcd_updt
! NOTICE:  f_leak => def_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => fgh_updt
!  a |    b     |         c         
! ---+----------+-------------------
!  2 | bcd_updt | rls_regress_user1
!  3 | cde      | rls_regress_user2
!  4 | def_updt | rls_regress_user2
!  6 | fgh_updt | rls_regress_user1
!  7 | fgh      | rls_regress_user2
!  8 | fgh_updt | rls_regress_user2
! (6 rows)
! 
! UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => bcd_updt
! NOTICE:  f_leak => def_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => fgh_updt
!  a |       b       |         c         
! ---+---------------+-------------------
!  3 | cde_updt      | rls_regress_user2
!  7 | fgh_updt      | rls_regress_user2
!  2 | bcd_updt_updt | rls_regress_user1
!  4 | def_updt_updt | rls_regress_user2
!  6 | fgh_updt_updt | rls_regress_user1
!  8 | fgh_updt_updt | rls_regress_user2
! (6 rows)
! 
! DELETE FROM x1 WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => abc_updt
! NOTICE:  f_leak => efg_updt
! NOTICE:  f_leak => cde_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => bcd_updt_updt
! NOTICE:  f_leak => def_updt_updt
! NOTICE:  f_leak => fgh_updt_updt
! NOTICE:  f_leak => fgh_updt_updt
!  a |       b       |         c         
! ---+---------------+-------------------
!  1 | abc_updt      | rls_regress_user1
!  5 | efg_updt      | rls_regress_user1
!  3 | cde_updt      | rls_regress_user2
!  7 | fgh_updt      | rls_regress_user2
!  2 | bcd_updt_updt | rls_regress_user1
!  4 | def_updt_updt | rls_regress_user2
!  6 | fgh_updt_updt | rls_regress_user1
!  8 | fgh_updt_updt | rls_regress_user2
! (8 rows)
! 
! --
! -- Duplicate Policy Names
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE y1 (a int, b text);
! CREATE TABLE y2 (a int, b text);
! GRANT ALL ON y1, y2 TO rls_regress_user1;
! CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
! CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
! CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);  --fail
! ERROR:  policy "p1" for relation "y1" already exists
! CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);  --OK
! ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
! --
! -- Expression structure with SBV
! --
! -- Create view as table owner.  RLS should NOT be applied.
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE VIEW rls_sbv WITH (security_barrier) AS
!     SELECT * FROM y1 WHERE f_leak(b);
! EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
!             QUERY PLAN             
! -----------------------------------
!  Seq Scan on y1
!    Filter: (f_leak(b) AND (a = 1))
! (2 rows)
! 
! DROP VIEW rls_sbv;
! -- Create view as role that does not own table.  RLS should be applied.
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rls_sbv WITH (security_barrier) AS
!     SELECT * FROM y1 WHERE f_leak(b);
! EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on y1
!    Filter: f_leak(y1.b)
!    ->  Seq Scan on y1 y1_1
!          Filter: ((a = 1) AND ((a > 2) OR ((a % 2) = 0)))
! (4 rows)
! 
! DROP VIEW rls_sbv;
! --
! -- Expression structure
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! INSERT INTO y2 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
! CREATE POLICY p2 ON y2 USING (a % 3 = 0);
! CREATE POLICY p3 ON y2 USING (a % 4 = 0);
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM y2 WHERE f_leak(b);
! NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => eccbc87e4b5ce2fe28308fd9f2a7baf3
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
! NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
! NOTICE:  f_leak => 45c48cce2e2d7fbdea1afc51c7c6ad26
! NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
! NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
! NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
! NOTICE:  f_leak => 9bf31c7ff062936a96d3c8bd1f8f2ff3
! NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
! NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
! NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (14 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Subquery Scan on y2
!    Filter: f_leak(y2.b)
!    ->  Seq Scan on y2 y2_1
!          Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))
! (4 rows)
! 
! --
! -- Plancache invalidate on user change.
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE t1 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table t2
! drop cascades to table t3
! CREATE TABLE t1 (a integer);
! GRANT SELECT ON t1 TO rls_regress_user1, rls_regress_user2;
! CREATE POLICY p1 ON t1 TO rls_regress_user1 USING ((a % 2) = 0);
! CREATE POLICY p2 ON t1 TO rls_regress_user2 USING ((a % 4) = 0);
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! SET ROLE rls_regress_user1;
! PREPARE role_inval AS SELECT * FROM t1;
! EXPLAIN (COSTS OFF) EXECUTE role_inval;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on t1
!    Filter: ((a % 2) = 0)
! (2 rows)
! 
! SET ROLE rls_regress_user2;
! EXPLAIN (COSTS OFF) EXECUTE role_inval;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on t1
!    Filter: ((a % 4) = 0)
! (2 rows)
! 
! --
! -- CTE and RLS
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE t1 CASCADE;
! CREATE TABLE t1 (a integer, b text);
! CREATE POLICY p1 ON t1 USING (a % 2 = 0);
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! GRANT ALL ON t1 TO rls_regress_user1;
! INSERT INTO t1 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
! SET SESSION AUTHORIZATION rls_regress_user1;
! WITH cte1 AS (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
! NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
! NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
! NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
! NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
! NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
! NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
! NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
! NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (11 rows)
! 
! EXPLAIN (COSTS OFF) WITH cte1 AS (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
!               QUERY PLAN               
! ---------------------------------------
!  CTE Scan on cte1
!    CTE cte1
!      ->  Subquery Scan on t1
!            Filter: f_leak(t1.b)
!            ->  Seq Scan on t1 t1_1
!                  Filter: ((a % 2) = 0)
! (6 rows)
! 
! WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1; --fail
! ERROR:  new row violates WITH CHECK OPTION for "t1"
! DETAIL:  Failing row contains (1, cfcd208495d565ef66e7dff9f98764da).
! WITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1; --ok
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (11 rows)
! 
! WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1; --fail
! ERROR:  new row violates WITH CHECK OPTION for "t1"
! DETAIL:  Failing row contains (21, Fail).
! WITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1; --ok
!  a  |    b    
! ----+---------
!  20 | Success
! (1 row)
! 
! --
! -- Rename Policy
! --
! RESET SESSION AUTHORIZATION;
! ALTER POLICY p1 ON t1 RENAME TO p1; --fail
! ERROR:  row-policy "p1" for table "t1" already exists
! SELECT rsecpolname, relname
!     FROM pg_rowsecurity rs
!     JOIN pg_class pc ON (pc.oid = rs.rsecrelid)
!     WHERE relname = 't1';
!  rsecpolname | relname 
! -------------+---------
!  p1          | t1
! (1 row)
! 
! ALTER POLICY p1 ON t1 RENAME TO p2; --ok
! SELECT rsecpolname, relname
!     FROM pg_rowsecurity rs
!     JOIN pg_class pc ON (pc.oid = rs.rsecrelid)
!     WHERE relname = 't1';
!  rsecpolname | relname 
! -------------+---------
!  p2          | t1
! (1 row)
! 
! --
! -- Check INSERT SELECT
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE TABLE t2 (a integer, b text);
! INSERT INTO t2 (SELECT * FROM t1);
! EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
!           QUERY PLAN           
! -------------------------------
!  Insert on t2
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
! (3 rows)
! 
! SELECT * FROM t2;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t2;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t2
! (1 row)
! 
! CREATE TABLE t3 AS SELECT * FROM t1;
! SELECT * FROM t3;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! SELECT * INTO t4 FROM t1;
! SELECT * FROM t4;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! --
! -- RLS with JOIN
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE blog (id integer, author text, post text);
! CREATE TABLE comment (blog_id integer, message text);
! GRANT ALL ON blog, comment TO rls_regress_user1;
! CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
! ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
! INSERT INTO blog VALUES
!     (1, 'alice', 'blog #1'),
!     (2, 'bob', 'blog #1'),
!     (3, 'alice', 'blog #2'),
!     (4, 'alice', 'blog #3'),
!     (5, 'john', 'blog #1');
! INSERT INTO comment VALUES
!     (1, 'cool blog'),
!     (1, 'fun blog'),
!     (3, 'crazy blog'),
!     (5, 'what?'),
!     (4, 'insane!'),
!     (2, 'who did it?');
! SET SESSION AUTHORIZATION rls_regress_user1;
! -- Check RLS JOIN with Non-RLS.
! SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   4 | alice  | insane!
!   2 | bob    | who did it?
! (2 rows)
! 
! -- Check Non-RLS JOIN with RLS.
! SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   4 | alice  | insane!
!   2 | bob    | who did it?
! (2 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY comment_1 ON comment USING (blog_id < 4);
! ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! -- Check RLS JOIN RLS
! SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   2 | bob    | who did it?
! (1 row)
! 
! SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   2 | bob    | who did it?
! (1 row)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! DROP TABLE blog, comment;
! --
! -- Default Deny Policy
! --
! RESET SESSION AUTHORIZATION;
! DROP POLICY p2 ON t1;
! ALTER TABLE t1 OWNER TO rls_regress_user0;
! -- Check that default deny does not apply to superuser.
! RESET SESSION AUTHORIZATION;
! SELECT * FROM t1;
!  a  |                b                 
! ----+----------------------------------
!   1 | c4ca4238a0b923820dcc509a6f75849b
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   5 | e4da3b7fbbce2345d7772b0674a318d5
!   7 | 8f14e45fceea167a5a36dedd4bea2543
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  11 | 6512bd43d9caa6e02c990b0a82652dca
!  13 | c51ce410c124a10e0db5e4b97fc2af39
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  17 | 70efdf2ec9b086079795c442636b55fb
!  19 | 1f0e3dad99908345f7439f8ffabdffc4
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (22 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t1
! (1 row)
! 
! -- Check that default deny does not apply to table owner.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM t1;
!  a  |                b                 
! ----+----------------------------------
!   1 | c4ca4238a0b923820dcc509a6f75849b
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   5 | e4da3b7fbbce2345d7772b0674a318d5
!   7 | 8f14e45fceea167a5a36dedd4bea2543
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  11 | 6512bd43d9caa6e02c990b0a82652dca
!  13 | c51ce410c124a10e0db5e4b97fc2af39
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  17 | 70efdf2ec9b086079795c442636b55fb
!  19 | 1f0e3dad99908345f7439f8ffabdffc4
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (22 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t1
! (1 row)
! 
! -- Check that default deny does apply to superuser when RLS force.
! SET row_security TO FORCE;
! RESET SESSION AUTHORIZATION;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- Check that default deny does apply to table owner when RLS force.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- Check that default deny applies to non-owner/non-superuser when RLS on.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! --
! -- Event Triggers
! --
! RESET SESSION AUTHORIZATION;
! CREATE TABLE event_trigger_test (a integer, b text);
! CREATE OR REPLACE FUNCTION start_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - ddl_command_start', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE OR REPLACE FUNCTION end_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - ddl_command_end', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE OR REPLACE FUNCTION drop_sql_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - sql_drop', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE EVENT TRIGGER start_rls_command ON ddl_command_start
!     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE start_command();
! CREATE EVENT TRIGGER end_rls_command ON ddl_command_end
!     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE end_command();
! CREATE EVENT TRIGGER sql_drop_command ON sql_drop
!     WHEN TAG IN ('DROP POLICY') EXECUTE PROCEDURE drop_sql_command();
! CREATE POLICY p1 ON event_trigger_test USING (FALSE);
! NOTICE:  CREATE POLICY - ddl_command_start
! NOTICE:  CREATE POLICY - ddl_command_end
! ALTER POLICY p1 ON event_trigger_test USING (TRUE);
! NOTICE:  ALTER POLICY - ddl_command_start
! NOTICE:  ALTER POLICY - ddl_command_end
! ALTER POLICY p1 ON event_trigger_test RENAME TO p2;
! NOTICE:  ALTER POLICY - ddl_command_start
! NOTICE:  ALTER POLICY - ddl_command_end
! DROP POLICY p2 ON event_trigger_test;
! NOTICE:  DROP POLICY - ddl_command_start
! NOTICE:  DROP POLICY - sql_drop
! NOTICE:  DROP POLICY - ddl_command_end
! DROP EVENT TRIGGER start_rls_command;
! DROP EVENT TRIGGER end_rls_command;
! DROP EVENT TRIGGER sql_drop_command;
! --
! -- COPY TO/FROM
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE copy_t CASCADE;
! ERROR:  table "copy_t" does not exist
! CREATE TABLE copy_t (a integer, b text);
! CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
! ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
! GRANT ALL ON copy_t TO rls_regress_user1, rls_regress_exempt_user;
! INSERT INTO copy_t (SELECT x, md5(x::text) FROM generate_series(0,10) x);
! -- Check COPY TO as Superuser/owner.
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - insufficient to bypass rls
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user with permissions and BYPASSRLS
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user without permissions.SET row_security TO OFF;
! SET SESSION AUTHORIZATION rls_regress_user2;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - insufficient to bypass rls
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission denied
! ERROR:  permission denied for relation copy_t
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission denied
! ERROR:  permission denied for relation copy_t
! -- Check COPY FROM as Superuser/owner.
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY FROM as user with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --fail - insufficient privilege to bypass rls.
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY TO as user with permissions and BYPASSRLS
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY FROM as user without permissions.
! SET SESSION AUTHORIZATION rls_regress_user2;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! RESET SESSION AUTHORIZATION;
! DROP TABLE copy_t;
! --
! -- Clean up objects
! --
! RESET SESSION AUTHORIZATION;
! DROP SCHEMA rls_regress_schema CASCADE;
! NOTICE:  drop cascades to 24 other objects
! DETAIL:  drop cascades to function f_leak(text)
! drop cascades to table uaccount
! drop cascades to table category
! drop cascades to table document
! drop cascades to table dependent
! drop cascades to table rec1
! drop cascades to table rec2
! drop cascades to view rec1v
! drop cascades to view rec2v
! drop cascades to table s1
! drop cascades to table s2
! drop cascades to view v2
! drop cascades to table z1
! drop cascades to table x1
! drop cascades to table y1
! drop cascades to table y2
! drop cascades to table t1
! drop cascades to table t2
! drop cascades to table t3
! drop cascades to table t4
! drop cascades to table event_trigger_test
! drop cascades to function start_command()
! drop cascades to function end_command()
! drop cascades to function drop_sql_command()
! DROP USER rls_regress_user0;
! DROP USER rls_regress_user1;
! DROP USER rls_regress_user2;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/alter_generic.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/alter_generic.out	2015-01-10 10:11:46.795649466 +0300
***************
*** 1,681 ****
! --
! -- Test for ALTER some_object {RENAME TO, OWNER TO, SET SCHEMA}
! --
! -- Clean up in case a prior regression run failed
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS regtest_alter_user1;
! DROP ROLE IF EXISTS regtest_alter_user2;
! DROP ROLE IF EXISTS regtest_alter_user3;
! RESET client_min_messages;
! CREATE USER regtest_alter_user3;
! CREATE USER regtest_alter_user2;
! CREATE USER regtest_alter_user1 IN ROLE regtest_alter_user3;
! CREATE SCHEMA alt_nsp1;
! CREATE SCHEMA alt_nsp2;
! GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;
! SET search_path = alt_nsp1, public;
! --
! -- Function and Aggregate
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 + 1';
! CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 - 1';
! CREATE AGGREGATE alt_agg1 (
!   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0
! );
! CREATE AGGREGATE alt_agg2 (
!   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0
! );
! ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER AGGREGATE alt_func1(int) OWNER TO regtest_alter_user3;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;  -- failed (name conflict)
! ERROR:  function alt_func2(integer) already exists in schema "alt_nsp1"
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;  -- OK
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user3;  -- OK
! ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OK
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict)
! ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp1"
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OK
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user3;  -- OK
! ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 + 2';
! CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 - 2';
! CREATE AGGREGATE alt_agg1 (
!   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100
! );
! CREATE AGGREGATE alt_agg2 (
!   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100
! );
! ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;	-- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func4;	-- OK
! ALTER FUNCTION alt_func3(int) OWNER TO regtest_alter_user2;	-- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user3;	-- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;      -- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;	-- failed (name conflicts)
! ERROR:  function alt_func2(integer) already exists in schema "alt_nsp2"
! ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;   -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;   -- OK
! ALTER AGGREGATE alt_agg3(int) OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, proname, prorettype::regtype, proisagg, a.rolname
!   FROM pg_proc p, pg_namespace n, pg_authid a
!   WHERE p.pronamespace = n.oid AND p.proowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, proname;
!  nspname  |  proname  | prorettype | proisagg |       rolname       
! ----------+-----------+------------+----------+---------------------
!  alt_nsp1 | alt_agg2  | integer    | t        | regtest_alter_user2
!  alt_nsp1 | alt_agg3  | integer    | t        | regtest_alter_user1
!  alt_nsp1 | alt_agg4  | integer    | t        | regtest_alter_user2
!  alt_nsp1 | alt_func2 | integer    | f        | regtest_alter_user2
!  alt_nsp1 | alt_func3 | integer    | f        | regtest_alter_user1
!  alt_nsp1 | alt_func4 | integer    | f        | regtest_alter_user2
!  alt_nsp2 | alt_agg2  | integer    | t        | regtest_alter_user3
!  alt_nsp2 | alt_func2 | integer    | f        | regtest_alter_user3
! (8 rows)
! 
! --
! -- We would test collations here, but it's not possible because the error
! -- messages tend to be nonportable.
! --
! --
! -- Conversion
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;  -- failed (name conflict)
! ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp1"
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;  -- OK
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user3;  -- OK
! ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;  -- OK
! ALTER CONVERSION alt_conv3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, c.conname, a.rolname
!   FROM pg_conversion c, pg_namespace n, pg_authid a
!   WHERE c.connamespace = n.oid AND c.conowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, conname;
!  nspname  |  conname  |       rolname       
! ----------+-----------+---------------------
!  alt_nsp1 | alt_conv2 | regtest_alter_user2
!  alt_nsp1 | alt_conv3 | regtest_alter_user1
!  alt_nsp1 | alt_conv4 | regtest_alter_user2
!  alt_nsp2 | alt_conv2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Foreign Data Wrapper and Foreign Server
! --
! CREATE FOREIGN DATA WRAPPER alt_fdw1;
! CREATE FOREIGN DATA WRAPPER alt_fdw2;
! CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
! CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
! ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict)
! ERROR:  foreign-data wrapper "alt_fdw2" already exists
! ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OK
! ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict)
! ERROR:  server "alt_fserv2" already exists
! ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OK
! SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
!  fdwname  
! ----------
!  alt_fdw2
!  alt_fdw3
! (2 rows)
! 
! SELECT srvname FROM pg_foreign_server WHERE srvname like 'alt_fserv%';
!   srvname   
! ------------
!  alt_fserv2
!  alt_fserv3
! (2 rows)
! 
! --
! -- Procedural Language
! --
! CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
! CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler;
! ALTER LANGUAGE alt_lang1 OWNER TO regtest_alter_user1;  -- OK
! ALTER LANGUAGE alt_lang2 OWNER TO regtest_alter_user2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user1;
! ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;   -- failed (name conflict)
! ERROR:  language "alt_lang2" already exists
! ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;   -- failed (not owner)
! ERROR:  must be owner of language alt_lang2
! ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;   -- OK
! ALTER LANGUAGE alt_lang2 OWNER TO regtest_alter_user3;  -- failed (not owner)
! ERROR:  must be owner of language alt_lang2
! ALTER LANGUAGE alt_lang3 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER LANGUAGE alt_lang3 OWNER TO regtest_alter_user3;  -- OK
! RESET SESSION AUTHORIZATION;
! SELECT lanname, a.rolname
!   FROM pg_language l, pg_authid a
!   WHERE l.lanowner = a.oid AND l.lanname like 'alt_lang%'
!   ORDER BY lanname;
!   lanname  |       rolname       
! -----------+---------------------
!  alt_lang2 | regtest_alter_user2
!  alt_lang3 | regtest_alter_user3
! (2 rows)
! 
! --
! -- Operator
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
! CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;           -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator @+@
! ALTER OPERATOR @-@(int4, int4) OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (not owner)
! ERROR:  must be owner of operator @+@
! -- can't test this: the error message includes the raw oid of namespace
! -- ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (name conflict)
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, oprname, a.rolname,
!     oprleft::regtype, oprright::regtype, oprcode::regproc
!   FROM pg_operator o, pg_namespace n, pg_authid a
!   WHERE o.oprnamespace = n.oid AND o.oprowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, oprname;
!  nspname  | oprname |       rolname       | oprleft | oprright | oprcode 
! ----------+---------+---------------------+---------+----------+---------
!  alt_nsp1 | @+@     | regtest_alter_user3 | integer | integer  | int4pl
!  alt_nsp1 | @-@     | regtest_alter_user2 | integer | integer  | int4mi
!  alt_nsp2 | @-@     | regtest_alter_user1 | integer | integer  | int4mi
! (3 rows)
! 
! --
! -- OpFamily and OpClass
! --
! CREATE OPERATOR FAMILY alt_opf1 USING hash;
! CREATE OPERATOR FAMILY alt_opf2 USING hash;
! ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regtest_alter_user1;
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user1;
! CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
! CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
! ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regtest_alter_user1;
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user1;
! SET SESSION AUTHORIZATION regtest_alter_user1;
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict)
! ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OK
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OK
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict)
! ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OK
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- OK
! RESET SESSION AUTHORIZATION;
! CREATE OPERATOR FAMILY alt_opf1 USING hash;
! CREATE OPERATOR FAMILY alt_opf2 USING hash;
! ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regtest_alter_user2;
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user2;
! CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
! CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
! ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regtest_alter_user2;
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user2;
! SET SESSION AUTHORIZATION regtest_alter_user2;
! ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OK
! ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"
! ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OK
! ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, opfname, amname, rolname
!   FROM pg_opfamily o, pg_am m, pg_namespace n, pg_authid a
!   WHERE o.opfmethod = m.oid AND o.opfnamespace = n.oid AND o.opfowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
! 	AND NOT opfname LIKE 'alt_opc%'
!   ORDER BY nspname, opfname;
!  nspname  | opfname  | amname |       rolname       
! ----------+----------+--------+---------------------
!  alt_nsp1 | alt_opf2 | hash   | regtest_alter_user2
!  alt_nsp1 | alt_opf3 | hash   | regtest_alter_user1
!  alt_nsp1 | alt_opf4 | hash   | regtest_alter_user2
!  alt_nsp2 | alt_opf2 | hash   | regtest_alter_user3
! (4 rows)
! 
! SELECT nspname, opcname, amname, rolname
!   FROM pg_opclass o, pg_am m, pg_namespace n, pg_authid a
!   WHERE o.opcmethod = m.oid AND o.opcnamespace = n.oid AND o.opcowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, opcname;
!  nspname  | opcname  | amname |       rolname       
! ----------+----------+--------+---------------------
!  alt_nsp1 | alt_opc2 | hash   | regtest_alter_user2
!  alt_nsp1 | alt_opc3 | hash   | regtest_alter_user1
!  alt_nsp1 | alt_opc4 | hash   | regtest_alter_user2
!  alt_nsp2 | alt_opc2 | hash   | regtest_alter_user3
! (4 rows)
! 
! -- ALTER OPERATOR FAMILY ... ADD/DROP
! -- Should work. Textbook case of CREATE / ALTER ADD / ALTER DROP / DROP
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf4 USING btree;
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD
!   -- int4 vs int2
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);
! ALTER OPERATOR FAMILY alt_opf4 USING btree DROP
!   -- int4 vs int2
!   OPERATOR 1 (int4, int2) ,
!   OPERATOR 2 (int4, int2) ,
!   OPERATOR 3 (int4, int2) ,
!   OPERATOR 4 (int4, int2) ,
!   OPERATOR 5 (int4, int2) ,
!   FUNCTION 1 (int4, int2) ;
! DROP OPERATOR FAMILY alt_opf4 USING btree;
! ROLLBACK;
! -- Should fail. Invalid values for ALTER OPERATOR FAMILY .. ADD / DROP
! CREATE OPERATOR FAMILY alt_opf4 USING btree;
! ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2); -- invalid indexing_method
! ERROR:  access method "invalid_index_method" does not exist
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2); -- operator number should be between 1 and 5
! ERROR:  invalid operator number 6, must be between 1 and 5
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2); -- operator number should be between 1 and 5
! ERROR:  invalid operator number 0, must be between 1 and 5
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ; -- operator without argument types
! ERROR:  operator argument types must be specified in ALTER OPERATOR FAMILY
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2); -- function number should be between 1 and 5
! ERROR:  invalid procedure number 0, must be between 1 and 2
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2); -- function number should be between 1 and 5
! ERROR:  invalid procedure number 6, must be between 1 and 2
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage; -- Ensure STORAGE is not a part of ALTER OPERATOR FAMILY
! ERROR:  STORAGE cannot be specified in ALTER OPERATOR FAMILY
! DROP OPERATOR FAMILY alt_opf4 USING btree;
! -- Should fail. Need to be SUPERUSER to do ALTER OPERATOR FAMILY .. ADD / DROP
! BEGIN TRANSACTION;
! CREATE ROLE regtest_alter_user5 NOSUPERUSER;
! CREATE OPERATOR FAMILY alt_opf5 USING btree;
! SET ROLE regtest_alter_user5;
! ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
! ERROR:  must be superuser to alter an operator family
! RESET ROLE;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DROP OPERATOR FAMILY alt_opf5 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. Need rights to namespace for ALTER OPERATOR FAMILY .. ADD / DROP
! BEGIN TRANSACTION;
! CREATE ROLE regtest_alter_user6;
! CREATE SCHEMA alt_nsp6;
! REVOKE ALL ON SCHEMA alt_nsp6 FROM regtest_alter_user6;
! CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
! SET ROLE regtest_alter_user6;
! ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
! ERROR:  permission denied for schema alt_nsp6
! ROLLBACK;
! -- Should fail. Only two arguments required for ALTER OPERATOR FAMILY ... DROP OPERATOR
! CREATE OPERATOR FAMILY alt_opf7 USING btree;
! ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
! ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
! ERROR:  one or two argument types must be specified
! DROP OPERATOR FAMILY alt_opf7 USING btree;
! -- Should work. During ALTER OPERATOR FAMILY ... DROP OPERATOR
! -- when left type is the same as right type, a DROP with only one argument type should work
! CREATE OPERATOR FAMILY alt_opf8 USING btree;
! ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
! DROP OPERATOR FAMILY alt_opf8 USING btree;
! -- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf9 USING gist;
! ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! DROP OPERATOR FAMILY alt_opf9 USING gist;
! -- Should fail. Ensure correct ordering methods in ALTER OPERATOR FAMILY ... ADD OPERATOR .. FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf10 USING btree;
! ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! ERROR:  access method "btree" does not support ordering operators
! DROP OPERATOR FAMILY alt_opf10 USING btree;
! -- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf11 USING gist;
! ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
! DROP OPERATOR FAMILY alt_opf11 USING gist;
! -- Should fail. btree comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf12 USING btree;
! CREATE FUNCTION fn_opf12  (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
! ERROR:  btree comparison procedures must return integer
! DROP OPERATOR FAMILY alt_opf12 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. hash comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf13 USING hash;
! CREATE FUNCTION fn_opf13  (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
! ERROR:  hash procedures must return integer
! DROP OPERATOR FAMILY alt_opf13 USING hash;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. btree comparison functions should have two arguments in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf14 USING btree;
! CREATE FUNCTION fn_opf14 (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
! ERROR:  btree comparison procedures must have two arguments
! DROP OPERATOR FAMILY alt_opf14 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. hash comparison functions should have one argument in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf15 USING hash;
! CREATE FUNCTION fn_opf15 (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
! ERROR:  hash procedures must have one argument
! DROP OPERATOR FAMILY alt_opf15 USING hash;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. In gist throw an error when giving different data types for function argument
! -- without defining left / right type in ALTER OPERATOR FAMILY ... ADD FUNCTION
! CREATE OPERATOR FAMILY alt_opf16 USING gist;
! ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
! ERROR:  associated data types must be specified for index support procedure
! DROP OPERATOR FAMILY alt_opf16 USING gist;
! -- Should fail. duplicate operator number / function number in ALTER OPERATOR FAMILY ... ADD FUNCTION
! CREATE OPERATOR FAMILY alt_opf17 USING btree;
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4); -- operator # appears twice in same statment
! ERROR:  operator number 1 for (integer,integer) appears more than once
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested first-time
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested again in separate statement
! ERROR:  operator 1(integer,integer) already exists in operator family "alt_opf17"
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears twice in same statement
! ERROR:  procedure number 1 for (integer,smallint) appears more than once
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears first time
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 requested again in separate statement
! ERROR:  operator 1(integer,smallint) already exists in operator family "alt_opf17"
! DROP OPERATOR FAMILY alt_opf17 USING btree;
! -- Should fail. Ensure that DROP requests for missing OPERATOR / FUNCTIONS
! -- return appropriate message in ALTER OPERATOR FAMILY ... DROP OPERATOR / FUNCTION
! CREATE OPERATOR FAMILY alt_opf18 USING btree;
! ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
! ERROR:  operator 1(integer,integer) does not exist in operator family "alt_opf18"
! ALTER OPERATOR FAMILY alt_opf18 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);
! ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
! ERROR:  function 2(integer,integer) does not exist in operator family "alt_opf18"
! DROP OPERATOR FAMILY alt_opf18 USING btree;
! --
! -- Text Search Dictionary
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;  -- failed (name conflict)
! ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user3;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, dictname, rolname
!   FROM pg_ts_dict t, pg_namespace n, pg_authid a
!   WHERE t.dictnamespace = n.oid AND t.dictowner = a.oid
!     AND n.nspname in ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, dictname;
!  nspname  |   dictname   |       rolname       
! ----------+--------------+---------------------
!  alt_nsp1 | alt_ts_dict2 | regtest_alter_user2
!  alt_nsp1 | alt_ts_dict3 | regtest_alter_user1
!  alt_nsp1 | alt_ts_dict4 | regtest_alter_user2
!  alt_nsp2 | alt_ts_dict2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Text Search Configuration
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict)
! ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user3;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, cfgname, rolname
!   FROM pg_ts_config t, pg_namespace n, pg_authid a
!   WHERE t.cfgnamespace = n.oid AND t.cfgowner = a.oid
!     AND n.nspname in ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, cfgname;
!  nspname  |   cfgname    |       rolname       
! ----------+--------------+---------------------
!  alt_nsp1 | alt_ts_conf2 | regtest_alter_user2
!  alt_nsp1 | alt_ts_conf3 | regtest_alter_user1
!  alt_nsp1 | alt_ts_conf4 | regtest_alter_user2
!  alt_nsp2 | alt_ts_conf2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Text Search Template
! --
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2; -- failed (name conflict)
! ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3; -- OK
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- OK
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- failed (name conflict)
! ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp2"
! SELECT nspname, tmplname
!   FROM pg_ts_template t, pg_namespace n
!   WHERE t.tmplnamespace = n.oid AND nspname like 'alt_nsp%'
!   ORDER BY nspname, tmplname;
!  nspname  |   tmplname   
! ----------+--------------
!  alt_nsp1 | alt_ts_temp2
!  alt_nsp1 | alt_ts_temp3
!  alt_nsp2 | alt_ts_temp2
! (3 rows)
! 
! --
! -- Text Search Parser
! --
! CREATE TEXT SEARCH PARSER alt_ts_prs1
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! CREATE TEXT SEARCH PARSER alt_ts_prs2
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2; -- failed (name conflict)
! ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3; -- OK
! ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- OK
! CREATE TEXT SEARCH PARSER alt_ts_prs2
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- failed (name conflict)
! ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp2"
! SELECT nspname, prsname
!   FROM pg_ts_parser t, pg_namespace n
!   WHERE t.prsnamespace = n.oid AND nspname like 'alt_nsp%'
!   ORDER BY nspname, prsname;
!  nspname  |   prsname   
! ----------+-------------
!  alt_nsp1 | alt_ts_prs2
!  alt_nsp1 | alt_ts_prs3
!  alt_nsp2 | alt_ts_prs2
! (3 rows)
! 
! ---
! --- Cleanup resources
! ---
! DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
! NOTICE:  drop cascades to server alt_fserv2
! DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
! NOTICE:  drop cascades to server alt_fserv3
! DROP LANGUAGE alt_lang2 CASCADE;
! DROP LANGUAGE alt_lang3 CASCADE;
! DROP LANGUAGE alt_lang4 CASCADE;
! ERROR:  language "alt_lang4" does not exist
! DROP SCHEMA alt_nsp1 CASCADE;
! NOTICE:  drop cascades to 26 other objects
! DETAIL:  drop cascades to function alt_func3(integer)
! drop cascades to function alt_agg3(integer)
! drop cascades to function alt_func4(integer)
! drop cascades to function alt_func2(integer)
! drop cascades to function alt_agg4(integer)
! drop cascades to function alt_agg2(integer)
! drop cascades to conversion alt_conv3
! drop cascades to conversion alt_conv4
! drop cascades to conversion alt_conv2
! drop cascades to operator @+@(integer,integer)
! drop cascades to operator @-@(integer,integer)
! drop cascades to operator family alt_opf3 for access method hash
! drop cascades to operator family alt_opc1 for access method hash
! drop cascades to operator family alt_opc2 for access method hash
! drop cascades to operator family alt_opf4 for access method hash
! drop cascades to operator family alt_opf2 for access method hash
! drop cascades to text search dictionary alt_ts_dict3
! drop cascades to text search dictionary alt_ts_dict4
! drop cascades to text search dictionary alt_ts_dict2
! drop cascades to text search configuration alt_ts_conf3
! drop cascades to text search configuration alt_ts_conf4
! drop cascades to text search configuration alt_ts_conf2
! drop cascades to text search template alt_ts_temp3
! drop cascades to text search template alt_ts_temp2
! drop cascades to text search parser alt_ts_prs3
! drop cascades to text search parser alt_ts_prs2
! DROP SCHEMA alt_nsp2 CASCADE;
! NOTICE:  drop cascades to 9 other objects
! DETAIL:  drop cascades to function alt_nsp2.alt_func2(integer)
! drop cascades to function alt_nsp2.alt_agg2(integer)
! drop cascades to conversion alt_conv2
! drop cascades to operator alt_nsp2.@-@(integer,integer)
! drop cascades to operator family alt_nsp2.alt_opf2 for access method hash
! drop cascades to text search dictionary alt_ts_dict2
! drop cascades to text search configuration alt_ts_conf2
! drop cascades to text search template alt_ts_temp2
! drop cascades to text search parser alt_ts_prs2
! DROP USER regtest_alter_user1;
! DROP USER regtest_alter_user2;
! DROP USER regtest_alter_user3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/misc.out	2015-01-10 10:11:34.243649159 +0300
--- /home/orion/postgres/src/test/regress/results/misc.out	2015-01-10 10:11:46.795649466 +0300
***************
*** 1,843 ****
! --
! -- MISC
! --
! --
! -- BTREE
! --
! UPDATE onek
!    SET unique1 = onek.unique1 + 1;
! UPDATE onek
!    SET unique1 = onek.unique1 - 1;
! --
! -- BTREE partial
! --
! -- UPDATE onek2
! --   SET unique1 = onek2.unique1 + 1;
! --UPDATE onek2
! --   SET unique1 = onek2.unique1 - 1;
! --
! -- BTREE shutting out non-functional updates
! --
! -- the following two tests seem to take a long time on some
! -- systems.    This non-func update stuff needs to be examined
! -- more closely.  			- jolly (2/22/96)
! --
! UPDATE tmp
!    SET stringu1 = reverse_name(onek.stringu1)
!    FROM onek
!    WHERE onek.stringu1 = 'JBAAAA' and
! 	  onek.stringu1 = tmp.stringu1;
! UPDATE tmp
!    SET stringu1 = reverse_name(onek2.stringu1)
!    FROM onek2
!    WHERE onek2.stringu1 = 'JCAAAA' and
! 	  onek2.stringu1 = tmp.stringu1;
! DROP TABLE tmp;
! --UPDATE person*
! --   SET age = age + 1;
! --UPDATE person*
! --   SET age = age + 3
! --   WHERE name = 'linda';
! --
! -- copy
! --
! COPY onek TO '/home/orion/postgres/src/test/regress/results/onek.data';
! DELETE FROM onek;
! COPY onek FROM '/home/orion/postgres/src/test/regress/results/onek.data';
! SELECT unique1 FROM onek WHERE unique1 < 2 ORDER BY unique1;
!  unique1 
! ---------
!        0
!        1
! (2 rows)
! 
! DELETE FROM onek2;
! COPY onek2 FROM '/home/orion/postgres/src/test/regress/results/onek.data';
! SELECT unique1 FROM onek2 WHERE unique1 < 2 ORDER BY unique1;
!  unique1 
! ---------
!        0
!        1
! (2 rows)
! 
! COPY BINARY stud_emp TO '/home/orion/postgres/src/test/regress/results/stud_emp.data';
! DELETE FROM stud_emp;
! COPY BINARY stud_emp FROM '/home/orion/postgres/src/test/regress/results/stud_emp.data';
! SELECT * FROM stud_emp;
!  name  | age |  location  | salary | manager | gpa | percent 
! -------+-----+------------+--------+---------+-----+---------
!  jeff  |  23 | (8,7.7)    |    600 | sharon  | 3.5 |        
!  cim   |  30 | (10.5,4.7) |    400 |         | 3.4 |        
!  linda |  19 | (0.9,6.1)  |    100 |         | 2.9 |        
! (3 rows)
! 
! -- COPY aggtest FROM stdin;
! -- 56	7.8
! -- 100	99.097
! -- 0	0.09561
! -- 42	324.78
! -- .
! -- COPY aggtest TO stdout;
! --
! -- inheritance stress test
! --
! SELECT * FROM a_star*;
!  class | a  
! -------+----
!  a     |  1
!  a     |  2
!  a     |   
!  b     |  3
!  b     |  4
!  b     |   
!  b     |   
!  c     |  5
!  c     |  6
!  c     |   
!  c     |   
!  d     |  7
!  d     |  8
!  d     |  9
!  d     | 10
!  d     |   
!  d     | 11
!  d     | 12
!  d     | 13
!  d     |   
!  d     |   
!  d     |   
!  d     | 14
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  e     | 15
!  e     | 16
!  e     | 17
!  e     |   
!  e     | 18
!  e     |   
!  e     |   
!  f     | 19
!  f     | 20
!  f     | 21
!  f     | 22
!  f     |   
!  f     | 24
!  f     | 25
!  f     | 26
!  f     |   
!  f     |   
!  f     |   
!  f     | 27
!  f     |   
!  f     |   
!  f     |   
!  f     |   
! (50 rows)
! 
! SELECT *
!    FROM b_star* x
!    WHERE x.b = text 'bumble' or x.a < 3;
!  class | a |   b    
! -------+---+--------
!  b     |   | bumble
! (1 row)
! 
! SELECT class, a
!    FROM c_star* x
!    WHERE x.c ~ text 'hi';
!  class | a  
! -------+----
!  c     |  5
!  c     |   
!  d     |  7
!  d     |  8
!  d     | 10
!  d     |   
!  d     | 12
!  d     |   
!  d     |   
!  d     |   
!  e     | 15
!  e     | 16
!  e     |   
!  e     |   
!  f     | 19
!  f     | 20
!  f     | 21
!  f     |   
!  f     | 24
!  f     |   
!  f     |   
!  f     |   
! (22 rows)
! 
! SELECT class, b, c
!    FROM d_star* x
!    WHERE x.a < 100;
!  class |    b    |     c      
! -------+---------+------------
!  d     | grumble | hi sunita
!  d     | stumble | hi koko
!  d     | rumble  | 
!  d     |         | hi kristin
!  d     | fumble  | 
!  d     |         | hi avi
!  d     |         | 
!  d     |         | 
! (8 rows)
! 
! SELECT class, c FROM e_star* x WHERE x.c NOTNULL;
!  class |      c      
! -------+-------------
!  e     | hi carol
!  e     | hi bob
!  e     | hi michelle
!  e     | hi elisa
!  f     | hi claire
!  f     | hi mike
!  f     | hi marcel
!  f     | hi keith
!  f     | hi marc
!  f     | hi allison
!  f     | hi jeff
!  f     | hi carl
! (12 rows)
! 
! SELECT * FROM f_star* x WHERE x.c ISNULL;
!  class | a  | c |  e  |                     f                     
! -------+----+---+-----+-------------------------------------------
!  f     | 22 |   |  -7 | ((111,555),(222,666),(333,777),(444,888))
!  f     | 25 |   |  -9 | 
!  f     | 26 |   |     | ((11111,33333),(22222,44444))
!  f     |    |   | -11 | ((1111111,3333333),(2222222,4444444))
!  f     | 27 |   |     | 
!  f     |    |   | -12 | 
!  f     |    |   |     | ((11111111,33333333),(22222222,44444444))
!  f     |    |   |     | 
! (8 rows)
! 
! -- grouping and aggregation on inherited sets have been busted in the past...
! SELECT sum(a) FROM a_star*;
!  sum 
! -----
!  355
! (1 row)
! 
! SELECT class, sum(a) FROM a_star* GROUP BY class ORDER BY class;
!  class | sum 
! -------+-----
!  a     |   3
!  b     |   7
!  c     |  11
!  d     |  84
!  e     |  66
!  f     | 184
! (6 rows)
! 
! ALTER TABLE f_star RENAME COLUMN f TO ff;
! ALTER TABLE e_star* RENAME COLUMN e TO ee;
! ALTER TABLE d_star* RENAME COLUMN d TO dd;
! ALTER TABLE c_star* RENAME COLUMN c TO cc;
! ALTER TABLE b_star* RENAME COLUMN b TO bb;
! ALTER TABLE a_star* RENAME COLUMN a TO aa;
! SELECT class, aa
!    FROM a_star* x
!    WHERE aa ISNULL;
!  class | aa 
! -------+----
!  a     |   
!  b     |   
!  b     |   
!  c     |   
!  c     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  e     |   
!  e     |   
!  e     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
! (24 rows)
! 
! -- As of Postgres 7.1, ALTER implicitly recurses,
! -- so this should be same as ALTER a_star*
! ALTER TABLE a_star RENAME COLUMN aa TO foo;
! SELECT class, foo
!    FROM a_star* x
!    WHERE x.foo >= 2;
!  class | foo 
! -------+-----
!  a     |   2
!  b     |   3
!  b     |   4
!  c     |   5
!  c     |   6
!  d     |   7
!  d     |   8
!  d     |   9
!  d     |  10
!  d     |  11
!  d     |  12
!  d     |  13
!  d     |  14
!  e     |  15
!  e     |  16
!  e     |  17
!  e     |  18
!  f     |  19
!  f     |  20
!  f     |  21
!  f     |  22
!  f     |  24
!  f     |  25
!  f     |  26
!  f     |  27
! (25 rows)
! 
! ALTER TABLE a_star RENAME COLUMN foo TO aa;
! SELECT *
!    from a_star*
!    WHERE aa < 1000;
!  class | aa 
! -------+----
!  a     |  1
!  a     |  2
!  b     |  3
!  b     |  4
!  c     |  5
!  c     |  6
!  d     |  7
!  d     |  8
!  d     |  9
!  d     | 10
!  d     | 11
!  d     | 12
!  d     | 13
!  d     | 14
!  e     | 15
!  e     | 16
!  e     | 17
!  e     | 18
!  f     | 19
!  f     | 20
!  f     | 21
!  f     | 22
!  f     | 24
!  f     | 25
!  f     | 26
!  f     | 27
! (26 rows)
! 
! ALTER TABLE f_star ADD COLUMN f int4;
! UPDATE f_star SET f = 10;
! ALTER TABLE e_star* ADD COLUMN e int4;
! --UPDATE e_star* SET e = 42;
! SELECT * FROM e_star*;
!  class | aa |     cc      | ee  | e 
! -------+----+-------------+-----+---
!  e     | 15 | hi carol    |  -1 |  
!  e     | 16 | hi bob      |     |  
!  e     | 17 |             |  -2 |  
!  e     |    | hi michelle |  -3 |  
!  e     | 18 |             |     |  
!  e     |    | hi elisa    |     |  
!  e     |    |             |  -4 |  
!  f     | 19 | hi claire   |  -5 |  
!  f     | 20 | hi mike     |  -6 |  
!  f     | 21 | hi marcel   |     |  
!  f     | 22 |             |  -7 |  
!  f     |    | hi keith    |  -8 |  
!  f     | 24 | hi marc     |     |  
!  f     | 25 |             |  -9 |  
!  f     | 26 |             |     |  
!  f     |    | hi allison  | -10 |  
!  f     |    | hi jeff     |     |  
!  f     |    |             | -11 |  
!  f     | 27 |             |     |  
!  f     |    | hi carl     |     |  
!  f     |    |             | -12 |  
!  f     |    |             |     |  
!  f     |    |             |     |  
! (23 rows)
! 
! ALTER TABLE a_star* ADD COLUMN a text;
! NOTICE:  merging definition of column "a" for child "d_star"
! -- That ALTER TABLE should have added TOAST tables.
! SELECT relname, reltoastrelid <> 0 AS has_toast_table
!    FROM pg_class
!    WHERE oid::regclass IN ('a_star', 'c_star')
!    ORDER BY 1;
!  relname | has_toast_table 
! ---------+-----------------
!  a_star  | t
!  c_star  | t
! (2 rows)
! 
! --UPDATE b_star*
! --   SET a = text 'gazpacho'
! --   WHERE aa > 4;
! SELECT class, aa, a FROM a_star*;
!  class | aa | a 
! -------+----+---
!  a     |  1 | 
!  a     |  2 | 
!  a     |    | 
!  b     |  3 | 
!  b     |  4 | 
!  b     |    | 
!  b     |    | 
!  c     |  5 | 
!  c     |  6 | 
!  c     |    | 
!  c     |    | 
!  d     |  7 | 
!  d     |  8 | 
!  d     |  9 | 
!  d     | 10 | 
!  d     |    | 
!  d     | 11 | 
!  d     | 12 | 
!  d     | 13 | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  d     | 14 | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  e     | 15 | 
!  e     | 16 | 
!  e     | 17 | 
!  e     |    | 
!  e     | 18 | 
!  e     |    | 
!  e     |    | 
!  f     | 19 | 
!  f     | 20 | 
!  f     | 21 | 
!  f     | 22 | 
!  f     |    | 
!  f     | 24 | 
!  f     | 25 | 
!  f     | 26 | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
!  f     | 27 | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
! (50 rows)
! 
! --
! -- versions
! --
! --
! -- postquel functions
! --
! --
! -- mike does post_hacking,
! -- joe and sally play basketball, and
! -- everyone else does nothing.
! --
! SELECT p.name, name(p.hobbies) FROM ONLY person p;
!  name  |    name     
! -------+-------------
!  mike  | posthacking
!  joe   | basketball
!  sally | basketball
! (3 rows)
! 
! --
! -- as above, but jeff also does post_hacking.
! --
! SELECT p.name, name(p.hobbies) FROM person* p;
!  name  |    name     
! -------+-------------
!  mike  | posthacking
!  joe   | basketball
!  sally | basketball
!  jeff  | posthacking
! (4 rows)
! 
! --
! -- the next two queries demonstrate how functions generate bogus duplicates.
! -- this is a "feature" ..
! --
! SELECT DISTINCT hobbies_r.name, name(hobbies_r.equipment) FROM hobbies_r
!   ORDER BY 1,2;
!     name     |     name      
! -------------+---------------
!  basketball  | hightops
!  posthacking | advil
!  posthacking | peet's coffee
!  skywalking  | guts
! (4 rows)
! 
! SELECT hobbies_r.name, (hobbies_r.equipment).name FROM hobbies_r;
!     name     |     name      
! -------------+---------------
!  posthacking | advil
!  posthacking | peet's coffee
!  posthacking | advil
!  posthacking | peet's coffee
!  basketball  | hightops
!  basketball  | hightops
!  skywalking  | guts
! (7 rows)
! 
! --
! -- mike needs advil and peet's coffee,
! -- joe and sally need hightops, and
! -- everyone else is fine.
! --
! SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM ONLY person p;
!  name  |    name     |     name      
! -------+-------------+---------------
!  mike  | posthacking | advil
!  mike  | posthacking | peet's coffee
!  joe   | basketball  | hightops
!  sally | basketball  | hightops
! (4 rows)
! 
! --
! -- as above, but jeff needs advil and peet's coffee as well.
! --
! SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM person* p;
!  name  |    name     |     name      
! -------+-------------+---------------
!  mike  | posthacking | advil
!  mike  | posthacking | peet's coffee
!  joe   | basketball  | hightops
!  sally | basketball  | hightops
!  jeff  | posthacking | advil
!  jeff  | posthacking | peet's coffee
! (6 rows)
! 
! --
! -- just like the last two, but make sure that the target list fixup and
! -- unflattening is being done correctly.
! --
! SELECT name(equipment(p.hobbies)), p.name, name(p.hobbies) FROM ONLY person p;
!      name      | name  |    name     
! ---------------+-------+-------------
!  advil         | mike  | posthacking
!  peet's coffee | mike  | posthacking
!  hightops      | joe   | basketball
!  hightops      | sally | basketball
! (4 rows)
! 
! SELECT (p.hobbies).equipment.name, p.name, name(p.hobbies) FROM person* p;
!      name      | name  |    name     
! ---------------+-------+-------------
!  advil         | mike  | posthacking
!  peet's coffee | mike  | posthacking
!  hightops      | joe   | basketball
!  hightops      | sally | basketball
!  advil         | jeff  | posthacking
!  peet's coffee | jeff  | posthacking
! (6 rows)
! 
! SELECT (p.hobbies).equipment.name, name(p.hobbies), p.name FROM ONLY person p;
!      name      |    name     | name  
! ---------------+-------------+-------
!  advil         | posthacking | mike
!  peet's coffee | posthacking | mike
!  hightops      | basketball  | joe
!  hightops      | basketball  | sally
! (4 rows)
! 
! SELECT name(equipment(p.hobbies)), name(p.hobbies), p.name FROM person* p;
!      name      |    name     | name  
! ---------------+-------------+-------
!  advil         | posthacking | mike
!  peet's coffee | posthacking | mike
!  hightops      | basketball  | joe
!  hightops      | basketball  | sally
!  advil         | posthacking | jeff
!  peet's coffee | posthacking | jeff
! (6 rows)
! 
! SELECT user_relns() AS user_relns
!    ORDER BY user_relns;
!      user_relns      
! ---------------------
!  a
!  a_star
!  abstime_tbl
!  aggtest
!  aggtype
!  array_index_op_test
!  array_op_test
!  arrtest
!  b
!  b_star
!  bb
!  box_tbl
!  bprime
!  brinopers
!  brintest
!  bt_f8_heap
!  bt_i4_heap
!  bt_name_heap
!  bt_txt_heap
!  btree_tall_tbl
!  c
!  c_star
!  char_tbl
!  check2_tbl
!  check_seq
!  check_tbl
!  circle_tbl
!  city
!  copy_tbl
!  d
!  d_star
!  date_tbl
!  default_seq
!  default_tbl
!  defaultexpr_tbl
!  dept
!  dupindexcols
!  e_star
!  emp
!  equipment_r
!  f_star
!  fast_emp4000
!  float4_tbl
!  float8_tbl
!  func_index_heap
!  gin_test_tbl
!  gist_point_tbl
!  hash_f8_heap
!  hash_i4_heap
!  hash_name_heap
!  hash_txt_heap
!  hobbies_r
!  iexit
!  ihighway
!  inet_tbl
!  inhf
!  inhx
!  insert_seq
!  insert_tbl
!  int2_tbl
!  int4_tbl
!  int8_tbl
!  interval_tbl
!  iportaltest
!  kd_point_tbl
!  line_tbl
!  log_table
!  lseg_tbl
!  main_table
!  money_data
!  num_data
!  num_exp_add
!  num_exp_div
!  num_exp_ln
!  num_exp_log10
!  num_exp_mul
!  num_exp_power_10_ln
!  num_exp_sqrt
!  num_exp_sub
!  num_input_test
!  num_result
!  onek
!  onek2
!  path_tbl
!  person
!  point_tbl
!  polygon_tbl
!  quad_point_tbl
!  radix_text_tbl
!  ramp
!  random_tbl
!  real_city
!  reltime_tbl
!  road
!  shighway
!  slow_emp4000
!  spgist_point_tbl
!  spgist_text_tbl
!  street
!  stud_emp
!  student
!  subselect_tbl
!  t
!  tenk1
!  tenk2
!  test_range_excl
!  test_range_gist
!  test_range_spgist
!  test_tsvector
!  testjsonb
!  text_tbl
!  time_tbl
!  timestamp_tbl
!  timestamptz_tbl
!  timetz_tbl
!  tinterval_tbl
!  tm
!  tmm
!  toyemp
!  tv
!  tvm
!  tvmm
!  tvv
!  tvvm
!  tvvmv
!  varchar_tbl
!  xacttest
! (127 rows)
! 
! SELECT name(equipment(hobby_construct(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1a(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1b(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1c(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_2a(text 'skywalking'));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_2b(text 'skywalking'));
!      name      
! ---------------
!  advil
!  peet's coffee
!  hightops
!  guts
! (4 rows)
! 
! SELECT hobbies_by_name('basketball');
!  hobbies_by_name 
! -----------------
!  joe
! (1 row)
! 
! SELECT name, overpaid(emp.*) FROM emp;
!   name  | overpaid 
! --------+----------
!  sharon | t
!  sam    | t
!  bill   | t
!  jeff   | f
!  cim    | f
!  linda  | f
! (6 rows)
! 
! --
! -- Try a few cases with SQL-spec row constructor expressions
! --
! SELECT * FROM equipment(ROW('skywalking', 'mer'));
!  name |   hobby    
! ------+------------
!  guts | skywalking
! (1 row)
! 
! SELECT name(equipment(ROW('skywalking', 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT *, name(equipment(h.*)) FROM hobbies_r h;
!     name     | person |     name      
! -------------+--------+---------------
!  posthacking | mike   | advil
!  posthacking | mike   | peet's coffee
!  posthacking | jeff   | advil
!  posthacking | jeff   | peet's coffee
!  basketball  | joe    | hightops
!  basketball  | sally  | hightops
!  skywalking  |        | guts
! (7 rows)
! 
! SELECT *, (equipment(CAST((h.*) AS hobbies_r))).name FROM hobbies_r h;
!     name     | person |     name      
! -------------+--------+---------------
!  posthacking | mike   | advil
!  posthacking | mike   | peet's coffee
!  posthacking | jeff   | advil
!  posthacking | jeff   | peet's coffee
!  basketball  | joe    | hightops
!  basketball  | sally  | hightops
!  skywalking  |        | guts
! (7 rows)
! 
! --
! -- check that old-style C functions work properly with TOASTed values
! --
! create table oldstyle_test(i int4, t text);
! insert into oldstyle_test values(null,null);
! insert into oldstyle_test values(0,'12');
! insert into oldstyle_test values(1000,'12');
! insert into oldstyle_test values(0, repeat('x', 50000));
! select i, length(t), octet_length(t), oldstyle_length(i,t) from oldstyle_test;
!   i   | length | octet_length | oldstyle_length 
! ------+--------+--------------+-----------------
!       |        |              |                
!     0 |      2 |            2 |               2
!  1000 |      2 |            2 |            1002
!     0 |  50000 |        50000 |           50000
! (4 rows)
! 
! drop table oldstyle_test;
! --
! -- functional joins
! --
! --
! -- instance rules
! --
! --
! -- rewrite rules
! --
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/psql.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/psql.out	2015-01-10 10:11:46.775649466 +0300
***************
*** 1,2127 ****
! --
! -- Tests for psql features that aren't closely connected to any
! -- specific server features
! --
! -- \gset
! select 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_
! \echo :pref01_test01 :pref01_test02 :pref01_test03
! 10 20 Hello
! -- should fail: bad variable name
! select 10 as "bad name"
! \gset
! could not set variable "bad name"
! -- multiple backslash commands in one line
! select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
! 1
! select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
! 3
! 4
! select 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_y
!  x | y 
! ---+---
!  5 | 6
! (1 row)
! 
! 5 6
! select 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y
!  x | y 
! ---+---
!  7 | 8
! (1 row)
! 
! 7 8
! -- NULL should unset the variable
! \set var2 xyz
! select 1 as var1, NULL as var2, 3 as var3 \gset
! \echo :var1 :var2 :var3
! 1 :var2 3
! -- \gset requires just one tuple
! select 10 as test01, 20 as test02 from generate_series(1,3) \gset
! more than one row returned for \gset
! select 10 as test01, 20 as test02 from generate_series(1,0) \gset
! no rows returned for \gset
! -- \gset should work in FETCH_COUNT mode too
! \set FETCH_COUNT 1
! select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
! 1
! select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
! 3
! 4
! select 10 as test01, 20 as test02 from generate_series(1,3) \gset
! more than one row returned for \gset
! select 10 as test01, 20 as test02 from generate_series(1,0) \gset
! no rows returned for \gset
! \unset FETCH_COUNT
! -- show all pset options
! \pset
! border                   1
! columns                  0
! expanded                 off
! fieldsep                 '|'
! fieldsep_zero            off
! footer                   on
! format                   aligned
! linestyle                ascii
! null                     ''
! numericlocale            off
! pager                    1
! recordsep                '\n'
! recordsep_zero           off
! tableattr                
! title                    
! tuples_only              off
! unicode_border_linestyle single
! unicode_column_linestyle single
! unicode_header_linestyle single
! -- test multi-line headers, wrapping, and newline indicators
! prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab
! 
! c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
! bc" from generate_series(1,10) as n(n) group by n>1 ;
! \pset linestyle ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!          ab         +        a         +
!                     +        bc         
!          c                              
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                +yyyyyyyyyyyyyyyy  +
! xxxxxx              +yyyyyyyyyyyyyy    +
! xxxxxxxx            +yyyyyyyyyyyy      +
! xxxxxxxxxx          +yyyyyyyyyy        +
! xxxxxxxxxxxx        +yyyyyyyy          +
! xxxxxxxxxxxxxx      +yyyyyy            +
! xxxxxxxxxxxxxxxx    +yyyy              +
! xxxxxxxxxxxxxxxxxx  +yy                +
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!          ab         +        a         +
!                     +        bc         
!          c                              
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                +yyyyyyyyyyyyyyyy  +
! xxxxxx              +yyyyyyyyyyyyyy    +
! xxxxxxxx            +yyyyyyyyyyyy      +
! xxxxxxxxxx          +yyyyyyyyyy        +
! xxxxxxxxxxxx        +yyyyyyyy          +
! xxxxxxxxxxxxxx      +yyyyyy            +
! xxxxxxxxxxxxxxxx    +yyyy              +
! xxxxxxxxxxxxxxxxxx  +yy                +
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!           ab         +|         a         +
!                      +|         bc         
!           c           |                    
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                +| yyyyyyyyyyyyyyyy  +
!  xxxxxx              +| yyyyyyyyyyyyyy    +
!  xxxxxxxx            +| yyyyyyyyyyyy      +
!  xxxxxxxxxx          +| yyyyyyyyyy        +
!  xxxxxxxxxxxx        +| yyyyyyyy          +
!  xxxxxxxxxxxxxx      +| yyyyyy            +
!  xxxxxxxxxxxxxxxx    +| yyyy              +
!  xxxxxxxxxxxxxxxxxx  +| yy                +
!  xxxxxxxxxxxxxxxxxxxx | 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!         ab        +|         a         +
!                   +|         bc         
!          c         |                    
! -------------------+--------------------
!  xx                | yyyyyyyyyyyyyyyyyy
!  xxxx             +| yyyyyyyyyyyyyyyy  +
!  xxxxxx           +| yyyyyyyyyyyyyy    +
!  xxxxxxxx         +| yyyyyyyyyyyy      +
!  xxxxxxxxxx       +| yyyyyyyyyy        +
!  xxxxxxxxxxxx     +| yyyyyyyy          +
!  xxxxxxxxxxxxxx   +| yyyyyy            +
!  xxxxxxxxxxxxxxxx +| yyyy              +
!  xxxxxxxxxxxxxxxxx.| yy                +
! .x                +| 
!  xxxxxxxxxxxxxxxxx.| 
! .xxx               | 
! (2 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |          ab         +|         a         +|
! |                     +|         bc         |
! |          c           |                    |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                +| yyyyyyyyyyyyyyyy  +|
! | xxxxxx              +| yyyyyyyyyyyyyy    +|
! | xxxxxxxx            +| yyyyyyyyyyyy      +|
! | xxxxxxxxxx          +| yyyyyyyyyy        +|
! | xxxxxxxxxxxx        +| yyyyyyyy          +|
! | xxxxxxxxxxxxxx      +| yyyyyy            +|
! | xxxxxxxxxxxxxxxx    +| yyyy              +|
! | xxxxxxxxxxxxxxxxxx  +| yy                +|
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (2 rows)
! 
! \pset format wrapped
! execute q;
! +-----------------+--------------------+
! |       ab       +|         a         +|
! |                +|         bc         |
! |        c        |                    |
! +-----------------+--------------------+
! | xx              | yyyyyyyyyyyyyyyyyy |
! | xxxx           +| yyyyyyyyyyyyyyyy  +|
! | xxxxxx         +| yyyyyyyyyyyyyy    +|
! | xxxxxxxx       +| yyyyyyyyyyyy      +|
! | xxxxxxxxxx     +| yyyyyyyyyy        +|
! | xxxxxxxxxxxx   +| yyyyyyyy          +|
! | xxxxxxxxxxxxxx +| yyyyyy            +|
! | xxxxxxxxxxxxxxx.| yyyy              +|
! |.x              +| yy                +|
! | xxxxxxxxxxxxxxx.|                    |
! |.xxx            +|                    |
! | xxxxxxxxxxxxxxx.|                    |
! |.xxxxx           |                    |
! +-----------------+--------------------+
! (2 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! * Record 1            
! ab+ xx
!   +
! c  
! a + yyyyyyyyyyyyyyyyyy
! bc 
! * Record 2            
! ab+ xxxx                +
!   + xxxxxx              +
! c   xxxxxxxx            +
!     xxxxxxxxxx          +
!     xxxxxxxxxxxx        +
!     xxxxxxxxxxxxxx      +
!     xxxxxxxxxxxxxxxx    +
!     xxxxxxxxxxxxxxxxxx  +
!     xxxxxxxxxxxxxxxxxxxx
! a + yyyyyyyyyyyyyyyy    +
! bc  yyyyyyyyyyyyyy      +
!     yyyyyyyyyyyy        +
!     yyyyyyyyyy          +
!     yyyyyyyy            +
!     yyyyyy              +
!     yyyy                +
!     yy                  +
!     
! 
! \pset format wrapped
! execute q;
! * Record 1       
! ab+ xx
!   +
! c  
! a + yyyyyyyyyyyyyyy.
! bc .yyy
! * Record 2       
! ab+ xxxx           +
!   + xxxxxx         +
! c   xxxxxxxx       +
!     xxxxxxxxxx     +
!     xxxxxxxxxxxx   +
!     xxxxxxxxxxxxxx +
!     xxxxxxxxxxxxxxx.
!    .x              +
!     xxxxxxxxxxxxxxx.
!    .xxx            +
!     xxxxxxxxxxxxxxx.
!    .xxxxx
! a + yyyyyyyyyyyyyyy.
! bc .y              +
!     yyyyyyyyyyyyyy +
!     yyyyyyyyyyyy   +
!     yyyyyyyyyy     +
!     yyyyyyyy       +
!     yyyyyy         +
!     yyyy           +
!     yy             +
!     
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! -[ RECORD 1 ]------------
! ab+| xx
!   +|
! c  |
! a +| yyyyyyyyyyyyyyyyyy
! bc |
! -[ RECORD 2 ]------------
! ab+| xxxx                +
!   +| xxxxxx              +
! c  | xxxxxxxx            +
!    | xxxxxxxxxx          +
!    | xxxxxxxxxxxx        +
!    | xxxxxxxxxxxxxx      +
!    | xxxxxxxxxxxxxxxx    +
!    | xxxxxxxxxxxxxxxxxx  +
!    | xxxxxxxxxxxxxxxxxxxx
! a +| yyyyyyyyyyyyyyyy    +
! bc | yyyyyyyyyyyyyy      +
!    | yyyyyyyyyyyy        +
!    | yyyyyyyyyy          +
!    | yyyyyyyy            +
!    | yyyyyy              +
!    | yyyy                +
!    | yy                  +
!    | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]------
! ab+| xx
!   +|
! c  |
! a +| yyyyyyyyyyyyyy.
! bc |.yyyy
! -[ RECORD 2 ]------
! ab+| xxxx          +
!   +| xxxxxx        +
! c  | xxxxxxxx      +
!    | xxxxxxxxxx    +
!    | xxxxxxxxxxxx  +
!    | xxxxxxxxxxxxxx+
!    | xxxxxxxxxxxxxx.
!    |.xx            +
!    | xxxxxxxxxxxxxx.
!    |.xxxx          +
!    | xxxxxxxxxxxxxx.
!    |.xxxxxx
! a +| yyyyyyyyyyyyyy.
! bc |.yy            +
!    | yyyyyyyyyyyyyy+
!    | yyyyyyyyyyyy  +
!    | yyyyyyyyyy    +
!    | yyyyyyyy      +
!    | yyyyyy        +
!    | yyyy          +
!    | yy            +
!    | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]--------------+
! | ab+| xx                   |
! |   +|                      |
! | c  |                      |
! | a +| yyyyyyyyyyyyyyyyyy   |
! | bc |                      |
! +-[ RECORD 2 ]--------------+
! | ab+| xxxx                +|
! |   +| xxxxxx              +|
! | c  | xxxxxxxx            +|
! |    | xxxxxxxxxx          +|
! |    | xxxxxxxxxxxx        +|
! |    | xxxxxxxxxxxxxx      +|
! |    | xxxxxxxxxxxxxxxx    +|
! |    | xxxxxxxxxxxxxxxxxx  +|
! |    | xxxxxxxxxxxxxxxxxxxx |
! | a +| yyyyyyyyyyyyyyyy    +|
! | bc | yyyyyyyyyyyyyy      +|
! |    | yyyyyyyyyyyy        +|
! |    | yyyyyyyyyy          +|
! |    | yyyyyyyy            +|
! |    | yyyyyy              +|
! |    | yyyy                +|
! |    | yy                  +|
! |    |                      |
! +----+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+
! | ab+| xx          |
! |   +|             |
! | c  |             |
! | a +| yyyyyyyyyyy.|
! | bc |.yyyyyyy     |
! +-[ RECORD 2 ]-----+
! | ab+| xxxx       +|
! |   +| xxxxxx     +|
! | c  | xxxxxxxx   +|
! |    | xxxxxxxxxx +|
! |    | xxxxxxxxxxx.|
! |    |.x          +|
! |    | xxxxxxxxxxx.|
! |    |.xxx        +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxx      +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxxxx    +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxxxxxx   |
! | a +| yyyyyyyyyyy.|
! | bc |.yyyyy      +|
! |    | yyyyyyyyyyy.|
! |    |.yyy        +|
! |    | yyyyyyyyyyy.|
! |    |.y          +|
! |    | yyyyyyyyyy +|
! |    | yyyyyyyy   +|
! |    | yyyyyy     +|
! |    | yyyy       +|
! |    | yy         +|
! |    |             |
! +----+-------------+
! 
! \pset linestyle old-ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!          ab                  a         
!                     +        bc        
!          c          +                  
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy   
! xxxxxx               yyyyyyyyyyyyyy     
! xxxxxxxx             yyyyyyyyyyyy       
! xxxxxxxxxx           yyyyyyyyyy         
! xxxxxxxxxxxx         yyyyyyyy           
! xxxxxxxxxxxxxx       yyyyyy             
! xxxxxxxxxxxxxxxx     yyyy               
! xxxxxxxxxxxxxxxxxx   yy                 
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!          ab                  a         
!                     +        bc        
!          c          +                  
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy   
! xxxxxx               yyyyyyyyyyyyyy     
! xxxxxxxx             yyyyyyyyyyyy       
! xxxxxxxxxx           yyyyyyyyyy         
! xxxxxxxxxxxx         yyyyyyyy           
! xxxxxxxxxxxxxx       yyyyyy             
! xxxxxxxxxxxxxxxx     yyyy               
! xxxxxxxxxxxxxxxxxx   yy                 
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!           ab          |         a          
! +                     |+        bc         
! +         c           |+                   
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy   
!  xxxxxx               : yyyyyyyyyyyyyy     
!  xxxxxxxx             : yyyyyyyyyyyy       
!  xxxxxxxxxx           : yyyyyyyyyy         
!  xxxxxxxxxxxx         : yyyyyyyy           
!  xxxxxxxxxxxxxx       : yyyyyy             
!  xxxxxxxxxxxxxxxx     : yyyy               
!  xxxxxxxxxxxxxxxxxx   : yy                 
!  xxxxxxxxxxxxxxxxxxxx : 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!         ab         |         a          
! +                  |+        bc         
! +        c         |+                   
! -------------------+--------------------
!  xx                | yyyyyyyyyyyyyyyyyy
!  xxxx              | yyyyyyyyyyyyyyyy   
!  xxxxxx            : yyyyyyyyyyyyyy     
!  xxxxxxxx          : yyyyyyyyyyyy       
!  xxxxxxxxxx        : yyyyyyyyyy         
!  xxxxxxxxxxxx      : yyyyyyyy           
!  xxxxxxxxxxxxxx    : yyyyyy             
!  xxxxxxxxxxxxxxxx  : yyyy               
!  xxxxxxxxxxxxxxxxx : yy                 
!  x                 : 
!  xxxxxxxxxxxxxxxxx   
!  xxx                 
! (2 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |          ab          |         a          |
! |+                     |+        bc         |
! |+         c           |+                   |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               : yyyyyyyyyyyyyy     |
! | xxxxxxxx             : yyyyyyyyyyyy       |
! | xxxxxxxxxx           : yyyyyyyyyy         |
! | xxxxxxxxxxxx         : yyyyyyyy           |
! | xxxxxxxxxxxxxx       : yyyyyy             |
! | xxxxxxxxxxxxxxxx     : yyyy               |
! | xxxxxxxxxxxxxxxxxx   : yy                 |
! | xxxxxxxxxxxxxxxxxxxx :                    |
! +----------------------+--------------------+
! (2 rows)
! 
! \pset format wrapped
! execute q;
! +-----------------+--------------------+
! |       ab        |         a          |
! |+                |+        bc         |
! |+       c        |+                   |
! +-----------------+--------------------+
! | xx              | yyyyyyyyyyyyyyyyyy |
! | xxxx            | yyyyyyyyyyyyyyyy   |
! | xxxxxx          : yyyyyyyyyyyyyy     |
! | xxxxxxxx        : yyyyyyyyyyyy       |
! | xxxxxxxxxx      : yyyyyyyyyy         |
! | xxxxxxxxxxxx    : yyyyyyyy           |
! | xxxxxxxxxxxxxx  : yyyyyy             |
! | xxxxxxxxxxxxxxx : yyyy               |
! | x               : yy                 |
! | xxxxxxxxxxxxxxx :                    |
! | xxx                                  |
! | xxxxxxxxxxxxxxx                      |
! | xxxxx                                |
! +-----------------+--------------------+
! (2 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! * Record 1             
!  ab xx
! +  
! +c 
!  a  yyyyyyyyyyyyyyyyyy
! +bc
! * Record 2             
!  ab xxxx
! +   xxxxxx
! +c  xxxxxxxx
!     xxxxxxxxxx
!     xxxxxxxxxxxx
!     xxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxxxxxx
!  a  yyyyyyyyyyyyyyyy
! +bc yyyyyyyyyyyyyy
!     yyyyyyyyyyyy
!     yyyyyyyyyy
!     yyyyyyyy
!     yyyyyy
!     yyyy
!     yy
!     
! 
! \pset format wrapped
! execute q;
! * Record 1         
!  ab xx
! +  
! +c 
!  a  yyyyyyyyyyyyyyyy
! +bc yy
! * Record 2         
!  ab xxxx
! +   xxxxxx
! +c  xxxxxxxx
!     xxxxxxxxxx
!     xxxxxxxxxxxx
!     xxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xx
!     xxxxxxxxxxxxxxxx
!     xxxx
!  a  yyyyyyyyyyyyyyyy
! +bc yyyyyyyyyyyyyy
!     yyyyyyyyyyyy
!     yyyyyyyyyy
!     yyyyyyyy
!     yyyyyy
!     yyyy
!     yy
!     
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! -[ RECORD 1 ]-------------
!  ab | xx
! +   ;
! +c  ;
!  a  | yyyyyyyyyyyyyyyyyy
! +bc ;
! -[ RECORD 2 ]-------------
!  ab | xxxx
! +   : xxxxxx
! +c  : xxxxxxxx
!     : xxxxxxxxxx
!     : xxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxxxxxx
!  a  | yyyyyyyyyyyyyyyy
! +bc : yyyyyyyyyyyyyy
!     : yyyyyyyyyyyy
!     : yyyyyyyyyy
!     : yyyyyyyy
!     : yyyyyy
!     : yyyy
!     : yy
!     : 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]-------
!  ab | xx
! +   ;
! +c  ;
!  a  | yyyyyyyyyyyyyy
! +bc ; yyyy
! -[ RECORD 2 ]-------
!  ab | xxxx
! +   : xxxxxx
! +c  : xxxxxxxx
!     : xxxxxxxxxx
!     : xxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     ; xx
!     : xxxxxxxxxxxxxx
!     ; xxxx
!     : xxxxxxxxxxxxxx
!     ; xxxxxx
!  a  | yyyyyyyyyyyyyy
! +bc ; yy
!     : yyyyyyyyyyyyyy
!     : yyyyyyyyyyyy
!     : yyyyyyyyyy
!     : yyyyyyyy
!     : yyyyyy
!     : yyyy
!     : yy
!     : 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]--------------+
! | ab | xx                   |
! |+   ;                      |
! |+c  ;                      |
! | a  | yyyyyyyyyyyyyyyyyy   |
! |+bc ;                      |
! +-[ RECORD 2 ]--------------+
! | ab | xxxx                 |
! |+   : xxxxxx               |
! |+c  : xxxxxxxx             |
! |    : xxxxxxxxxx           |
! |    : xxxxxxxxxxxx         |
! |    : xxxxxxxxxxxxxx       |
! |    : xxxxxxxxxxxxxxxx     |
! |    : xxxxxxxxxxxxxxxxxx   |
! |    : xxxxxxxxxxxxxxxxxxxx |
! | a  | yyyyyyyyyyyyyyyy     |
! |+bc : yyyyyyyyyyyyyy       |
! |    : yyyyyyyyyyyy         |
! |    : yyyyyyyyyy           |
! |    : yyyyyyyy             |
! |    : yyyyyy               |
! |    : yyyy                 |
! |    : yy                   |
! |    :                      |
! +----+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+
! | ab | xx          |
! |+   ;             |
! |+c  ;             |
! | a  | yyyyyyyyyyy |
! |+bc ; yyyyyyy     |
! +-[ RECORD 2 ]-----+
! | ab | xxxx        |
! |+   : xxxxxx      |
! |+c  : xxxxxxxx    |
! |    : xxxxxxxxxx  |
! |    : xxxxxxxxxxx |
! |    ; x           |
! |    : xxxxxxxxxxx |
! |    ; xxx         |
! |    : xxxxxxxxxxx |
! |    ; xxxxx       |
! |    : xxxxxxxxxxx |
! |    ; xxxxxxx     |
! |    : xxxxxxxxxxx |
! |    ; xxxxxxxxx   |
! | a  | yyyyyyyyyyy |
! |+bc ; yyyyy       |
! |    : yyyyyyyyyyy |
! |    ; yyy         |
! |    : yyyyyyyyyyy |
! |    ; y           |
! |    : yyyyyyyyyy  |
! |    : yyyyyyyy    |
! |    : yyyyyy      |
! |    : yyyy        |
! |    : yy          |
! |    :             |
! +----+-------------+
! 
! deallocate q;
! -- test single-line header and data
! prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
! \pset linestyle ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!   0123456789abcdef       0123456789     
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef       0123456789     
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!    0123456789abcdef   |     0123456789     
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy
!  xxxxxx               | yyyyyyyyyyyyyy
!  xxxxxxxx             | yyyyyyyyyyyy
!  xxxxxxxxxx           | yyyyyyyyyy
!  xxxxxxxxxxxx         | yyyyyyyy
!  xxxxxxxxxxxxxx       | yyyyyy
!  xxxxxxxxxxxxxxxx     | yyyy
!  xxxxxxxxxxxxxxxxxx   | yy
!  xxxxxxxxxxxxxxxxxxxx | 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef   |    0123456789    
! ---------------------+------------------
!  xx                  | yyyyyyyyyyyyyyyy.
!                      |.yy
!  xxxx                | yyyyyyyyyyyyyyyy
!  xxxxxx              | yyyyyyyyyyyyyy
!  xxxxxxxx            | yyyyyyyyyyyy
!  xxxxxxxxxx          | yyyyyyyyyy
!  xxxxxxxxxxxx        | yyyyyyyy
!  xxxxxxxxxxxxxx      | yyyyyy
!  xxxxxxxxxxxxxxxx    | yyyy
!  xxxxxxxxxxxxxxxxxx  | yy
!  xxxxxxxxxxxxxxxxxxx.| 
! .x                   | 
! (10 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |   0123456789abcdef   |     0123456789     |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               | yyyyyyyyyyyyyy     |
! | xxxxxxxx             | yyyyyyyyyyyy       |
! | xxxxxxxxxx           | yyyyyyyyyy         |
! | xxxxxxxxxxxx         | yyyyyyyy           |
! | xxxxxxxxxxxxxx       | yyyyyy             |
! | xxxxxxxxxxxxxxxx     | yyyy               |
! | xxxxxxxxxxxxxxxxxx   | yy                 |
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (10 rows)
! 
! \pset format wrapped
! execute q;
! +--------------------+-----------------+
! |  0123456789abcdef  |   0123456789    |
! +--------------------+-----------------+
! | xx                 | yyyyyyyyyyyyyyy.|
! |                    |.yyy             |
! | xxxx               | yyyyyyyyyyyyyyy.|
! |                    |.y               |
! | xxxxxx             | yyyyyyyyyyyyyy  |
! | xxxxxxxx           | yyyyyyyyyyyy    |
! | xxxxxxxxxx         | yyyyyyyyyy      |
! | xxxxxxxxxxxx       | yyyyyyyy        |
! | xxxxxxxxxxxxxx     | yyyyyy          |
! | xxxxxxxxxxxxxxxx   | yyyy            |
! | xxxxxxxxxxxxxxxxxx | yy              |
! | xxxxxxxxxxxxxxxxxx.|                 |
! |.xx                 |                 |
! +--------------------+-----------------+
! (10 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! * Record 1                          
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                          
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                          
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                          
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                          
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                          
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                          
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                          
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                          
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                         
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset format wrapped
! execute q;
! * Record 1        
! 0123456789abcdef xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 2        
! 0123456789abcdef xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 3        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 4        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 5        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 6        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 7        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy
! * Record 8        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy
! * Record 9        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy
! * Record 10       
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! -[ RECORD 1 ]----+---------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+---------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+---------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+---------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]----+----
! 0123456789abcdef | xx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy
! -[ RECORD 2 ]----+----
! 0123456789abcdef | xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.y
! -[ RECORD 3 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yy
! -[ RECORD 4 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy
! -[ RECORD 5 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.y
! -[ RECORD 6 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yy
! -[ RECORD 7 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | yyy.
!                  |.yyy
! -[ RECORD 8 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.y
! -[ RECORD 9 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx
! 0123456789       | yy
! -[ RECORD 10 ]---+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]-----+----------------------+
! | 0123456789abcdef | xx                   |
! | 0123456789       | yyyyyyyyyyyyyyyyyy   |
! +-[ RECORD 2 ]-----+----------------------+
! | 0123456789abcdef | xxxx                 |
! | 0123456789       | yyyyyyyyyyyyyyyy     |
! +-[ RECORD 3 ]-----+----------------------+
! | 0123456789abcdef | xxxxxx               |
! | 0123456789       | yyyyyyyyyyyyyy       |
! +-[ RECORD 4 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxx             |
! | 0123456789       | yyyyyyyyyyyy         |
! +-[ RECORD 5 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxx           |
! | 0123456789       | yyyyyyyyyy           |
! +-[ RECORD 6 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxx         |
! | 0123456789       | yyyyyyyy             |
! +-[ RECORD 7 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx       |
! | 0123456789       | yyyyyy               |
! +-[ RECORD 8 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx     |
! | 0123456789       | yyyy                 |
! +-[ RECORD 9 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
! | 0123456789       | yy                   |
! +-[ RECORD 10 ]----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
! | 0123456789       |                      |
! +------------------+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+-----+
! | 0123456789abcdef | xx  |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy |
! +-[ RECORD 2 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.y   |
! +-[ RECORD 3 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yy  |
! +-[ RECORD 4 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy |
! +-[ RECORD 5 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.y   |
! +-[ RECORD 6 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yy  |
! +-[ RECORD 7 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       | yyy.|
! |                  |.yyy |
! +-[ RECORD 8 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.y   |
! +-[ RECORD 9 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx |
! | 0123456789       | yy  |
! +-[ RECORD 10 ]----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       |     |
! +------------------+-----+
! 
! \pset linestyle old-ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!   0123456789abcdef       0123456789    
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef       0123456789    
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!    0123456789abcdef   |     0123456789     
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy
!  xxxxxx               | yyyyyyyyyyyyyy
!  xxxxxxxx             | yyyyyyyyyyyy
!  xxxxxxxxxx           | yyyyyyyyyy
!  xxxxxxxxxxxx         | yyyyyyyy
!  xxxxxxxxxxxxxx       | yyyyyy
!  xxxxxxxxxxxxxxxx     | yyyy
!  xxxxxxxxxxxxxxxxxx   | yy
!  xxxxxxxxxxxxxxxxxxxx | 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef   |    0123456789    
! ---------------------+------------------
!  xx                  | yyyyyyyyyyyyyyyy 
!                      ; yy
!  xxxx                | yyyyyyyyyyyyyyyy
!  xxxxxx              | yyyyyyyyyyyyyy
!  xxxxxxxx            | yyyyyyyyyyyy
!  xxxxxxxxxx          | yyyyyyyyyy
!  xxxxxxxxxxxx        | yyyyyyyy
!  xxxxxxxxxxxxxx      | yyyyyy
!  xxxxxxxxxxxxxxxx    | yyyy
!  xxxxxxxxxxxxxxxxxx  | yy
!  xxxxxxxxxxxxxxxxxxx | 
!  x                     
! (10 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |   0123456789abcdef   |     0123456789     |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               | yyyyyyyyyyyyyy     |
! | xxxxxxxx             | yyyyyyyyyyyy       |
! | xxxxxxxxxx           | yyyyyyyyyy         |
! | xxxxxxxxxxxx         | yyyyyyyy           |
! | xxxxxxxxxxxxxx       | yyyyyy             |
! | xxxxxxxxxxxxxxxx     | yyyy               |
! | xxxxxxxxxxxxxxxxxx   | yy                 |
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (10 rows)
! 
! \pset format wrapped
! execute q;
! +--------------------+-----------------+
! |  0123456789abcdef  |   0123456789    |
! +--------------------+-----------------+
! | xx                 | yyyyyyyyyyyyyyy |
! |                    ; yyy             |
! | xxxx               | yyyyyyyyyyyyyyy |
! |                    ; y               |
! | xxxxxx             | yyyyyyyyyyyyyy  |
! | xxxxxxxx           | yyyyyyyyyyyy    |
! | xxxxxxxxxx         | yyyyyyyyyy      |
! | xxxxxxxxxxxx       | yyyyyyyy        |
! | xxxxxxxxxxxxxx     | yyyyyy          |
! | xxxxxxxxxxxxxxxx   | yyyy            |
! | xxxxxxxxxxxxxxxxxx | yy              |
! | xxxxxxxxxxxxxxxxxx |                 |
! | xx                                   |
! +--------------------+-----------------+
! (10 rows)
! 
! \pset expanded on
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! * Record 1                          
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                          
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                          
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                          
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                          
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                          
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                          
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                          
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                          
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                         
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset format wrapped
! execute q;
! * Record 1                             
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                             
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                             
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                             
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                             
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                             
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                             
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                             
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                             
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                            
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! -[ RECORD 1 ]----+---------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+---------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+---------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+---------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]----+----------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+----------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+----------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+----------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]-----+----------------------+
! | 0123456789abcdef | xx                   |
! | 0123456789       | yyyyyyyyyyyyyyyyyy   |
! +-[ RECORD 2 ]-----+----------------------+
! | 0123456789abcdef | xxxx                 |
! | 0123456789       | yyyyyyyyyyyyyyyy     |
! +-[ RECORD 3 ]-----+----------------------+
! | 0123456789abcdef | xxxxxx               |
! | 0123456789       | yyyyyyyyyyyyyy       |
! +-[ RECORD 4 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxx             |
! | 0123456789       | yyyyyyyyyyyy         |
! +-[ RECORD 5 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxx           |
! | 0123456789       | yyyyyyyyyy           |
! +-[ RECORD 6 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxx         |
! | 0123456789       | yyyyyyyy             |
! +-[ RECORD 7 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx       |
! | 0123456789       | yyyyyy               |
! +-[ RECORD 8 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx     |
! | 0123456789       | yyyy                 |
! +-[ RECORD 9 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
! | 0123456789       | yy                   |
! +-[ RECORD 10 ]----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
! | 0123456789       |                      |
! +------------------+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+-------------------+
! | 0123456789abcdef | xx                |
! | 0123456789       | yyyyyyyyyyyyyyyyy |
! |                  ; y                 |
! +-[ RECORD 2 ]-----+-------------------+
! | 0123456789abcdef | xxxx              |
! | 0123456789       | yyyyyyyyyyyyyyyy  |
! +-[ RECORD 3 ]-----+-------------------+
! | 0123456789abcdef | xxxxxx            |
! | 0123456789       | yyyyyyyyyyyyyy    |
! +-[ RECORD 4 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxx          |
! | 0123456789       | yyyyyyyyyyyy      |
! +-[ RECORD 5 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxx        |
! | 0123456789       | yyyyyyyyyy        |
! +-[ RECORD 6 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxx      |
! | 0123456789       | yyyyyyyy          |
! +-[ RECORD 7 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx    |
! | 0123456789       | yyyyyy            |
! +-[ RECORD 8 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx  |
! | 0123456789       | yyyy              |
! +-[ RECORD 9 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxx |
! |                  ; x                 |
! | 0123456789       | yy                |
! +-[ RECORD 10 ]----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxx |
! |                  ; xxx               |
! | 0123456789       |                   |
! +------------------+-------------------+
! 
! deallocate q;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/async.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/async.out	2015-01-10 10:11:46.771649466 +0300
***************
*** 1,34 ****
! --
! -- ASYNC
! --
! --Should work. Send a valid message via a valid channel name
! SELECT pg_notify('notify_async1','sample message1');
!  pg_notify 
! -----------
!  
! (1 row)
! 
! SELECT pg_notify('notify_async1','');
!  pg_notify 
! -----------
!  
! (1 row)
! 
! SELECT pg_notify('notify_async1',NULL);
!  pg_notify 
! -----------
!  
! (1 row)
! 
! -- Should fail. Send a valid message via an invalid channel name
! SELECT pg_notify('','sample message1');
! ERROR:  channel name cannot be empty
! SELECT pg_notify(NULL,'sample message1');
! ERROR:  channel name cannot be empty
! SELECT pg_notify('notify_async_channel_name_too_long______________________________','sample_message1');
! ERROR:  channel name too long
! --Should work. Valid NOTIFY/LISTEN/UNLISTEN commands
! NOTIFY notify_async2;
! LISTEN notify_async2;
! UNLISTEN notify_async2;
! UNLISTEN *;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rules.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/rules.out	2015-01-10 10:11:46.863649468 +0300
***************
*** 1,2681 ****
! --
! -- RULES
! -- From Jan's original setup_ruletest.sql and run_ruletest.sql
! -- - thomas 1998-09-13
! --
! --
! -- Tables and rules for the view test
! --
! create table rtest_t1 (a int4, b int4);
! create table rtest_t2 (a int4, b int4);
! create table rtest_t3 (a int4, b int4);
! create view rtest_v1 as select * from rtest_t1;
! create rule rtest_v1_ins as on insert to rtest_v1 do instead
! 	insert into rtest_t1 values (new.a, new.b);
! create rule rtest_v1_upd as on update to rtest_v1 do instead
! 	update rtest_t1 set a = new.a, b = new.b
! 	where a = old.a;
! create rule rtest_v1_del as on delete to rtest_v1 do instead
! 	delete from rtest_t1 where a = old.a;
! -- Test comments
! COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
! ERROR:  rule "rtest_v1_bad" for relation "rtest_v1" does not exist
! COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
! COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
! --
! -- Tables and rules for the constraint update/delete test
! --
! -- Note:
! -- 	Now that we have multiple action rule support, we check
! -- 	both possible syntaxes to define them (The last action
! --  can but must not have a semicolon at the end).
! --
! create table rtest_system (sysname text, sysdesc text);
! create table rtest_interface (sysname text, ifname text);
! create table rtest_person (pname text, pdesc text);
! create table rtest_admin (pname text, sysname text);
! create rule rtest_sys_upd as on update to rtest_system do also (
! 	update rtest_interface set sysname = new.sysname
! 		where sysname = old.sysname;
! 	update rtest_admin set sysname = new.sysname
! 		where sysname = old.sysname
! 	);
! create rule rtest_sys_del as on delete to rtest_system do also (
! 	delete from rtest_interface where sysname = old.sysname;
! 	delete from rtest_admin where sysname = old.sysname;
! 	);
! create rule rtest_pers_upd as on update to rtest_person do also
! 	update rtest_admin set pname = new.pname where pname = old.pname;
! create rule rtest_pers_del as on delete to rtest_person do also
! 	delete from rtest_admin where pname = old.pname;
! --
! -- Tables and rules for the logging test
! --
! create table rtest_emp (ename char(20), salary money);
! create table rtest_emplog (ename char(20), who name, action char(10), newsal money, oldsal money);
! create table rtest_empmass (ename char(20), salary money);
! create rule rtest_emp_ins as on insert to rtest_emp do
! 	insert into rtest_emplog values (new.ename, current_user,
! 			'hired', new.salary, '0.00');
! create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
! 	insert into rtest_emplog values (new.ename, current_user,
! 			'honored', new.salary, old.salary);
! create rule rtest_emp_del as on delete to rtest_emp do
! 	insert into rtest_emplog values (old.ename, current_user,
! 			'fired', '0.00', old.salary);
! --
! -- Tables and rules for the multiple cascaded qualified instead
! -- rule test
! --
! create table rtest_t4 (a int4, b text);
! create table rtest_t5 (a int4, b text);
! create table rtest_t6 (a int4, b text);
! create table rtest_t7 (a int4, b text);
! create table rtest_t8 (a int4, b text);
! create table rtest_t9 (a int4, b text);
! create rule rtest_t4_ins1 as on insert to rtest_t4
! 		where new.a >= 10 and new.a < 20 do instead
! 	insert into rtest_t5 values (new.a, new.b);
! create rule rtest_t4_ins2 as on insert to rtest_t4
! 		where new.a >= 20 and new.a < 30 do
! 	insert into rtest_t6 values (new.a, new.b);
! create rule rtest_t5_ins as on insert to rtest_t5
! 		where new.a > 15 do
! 	insert into rtest_t7 values (new.a, new.b);
! create rule rtest_t6_ins as on insert to rtest_t6
! 		where new.a > 25 do instead
! 	insert into rtest_t8 values (new.a, new.b);
! --
! -- Tables and rules for the rule fire order test
! --
! -- As of PG 7.3, the rules should fire in order by name, regardless
! -- of INSTEAD attributes or creation order.
! --
! create table rtest_order1 (a int4);
! create table rtest_order2 (a int4, b int4, c text);
! create sequence rtest_seq;
! create rule rtest_order_r3 as on insert to rtest_order1 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 3 - this should run 3rd');
! create rule rtest_order_r4 as on insert to rtest_order1
! 		where a < 100 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 4 - this should run 4th');
! create rule rtest_order_r2 as on insert to rtest_order1 do
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 2 - this should run 2nd');
! create rule rtest_order_r1 as on insert to rtest_order1 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 1 - this should run 1st');
! --
! -- Tables and rules for the instead nothing test
! --
! create table rtest_nothn1 (a int4, b text);
! create table rtest_nothn2 (a int4, b text);
! create table rtest_nothn3 (a int4, b text);
! create table rtest_nothn4 (a int4, b text);
! create rule rtest_nothn_r1 as on insert to rtest_nothn1
! 	where new.a >= 10 and new.a < 20 do instead nothing;
! create rule rtest_nothn_r2 as on insert to rtest_nothn1
! 	where new.a >= 30 and new.a < 40 do instead nothing;
! create rule rtest_nothn_r3 as on insert to rtest_nothn2
! 	where new.a >= 100 do instead
! 	insert into rtest_nothn3 values (new.a, new.b);
! create rule rtest_nothn_r4 as on insert to rtest_nothn2
! 	do instead nothing;
! --
! -- Tests on a view that is select * of a table
! -- and has insert/update/delete instead rules to
! -- behave close like the real table.
! --
! --
! -- We need test date later
! --
! insert into rtest_t2 values (1, 21);
! insert into rtest_t2 values (2, 22);
! insert into rtest_t2 values (3, 23);
! insert into rtest_t3 values (1, 31);
! insert into rtest_t3 values (2, 32);
! insert into rtest_t3 values (3, 33);
! insert into rtest_t3 values (4, 34);
! insert into rtest_t3 values (5, 35);
! -- insert values
! insert into rtest_v1 values (1, 11);
! insert into rtest_v1 values (2, 12);
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
!  2 | 12
! (2 rows)
! 
! -- delete with constant expression
! delete from rtest_v1 where a = 1;
! select * from rtest_v1;
!  a | b  
! ---+----
!  2 | 12
! (1 row)
! 
! insert into rtest_v1 values (1, 11);
! delete from rtest_v1 where b = 12;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
! (1 row)
! 
! insert into rtest_v1 values (2, 12);
! insert into rtest_v1 values (2, 13);
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
!  2 | 12
!  2 | 13
! (3 rows)
! 
! ** Remember the delete rule on rtest_v1: It says
! ** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
! ** So this time both rows with a = 2 must get deleted
! \p
! ** Remember the delete rule on rtest_v1: It says
! ** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
! ** So this time both rows with a = 2 must get deleted
! \r
! delete from rtest_v1 where b = 12;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
! (1 row)
! 
! delete from rtest_v1;
! -- insert select
! insert into rtest_v1 select * from rtest_t2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! delete from rtest_v1;
! -- same with swapped targetlist
! insert into rtest_v1 (b, a) select b, a from rtest_t2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! -- now with only one target attribute
! insert into rtest_v1 (a) select a from rtest_t3;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
!  1 |   
!  2 |   
!  3 |   
!  4 |   
!  5 |   
! (8 rows)
! 
! select * from rtest_v1 where b isnull;
!  a | b 
! ---+---
!  1 |  
!  2 |  
!  3 |  
!  4 |  
!  5 |  
! (5 rows)
! 
! -- let attribute a differ (must be done on rtest_t1 - see above)
! update rtest_t1 set a = a + 10 where b isnull;
! delete from rtest_v1 where b isnull;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! -- now updates with constant expression
! update rtest_v1 set b = 42 where a = 2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  3 | 23
!  2 | 42
! (3 rows)
! 
! update rtest_v1 set b = 99 where b = 42;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  3 | 23
!  2 | 99
! (3 rows)
! 
! update rtest_v1 set b = 88 where b < 50;
! select * from rtest_v1;
!  a | b  
! ---+----
!  2 | 99
!  1 | 88
!  3 | 88
! (3 rows)
! 
! delete from rtest_v1;
! insert into rtest_v1 select rtest_t2.a, rtest_t3.b
!     from rtest_t2, rtest_t3
!     where rtest_t2.a = rtest_t3.a;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 31
!  2 | 32
!  3 | 33
! (3 rows)
! 
! -- updates in a mergejoin
! update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! insert into rtest_v1 select * from rtest_t3;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
!  1 | 31
!  2 | 32
!  3 | 33
!  4 | 34
!  5 | 35
! (8 rows)
! 
! update rtest_t1 set a = a + 10 where b > 30;
! select * from rtest_v1;
!  a  | b  
! ----+----
!   1 | 21
!   2 | 22
!   3 | 23
!  11 | 31
!  12 | 32
!  13 | 33
!  14 | 34
!  15 | 35
! (8 rows)
! 
! update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
! select * from rtest_v1;
!  a  | b  
! ----+----
!   1 | 21
!   2 | 22
!   3 | 23
!  21 | 31
!  22 | 32
!  23 | 33
!  24 | 34
!  25 | 35
! (8 rows)
! 
! --
! -- Test for constraint updates/deletes
! --
! insert into rtest_system values ('orion', 'Linux Jan Wieck');
! insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
! insert into rtest_system values ('neptun', 'Fileserver');
! insert into rtest_interface values ('orion', 'eth0');
! insert into rtest_interface values ('orion', 'eth1');
! insert into rtest_interface values ('notjw', 'eth0');
! insert into rtest_interface values ('neptun', 'eth0');
! insert into rtest_person values ('jw', 'Jan Wieck');
! insert into rtest_person values ('bm', 'Bruce Momjian');
! insert into rtest_admin values ('jw', 'orion');
! insert into rtest_admin values ('jw', 'notjw');
! insert into rtest_admin values ('bm', 'neptun');
! update rtest_system set sysname = 'pluto' where sysname = 'neptun';
! select * from rtest_interface;
!  sysname | ifname 
! ---------+--------
!  orion   | eth0
!  orion   | eth1
!  notjw   | eth0
!  pluto   | eth0
! (4 rows)
! 
! select * from rtest_admin;
!  pname | sysname 
! -------+---------
!  jw    | orion
!  jw    | notjw
!  bm    | pluto
! (3 rows)
! 
! update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
! -- Note: use ORDER BY here to ensure consistent output across all systems.
! -- The above UPDATE affects two rows with equal keys, so they could be
! -- updated in either order depending on the whim of the local qsort().
! select * from rtest_admin order by pname, sysname;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
!  jwieck | orion
! (3 rows)
! 
! delete from rtest_system where sysname = 'orion';
! select * from rtest_interface;
!  sysname | ifname 
! ---------+--------
!  notjw   | eth0
!  pluto   | eth0
! (2 rows)
! 
! select * from rtest_admin;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
! (2 rows)
! 
! --
! -- Rule qualification test
! --
! insert into rtest_emp values ('wiecc', '5000.00');
! insert into rtest_emp values ('gates', '80000.00');
! update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
! update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
! update rtest_emp set salary = '7000.00' where ename = 'wieck';
! delete from rtest_emp where ename = 'gates';
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (5 rows)
! 
! insert into rtest_empmass values ('meyer', '4000.00');
! insert into rtest_empmass values ('maier', '5000.00');
! insert into rtest_empmass values ('mayr', '6000.00');
! insert into rtest_emp select * from rtest_empmass;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (8 rows)
! 
! update rtest_empmass set salary = salary + '1000.00';
! update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (11 rows)
! 
! delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | fired      |      $0.00 |  $6,000.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | fired      |      $0.00 |  $7,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | fired      |      $0.00 |  $5,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (14 rows)
! 
! --
! -- Multiple cascaded qualified instead rule test
! --
! insert into rtest_t4 values (1, 'Record should go to rtest_t4');
! insert into rtest_t4 values (2, 'Record should go to rtest_t4');
! insert into rtest_t4 values (10, 'Record should go to rtest_t5');
! insert into rtest_t4 values (15, 'Record should go to rtest_t5');
! insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
! insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
! insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
! insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
! insert into rtest_t4 values (30, 'Record should go to rtest_t4');
! insert into rtest_t4 values (40, 'Record should go to rtest_t4');
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  20 | Record should go to rtest_t4 and t6
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
!  30 | Record should go to rtest_t4
!  40 | Record should go to rtest_t4
! (7 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a  |                  b                  
! ----+-------------------------------------
!  20 | Record should go to rtest_t4 and t6
! (1 row)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! delete from rtest_t4;
! delete from rtest_t5;
! delete from rtest_t6;
! delete from rtest_t7;
! delete from rtest_t8;
! insert into rtest_t9 values (1, 'Record should go to rtest_t4');
! insert into rtest_t9 values (2, 'Record should go to rtest_t4');
! insert into rtest_t9 values (10, 'Record should go to rtest_t5');
! insert into rtest_t9 values (15, 'Record should go to rtest_t5');
! insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
! insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
! insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
! insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
! insert into rtest_t9 values (30, 'Record should go to rtest_t4');
! insert into rtest_t9 values (40, 'Record should go to rtest_t4');
! insert into rtest_t4 select * from rtest_t9 where a < 20;
! select * from rtest_t4;
!  a |              b               
! ---+------------------------------
!  1 | Record should go to rtest_t4
!  2 | Record should go to rtest_t4
! (2 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a | b 
! ---+---
! (0 rows)
! 
! insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (4 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
!  21 | Record should go to rtest_t4 and t6
!  31 | Record should go to rtest_t4
!  41 | Record should go to rtest_t4
! (7 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a  |                  b                  
! ----+-------------------------------------
!  21 | Record should go to rtest_t4 and t6
! (1 row)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! --
! -- Check that the ordering of rules fired is correct
! --
! insert into rtest_order1 values (1);
! select * from rtest_order2;
!  a | b |              c               
! ---+---+------------------------------
!  1 | 1 | rule 1 - this should run 1st
!  1 | 2 | rule 2 - this should run 2nd
!  1 | 3 | rule 3 - this should run 3rd
!  1 | 4 | rule 4 - this should run 4th
! (4 rows)
! 
! --
! -- Check if instead nothing w/without qualification works
! --
! insert into rtest_nothn1 values (1, 'want this');
! insert into rtest_nothn1 values (2, 'want this');
! insert into rtest_nothn1 values (10, 'don''t want this');
! insert into rtest_nothn1 values (19, 'don''t want this');
! insert into rtest_nothn1 values (20, 'want this');
! insert into rtest_nothn1 values (29, 'want this');
! insert into rtest_nothn1 values (30, 'don''t want this');
! insert into rtest_nothn1 values (39, 'don''t want this');
! insert into rtest_nothn1 values (40, 'want this');
! insert into rtest_nothn1 values (50, 'want this');
! insert into rtest_nothn1 values (60, 'want this');
! select * from rtest_nothn1;
!  a  |     b     
! ----+-----------
!   1 | want this
!   2 | want this
!  20 | want this
!  29 | want this
!  40 | want this
!  50 | want this
!  60 | want this
! (7 rows)
! 
! insert into rtest_nothn2 values (10, 'too small');
! insert into rtest_nothn2 values (50, 'too small');
! insert into rtest_nothn2 values (100, 'OK');
! insert into rtest_nothn2 values (200, 'OK');
! select * from rtest_nothn2;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_nothn3;
!   a  | b  
! -----+----
!  100 | OK
!  200 | OK
! (2 rows)
! 
! delete from rtest_nothn1;
! delete from rtest_nothn2;
! delete from rtest_nothn3;
! insert into rtest_nothn4 values (1, 'want this');
! insert into rtest_nothn4 values (2, 'want this');
! insert into rtest_nothn4 values (10, 'don''t want this');
! insert into rtest_nothn4 values (19, 'don''t want this');
! insert into rtest_nothn4 values (20, 'want this');
! insert into rtest_nothn4 values (29, 'want this');
! insert into rtest_nothn4 values (30, 'don''t want this');
! insert into rtest_nothn4 values (39, 'don''t want this');
! insert into rtest_nothn4 values (40, 'want this');
! insert into rtest_nothn4 values (50, 'want this');
! insert into rtest_nothn4 values (60, 'want this');
! insert into rtest_nothn1 select * from rtest_nothn4;
! select * from rtest_nothn1;
!  a  |     b     
! ----+-----------
!   1 | want this
!   2 | want this
!  20 | want this
!  29 | want this
!  40 | want this
!  50 | want this
!  60 | want this
! (7 rows)
! 
! delete from rtest_nothn4;
! insert into rtest_nothn4 values (10, 'too small');
! insert into rtest_nothn4 values (50, 'too small');
! insert into rtest_nothn4 values (100, 'OK');
! insert into rtest_nothn4 values (200, 'OK');
! insert into rtest_nothn2 select * from rtest_nothn4;
! select * from rtest_nothn2;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_nothn3;
!   a  | b  
! -----+----
!  100 | OK
!  200 | OK
! (2 rows)
! 
! create table rtest_view1 (a int4, b text, v bool);
! create table rtest_view2 (a int4);
! create table rtest_view3 (a int4, b text);
! create table rtest_view4 (a int4, b text, c int4);
! create view rtest_vview1 as select a, b from rtest_view1 X
! 	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
! create view rtest_vview2 as select a, b from rtest_view1 where v;
! create view rtest_vview3 as select a, b from rtest_vview2 X
! 	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
! create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
! 	from rtest_view1 X, rtest_view2 Y
! 	where X.a = Y.a
! 	group by X.a, X.b;
! create function rtest_viewfunc1(int4) returns int4 as
! 	'select count(*)::int4 from rtest_view2 where a = $1'
! 	language sql;
! create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
! 	from rtest_view1;
! insert into rtest_view1 values (1, 'item 1', 't');
! insert into rtest_view1 values (2, 'item 2', 't');
! insert into rtest_view1 values (3, 'item 3', 't');
! insert into rtest_view1 values (4, 'item 4', 'f');
! insert into rtest_view1 values (5, 'item 5', 't');
! insert into rtest_view1 values (6, 'item 6', 'f');
! insert into rtest_view1 values (7, 'item 7', 't');
! insert into rtest_view1 values (8, 'item 8', 't');
! insert into rtest_view2 values (2);
! insert into rtest_view2 values (2);
! insert into rtest_view2 values (4);
! insert into rtest_view2 values (5);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! select * from rtest_vview1;
!  a |   b    
! ---+--------
!  2 | item 2
!  4 | item 4
!  5 | item 5
!  7 | item 7
! (4 rows)
! 
! select * from rtest_vview2;
!  a |   b    
! ---+--------
!  1 | item 1
!  2 | item 2
!  3 | item 3
!  5 | item 5
!  7 | item 7
!  8 | item 8
! (6 rows)
! 
! select * from rtest_vview3;
!  a |   b    
! ---+--------
!  2 | item 2
!  5 | item 5
!  7 | item 7
! (3 rows)
! 
! select * from rtest_vview4 order by a, b;
!  a |   b    | refcount 
! ---+--------+----------
!  2 | item 2 |        2
!  4 | item 4 |        1
!  5 | item 5 |        1
!  7 | item 7 |        4
! (4 rows)
! 
! select * from rtest_vview5;
!  a |   b    | refcount 
! ---+--------+----------
!  1 | item 1 |        0
!  2 | item 2 |        2
!  3 | item 3 |        0
!  4 | item 4 |        1
!  5 | item 5 |        1
!  6 | item 6 |        0
!  7 | item 7 |        4
!  8 | item 8 |        0
! (8 rows)
! 
! insert into rtest_view3 select * from rtest_vview1 where a < 7;
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  2 | item 2
!  4 | item 4
!  5 | item 5
! (3 rows)
! 
! delete from rtest_view3;
! insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  1 | item 1
!  3 | item 3
!  7 | item 7
!  8 | item 8
! (4 rows)
! 
! delete from rtest_view3;
! insert into rtest_view3 select * from rtest_vview3;
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  2 | item 2
!  5 | item 5
!  7 | item 7
! (3 rows)
! 
! delete from rtest_view3;
! insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
! select * from rtest_view4 order by a, b;
!  a |   b    | c 
! ---+--------+---
!  2 | item 2 | 2
!  4 | item 4 | 1
!  5 | item 5 | 1
! (3 rows)
! 
! delete from rtest_view4;
! insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
! select * from rtest_view4;
!  a |   b    | c 
! ---+--------+---
!  3 | item 3 | 0
!  6 | item 6 | 0
!  8 | item 8 | 0
! (3 rows)
! 
! delete from rtest_view4;
! --
! -- Test for computations in views
! --
! create table rtest_comp (
! 	part	text,
! 	unit	char(4),
! 	size	float
! );
! create table rtest_unitfact (
! 	unit	char(4),
! 	factor	float
! );
! create view rtest_vcomp as
! 	select X.part, (X.size * Y.factor) as size_in_cm
! 			from rtest_comp X, rtest_unitfact Y
! 			where X.unit = Y.unit;
! insert into rtest_unitfact values ('m', 100.0);
! insert into rtest_unitfact values ('cm', 1.0);
! insert into rtest_unitfact values ('inch', 2.54);
! insert into rtest_comp values ('p1', 'm', 5.0);
! insert into rtest_comp values ('p2', 'm', 3.0);
! insert into rtest_comp values ('p3', 'cm', 5.0);
! insert into rtest_comp values ('p4', 'cm', 15.0);
! insert into rtest_comp values ('p5', 'inch', 7.0);
! insert into rtest_comp values ('p6', 'inch', 4.4);
! select * from rtest_vcomp order by part;
!  part | size_in_cm 
! ------+------------
!  p1   |        500
!  p2   |        300
!  p3   |          5
!  p4   |         15
!  p5   |      17.78
!  p6   |     11.176
! (6 rows)
! 
! select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
!  part | size_in_cm 
! ------+------------
!  p1   |        500
!  p2   |        300
!  p5   |      17.78
!  p4   |         15
!  p6   |     11.176
! (5 rows)
! 
! --
! -- In addition run the (slightly modified) queries from the
! -- programmers manual section on the rule system.
! --
! CREATE TABLE shoe_data (
! 	shoename   char(10),      -- primary key
! 	sh_avail   integer,       -- available # of pairs
! 	slcolor    char(10),      -- preferred shoelace color
! 	slminlen   float,         -- miminum shoelace length
! 	slmaxlen   float,         -- maximum shoelace length
! 	slunit     char(8)        -- length unit
! );
! CREATE TABLE shoelace_data (
! 	sl_name    char(10),      -- primary key
! 	sl_avail   integer,       -- available # of pairs
! 	sl_color   char(10),      -- shoelace color
! 	sl_len     float,         -- shoelace length
! 	sl_unit    char(8)        -- length unit
! );
! CREATE TABLE unit (
! 	un_name    char(8),       -- the primary key
! 	un_fact    float          -- factor to transform to cm
! );
! CREATE VIEW shoe AS
! 	SELECT sh.shoename,
! 		   sh.sh_avail,
! 		   sh.slcolor,
! 		   sh.slminlen,
! 		   sh.slminlen * un.un_fact AS slminlen_cm,
! 		   sh.slmaxlen,
! 		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
! 		   sh.slunit
! 	  FROM shoe_data sh, unit un
! 	 WHERE sh.slunit = un.un_name;
! CREATE VIEW shoelace AS
! 	SELECT s.sl_name,
! 		   s.sl_avail,
! 		   s.sl_color,
! 		   s.sl_len,
! 		   s.sl_unit,
! 		   s.sl_len * u.un_fact AS sl_len_cm
! 	  FROM shoelace_data s, unit u
! 	 WHERE s.sl_unit = u.un_name;
! CREATE VIEW shoe_ready AS
! 	SELECT rsh.shoename,
! 		   rsh.sh_avail,
! 		   rsl.sl_name,
! 		   rsl.sl_avail,
! 		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
! 	  FROM shoe rsh, shoelace rsl
! 	 WHERE rsl.sl_color = rsh.slcolor
! 	   AND rsl.sl_len_cm >= rsh.slminlen_cm
! 	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
! INSERT INTO unit VALUES ('cm', 1.0);
! INSERT INTO unit VALUES ('m', 100.0);
! INSERT INTO unit VALUES ('inch', 2.54);
! INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
! INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
! INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
! INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
! INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
! INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
! INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
! INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
! INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
! INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
! INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
! INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
! -- SELECTs in doc
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        7 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
!   shoename  | sh_avail |  sl_name   | sl_avail | total_avail 
! ------------+----------+------------+----------+-------------
!  sh1        |        2 | sl1        |        5 |           2
!  sh3        |        4 | sl7        |        7 |           4
! (2 rows)
! 
!     CREATE TABLE shoelace_log (
!         sl_name    char(10),      -- shoelace changed
!         sl_avail   integer,       -- new available value
!         log_who    name,          -- who did it
!         log_when   timestamp      -- when
!     );
! -- Want "log_who" to be CURRENT_USER,
! -- but that is non-portable for the regression test
! -- - thomas 1999-02-21
!     CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
!         WHERE NEW.sl_avail != OLD.sl_avail
!         DO INSERT INTO shoelace_log VALUES (
!                                         NEW.sl_name,
!                                         NEW.sl_avail,
!                                         'Al Bundy',
!                                         'epoch'
!                                     );
! UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
! SELECT * FROM shoelace_log;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
! (1 row)
! 
!     CREATE RULE shoelace_ins AS ON INSERT TO shoelace
!         DO INSTEAD
!         INSERT INTO shoelace_data VALUES (
!                NEW.sl_name,
!                NEW.sl_avail,
!                NEW.sl_color,
!                NEW.sl_len,
!                NEW.sl_unit);
!     CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
!         DO INSTEAD
!         UPDATE shoelace_data SET
!                sl_name = NEW.sl_name,
!                sl_avail = NEW.sl_avail,
!                sl_color = NEW.sl_color,
!                sl_len = NEW.sl_len,
!                sl_unit = NEW.sl_unit
!          WHERE sl_name = OLD.sl_name;
!     CREATE RULE shoelace_del AS ON DELETE TO shoelace
!         DO INSTEAD
!         DELETE FROM shoelace_data
!          WHERE sl_name = OLD.sl_name;
!     CREATE TABLE shoelace_arrive (
!         arr_name    char(10),
!         arr_quant   integer
!     );
!     CREATE TABLE shoelace_ok (
!         ok_name     char(10),
!         ok_quant    integer
!     );
!     CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
!         DO INSTEAD
!         UPDATE shoelace SET
!                sl_avail = sl_avail + NEW.ok_quant
!          WHERE sl_name = NEW.ok_name;
! INSERT INTO shoelace_arrive VALUES ('sl3', 10);
! INSERT INTO shoelace_arrive VALUES ('sl6', 20);
! INSERT INTO shoelace_arrive VALUES ('sl8', 20);
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! insert into shoelace_ok select * from shoelace_arrive;
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! SELECT * FROM shoelace_log ORDER BY sl_name;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl3        |       10 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl6        |       20 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl8        |       21 | Al Bundy | Thu Jan 01 00:00:00 1970
! (4 rows)
! 
!     CREATE VIEW shoelace_obsolete AS
! 	SELECT * FROM shoelace WHERE NOT EXISTS
! 	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
!     CREATE VIEW shoelace_candelete AS
! 	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
! insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
! insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
! SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
! (2 rows)
! 
! SELECT * FROM shoelace_candelete;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
! (1 row)
! 
! DELETE FROM shoelace WHERE EXISTS
!     (SELECT * FROM shoelace_candelete
!              WHERE sl_name = shoelace.sl_name);
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (9 rows)
! 
! SELECT * FROM shoe ORDER BY shoename;
!   shoename  | sh_avail |  slcolor   | slminlen | slminlen_cm | slmaxlen | slmaxlen_cm |  slunit  
! ------------+----------+------------+----------+-------------+----------+-------------+----------
!  sh1        |        2 | black      |       70 |          70 |       90 |          90 | cm      
!  sh2        |        0 | black      |       30 |        76.2 |       40 |       101.6 | inch    
!  sh3        |        4 | brown      |       50 |          50 |       65 |          65 | cm      
!  sh4        |        3 | brown      |       40 |       101.6 |       50 |         127 | inch    
! (4 rows)
! 
! SELECT count(*) FROM shoe;
!  count 
! -------
!      4
! (1 row)
! 
! --
! -- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
! --
! create table foo (f1 int);
! create table foo2 (f1 int);
! create rule foorule as on insert to foo where f1 < 100
! do instead nothing;
! insert into foo values(1);
! insert into foo values(1001);
! select * from foo;
!   f1  
! ------
!  1001
! (1 row)
! 
! drop rule foorule on foo;
! -- this should fail because f1 is not exposed for unqualified reference:
! create rule foorule as on insert to foo where f1 < 100
! do instead insert into foo2 values (f1);
! ERROR:  column "f1" does not exist
! LINE 2: do instead insert into foo2 values (f1);
!                                             ^
! HINT:  There is a column named "f1" in table "old", but it cannot be referenced from this part of the query.
! -- this is the correct way:
! create rule foorule as on insert to foo where f1 < 100
! do instead insert into foo2 values (new.f1);
! insert into foo values(2);
! insert into foo values(100);
! select * from foo;
!   f1  
! ------
!  1001
!   100
! (2 rows)
! 
! select * from foo2;
!  f1 
! ----
!   2
! (1 row)
! 
! drop rule foorule on foo;
! drop table foo;
! drop table foo2;
! --
! -- Test rules containing INSERT ... SELECT, which is a very ugly special
! -- case as of 7.1.  Example is based on bug report from Joel Burton.
! --
! create table pparent (pid int, txt text);
! insert into pparent values (1,'parent1');
! insert into pparent values (2,'parent2');
! create table cchild (pid int, descrip text);
! insert into cchild values (1,'descrip1');
! create view vview as
!   select pparent.pid, txt, descrip from
!     pparent left join cchild using (pid);
! create rule rrule as
!   on update to vview do instead
! (
!   insert into cchild (pid, descrip)
!     select old.pid, new.descrip where old.descrip isnull;
!   update cchild set descrip = new.descrip where cchild.pid = old.pid;
! );
! select * from vview;
!  pid |   txt   | descrip  
! -----+---------+----------
!    1 | parent1 | descrip1
!    2 | parent2 | 
! (2 rows)
! 
! update vview set descrip='test1' where pid=1;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | 
! (2 rows)
! 
! update vview set descrip='test2' where pid=2;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | test2
! (2 rows)
! 
! update vview set descrip='test3' where pid=3;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | test2
! (2 rows)
! 
! select * from cchild;
!  pid | descrip 
! -----+---------
!    1 | test1
!    2 | test2
! (2 rows)
! 
! drop rule rrule on vview;
! drop view vview;
! drop table pparent;
! drop table cchild;
! --
! -- Check that ruleutils are working
! --
! -- temporarily disable fancy output, so view changes create less diff noise
! \a\t
! SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
! iexit| SELECT ih.name,
!     ih.thepath,
!     interpt_pp(ih.thepath, r.thepath) AS exit
!    FROM ihighway ih,
!     ramp r
!   WHERE (ih.thepath ## r.thepath);
! pg_available_extension_versions| SELECT e.name,
!     e.version,
!     (x.extname IS NOT NULL) AS installed,
!     e.superuser,
!     e.relocatable,
!     e.schema,
!     e.requires,
!     e.comment
!    FROM (pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment)
!      LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));
! pg_available_extensions| SELECT e.name,
!     e.default_version,
!     x.extversion AS installed_version,
!     e.comment
!    FROM (pg_available_extensions() e(name, default_version, comment)
!      LEFT JOIN pg_extension x ON ((e.name = x.extname)));
! pg_cursors| SELECT c.name,
!     c.statement,
!     c.is_holdable,
!     c.is_binary,
!     c.is_scrollable,
!     c.creation_time
!    FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);
! pg_group| SELECT pg_authid.rolname AS groname,
!     pg_authid.oid AS grosysid,
!     ARRAY( SELECT pg_auth_members.member
!            FROM pg_auth_members
!           WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist
!    FROM pg_authid
!   WHERE (NOT pg_authid.rolcanlogin);
! pg_indexes| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     i.relname AS indexname,
!     t.spcname AS tablespace,
!     pg_get_indexdef(i.oid) AS indexdef
!    FROM ((((pg_index x
!      JOIN pg_class c ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))
!   WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'm'::"char"])) AND (i.relkind = 'i'::"char"));
! pg_locks| SELECT l.locktype,
!     l.database,
!     l.relation,
!     l.page,
!     l.tuple,
!     l.virtualxid,
!     l.transactionid,
!     l.classid,
!     l.objid,
!     l.objsubid,
!     l.virtualtransaction,
!     l.pid,
!     l.mode,
!     l.granted,
!     l.fastpath
!    FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath);
! pg_matviews| SELECT n.nspname AS schemaname,
!     c.relname AS matviewname,
!     pg_get_userbyid(c.relowner) AS matviewowner,
!     t.spcname AS tablespace,
!     c.relhasindex AS hasindexes,
!     c.relispopulated AS ispopulated,
!     pg_get_viewdef(c.oid) AS definition
!    FROM ((pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
!   WHERE (c.relkind = 'm'::"char");
! pg_policies| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     rs.rsecpolname AS policyname,
!         CASE
!             WHEN (rs.rsecroles = '{0}'::oid[]) THEN (string_to_array('public'::text, ''::text))::name[]
!             ELSE ARRAY( SELECT pg_authid.rolname
!                FROM pg_authid
!               WHERE (pg_authid.oid = ANY (rs.rsecroles))
!               ORDER BY pg_authid.rolname)
!         END AS roles,
!         CASE
!             WHEN (rs.rseccmd IS NULL) THEN 'ALL'::text
!             ELSE
!             CASE rs.rseccmd
!                 WHEN 'r'::"char" THEN 'SELECT'::text
!                 WHEN 'a'::"char" THEN 'INSERT'::text
!                 WHEN 'u'::"char" THEN 'UPDATE'::text
!                 WHEN 'd'::"char" THEN 'DELETE'::text
!                 ELSE NULL::text
!             END
!         END AS cmd,
!     pg_get_expr(rs.rsecqual, rs.rsecrelid) AS qual,
!     pg_get_expr(rs.rsecwithcheck, rs.rsecrelid) AS with_check
!    FROM ((pg_rowsecurity rs
!      JOIN pg_class c ON ((c.oid = rs.rsecrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));
! pg_prepared_statements| SELECT p.name,
!     p.statement,
!     p.prepare_time,
!     p.parameter_types,
!     p.from_sql
!    FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT p.transaction,
!     p.gid,
!     p.prepared,
!     u.rolname AS owner,
!     d.datname AS database
!    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
!      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
!      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
! pg_replication_slots| SELECT l.slot_name,
!     l.plugin,
!     l.slot_type,
!     l.datoid,
!     d.datname AS database,
!     l.active,
!     l.xmin,
!     l.catalog_xmin,
!     l.restart_lsn
!    FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, active, xmin, catalog_xmin, restart_lsn)
!      LEFT JOIN pg_database d ON ((l.datoid = d.oid)));
! pg_roles| SELECT pg_authid.rolname,
!     pg_authid.rolsuper,
!     pg_authid.rolinherit,
!     pg_authid.rolcreaterole,
!     pg_authid.rolcreatedb,
!     pg_authid.rolcatupdate,
!     pg_authid.rolcanlogin,
!     pg_authid.rolreplication,
!     pg_authid.rolconnlimit,
!     '********'::text AS rolpassword,
!     pg_authid.rolvaliduntil,
!     pg_authid.rolbypassrls,
!     s.setconfig AS rolconfig,
!     pg_authid.oid
!    FROM (pg_authid
!      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));
! pg_rules| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     r.rulename,
!     pg_get_ruledef(r.oid) AS definition
!    FROM ((pg_rewrite r
!      JOIN pg_class c ON ((c.oid = r.ev_class)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (r.rulename <> '_RETURN'::name);
! pg_seclabels| SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (rel.relkind = 'r'::"char") THEN 'table'::text
!             WHEN (rel.relkind = 'v'::"char") THEN 'view'::text
!             WHEN (rel.relkind = 'm'::"char") THEN 'materialized view'::text
!             WHEN (rel.relkind = 'S'::"char") THEN 'sequence'::text
!             WHEN (rel.relkind = 'f'::"char") THEN 'foreign table'::text
!             ELSE NULL::text
!         END AS objtype,
!     rel.relnamespace AS objnamespace,
!         CASE
!             WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
!         END AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
!      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'column'::text AS objtype,
!     rel.relnamespace AS objnamespace,
!     ((
!         CASE
!             WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
!         END || '.'::text) || (att.attname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (((pg_seclabel l
!      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
!      JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))
!      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
!   WHERE (l.objsubid <> 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (pro.proisagg = true) THEN 'aggregate'::text
!             WHEN (pro.proisagg = false) THEN 'function'::text
!             ELSE NULL::text
!         END AS objtype,
!     pro.pronamespace AS objnamespace,
!     (((
!         CASE
!             WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((pro.proname)::text))
!         END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text) AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))
!      JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (typ.typtype = 'd'::"char") THEN 'domain'::text
!             ELSE 'type'::text
!         END AS objtype,
!     typ.typnamespace AS objnamespace,
!         CASE
!             WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((typ.typname)::text))
!         END AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))
!      JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'large object'::text AS objtype,
!     NULL::oid AS objnamespace,
!     (l.objoid)::text AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))
!   WHERE ((l.classoid = ('pg_largeobject'::regclass)::oid) AND (l.objsubid = 0))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'language'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((lan.lanname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'schema'::text AS objtype,
!     nsp.oid AS objnamespace,
!     quote_ident((nsp.nspname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'event trigger'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((evt.evtname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'database'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((dat.datname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'tablespace'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((spc.spcname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'role'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((rol.rolname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));
! pg_settings| SELECT a.name,
!     a.setting,
!     a.unit,
!     a.category,
!     a.short_desc,
!     a.extra_desc,
!     a.context,
!     a.vartype,
!     a.source,
!     a.min_val,
!     a.max_val,
!     a.enumvals,
!     a.boot_val,
!     a.reset_val,
!     a.sourcefile,
!     a.sourceline
!    FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline);
! pg_shadow| SELECT pg_authid.rolname AS usename,
!     pg_authid.oid AS usesysid,
!     pg_authid.rolcreatedb AS usecreatedb,
!     pg_authid.rolsuper AS usesuper,
!     pg_authid.rolcatupdate AS usecatupd,
!     pg_authid.rolreplication AS userepl,
!     pg_authid.rolpassword AS passwd,
!     (pg_authid.rolvaliduntil)::abstime AS valuntil,
!     s.setconfig AS useconfig
!    FROM (pg_authid
!      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))))
!   WHERE pg_authid.rolcanlogin;
! pg_stat_activity| SELECT s.datid,
!     d.datname,
!     s.pid,
!     s.usesysid,
!     u.rolname AS usename,
!     s.application_name,
!     s.client_addr,
!     s.client_hostname,
!     s.client_port,
!     s.backend_start,
!     s.xact_start,
!     s.query_start,
!     s.state_change,
!     s.waiting,
!     s.state,
!     s.backend_xid,
!     s.backend_xmin,
!     s.query
!    FROM pg_database d,
!     pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin),
!     pg_authid u
!   WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));
! pg_stat_all_indexes| SELECT c.oid AS relid,
!     i.oid AS indexrelid,
!     n.nspname AS schemaname,
!     c.relname,
!     i.relname AS indexrelname,
!     pg_stat_get_numscans(i.oid) AS idx_scan,
!     pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
!     pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch
!    FROM (((pg_class c
!      JOIN pg_index x ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));
! pg_stat_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     pg_stat_get_numscans(c.oid) AS seq_scan,
!     pg_stat_get_tuples_returned(c.oid) AS seq_tup_read,
!     (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan,
!     ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch,
!     pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins,
!     pg_stat_get_tuples_updated(c.oid) AS n_tup_upd,
!     pg_stat_get_tuples_deleted(c.oid) AS n_tup_del,
!     pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd,
!     pg_stat_get_live_tuples(c.oid) AS n_live_tup,
!     pg_stat_get_dead_tuples(c.oid) AS n_dead_tup,
!     pg_stat_get_mod_since_analyze(c.oid) AS n_mod_since_analyze,
!     pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum,
!     pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum,
!     pg_stat_get_last_analyze_time(c.oid) AS last_analyze,
!     pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze,
!     pg_stat_get_vacuum_count(c.oid) AS vacuum_count,
!     pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count,
!     pg_stat_get_analyze_count(c.oid) AS analyze_count,
!     pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count
!    FROM ((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname;
! pg_stat_archiver| SELECT s.archived_count,
!     s.last_archived_wal,
!     s.last_archived_time,
!     s.failed_count,
!     s.last_failed_wal,
!     s.last_failed_time,
!     s.stats_reset
!    FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);
! pg_stat_bgwriter| SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed,
!     pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req,
!     pg_stat_get_checkpoint_write_time() AS checkpoint_write_time,
!     pg_stat_get_checkpoint_sync_time() AS checkpoint_sync_time,
!     pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
!     pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean,
!     pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean,
!     pg_stat_get_buf_written_backend() AS buffers_backend,
!     pg_stat_get_buf_fsync_backend() AS buffers_backend_fsync,
!     pg_stat_get_buf_alloc() AS buffers_alloc,
!     pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;
! pg_stat_database| SELECT d.oid AS datid,
!     d.datname,
!     pg_stat_get_db_numbackends(d.oid) AS numbackends,
!     pg_stat_get_db_xact_commit(d.oid) AS xact_commit,
!     pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback,
!     (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read,
!     pg_stat_get_db_blocks_hit(d.oid) AS blks_hit,
!     pg_stat_get_db_tuples_returned(d.oid) AS tup_returned,
!     pg_stat_get_db_tuples_fetched(d.oid) AS tup_fetched,
!     pg_stat_get_db_tuples_inserted(d.oid) AS tup_inserted,
!     pg_stat_get_db_tuples_updated(d.oid) AS tup_updated,
!     pg_stat_get_db_tuples_deleted(d.oid) AS tup_deleted,
!     pg_stat_get_db_conflict_all(d.oid) AS conflicts,
!     pg_stat_get_db_temp_files(d.oid) AS temp_files,
!     pg_stat_get_db_temp_bytes(d.oid) AS temp_bytes,
!     pg_stat_get_db_deadlocks(d.oid) AS deadlocks,
!     pg_stat_get_db_blk_read_time(d.oid) AS blk_read_time,
!     pg_stat_get_db_blk_write_time(d.oid) AS blk_write_time,
!     pg_stat_get_db_stat_reset_time(d.oid) AS stats_reset
!    FROM pg_database d;
! pg_stat_database_conflicts| SELECT d.oid AS datid,
!     d.datname,
!     pg_stat_get_db_conflict_tablespace(d.oid) AS confl_tablespace,
!     pg_stat_get_db_conflict_lock(d.oid) AS confl_lock,
!     pg_stat_get_db_conflict_snapshot(d.oid) AS confl_snapshot,
!     pg_stat_get_db_conflict_bufferpin(d.oid) AS confl_bufferpin,
!     pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
!    FROM pg_database d;
! pg_stat_replication| SELECT s.pid,
!     s.usesysid,
!     u.rolname AS usename,
!     s.application_name,
!     s.client_addr,
!     s.client_hostname,
!     s.client_port,
!     s.backend_start,
!     s.backend_xmin,
!     w.state,
!     w.sent_location,
!     w.write_location,
!     w.flush_location,
!     w.replay_location,
!     w.sync_priority,
!     w.sync_state
!    FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin),
!     pg_authid u,
!     pg_stat_get_wal_senders() w(pid, state, sent_location, write_location, flush_location, replay_location, sync_priority, sync_state)
!   WHERE ((s.usesysid = u.oid) AND (s.pid = w.pid));
! pg_stat_sys_indexes| SELECT pg_stat_all_indexes.relid,
!     pg_stat_all_indexes.indexrelid,
!     pg_stat_all_indexes.schemaname,
!     pg_stat_all_indexes.relname,
!     pg_stat_all_indexes.indexrelname,
!     pg_stat_all_indexes.idx_scan,
!     pg_stat_all_indexes.idx_tup_read,
!     pg_stat_all_indexes.idx_tup_fetch
!    FROM pg_stat_all_indexes
!   WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_indexes.schemaname ~ '^pg_toast'::text));
! pg_stat_sys_tables| SELECT pg_stat_all_tables.relid,
!     pg_stat_all_tables.schemaname,
!     pg_stat_all_tables.relname,
!     pg_stat_all_tables.seq_scan,
!     pg_stat_all_tables.seq_tup_read,
!     pg_stat_all_tables.idx_scan,
!     pg_stat_all_tables.idx_tup_fetch,
!     pg_stat_all_tables.n_tup_ins,
!     pg_stat_all_tables.n_tup_upd,
!     pg_stat_all_tables.n_tup_del,
!     pg_stat_all_tables.n_tup_hot_upd,
!     pg_stat_all_tables.n_live_tup,
!     pg_stat_all_tables.n_dead_tup,
!     pg_stat_all_tables.n_mod_since_analyze,
!     pg_stat_all_tables.last_vacuum,
!     pg_stat_all_tables.last_autovacuum,
!     pg_stat_all_tables.last_analyze,
!     pg_stat_all_tables.last_autoanalyze,
!     pg_stat_all_tables.vacuum_count,
!     pg_stat_all_tables.autovacuum_count,
!     pg_stat_all_tables.analyze_count,
!     pg_stat_all_tables.autoanalyze_count
!    FROM pg_stat_all_tables
!   WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_tables.schemaname ~ '^pg_toast'::text));
! pg_stat_user_functions| SELECT p.oid AS funcid,
!     n.nspname AS schemaname,
!     p.proname AS funcname,
!     pg_stat_get_function_calls(p.oid) AS calls,
!     pg_stat_get_function_total_time(p.oid) AS total_time,
!     pg_stat_get_function_self_time(p.oid) AS self_time
!    FROM (pg_proc p
!      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
!   WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));
! pg_stat_user_indexes| SELECT pg_stat_all_indexes.relid,
!     pg_stat_all_indexes.indexrelid,
!     pg_stat_all_indexes.schemaname,
!     pg_stat_all_indexes.relname,
!     pg_stat_all_indexes.indexrelname,
!     pg_stat_all_indexes.idx_scan,
!     pg_stat_all_indexes.idx_tup_read,
!     pg_stat_all_indexes.idx_tup_fetch
!    FROM pg_stat_all_indexes
!   WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_indexes.schemaname !~ '^pg_toast'::text));
! pg_stat_user_tables| SELECT pg_stat_all_tables.relid,
!     pg_stat_all_tables.schemaname,
!     pg_stat_all_tables.relname,
!     pg_stat_all_tables.seq_scan,
!     pg_stat_all_tables.seq_tup_read,
!     pg_stat_all_tables.idx_scan,
!     pg_stat_all_tables.idx_tup_fetch,
!     pg_stat_all_tables.n_tup_ins,
!     pg_stat_all_tables.n_tup_upd,
!     pg_stat_all_tables.n_tup_del,
!     pg_stat_all_tables.n_tup_hot_upd,
!     pg_stat_all_tables.n_live_tup,
!     pg_stat_all_tables.n_dead_tup,
!     pg_stat_all_tables.n_mod_since_analyze,
!     pg_stat_all_tables.last_vacuum,
!     pg_stat_all_tables.last_autovacuum,
!     pg_stat_all_tables.last_analyze,
!     pg_stat_all_tables.last_autoanalyze,
!     pg_stat_all_tables.vacuum_count,
!     pg_stat_all_tables.autovacuum_count,
!     pg_stat_all_tables.analyze_count,
!     pg_stat_all_tables.autoanalyze_count
!    FROM pg_stat_all_tables
!   WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_tables.schemaname !~ '^pg_toast'::text));
! pg_stat_xact_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     pg_stat_get_xact_numscans(c.oid) AS seq_scan,
!     pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read,
!     (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan,
!     ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_xact_tuples_fetched(c.oid)) AS idx_tup_fetch,
!     pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins,
!     pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd,
!     pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del,
!     pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd
!    FROM ((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname;
! pg_stat_xact_sys_tables| SELECT pg_stat_xact_all_tables.relid,
!     pg_stat_xact_all_tables.schemaname,
!     pg_stat_xact_all_tables.relname,
!     pg_stat_xact_all_tables.seq_scan,
!     pg_stat_xact_all_tables.seq_tup_read,
!     pg_stat_xact_all_tables.idx_scan,
!     pg_stat_xact_all_tables.idx_tup_fetch,
!     pg_stat_xact_all_tables.n_tup_ins,
!     pg_stat_xact_all_tables.n_tup_upd,
!     pg_stat_xact_all_tables.n_tup_del,
!     pg_stat_xact_all_tables.n_tup_hot_upd
!    FROM pg_stat_xact_all_tables
!   WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text));
! pg_stat_xact_user_functions| SELECT p.oid AS funcid,
!     n.nspname AS schemaname,
!     p.proname AS funcname,
!     pg_stat_get_xact_function_calls(p.oid) AS calls,
!     pg_stat_get_xact_function_total_time(p.oid) AS total_time,
!     pg_stat_get_xact_function_self_time(p.oid) AS self_time
!    FROM (pg_proc p
!      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
!   WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));
! pg_stat_xact_user_tables| SELECT pg_stat_xact_all_tables.relid,
!     pg_stat_xact_all_tables.schemaname,
!     pg_stat_xact_all_tables.relname,
!     pg_stat_xact_all_tables.seq_scan,
!     pg_stat_xact_all_tables.seq_tup_read,
!     pg_stat_xact_all_tables.idx_scan,
!     pg_stat_xact_all_tables.idx_tup_fetch,
!     pg_stat_xact_all_tables.n_tup_ins,
!     pg_stat_xact_all_tables.n_tup_upd,
!     pg_stat_xact_all_tables.n_tup_del,
!     pg_stat_xact_all_tables.n_tup_hot_upd
!    FROM pg_stat_xact_all_tables
!   WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text));
! pg_statio_all_indexes| SELECT c.oid AS relid,
!     i.oid AS indexrelid,
!     n.nspname AS schemaname,
!     c.relname,
!     i.relname AS indexrelname,
!     (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,
!     pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit
!    FROM (((pg_class c
!      JOIN pg_index x ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));
! pg_statio_all_sequences| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,
!     pg_stat_get_blocks_hit(c.oid) AS blks_hit
!    FROM (pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = 'S'::"char");
! pg_statio_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,
!     pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit,
!     (sum((pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))))::bigint AS idx_blks_read,
!     (sum(pg_stat_get_blocks_hit(i.indexrelid)))::bigint AS idx_blks_hit,
!     (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,
!     pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit,
!     (sum((pg_stat_get_blocks_fetched(x.indexrelid) - pg_stat_get_blocks_hit(x.indexrelid))))::bigint AS tidx_blks_read,
!     (sum(pg_stat_get_blocks_hit(x.indexrelid)))::bigint AS tidx_blks_hit
!    FROM ((((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))
!      LEFT JOIN pg_index x ON ((t.oid = x.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;
! pg_statio_sys_indexes| SELECT pg_statio_all_indexes.relid,
!     pg_statio_all_indexes.indexrelid,
!     pg_statio_all_indexes.schemaname,
!     pg_statio_all_indexes.relname,
!     pg_statio_all_indexes.indexrelname,
!     pg_statio_all_indexes.idx_blks_read,
!     pg_statio_all_indexes.idx_blks_hit
!    FROM pg_statio_all_indexes
!   WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_indexes.schemaname ~ '^pg_toast'::text));
! pg_statio_sys_sequences| SELECT pg_statio_all_sequences.relid,
!     pg_statio_all_sequences.schemaname,
!     pg_statio_all_sequences.relname,
!     pg_statio_all_sequences.blks_read,
!     pg_statio_all_sequences.blks_hit
!    FROM pg_statio_all_sequences
!   WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_sequences.schemaname ~ '^pg_toast'::text));
! pg_statio_sys_tables| SELECT pg_statio_all_tables.relid,
!     pg_statio_all_tables.schemaname,
!     pg_statio_all_tables.relname,
!     pg_statio_all_tables.heap_blks_read,
!     pg_statio_all_tables.heap_blks_hit,
!     pg_statio_all_tables.idx_blks_read,
!     pg_statio_all_tables.idx_blks_hit,
!     pg_statio_all_tables.toast_blks_read,
!     pg_statio_all_tables.toast_blks_hit,
!     pg_statio_all_tables.tidx_blks_read,
!     pg_statio_all_tables.tidx_blks_hit
!    FROM pg_statio_all_tables
!   WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_tables.schemaname ~ '^pg_toast'::text));
! pg_statio_user_indexes| SELECT pg_statio_all_indexes.relid,
!     pg_statio_all_indexes.indexrelid,
!     pg_statio_all_indexes.schemaname,
!     pg_statio_all_indexes.relname,
!     pg_statio_all_indexes.indexrelname,
!     pg_statio_all_indexes.idx_blks_read,
!     pg_statio_all_indexes.idx_blks_hit
!    FROM pg_statio_all_indexes
!   WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_indexes.schemaname !~ '^pg_toast'::text));
! pg_statio_user_sequences| SELECT pg_statio_all_sequences.relid,
!     pg_statio_all_sequences.schemaname,
!     pg_statio_all_sequences.relname,
!     pg_statio_all_sequences.blks_read,
!     pg_statio_all_sequences.blks_hit
!    FROM pg_statio_all_sequences
!   WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_sequences.schemaname !~ '^pg_toast'::text));
! pg_statio_user_tables| SELECT pg_statio_all_tables.relid,
!     pg_statio_all_tables.schemaname,
!     pg_statio_all_tables.relname,
!     pg_statio_all_tables.heap_blks_read,
!     pg_statio_all_tables.heap_blks_hit,
!     pg_statio_all_tables.idx_blks_read,
!     pg_statio_all_tables.idx_blks_hit,
!     pg_statio_all_tables.toast_blks_read,
!     pg_statio_all_tables.toast_blks_hit,
!     pg_statio_all_tables.tidx_blks_read,
!     pg_statio_all_tables.tidx_blks_hit
!    FROM pg_statio_all_tables
!   WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_tables.schemaname !~ '^pg_toast'::text));
! pg_stats| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     a.attname,
!     s.stainherit AS inherited,
!     s.stanullfrac AS null_frac,
!     s.stawidth AS avg_width,
!     s.stadistinct AS n_distinct,
!         CASE
!             WHEN (s.stakind1 = 1) THEN s.stavalues1
!             WHEN (s.stakind2 = 1) THEN s.stavalues2
!             WHEN (s.stakind3 = 1) THEN s.stavalues3
!             WHEN (s.stakind4 = 1) THEN s.stavalues4
!             WHEN (s.stakind5 = 1) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS most_common_vals,
!         CASE
!             WHEN (s.stakind1 = 1) THEN s.stanumbers1
!             WHEN (s.stakind2 = 1) THEN s.stanumbers2
!             WHEN (s.stakind3 = 1) THEN s.stanumbers3
!             WHEN (s.stakind4 = 1) THEN s.stanumbers4
!             WHEN (s.stakind5 = 1) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS most_common_freqs,
!         CASE
!             WHEN (s.stakind1 = 2) THEN s.stavalues1
!             WHEN (s.stakind2 = 2) THEN s.stavalues2
!             WHEN (s.stakind3 = 2) THEN s.stavalues3
!             WHEN (s.stakind4 = 2) THEN s.stavalues4
!             WHEN (s.stakind5 = 2) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS histogram_bounds,
!         CASE
!             WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]
!             WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]
!             WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]
!             WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]
!             WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]
!             ELSE NULL::real
!         END AS correlation,
!         CASE
!             WHEN (s.stakind1 = 4) THEN s.stavalues1
!             WHEN (s.stakind2 = 4) THEN s.stavalues2
!             WHEN (s.stakind3 = 4) THEN s.stavalues3
!             WHEN (s.stakind4 = 4) THEN s.stavalues4
!             WHEN (s.stakind5 = 4) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS most_common_elems,
!         CASE
!             WHEN (s.stakind1 = 4) THEN s.stanumbers1
!             WHEN (s.stakind2 = 4) THEN s.stanumbers2
!             WHEN (s.stakind3 = 4) THEN s.stanumbers3
!             WHEN (s.stakind4 = 4) THEN s.stanumbers4
!             WHEN (s.stakind5 = 4) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS most_common_elem_freqs,
!         CASE
!             WHEN (s.stakind1 = 5) THEN s.stanumbers1
!             WHEN (s.stakind2 = 5) THEN s.stanumbers2
!             WHEN (s.stakind3 = 5) THEN s.stanumbers3
!             WHEN (s.stakind4 = 5) THEN s.stanumbers4
!             WHEN (s.stakind5 = 5) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS elem_count_histogram
!    FROM (((pg_statistic s
!      JOIN pg_class c ON ((c.oid = s.starelid)))
!      JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text));
! pg_tables| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     pg_get_userbyid(c.relowner) AS tableowner,
!     t.spcname AS tablespace,
!     c.relhasindex AS hasindexes,
!     c.relhasrules AS hasrules,
!     c.relhastriggers AS hastriggers,
!     c.relrowsecurity AS rowsecurity
!    FROM ((pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
!   WHERE (c.relkind = 'r'::"char");
! pg_timezone_abbrevs| SELECT pg_timezone_abbrevs.abbrev,
!     pg_timezone_abbrevs.utc_offset,
!     pg_timezone_abbrevs.is_dst
!    FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);
! pg_timezone_names| SELECT pg_timezone_names.name,
!     pg_timezone_names.abbrev,
!     pg_timezone_names.utc_offset,
!     pg_timezone_names.is_dst
!    FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);
! pg_user| SELECT pg_shadow.usename,
!     pg_shadow.usesysid,
!     pg_shadow.usecreatedb,
!     pg_shadow.usesuper,
!     pg_shadow.usecatupd,
!     pg_shadow.userepl,
!     '********'::text AS passwd,
!     pg_shadow.valuntil,
!     pg_shadow.useconfig
!    FROM pg_shadow;
! pg_user_mappings| SELECT u.oid AS umid,
!     s.oid AS srvid,
!     s.srvname,
!     u.umuser,
!         CASE
!             WHEN (u.umuser = (0)::oid) THEN 'public'::name
!             ELSE a.rolname
!         END AS usename,
!         CASE
!             WHEN (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) THEN u.umoptions
!             ELSE NULL::text[]
!         END AS umoptions
!    FROM ((pg_user_mapping u
!      LEFT JOIN pg_authid a ON ((a.oid = u.umuser)))
!      JOIN pg_foreign_server s ON ((u.umserver = s.oid)));
! pg_views| SELECT n.nspname AS schemaname,
!     c.relname AS viewname,
!     pg_get_userbyid(c.relowner) AS viewowner,
!     pg_get_viewdef(c.oid) AS definition
!    FROM (pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = 'v'::"char");
! rtest_v1| SELECT rtest_t1.a,
!     rtest_t1.b
!    FROM rtest_t1;
! rtest_vcomp| SELECT x.part,
!     (x.size * y.factor) AS size_in_cm
!    FROM rtest_comp x,
!     rtest_unitfact y
!   WHERE (x.unit = y.unit);
! rtest_vview1| SELECT x.a,
!     x.b
!    FROM rtest_view1 x
!   WHERE (0 < ( SELECT count(*) AS count
!            FROM rtest_view2 y
!           WHERE (y.a = x.a)));
! rtest_vview2| SELECT rtest_view1.a,
!     rtest_view1.b
!    FROM rtest_view1
!   WHERE rtest_view1.v;
! rtest_vview3| SELECT x.a,
!     x.b
!    FROM rtest_vview2 x
!   WHERE (0 < ( SELECT count(*) AS count
!            FROM rtest_view2 y
!           WHERE (y.a = x.a)));
! rtest_vview4| SELECT x.a,
!     x.b,
!     count(y.a) AS refcount
!    FROM rtest_view1 x,
!     rtest_view2 y
!   WHERE (x.a = y.a)
!   GROUP BY x.a, x.b;
! rtest_vview5| SELECT rtest_view1.a,
!     rtest_view1.b,
!     rtest_viewfunc1(rtest_view1.a) AS refcount
!    FROM rtest_view1;
! shoe| SELECT sh.shoename,
!     sh.sh_avail,
!     sh.slcolor,
!     sh.slminlen,
!     (sh.slminlen * un.un_fact) AS slminlen_cm,
!     sh.slmaxlen,
!     (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,
!     sh.slunit
!    FROM shoe_data sh,
!     unit un
!   WHERE (sh.slunit = un.un_name);
! shoe_ready| SELECT rsh.shoename,
!     rsh.sh_avail,
!     rsl.sl_name,
!     rsl.sl_avail,
!     int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
!    FROM shoe rsh,
!     shoelace rsl
!   WHERE ((rsl.sl_color = rsh.slcolor) AND (rsl.sl_len_cm >= rsh.slminlen_cm) AND (rsl.sl_len_cm <= rsh.slmaxlen_cm));
! shoelace| SELECT s.sl_name,
!     s.sl_avail,
!     s.sl_color,
!     s.sl_len,
!     s.sl_unit,
!     (s.sl_len * u.un_fact) AS sl_len_cm
!    FROM shoelace_data s,
!     unit u
!   WHERE (s.sl_unit = u.un_name);
! shoelace_candelete| SELECT shoelace_obsolete.sl_name,
!     shoelace_obsolete.sl_avail,
!     shoelace_obsolete.sl_color,
!     shoelace_obsolete.sl_len,
!     shoelace_obsolete.sl_unit,
!     shoelace_obsolete.sl_len_cm
!    FROM shoelace_obsolete
!   WHERE (shoelace_obsolete.sl_avail = 0);
! shoelace_obsolete| SELECT shoelace.sl_name,
!     shoelace.sl_avail,
!     shoelace.sl_color,
!     shoelace.sl_len,
!     shoelace.sl_unit,
!     shoelace.sl_len_cm
!    FROM shoelace
!   WHERE (NOT (EXISTS ( SELECT shoe.shoename
!            FROM shoe
!           WHERE (shoe.slcolor = shoelace.sl_color))));
! street| SELECT r.name,
!     r.thepath,
!     c.cname
!    FROM ONLY road r,
!     real_city c
!   WHERE (c.outline ## r.thepath);
! toyemp| SELECT emp.name,
!     emp.age,
!     emp.location,
!     (12 * emp.salary) AS annualsal
!    FROM emp;
! tv| SELECT t.type,
!     sum(t.amt) AS totamt
!    FROM t
!   GROUP BY t.type;
! tvv| SELECT sum(tv.totamt) AS grandtot
!    FROM tv;
! tvvmv| SELECT tvvm.grandtot
!    FROM tvvm;
! SELECT tablename, rulename, definition FROM pg_rules
! 	ORDER BY tablename, rulename;
! pg_settings|pg_settings_n|CREATE RULE pg_settings_n AS
!     ON UPDATE TO pg_settings DO INSTEAD NOTHING;
! pg_settings|pg_settings_u|CREATE RULE pg_settings_u AS
!     ON UPDATE TO pg_settings
!    WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;
! rtest_emp|rtest_emp_del|CREATE RULE rtest_emp_del AS
!     ON DELETE TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);
! rtest_emp|rtest_emp_ins|CREATE RULE rtest_emp_ins AS
!     ON INSERT TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);
! rtest_emp|rtest_emp_upd|CREATE RULE rtest_emp_upd AS
!     ON UPDATE TO rtest_emp
!    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);
! rtest_nothn1|rtest_nothn_r1|CREATE RULE rtest_nothn_r1 AS
!     ON INSERT TO rtest_nothn1
!    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
! rtest_nothn1|rtest_nothn_r2|CREATE RULE rtest_nothn_r2 AS
!     ON INSERT TO rtest_nothn1
!    WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;
! rtest_nothn2|rtest_nothn_r3|CREATE RULE rtest_nothn_r3 AS
!     ON INSERT TO rtest_nothn2
!    WHERE (new.a >= 100) DO INSTEAD  INSERT INTO rtest_nothn3 (a, b)
!   VALUES (new.a, new.b);
! rtest_nothn2|rtest_nothn_r4|CREATE RULE rtest_nothn_r4 AS
!     ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;
! rtest_order1|rtest_order_r1|CREATE RULE rtest_order_r1 AS
!     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 1 - this should run 1st'::text);
! rtest_order1|rtest_order_r2|CREATE RULE rtest_order_r2 AS
!     ON INSERT TO rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 2 - this should run 2nd'::text);
! rtest_order1|rtest_order_r3|CREATE RULE rtest_order_r3 AS
!     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 3 - this should run 3rd'::text);
! rtest_order1|rtest_order_r4|CREATE RULE rtest_order_r4 AS
!     ON INSERT TO rtest_order1
!    WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
! rtest_person|rtest_pers_del|CREATE RULE rtest_pers_del AS
!     ON DELETE TO rtest_person DO  DELETE FROM rtest_admin
!   WHERE (rtest_admin.pname = old.pname);
! rtest_person|rtest_pers_upd|CREATE RULE rtest_pers_upd AS
!     ON UPDATE TO rtest_person DO  UPDATE rtest_admin SET pname = new.pname
!   WHERE (rtest_admin.pname = old.pname);
! rtest_system|rtest_sys_del|CREATE RULE rtest_sys_del AS
!     ON DELETE TO rtest_system DO ( DELETE FROM rtest_interface
!   WHERE (rtest_interface.sysname = old.sysname);
!  DELETE FROM rtest_admin
!   WHERE (rtest_admin.sysname = old.sysname);
! );
! rtest_system|rtest_sys_upd|CREATE RULE rtest_sys_upd AS
!     ON UPDATE TO rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname
!   WHERE (rtest_interface.sysname = old.sysname);
!  UPDATE rtest_admin SET sysname = new.sysname
!   WHERE (rtest_admin.sysname = old.sysname);
! );
! rtest_t4|rtest_t4_ins1|CREATE RULE rtest_t4_ins1 AS
!     ON INSERT TO rtest_t4
!    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)
!   VALUES (new.a, new.b);
! rtest_t4|rtest_t4_ins2|CREATE RULE rtest_t4_ins2 AS
!     ON INSERT TO rtest_t4
!    WHERE ((new.a >= 20) AND (new.a < 30)) DO  INSERT INTO rtest_t6 (a, b)
!   VALUES (new.a, new.b);
! rtest_t5|rtest_t5_ins|CREATE RULE rtest_t5_ins AS
!     ON INSERT TO rtest_t5
!    WHERE (new.a > 15) DO  INSERT INTO rtest_t7 (a, b)
!   VALUES (new.a, new.b);
! rtest_t6|rtest_t6_ins|CREATE RULE rtest_t6_ins AS
!     ON INSERT TO rtest_t6
!    WHERE (new.a > 25) DO INSTEAD  INSERT INTO rtest_t8 (a, b)
!   VALUES (new.a, new.b);
! rtest_v1|rtest_v1_del|CREATE RULE rtest_v1_del AS
!     ON DELETE TO rtest_v1 DO INSTEAD  DELETE FROM rtest_t1
!   WHERE (rtest_t1.a = old.a);
! rtest_v1|rtest_v1_ins|CREATE RULE rtest_v1_ins AS
!     ON INSERT TO rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)
!   VALUES (new.a, new.b);
! rtest_v1|rtest_v1_upd|CREATE RULE rtest_v1_upd AS
!     ON UPDATE TO rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b
!   WHERE (rtest_t1.a = old.a);
! shoelace|shoelace_del|CREATE RULE shoelace_del AS
!     ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data
!   WHERE (shoelace_data.sl_name = old.sl_name);
! shoelace|shoelace_ins|CREATE RULE shoelace_ins AS
!     ON INSERT TO shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)
!   VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
! shoelace|shoelace_upd|CREATE RULE shoelace_upd AS
!     ON UPDATE TO shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit
!   WHERE (shoelace_data.sl_name = old.sl_name);
! shoelace_data|log_shoelace|CREATE RULE log_shoelace AS
!     ON UPDATE TO shoelace_data
!    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)
!   VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
! shoelace_ok|shoelace_ok_ins|CREATE RULE shoelace_ok_ins AS
!     ON INSERT TO shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)
!   WHERE (shoelace.sl_name = new.ok_name);
! -- restore normal output mode
! \a\t
! --
! -- CREATE OR REPLACE RULE
! --
! CREATE TABLE ruletest_tbl (a int, b int);
! CREATE TABLE ruletest_tbl2 (a int, b int);
! CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
! 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
! INSERT INTO ruletest_tbl VALUES (99, 99);
! CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
! 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
! INSERT INTO ruletest_tbl VALUES (99, 99);
! SELECT * FROM ruletest_tbl2;
!   a   |  b   
! ------+------
!    10 |   10
!  1000 | 1000
! (2 rows)
! 
! -- Check that rewrite rules splitting one INSERT into multiple
! -- conditional statements does not disable FK checking.
! create table rule_and_refint_t1 (
! 	id1a integer,
! 	id1b integer,
! 	primary key (id1a, id1b)
! );
! create table rule_and_refint_t2 (
! 	id2a integer,
! 	id2c integer,
! 	primary key (id2a, id2c)
! );
! create table rule_and_refint_t3 (
! 	id3a integer,
! 	id3b integer,
! 	id3c integer,
! 	data text,
! 	primary key (id3a, id3b, id3c),
! 	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
! 	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
! );
! insert into rule_and_refint_t1 values (1, 11);
! insert into rule_and_refint_t1 values (1, 12);
! insert into rule_and_refint_t1 values (2, 21);
! insert into rule_and_refint_t1 values (2, 22);
! insert into rule_and_refint_t2 values (1, 11);
! insert into rule_and_refint_t2 values (1, 12);
! insert into rule_and_refint_t2 values (2, 21);
! insert into rule_and_refint_t2 values (2, 22);
! insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
! insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
! insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
! insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
! insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
! insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
! create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
! 	where (exists (select 1 from rule_and_refint_t3
! 			where (((rule_and_refint_t3.id3a = new.id3a)
! 			and (rule_and_refint_t3.id3b = new.id3b))
! 			and (rule_and_refint_t3.id3c = new.id3c))))
! 	do instead update rule_and_refint_t3 set data = new.data
! 	where (((rule_and_refint_t3.id3a = new.id3a)
! 	and (rule_and_refint_t3.id3b = new.id3b))
! 	and (rule_and_refint_t3.id3c = new.id3c));
! insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
! insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
! --
! -- disallow dropping a view's rule (bug #5072)
! --
! create view fooview as select 'foo'::text;
! drop rule "_RETURN" on fooview;
! ERROR:  cannot drop rule _RETURN on view fooview because view fooview requires it
! HINT:  You can drop view fooview instead.
! drop view fooview;
! --
! -- test conversion of table to view (needed to load some pg_dump files)
! --
! create table fooview (x int, y text);
! select xmin, * from fooview;
!  xmin | x | y 
! ------+---+---
! (0 rows)
! 
! create rule "_RETURN" as on select to fooview do instead
!   select 1 as x, 'aaa'::text as y;
! select * from fooview;
!  x |  y  
! ---+-----
!  1 | aaa
! (1 row)
! 
! select xmin, * from fooview;  -- fail, views don't have such a column
! ERROR:  column "xmin" does not exist
! LINE 1: select xmin, * from fooview;
!                ^
! select reltoastrelid, relkind, relfrozenxid
!   from pg_class where oid = 'fooview'::regclass;
!  reltoastrelid | relkind | relfrozenxid 
! ---------------+---------+--------------
!              0 | v       |            0
! (1 row)
! 
! drop view fooview;
! --
! -- check for planner problems with complex inherited UPDATES
! --
! create table id (id serial primary key, name text);
! -- currently, must respecify PKEY for each inherited subtable
! create table test_1 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! create table test_2 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! create table test_3 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! insert into test_1 (name) values ('Test 1');
! insert into test_1 (name) values ('Test 2');
! insert into test_2 (name) values ('Test 3');
! insert into test_2 (name) values ('Test 4');
! insert into test_3 (name) values ('Test 5');
! insert into test_3 (name) values ('Test 6');
! create view id_ordered as select * from id order by id;
! create rule update_id_ordered as on update to id_ordered
! 	do instead update id set name = new.name where id = old.id;
! select * from id_ordered;
!  id |  name  
! ----+--------
!   1 | Test 1
!   2 | Test 2
!   3 | Test 3
!   4 | Test 4
!   5 | Test 5
!   6 | Test 6
! (6 rows)
! 
! update id_ordered set name = 'update 2' where id = 2;
! update id_ordered set name = 'update 4' where id = 4;
! update id_ordered set name = 'update 5' where id = 5;
! select * from id_ordered;
!  id |   name   
! ----+----------
!   1 | Test 1
!   2 | update 2
!   3 | Test 3
!   4 | update 4
!   5 | update 5
!   6 | Test 6
! (6 rows)
! 
! set client_min_messages to warning; -- suppress cascade notices
! drop table id cascade;
! reset client_min_messages;
! --
! -- check corner case where an entirely-dummy subplan is created by
! -- constraint exclusion
! --
! create temp table t1 (a integer primary key);
! create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1);
! create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1);
! create rule t1_ins_1 as on insert to t1
! 	where new.a >= 0 and new.a < 10
! 	do instead
! 	insert into t1_1 values (new.a);
! create rule t1_ins_2 as on insert to t1
! 	where new.a >= 10 and new.a < 20
! 	do instead
! 	insert into t1_2 values (new.a);
! create rule t1_upd_1 as on update to t1
! 	where old.a >= 0 and old.a < 10
! 	do instead
! 	update t1_1 set a = new.a where a = old.a;
! create rule t1_upd_2 as on update to t1
! 	where old.a >= 10 and old.a < 20
! 	do instead
! 	update t1_2 set a = new.a where a = old.a;
! set constraint_exclusion = on;
! insert into t1 select * from generate_series(5,19,1) g;
! update t1 set a = 4 where a = 5;
! select * from only t1;
!  a 
! ---
! (0 rows)
! 
! select * from only t1_1;
!  a 
! ---
!  6
!  7
!  8
!  9
!  4
! (5 rows)
! 
! select * from only t1_2;
!  a  
! ----
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
! (10 rows)
! 
! -- test various flavors of pg_get_viewdef()
! select pg_get_viewdef('shoe'::regclass) as unpretty;
!                     unpretty                    
! ------------------------------------------------
!   SELECT sh.shoename,                          +
!      sh.sh_avail,                              +
!      sh.slcolor,                               +
!      sh.slminlen,                              +
!      (sh.slminlen * un.un_fact) AS slminlen_cm,+
!      sh.slmaxlen,                              +
!      (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,+
!      sh.slunit                                 +
!     FROM shoe_data sh,                         +
!      unit un                                   +
!    WHERE (sh.slunit = un.un_name);
! (1 row)
! 
! select pg_get_viewdef('shoe'::regclass,true) as pretty;
!                     pretty                    
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
! select pg_get_viewdef('shoe'::regclass,0) as prettier;
!                    prettier                   
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
! --
! -- check multi-row VALUES in rules
! --
! create table rules_src(f1 int, f2 int);
! create table rules_log(f1 int, f2 int, tag text);
! insert into rules_src values(1,2), (11,12);
! create rule r1 as on update to rules_src do also
!   insert into rules_log values(old.*, 'old'), (new.*, 'new');
! update rules_src set f2 = f2 + 1;
! update rules_src set f2 = f2 * 10;
! select * from rules_src;
!  f1 | f2  
! ----+-----
!   1 |  30
!  11 | 130
! (2 rows)
! 
! select * from rules_log;
!  f1 | f2  | tag 
! ----+-----+-----
!   1 |   2 | old
!   1 |   3 | new
!  11 |  12 | old
!  11 |  13 | new
!   1 |   3 | old
!   1 |  30 | new
!  11 |  13 | old
!  11 | 130 | new
! (8 rows)
! 
! create rule r2 as on update to rules_src do also
!   values(old.*, 'old'), (new.*, 'new');
! update rules_src set f2 = f2 / 10;
!  column1 | column2 | column3 
! ---------+---------+---------
!        1 |      30 | old
!        1 |       3 | new
!       11 |     130 | old
!       11 |      13 | new
! (4 rows)
! 
! select * from rules_src;
!  f1 | f2 
! ----+----
!   1 |  3
!  11 | 13
! (2 rows)
! 
! select * from rules_log;
!  f1 | f2  | tag 
! ----+-----+-----
!   1 |   2 | old
!   1 |   3 | new
!  11 |  12 | old
!  11 |  13 | new
!   1 |   3 | old
!   1 |  30 | new
!  11 |  13 | old
!  11 | 130 | new
!   1 |  30 | old
!   1 |   3 | new
!  11 | 130 | old
!  11 |  13 | new
! (12 rows)
! 
! create rule r3 as on delete to rules_src do notify rules_src_deletion;
! \d+ rules_src
!                       Table "public.rules_src"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  f1     | integer |           | plain   |              | 
!  f2     | integer |           | plain   |              | 
! Rules:
!     r1 AS
!     ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
!     r2 AS
!     ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
!     r3 AS
!     ON DELETE TO rules_src DO
!  NOTIFY rules_src_deletion
! 
! --
! -- check alter rename rule
! --
! CREATE TABLE rule_t1 (a INT);
! CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
! CREATE RULE InsertRule AS
!     ON INSERT TO rule_v1
!     DO INSTEAD
!         INSERT INTO rule_t1 VALUES(new.a);
! ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
! INSERT INTO rule_v1 VALUES(1);
! SELECT * FROM rule_v1;
!  a 
! ---
!  1
! (1 row)
! 
! \d+ rule_v1
!                 View "public.rule_v1"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rule_t1.a
!    FROM rule_t1;
! Rules:
!  newinsertrule AS
!     ON INSERT TO rule_v1 DO INSTEAD  INSERT INTO rule_t1 (a)
!   VALUES (new.a)
! 
! --
! -- error conditions for alter rename rule
! --
! ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist
! ERROR:  rule "insertrule" for relation "rule_v1" does not exist
! ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists
! ERROR:  rule "_RETURN" for relation "rule_v1" already exists
! ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed
! ERROR:  renaming an ON SELECT rule is not allowed
! DROP VIEW rule_v1;
! DROP TABLE rule_t1;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/event_trigger.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/event_trigger.out	2015-01-10 10:11:46.895649469 +0300
***************
*** 1,296 ****
! -- should fail, return type mismatch
! create event trigger regress_event_trigger
!    on ddl_command_start
!    execute procedure pg_backend_pid();
! ERROR:  function "pg_backend_pid" must return type "event_trigger"
! -- OK
! create function test_event_trigger() returns event_trigger as $$
! BEGIN
!     RAISE NOTICE 'test_event_trigger: % %', tg_event, tg_tag;
! END
! $$ language plpgsql;
! -- should fail, no elephant_bootstrap entry point
! create event trigger regress_event_trigger on elephant_bootstrap
!    execute procedure test_event_trigger();
! ERROR:  unrecognized event name "elephant_bootstrap"
! -- OK
! create event trigger regress_event_trigger on ddl_command_start
!    execute procedure test_event_trigger();
! -- OK
! create event trigger regress_event_trigger_end on ddl_command_end
!    execute procedure test_event_trigger();
! -- should fail, food is not a valid filter variable
! create event trigger regress_event_trigger2 on ddl_command_start
!    when food in ('sandwhich')
!    execute procedure test_event_trigger();
! ERROR:  unrecognized filter variable "food"
! -- should fail, sandwhich is not a valid command tag
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('sandwhich')
!    execute procedure test_event_trigger();
! ERROR:  filter value "sandwhich" not recognized for filter variable "tag"
! -- should fail, create skunkcabbage is not a valid comand tag
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table', 'create skunkcabbage')
!    execute procedure test_event_trigger();
! ERROR:  filter value "create skunkcabbage" not recognized for filter variable "tag"
! -- should fail, can't have event triggers on event triggers
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('DROP EVENT TRIGGER')
!    execute procedure test_event_trigger();
! ERROR:  event triggers are not supported for DROP EVENT TRIGGER
! -- should fail, can't have same filter variable twice
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table') and tag in ('CREATE FUNCTION')
!    execute procedure test_event_trigger();
! ERROR:  filter variable "tag" specified more than once
! -- OK
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table', 'CREATE FUNCTION')
!    execute procedure test_event_trigger();
! -- OK
! comment on event trigger regress_event_trigger is 'test comment';
! -- should fail, event triggers are not schema objects
! comment on event trigger wrong.regress_event_trigger is 'test comment';
! ERROR:  event trigger name cannot be qualified
! -- drop as non-superuser should fail
! create role regression_bob;
! set role regression_bob;
! create event trigger regress_event_trigger_noperms on ddl_command_start
!    execute procedure test_event_trigger();
! ERROR:  permission denied to create event trigger "regress_event_trigger_noperms"
! HINT:  Must be superuser to create an event trigger.
! reset role;
! -- all OK
! alter event trigger regress_event_trigger enable replica;
! alter event trigger regress_event_trigger enable always;
! alter event trigger regress_event_trigger enable;
! alter event trigger regress_event_trigger disable;
! -- regress_event_trigger2 and regress_event_trigger_end should fire, but not
! -- regress_event_trigger
! create table event_trigger_fire1 (a int);
! NOTICE:  test_event_trigger: ddl_command_start CREATE TABLE
! NOTICE:  test_event_trigger: ddl_command_end CREATE TABLE
! -- regress_event_trigger_end should fire here
! drop table event_trigger_fire1;
! NOTICE:  test_event_trigger: ddl_command_end DROP TABLE
! -- alter owner to non-superuser should fail
! alter event trigger regress_event_trigger owner to regression_bob;
! ERROR:  permission denied to change owner of event trigger "regress_event_trigger"
! HINT:  The owner of an event trigger must be a superuser.
! -- alter owner to superuser should work
! alter role regression_bob superuser;
! alter event trigger regress_event_trigger owner to regression_bob;
! -- should fail, name collision
! alter event trigger regress_event_trigger rename to regress_event_trigger2;
! ERROR:  event trigger "regress_event_trigger2" already exists
! -- OK
! alter event trigger regress_event_trigger rename to regress_event_trigger3;
! -- should fail, doesn't exist any more
! drop event trigger regress_event_trigger;
! ERROR:  event trigger "regress_event_trigger" does not exist
! -- should fail, regression_bob owns regress_event_trigger2/3
! drop role regression_bob;
! ERROR:  role "regression_bob" cannot be dropped because some objects depend on it
! DETAIL:  owner of event trigger regress_event_trigger3
! -- cleanup before next test
! -- these are all OK; the second one should emit a NOTICE
! drop event trigger if exists regress_event_trigger2;
! drop event trigger if exists regress_event_trigger2;
! NOTICE:  event trigger "regress_event_trigger2" does not exist, skipping
! drop event trigger regress_event_trigger3;
! drop event trigger regress_event_trigger_end;
! -- test support for dropped objects
! CREATE SCHEMA schema_one authorization regression_bob;
! CREATE SCHEMA schema_two authorization regression_bob;
! CREATE SCHEMA audit_tbls authorization regression_bob;
! SET SESSION AUTHORIZATION regression_bob;
! CREATE TABLE schema_one.table_one(a int);
! CREATE TABLE schema_one."table two"(a int);
! CREATE TABLE schema_one.table_three(a int);
! CREATE TABLE audit_tbls.schema_one_table_two(the_value text);
! CREATE TABLE schema_two.table_two(a int);
! CREATE TABLE schema_two.table_three(a int, b text);
! CREATE TABLE audit_tbls.schema_two_table_three(the_value text);
! CREATE OR REPLACE FUNCTION schema_two.add(int, int) RETURNS int LANGUAGE plpgsql
!   CALLED ON NULL INPUT
!   AS $$ BEGIN RETURN coalesce($1,0) + coalesce($2,0); END; $$;
! CREATE AGGREGATE schema_two.newton
!   (BASETYPE = int, SFUNC = schema_two.add, STYPE = int);
! RESET SESSION AUTHORIZATION;
! CREATE TABLE undroppable_objs (
! 	object_type text,
! 	object_identity text
! );
! INSERT INTO undroppable_objs VALUES
! ('table', 'schema_one.table_three'),
! ('table', 'audit_tbls.schema_two_table_three');
! CREATE TABLE dropped_objects (
! 	type text,
! 	schema text,
! 	object text
! );
! -- This tests errors raised within event triggers; the one in audit_tbls
! -- uses 2nd-level recursive invocation via test_evtrig_dropped_objects().
! CREATE OR REPLACE FUNCTION undroppable() RETURNS event_trigger
! LANGUAGE plpgsql AS $$
! DECLARE
! 	obj record;
! BEGIN
! 	PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs';
! 	IF NOT FOUND THEN
! 		RAISE NOTICE 'table undroppable_objs not found, skipping';
! 		RETURN;
! 	END IF;
! 	FOR obj IN
! 		SELECT * FROM pg_event_trigger_dropped_objects() JOIN
! 			undroppable_objs USING (object_type, object_identity)
! 	LOOP
! 		RAISE EXCEPTION 'object % of type % cannot be dropped',
! 			obj.object_identity, obj.object_type;
! 	END LOOP;
! END;
! $$;
! CREATE EVENT TRIGGER undroppable ON sql_drop
! 	EXECUTE PROCEDURE undroppable();
! CREATE OR REPLACE FUNCTION test_evtrig_dropped_objects() RETURNS event_trigger
! LANGUAGE plpgsql AS $$
! DECLARE
!     obj record;
! BEGIN
!     FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
!     LOOP
!         IF obj.object_type = 'table' THEN
!                 EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I',
! 					format('%s_%s', obj.schema_name, obj.object_name));
!         END IF;
! 
! 	INSERT INTO dropped_objects
! 		(type, schema, object) VALUES
! 		(obj.object_type, obj.schema_name, obj.object_identity);
!     END LOOP;
! END
! $$;
! CREATE EVENT TRIGGER regress_event_trigger_drop_objects ON sql_drop
! 	WHEN TAG IN ('drop table', 'drop function', 'drop view',
! 		'drop owned', 'drop schema', 'alter table')
! 	EXECUTE PROCEDURE test_evtrig_dropped_objects();
! ALTER TABLE schema_one.table_one DROP COLUMN a;
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! ERROR:  object audit_tbls.schema_two_table_three of type table cannot be dropped
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! DELETE FROM undroppable_objs WHERE object_identity = 'audit_tbls.schema_two_table_three';
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_one" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_one"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls."schema_one_table two""
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! ERROR:  object schema_one.table_three of type table cannot be dropped
! DELETE FROM undroppable_objs WHERE object_identity = 'schema_one.table_three';
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_one" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_one"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls."schema_one_table two""
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SELECT * FROM dropped_objects WHERE schema IS NULL OR schema <> 'pg_toast';
!      type     |   schema   |               object                
! --------------+------------+-------------------------------------
!  table column | schema_one | schema_one.table_one.a
!  schema       |            | schema_two
!  table        | schema_two | schema_two.table_two
!  type         | schema_two | schema_two.table_two
!  type         | schema_two | schema_two.table_two[]
!  table        | audit_tbls | audit_tbls.schema_two_table_three
!  type         | audit_tbls | audit_tbls.schema_two_table_three
!  type         | audit_tbls | audit_tbls.schema_two_table_three[]
!  table        | schema_two | schema_two.table_three
!  type         | schema_two | schema_two.table_three
!  type         | schema_two | schema_two.table_three[]
!  function     | schema_two | schema_two.add(integer,integer)
!  aggregate    | schema_two | schema_two.newton(integer)
!  schema       |            | schema_one
!  table        | schema_one | schema_one.table_one
!  type         | schema_one | schema_one.table_one
!  type         | schema_one | schema_one.table_one[]
!  table        | schema_one | schema_one."table two"
!  type         | schema_one | schema_one."table two"
!  type         | schema_one | schema_one."table two"[]
!  table        | schema_one | schema_one.table_three
!  type         | schema_one | schema_one.table_three
!  type         | schema_one | schema_one.table_three[]
! (23 rows)
! 
! DROP OWNED BY regression_bob;
! NOTICE:  schema "audit_tbls" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_one_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SELECT * FROM dropped_objects WHERE type = 'schema';
!   type  | schema |   object   
! --------+--------+------------
!  schema |        | schema_two
!  schema |        | schema_one
!  schema |        | audit_tbls
! (3 rows)
! 
! DROP ROLE regression_bob;
! DROP EVENT TRIGGER regress_event_trigger_drop_objects;
! DROP EVENT TRIGGER undroppable;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/portals_p2.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/portals_p2.out	2015-01-10 10:11:46.995649471 +0300
***************
*** 1,122 ****
! --
! -- PORTALS_P2
! --
! BEGIN;
! DECLARE foo13 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 50;
! DECLARE foo14 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 51;
! DECLARE foo15 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 52;
! DECLARE foo16 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 53;
! DECLARE foo17 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 54;
! DECLARE foo18 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 55;
! DECLARE foo19 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 56;
! DECLARE foo20 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 57;
! DECLARE foo21 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 58;
! DECLARE foo22 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 59;
! DECLARE foo23 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 60;
! DECLARE foo24 CURSOR FOR
!    SELECT * FROM onek2 WHERE unique1 = 50;
! DECLARE foo25 CURSOR FOR
!    SELECT * FROM onek2 WHERE unique1 = 60;
! FETCH all in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       50 |     253 |   0 |    2 |   0 |     10 |       0 |       50 |          50 |        50 |       50 |   0 |    1 | YBAAAA   | TJAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       51 |      76 |   1 |    3 |   1 |     11 |       1 |       51 |          51 |        51 |       51 |   2 |    3 | ZBAAAA   | YCAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       52 |     985 |   0 |    0 |   2 |     12 |       2 |       52 |          52 |        52 |       52 |   4 |    5 | ACAAAA   | XLBAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       53 |     196 |   1 |    1 |   3 |     13 |       3 |       53 |          53 |        53 |       53 |   6 |    7 | BCAAAA   | OHAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       54 |     356 |   0 |    2 |   4 |     14 |       4 |       54 |          54 |        54 |       54 |   8 |    9 | CCAAAA   | SNAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       55 |     627 |   1 |    3 |   5 |     15 |       5 |       55 |          55 |        55 |       55 |  10 |   11 | DCAAAA   | DYAAAA   | VVVVxx
! (1 row)
! 
! FETCH all in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       56 |      54 |   0 |    0 |   6 |     16 |       6 |       56 |          56 |        56 |       56 |  12 |   13 | ECAAAA   | CCAAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       57 |     942 |   1 |    1 |   7 |     17 |       7 |       57 |          57 |        57 |       57 |  14 |   15 | FCAAAA   | GKBAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       58 |     114 |   0 |    2 |   8 |     18 |       8 |       58 |          58 |        58 |       58 |  16 |   17 | GCAAAA   | KEAAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       59 |     593 |   1 |    3 |   9 |     19 |       9 |       59 |          59 |        59 |       59 |  18 |   19 | HCAAAA   | VWAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       60 |     483 |   0 |    0 |   0 |      0 |       0 |       60 |          60 |        60 |       60 |   0 |    1 | ICAAAA   | PSAAAA   | VVVVxx
! (1 row)
! 
! FETCH all in foo24;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       50 |     253 |   0 |    2 |   0 |     10 |       0 |       50 |          50 |        50 |       50 |   0 |    1 | YBAAAA   | TJAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       60 |     483 |   0 |    0 |   0 |      0 |       0 |       60 |          60 |        60 |       60 |   0 |    1 | ICAAAA   | PSAAAA   | VVVVxx
! (1 row)
! 
! CLOSE foo13;
! CLOSE foo14;
! CLOSE foo15;
! CLOSE foo16;
! CLOSE foo17;
! CLOSE foo18;
! CLOSE foo19;
! CLOSE foo20;
! CLOSE foo21;
! CLOSE foo22;
! CLOSE foo23;
! CLOSE foo24;
! CLOSE foo25;
! END;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/foreign_key.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/foreign_key.out	2015-01-10 10:11:47.027649472 +0300
***************
*** 1,1356 ****
! --
! -- FOREIGN KEY
! --
! -- MATCH FULL
! --
! -- First test, check and cascade
! --
! CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
! CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 'Test1');
! INSERT INTO PKTABLE VALUES (2, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2);
! INSERT INTO FKTABLE VALUES (2, 3);
! INSERT INTO FKTABLE VALUES (3, 4);
! INSERT INTO FKTABLE VALUES (NULL, 1);
! -- Insert a failed row into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1;
! -- Check FKTABLE for removal of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       2 |      3
!       3 |      4
!         |      1
! (3 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       3 |      4
!         |      1
!       1 |      3
! (3 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! --
! -- check set NULL and table constraint on multiple columns
! --
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)
!                        REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
! -- Test comments
! COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
! ERROR:  constraint "constrname_wrong" for table "fktable" does not exist
! COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
! COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
! INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
! INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2, 4);
! INSERT INTO FKTABLE VALUES (1, 3, 5);
! INSERT INTO FKTABLE VALUES (2, 4, 8);
! INSERT INTO FKTABLE VALUES (3, 6, 12);
! INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
! -- Insert failed rows into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
! -- Check FKTABLE for removal of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
! -- Delete another row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
! -- Check FKTABLE (should be no change)
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
! -- Try altering the column type where foreign keys are involved
! ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
! ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 | ptest3  
! --------+--------+---------
!       1 |      3 | Test1-2
!       3 |      6 | Test3
!       4 |      8 | Test4
!       1 |      4 | Test2
! (4 rows)
! 
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
! DROP TABLE PKTABLE CASCADE;
! NOTICE:  drop cascades to constraint constrname on table fktable
! DROP TABLE FKTABLE;
! --
! -- check set default and table constraint on multiple columns
! --
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)
!                        REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
! -- Insert a value in PKTABLE for default
! INSERT INTO PKTABLE VALUES (-1, -2, 'The Default!');
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
! INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
! INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2, 4);
! INSERT INTO FKTABLE VALUES (1, 3, 5);
! INSERT INTO FKTABLE VALUES (2, 4, 8);
! INSERT INTO FKTABLE VALUES (3, 6, 12);
! INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
! -- Insert failed rows into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
! -- Check FKTABLE to check for removal
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
! (5 rows)
! 
! -- Delete another row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
! -- Check FKTABLE (should be no change)
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
! (5 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
!      -1 |     -2 |      8
! (5 rows)
! 
! -- this should fail for lack of CASCADE
! DROP TABLE PKTABLE;
! ERROR:  cannot drop table pktable because other objects depend on it
! DETAIL:  constraint constrname2 on table fktable depends on table pktable
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TABLE PKTABLE CASCADE;
! NOTICE:  drop cascades to constraint constrname2 on table fktable
! DROP TABLE FKTABLE;
! --
! -- First test, check with no on delete or on update
! --
! CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
! CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL, ftest2 int );
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 'Test1');
! INSERT INTO PKTABLE VALUES (2, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2);
! INSERT INTO FKTABLE VALUES (2, 3);
! INSERT INTO FKTABLE VALUES (3, 4);
! INSERT INTO FKTABLE VALUES (NULL, 1);
! -- Insert a failed row into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
! -- Check PKTABLE
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       4 | Test4
!       5 | Test5
! (5 rows)
! 
! -- Delete a row from PK TABLE (should fail)
! DELETE FROM PKTABLE WHERE ptest1=1;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (ptest1)=(1) is still referenced from table "fktable".
! -- Delete a row from PK TABLE (should succeed)
! DELETE FROM PKTABLE WHERE ptest1=5;
! -- Check PKTABLE for deletes
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       4 | Test4
! (4 rows)
! 
! -- Update a row from PK TABLE (should fail)
! UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (ptest1)=(2) is still referenced from table "fktable".
! -- Update a row from PK TABLE (should succeed)
! UPDATE PKTABLE SET ptest1=0 WHERE ptest1=4;
! -- Check PKTABLE for updates
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       0 | Test4
! (4 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- MATCH SIMPLE
! -- Base test restricting update/delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! -- Try to update something that should fail
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
! DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
! -- Try to update something that should succeed
! UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
! -- Try to delete something that should fail
! DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
! DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
! -- Try to delete something that should work
! DELETE FROM PKTABLE where ptest1=2;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       1 |      2 |      3 | test1
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- cascade update/delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE CASCADE ON UPDATE CASCADE);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! -- Try to update something that will cascade
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! -- Try to update something that should not cascade
! UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       1 |      5 |      3 |      1
! (5 rows)
! 
! -- Try to delete something that should cascade
! DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
! -- Try to delete something that should not have a cascade
! DELETE FROM PKTABLE where ptest1=2;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (2 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- set null update / set default delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE SET DEFAULT ON UPDATE SET NULL);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (6 rows)
! 
! -- Try to update something that will set null
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! -- Try to update something that should not set null
! UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      3 |      4 | test3
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      2 |      3 | test2
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (6 rows)
! 
! -- Try to delete something that should set default
! DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      2 |      3 | test2
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
!       0 |        |        |      1
! (6 rows)
! 
! -- Try to delete something that should not set default
! DELETE FROM PKTABLE where ptest2=5;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      2 |      3 | test2
! (2 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
!       0 |        |        |      1
! (6 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- set default update / set null delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE SET NULL ON UPDATE SET DEFAULT);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! INSERT INTO PKTABLE VALUES (2, -1, 5, 'test5');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
! INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!       2 |      4 |      5 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (7 rows)
! 
! -- Try to update something that will fail
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(0, -1, -2) is not present in table "pktable".
! -- Try to update something that will set default
! UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
! UPDATE PKTABLE set ptest2=10 where ptest2=4;
! -- Try to update something that should not set default
! UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      3 |      4 | test3
!       2 |     -1 |      5 | test5
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (5 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
! (7 rows)
! 
! -- Try to delete something that should set null
! DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |     -1 |      5 | test5
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!         |        |        |      1
! (7 rows)
! 
! -- Try to delete something that should not set null
! DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!         |        |        |      1
! (7 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
! CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
! ERROR:  column "ftest2" referenced in foreign key constraint does not exist
! CREATE TABLE FKTABLE_FAIL2 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest1) REFERENCES PKTABLE(ptest2));
! ERROR:  column "ptest2" referenced in foreign key constraint does not exist
! DROP TABLE FKTABLE_FAIL1;
! ERROR:  table "fktable_fail1" does not exist
! DROP TABLE FKTABLE_FAIL2;
! ERROR:  table "fktable_fail2" does not exist
! DROP TABLE PKTABLE;
! -- Test for referencing column number smaller than referenced constraint
! CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
! CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
! ERROR:  there is no unique constraint matching given keys for referenced table "pktable"
! DROP TABLE FKTABLE_FAIL1;
! ERROR:  table "fktable_fail1" does not exist
! DROP TABLE PKTABLE;
! --
! -- Tests for mismatched types
! --
! -- Basic one column, two table setup
! CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! -- This next should fail, because int=inet does not exist
! CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! -- This should also fail for the same reason, but here we
! -- give the column name
! CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! -- This should succeed, even though they are different types,
! -- because int=int8 exists and is a member of the integer opfamily
! CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable);
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
! UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! -- This should fail, because we'd have to cast numeric to int which is
! -- not an implicit coercion (or use numeric=numeric, but that's not part
! -- of the integer opfamily)
! CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
! DROP TABLE PKTABLE;
! -- On the other hand, this should work because int implicitly promotes to
! -- numeric, and we allow promotion on the FK side
! CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! CREATE TABLE FKTABLE (ftest1 int REFERENCES pktable);
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
! UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- Two columns, two tables
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2));
! -- This should fail, because we just chose really odd types
! CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! -- Again, so should this...
! CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! -- This fails because we mixed up the column ordering
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
! -- As does this...
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
! -- And again..
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
! -- This works...
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1));
! DROP TABLE FKTABLE;
! -- As does this
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- Two columns, same table
! -- Make sure this still works...
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable(ptest1, ptest2));
! DROP TABLE PKTABLE;
! -- And this,
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable);
! DROP TABLE PKTABLE;
! -- This shouldn't (mixed up columns)
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable(ptest2, ptest1));
! ERROR:  foreign key constraint "pktable_ptest3_fkey" cannot be implemented
! DETAIL:  Key columns "ptest3" and "ptest2" are of incompatible types: integer and inet.
! -- Nor should this... (same reason, we have 4,3 referencing 1,2 which mismatches types
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
! ptest3) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
! -- Not this one either... Same as the last one except we didn't defined the columns being referenced.
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
! ptest3) REFERENCES pktable);
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
! --
! -- Now some cases with inheritance
! -- Basic 2 table case: 1 column of matching types.
! create table pktable_base (base1 int not null);
! create table pktable (ptest1 int, primary key(base1), unique(base1, ptest1)) inherits (pktable_base);
! create table fktable (ftest1 int references pktable(base1));
! -- now some ins, upd, del
! insert into pktable(base1) values (1);
! insert into pktable(base1) values (2);
! --  let's insert a non-existent fktable value
! insert into fktable(ftest1) values (3);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(3) is not present in table "pktable".
! --  let's make a valid row for that
! insert into pktable(base1) values (3);
! insert into fktable(ftest1) values (3);
! -- let's try removing a row that should fail from pktable
! delete from pktable where base1>2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
! -- okay, let's try updating all of the base1 values to *4
! -- which should fail.
! update pktable set base1=base1*4;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
! -- okay, let's try an update that should work.
! update pktable set base1=base1*4 where base1<3;
! -- and a delete that should work
! delete from pktable where base1>3;
! -- cleanup
! drop table fktable;
! delete from pktable;
! -- Now 2 columns 2 tables, matching types
! create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
! -- now some ins, upd, del
! insert into pktable(base1, ptest1) values (1, 1);
! insert into pktable(base1, ptest1) values (2, 2);
! --  let's insert a non-existent fktable value
! insert into fktable(ftest1, ftest2) values (3, 1);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1, ftest2)=(3, 1) is not present in table "pktable".
! --  let's make a valid row for that
! insert into pktable(base1,ptest1) values (3, 1);
! insert into fktable(ftest1, ftest2) values (3, 1);
! -- let's try removing a row that should fail from pktable
! delete from pktable where base1>2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
! -- okay, let's try updating all of the base1 values to *4
! -- which should fail.
! update pktable set base1=base1*4;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
! -- okay, let's try an update that should work.
! update pktable set base1=base1*4 where base1<3;
! -- and a delete that should work
! delete from pktable where base1>3;
! -- cleanup
! drop table fktable;
! drop table pktable;
! drop table pktable_base;
! -- Now we'll do one all in 1 table with 2 columns of matching types
! create table pktable_base(base1 int not null, base2 int);
! create table pktable(ptest1 int, ptest2 int, primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);
! -- fails (3,2) isn't in base1, ptest1
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
! ERROR:  insert or update on table "pktable" violates foreign key constraint "pktable_base2_fkey"
! DETAIL:  Key (base2, ptest2)=(3, 2) is not present in table "pktable".
! -- fails (2,2) is being referenced
! delete from pktable where base1=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(2, 2) is still referenced from table "pktable".
! -- fails (1,1) is being referenced (twice)
! update pktable set base1=3 where base1=1;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(1, 1) is still referenced from table "pktable".
! -- this sequence of two deletes will work, since after the first there will be no (2,*) references
! delete from pktable where base2=2;
! delete from pktable where base1=2;
! drop table pktable;
! drop table pktable_base;
! -- 2 columns (2 tables), mismatched types
! create table pktable_base(base1 int not null);
! create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
! -- just generally bad types (with and without column references on the referenced table)
! create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
! create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
! -- let's mix up which columns reference which
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable);
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1));
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: integer and inet.
! drop table pktable;
! drop table pktable_base;
! -- 2 columns (1 table), mismatched types
! create table pktable_base(base1 int not null, base2 int);
! create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_base2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "ptest1" are of incompatible types: inet[] and inet.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(ptest1, base1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_base2_fkey" cannot be implemented
! DETAIL:  Key columns "base2" and "ptest1" are of incompatible types: integer and inet.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_ptest2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_ptest2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
! drop table pktable;
! ERROR:  table "pktable" does not exist
! drop table pktable_base;
! --
! -- Deferrable constraints
! --		(right now, only FOREIGN KEY constraints can be deferred)
! --
! -- deferrable, explicitly deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE
! );
! -- default to immediate: should fail
! INSERT INTO fktable VALUES (5, 10);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(10) is not present in table "pktable".
! -- explicitly defer the constraint
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! INSERT INTO fktable VALUES (10, 15);
! INSERT INTO pktable VALUES (15, 0); -- make the FK insert valid
! COMMIT;
! DROP TABLE fktable, pktable;
! -- deferrable, initially deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
! );
! -- default to deferred, should succeed
! BEGIN;
! INSERT INTO fktable VALUES (100, 200);
! INSERT INTO pktable VALUES (200, 500); -- make the FK insert valid
! COMMIT;
! -- default to deferred, explicitly make immediate
! BEGIN;
! SET CONSTRAINTS ALL IMMEDIATE;
! -- should fail
! INSERT INTO fktable VALUES (500, 1000);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(1000) is not present in table "pktable".
! COMMIT;
! DROP TABLE fktable, pktable;
! -- tricky behavior: according to SQL99, if a deferred constraint is set
! -- to 'immediate' mode, it should be checked for validity *immediately*,
! -- not when the current transaction commits (i.e. the mode change applies
! -- retroactively)
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE
! );
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! -- should succeed, for now
! INSERT INTO fktable VALUES (1000, 2000);
! -- should cause transaction abort, due to preceding error
! SET CONSTRAINTS ALL IMMEDIATE;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(2000) is not present in table "pktable".
! INSERT INTO pktable VALUES (2000, 3); -- too late
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! COMMIT;
! DROP TABLE fktable, pktable;
! -- deferrable, initially deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
! );
! BEGIN;
! -- no error here
! INSERT INTO fktable VALUES (100, 200);
! -- error here on commit
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(200) is not present in table "pktable".
! DROP TABLE pktable, fktable;
! -- test notice about expensive referential integrity checks,
! -- where the index cannot be used because of type incompatibilities.
! CREATE TEMP TABLE pktable (
!         id1     INT4 PRIMARY KEY,
!         id2     VARCHAR(4) UNIQUE,
!         id3     REAL UNIQUE,
!         UNIQUE(id1, id2, id3)
! );
! CREATE TEMP TABLE fktable (
!         x1      INT4 REFERENCES pktable(id1),
!         x2      VARCHAR(4) REFERENCES pktable(id2),
!         x3      REAL REFERENCES pktable(id3),
!         x4      TEXT,
!         x5      INT2
! );
! -- check individual constraints with alter table.
! -- should fail
! -- varchar does not promote to real
! ALTER TABLE fktable ADD CONSTRAINT fk_2_3
! FOREIGN KEY (x2) REFERENCES pktable(id3);
! ERROR:  foreign key constraint "fk_2_3" cannot be implemented
! DETAIL:  Key columns "x2" and "id3" are of incompatible types: character varying and real.
! -- nor to int4
! ALTER TABLE fktable ADD CONSTRAINT fk_2_1
! FOREIGN KEY (x2) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_2_1" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
! -- real does not promote to int4
! ALTER TABLE fktable ADD CONSTRAINT fk_3_1
! FOREIGN KEY (x3) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_3_1" cannot be implemented
! DETAIL:  Key columns "x3" and "id1" are of incompatible types: real and integer.
! -- int4 does not promote to text
! ALTER TABLE fktable ADD CONSTRAINT fk_1_2
! FOREIGN KEY (x1) REFERENCES pktable(id2);
! ERROR:  foreign key constraint "fk_1_2" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
! -- should succeed
! -- int4 promotes to real
! ALTER TABLE fktable ADD CONSTRAINT fk_1_3
! FOREIGN KEY (x1) REFERENCES pktable(id3);
! -- text is compatible with varchar
! ALTER TABLE fktable ADD CONSTRAINT fk_4_2
! FOREIGN KEY (x4) REFERENCES pktable(id2);
! -- int2 is part of integer opfamily as of 8.0
! ALTER TABLE fktable ADD CONSTRAINT fk_5_1
! FOREIGN KEY (x5) REFERENCES pktable(id1);
! -- check multikey cases, especially out-of-order column lists
! -- these should work
! ALTER TABLE fktable ADD CONSTRAINT fk_123_123
! FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
! ALTER TABLE fktable ADD CONSTRAINT fk_213_213
! FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
! ALTER TABLE fktable ADD CONSTRAINT fk_253_213
! FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
! -- these should fail
! ALTER TABLE fktable ADD CONSTRAINT fk_123_231
! FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
! ERROR:  foreign key constraint "fk_123_231" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
! ALTER TABLE fktable ADD CONSTRAINT fk_241_132
! FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
! ERROR:  foreign key constraint "fk_241_132" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
! DROP TABLE pktable, fktable;
! -- test a tricky case: we can elide firing the FK check trigger during
! -- an UPDATE if the UPDATE did not change the foreign key
! -- field. However, we can't do this if our transaction was the one that
! -- created the updated row and the trigger is deferred, since our UPDATE
! -- will have invalidated the original newly-inserted tuple, and therefore
! -- cause the on-INSERT RI trigger not to be fired.
! CREATE TEMP TABLE pktable (
!     id int primary key,
!     other int
! );
! CREATE TEMP TABLE fktable (
!     id int primary key,
!     fk int references pktable deferrable initially deferred
! );
! -- check ALTER CONSTRAINT
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
! -- illegal option
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
! ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE
! LINE 1: ...e ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY ...
!                                                              ^
! -- reset
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY DEFERRED;
! INSERT INTO pktable VALUES (5, 10);
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! -- change the constraint definition and retest
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
! BEGIN;
! -- doesn't match PK, should throw error now
! INSERT INTO fktable VALUES (0, 20);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! COMMIT;
! -- reset
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY DEFERRED;
! -- check same case when insert is in a different subtransaction than update
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- UPDATE will be in a subxact
! SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! BEGIN;
! -- INSERT will be in a subxact
! SAVEPOINT savept1;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! RELEASE SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- UPDATE will be in a subxact
! SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- Roll back the UPDATE
! ROLLBACK TO savept1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! -- test order of firing of FK triggers when several RI-induced changes need to
! -- be made to the same row.  This was broken by subtransaction-related
! -- changes in 8.0.
! CREATE TEMP TABLE users (
!   id INT PRIMARY KEY,
!   name VARCHAR NOT NULL
! );
! INSERT INTO users VALUES (1, 'Jozko');
! INSERT INTO users VALUES (2, 'Ferko');
! INSERT INTO users VALUES (3, 'Samko');
! CREATE TEMP TABLE tasks (
!   id INT PRIMARY KEY,
!   owner INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
!   worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
!   checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL
! );
! INSERT INTO tasks VALUES (1,1,NULL,NULL);
! INSERT INTO tasks VALUES (2,2,2,NULL);
! INSERT INTO tasks VALUES (3,3,3,3);
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     3 |      3 |          3
! (3 rows)
! 
! UPDATE users SET id = 4 WHERE id = 3;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     4 |      4 |          4
! (3 rows)
! 
! DELETE FROM users WHERE id = 4;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |       |        |           
! (3 rows)
! 
! -- could fail with only 2 changes to make, if row was already updated
! BEGIN;
! UPDATE tasks set id=id WHERE id=2;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   3 |       |        |           
!   2 |     2 |      2 |           
! (3 rows)
! 
! DELETE FROM users WHERE id = 2;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   3 |       |        |           
!   2 |       |        |           
! (3 rows)
! 
! COMMIT;
! --
! -- Test self-referential FK with CASCADE (bug #6268)
! --
! create temp table selfref (
!     a int primary key,
!     b int,
!     foreign key (b) references selfref (a)
!         on update cascade on delete cascade
! );
! insert into selfref (a, b)
! values
!     (0, 0),
!     (1, 1);
! begin;
!     update selfref set a = 123 where a = 0;
!     select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  123 | 123
! (2 rows)
! 
!     update selfref set a = 456 where a = 123;
!     select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  456 | 456
! (2 rows)
! 
! commit;
! --
! -- Test that SET DEFAULT actions recognize updates to default values
! --
! create temp table defp (f1 int primary key);
! create temp table defc (f1 int default 0
!                         references defp on delete set default);
! insert into defp values (0), (1), (2);
! insert into defc values (2);
! select * from defc;
!  f1 
! ----
!   2
! (1 row)
! 
! delete from defp where f1 = 2;
! select * from defc;
!  f1 
! ----
!   0
! (1 row)
! 
! delete from defp where f1 = 0; -- fail
! ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
! DETAIL:  Key (f1)=(0) is still referenced from table "defc".
! alter table defc alter column f1 set default 1;
! delete from defp where f1 = 0;
! select * from defc;
!  f1 
! ----
!   1
! (1 row)
! 
! delete from defp where f1 = 1; -- fail
! ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
! DETAIL:  Key (f1)=(1) is still referenced from table "defc".
! --
! -- Test the difference between NO ACTION and RESTRICT
! --
! create temp table pp (f1 int primary key);
! create temp table cc (f1 int references pp on update no action);
! insert into pp values(12);
! insert into pp values(11);
! update pp set f1=f1+1;
! insert into cc values(13);
! update pp set f1=f1+1;
! update pp set f1=f1+1; -- fail
! ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
! DETAIL:  Key (f1)=(13) is still referenced from table "cc".
! drop table pp, cc;
! create temp table pp (f1 int primary key);
! create temp table cc (f1 int references pp on update restrict);
! insert into pp values(12);
! insert into pp values(11);
! update pp set f1=f1+1;
! insert into cc values(13);
! update pp set f1=f1+1; -- fail
! ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
! DETAIL:  Key (f1)=(13) is still referenced from table "cc".
! drop table pp, cc;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/cluster.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/cluster.out	2015-01-10 10:11:47.023649472 +0300
***************
*** 1,447 ****
! --
! --  CLUSTER
! --
! CREATE TABLE clstr_tst_s (rf_a SERIAL PRIMARY KEY,
! 	b INT);
! CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,
! 	b INT,
! 	c TEXT,
! 	d TEXT,
! 	CONSTRAINT clstr_tst_con FOREIGN KEY (b) REFERENCES clstr_tst_s);
! CREATE INDEX clstr_tst_b ON clstr_tst (b);
! CREATE INDEX clstr_tst_c ON clstr_tst (c);
! CREATE INDEX clstr_tst_c_b ON clstr_tst (c,b);
! CREATE INDEX clstr_tst_b_c ON clstr_tst (b,c);
! INSERT INTO clstr_tst_s (b) VALUES (0);
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! CREATE TABLE clstr_tst_inh () INHERITS (clstr_tst);
! INSERT INTO clstr_tst (b, c) VALUES (11, 'once');
! INSERT INTO clstr_tst (b, c) VALUES (10, 'diez');
! INSERT INTO clstr_tst (b, c) VALUES (31, 'treinta y uno');
! INSERT INTO clstr_tst (b, c) VALUES (22, 'veintidos');
! INSERT INTO clstr_tst (b, c) VALUES (3, 'tres');
! INSERT INTO clstr_tst (b, c) VALUES (20, 'veinte');
! INSERT INTO clstr_tst (b, c) VALUES (23, 'veintitres');
! INSERT INTO clstr_tst (b, c) VALUES (21, 'veintiuno');
! INSERT INTO clstr_tst (b, c) VALUES (4, 'cuatro');
! INSERT INTO clstr_tst (b, c) VALUES (14, 'catorce');
! INSERT INTO clstr_tst (b, c) VALUES (2, 'dos');
! INSERT INTO clstr_tst (b, c) VALUES (18, 'dieciocho');
! INSERT INTO clstr_tst (b, c) VALUES (27, 'veintisiete');
! INSERT INTO clstr_tst (b, c) VALUES (25, 'veinticinco');
! INSERT INTO clstr_tst (b, c) VALUES (13, 'trece');
! INSERT INTO clstr_tst (b, c) VALUES (28, 'veintiocho');
! INSERT INTO clstr_tst (b, c) VALUES (32, 'treinta y dos');
! INSERT INTO clstr_tst (b, c) VALUES (5, 'cinco');
! INSERT INTO clstr_tst (b, c) VALUES (29, 'veintinueve');
! INSERT INTO clstr_tst (b, c) VALUES (1, 'uno');
! INSERT INTO clstr_tst (b, c) VALUES (24, 'veinticuatro');
! INSERT INTO clstr_tst (b, c) VALUES (30, 'treinta');
! INSERT INTO clstr_tst (b, c) VALUES (12, 'doce');
! INSERT INTO clstr_tst (b, c) VALUES (17, 'diecisiete');
! INSERT INTO clstr_tst (b, c) VALUES (9, 'nueve');
! INSERT INTO clstr_tst (b, c) VALUES (19, 'diecinueve');
! INSERT INTO clstr_tst (b, c) VALUES (26, 'veintiseis');
! INSERT INTO clstr_tst (b, c) VALUES (15, 'quince');
! INSERT INTO clstr_tst (b, c) VALUES (7, 'siete');
! INSERT INTO clstr_tst (b, c) VALUES (16, 'dieciseis');
! INSERT INTO clstr_tst (b, c) VALUES (8, 'ocho');
! -- This entry is needed to test that TOASTED values are copied correctly.
! INSERT INTO clstr_tst (b, c, d) VALUES (6, 'seis', repeat('xyzzy', 100000));
! CLUSTER clstr_tst_c ON clstr_tst;
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  10 | 14 | catorce       |                                |       
!  18 |  5 | cinco         |                                |       
!   9 |  4 | cuatro        |                                |       
!  26 | 19 | diecinueve    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!   2 | 10 | diez          |                                |       
!  23 | 12 | doce          |                                |       
!  11 |  2 | dos           |                                |       
!  25 |  9 | nueve         |                                |       
!  31 |  8 | ocho          |                                |       
!   1 | 11 | once          |                                |       
!  28 | 15 | quince        |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  15 | 13 | trece         |                                |       
!  22 | 30 | treinta       |                                |       
!  17 | 32 | treinta y dos |                                |       
!   3 | 31 | treinta y uno |                                |       
!   5 |  3 | tres          |                                |       
!  20 |  1 | uno           |                                |       
!   6 | 20 | veinte        |                                |       
!  14 | 25 | veinticinco   |                                |       
!  21 | 24 | veinticuatro  |                                |       
!   4 | 22 | veintidos     |                                |       
!  19 | 29 | veintinueve   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!   1 | 11 | once          |                                |       
!   2 | 10 | diez          |                                |       
!   3 | 31 | treinta y uno |                                |       
!   4 | 22 | veintidos     |                                |       
!   5 |  3 | tres          |                                |       
!   6 | 20 | veinte        |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
!   9 |  4 | cuatro        |                                |       
!  10 | 14 | catorce       |                                |       
!  11 |  2 | dos           |                                |       
!  12 | 18 | dieciocho     |                                |       
!  13 | 27 | veintisiete   |                                |       
!  14 | 25 | veinticinco   |                                |       
!  15 | 13 | trece         |                                |       
!  16 | 28 | veintiocho    |                                |       
!  17 | 32 | treinta y dos |                                |       
!  18 |  5 | cinco         |                                |       
!  19 | 29 | veintinueve   |                                |       
!  20 |  1 | uno           |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  22 | 30 | treinta       |                                |       
!  23 | 12 | doce          |                                |       
!  24 | 17 | diecisiete    |                                |       
!  25 |  9 | nueve         |                                |       
!  26 | 19 | diecinueve    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  28 | 15 | quince        |                                |       
!  29 |  7 | siete         |                                |       
!  30 | 16 | dieciseis     |                                |       
!  31 |  8 | ocho          |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY b;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  20 |  1 | uno           |                                |       
!  11 |  2 | dos           |                                |       
!   5 |  3 | tres          |                                |       
!   9 |  4 | cuatro        |                                |       
!  18 |  5 | cinco         |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  31 |  8 | ocho          |                                |       
!  25 |  9 | nueve         |                                |       
!   2 | 10 | diez          |                                |       
!   1 | 11 | once          |                                |       
!  23 | 12 | doce          |                                |       
!  15 | 13 | trece         |                                |       
!  10 | 14 | catorce       |                                |       
!  28 | 15 | quince        |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  26 | 19 | diecinueve    |                                |       
!   6 | 20 | veinte        |                                |       
!   8 | 21 | veintiuno     |                                |       
!   4 | 22 | veintidos     |                                |       
!   7 | 23 | veintitres    |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  14 | 25 | veinticinco   |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  19 | 29 | veintinueve   |                                |       
!  22 | 30 | treinta       |                                |       
!   3 | 31 | treinta y uno |                                |       
!  17 | 32 | treinta y dos |                                |       
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY c;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  10 | 14 | catorce       |                                |       
!  18 |  5 | cinco         |                                |       
!   9 |  4 | cuatro        |                                |       
!  26 | 19 | diecinueve    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!   2 | 10 | diez          |                                |       
!  23 | 12 | doce          |                                |       
!  11 |  2 | dos           |                                |       
!  25 |  9 | nueve         |                                |       
!  31 |  8 | ocho          |                                |       
!   1 | 11 | once          |                                |       
!  28 | 15 | quince        |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  15 | 13 | trece         |                                |       
!  22 | 30 | treinta       |                                |       
!  17 | 32 | treinta y dos |                                |       
!   3 | 31 | treinta y uno |                                |       
!   5 |  3 | tres          |                                |       
!  20 |  1 | uno           |                                |       
!   6 | 20 | veinte        |                                |       
!  14 | 25 | veinticinco   |                                |       
!  21 | 24 | veinticuatro  |                                |       
!   4 | 22 | veintidos     |                                |       
!  19 | 29 | veintinueve   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
! (32 rows)
! 
! -- Verify that inheritance link still works
! INSERT INTO clstr_tst_inh VALUES (0, 100, 'in child table');
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
!  a  |  b  |       c        |           substring            | length 
! ----+-----+----------------+--------------------------------+--------
!  10 |  14 | catorce        |                                |       
!  18 |   5 | cinco          |                                |       
!   9 |   4 | cuatro         |                                |       
!  26 |  19 | diecinueve     |                                |       
!  12 |  18 | dieciocho      |                                |       
!  30 |  16 | dieciseis      |                                |       
!  24 |  17 | diecisiete     |                                |       
!   2 |  10 | diez           |                                |       
!  23 |  12 | doce           |                                |       
!  11 |   2 | dos            |                                |       
!  25 |   9 | nueve          |                                |       
!  31 |   8 | ocho           |                                |       
!   1 |  11 | once           |                                |       
!  28 |  15 | quince         |                                |       
!  32 |   6 | seis           | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |   7 | siete          |                                |       
!  15 |  13 | trece          |                                |       
!  22 |  30 | treinta        |                                |       
!  17 |  32 | treinta y dos  |                                |       
!   3 |  31 | treinta y uno  |                                |       
!   5 |   3 | tres           |                                |       
!  20 |   1 | uno            |                                |       
!   6 |  20 | veinte         |                                |       
!  14 |  25 | veinticinco    |                                |       
!  21 |  24 | veinticuatro   |                                |       
!   4 |  22 | veintidos      |                                |       
!  19 |  29 | veintinueve    |                                |       
!  16 |  28 | veintiocho     |                                |       
!  27 |  26 | veintiseis     |                                |       
!  13 |  27 | veintisiete    |                                |       
!   7 |  23 | veintitres     |                                |       
!   8 |  21 | veintiuno      |                                |       
!   0 | 100 | in child table |                                |       
! (33 rows)
! 
! -- Verify that foreign key link still works
! INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail');
! ERROR:  insert or update on table "clstr_tst" violates foreign key constraint "clstr_tst_con"
! DETAIL:  Key (b)=(1111) is not present in table "clstr_tst_s".
! SELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst'::regclass
! ORDER BY 1;
!     conname     
! ----------------
!  clstr_tst_con
!  clstr_tst_pkey
! (2 rows)
! 
! SELECT relname, relkind,
!     EXISTS(SELECT 1 FROM pg_class WHERE oid = c.reltoastrelid) AS hastoast
! FROM pg_class c WHERE relname LIKE 'clstr_tst%' ORDER BY relname;
!        relname        | relkind | hastoast 
! ----------------------+---------+----------
!  clstr_tst            | r       | t
!  clstr_tst_a_seq      | S       | f
!  clstr_tst_b          | i       | f
!  clstr_tst_b_c        | i       | f
!  clstr_tst_c          | i       | f
!  clstr_tst_c_b        | i       | f
!  clstr_tst_inh        | r       | t
!  clstr_tst_pkey       | i       | f
!  clstr_tst_s          | r       | f
!  clstr_tst_s_pkey     | i       | f
!  clstr_tst_s_rf_a_seq | S       | f
! (11 rows)
! 
! -- Verify that indisclustered is correctly set
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!    relname   
! -------------
!  clstr_tst_c
! (1 row)
! 
! -- Try changing indisclustered
! ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!     relname    
! ---------------
!  clstr_tst_b_c
! (1 row)
! 
! -- Try turning off all clustering
! ALTER TABLE clstr_tst SET WITHOUT CLUSTER;
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!  relname 
! ---------
! (0 rows)
! 
! -- Verify that clustering all tables does in fact cluster the right ones
! CREATE USER clstr_user;
! CREATE TABLE clstr_1 (a INT PRIMARY KEY);
! CREATE TABLE clstr_2 (a INT PRIMARY KEY);
! CREATE TABLE clstr_3 (a INT PRIMARY KEY);
! ALTER TABLE clstr_1 OWNER TO clstr_user;
! ALTER TABLE clstr_3 OWNER TO clstr_user;
! GRANT SELECT ON clstr_2 TO clstr_user;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! INSERT INTO clstr_2 VALUES (2);
! INSERT INTO clstr_2 VALUES (1);
! INSERT INTO clstr_3 VALUES (2);
! INSERT INTO clstr_3 VALUES (1);
! -- "CLUSTER <tablename>" on a table that hasn't been clustered
! CLUSTER clstr_2;
! ERROR:  there is no previously clustered index for table "clstr_2"
! CLUSTER clstr_1_pkey ON clstr_1;
! CLUSTER clstr_2 USING clstr_2_pkey;
! SELECT * FROM clstr_1 UNION ALL
!   SELECT * FROM clstr_2 UNION ALL
!   SELECT * FROM clstr_3;
!  a 
! ---
!  1
!  2
!  1
!  2
!  2
!  1
! (6 rows)
! 
! -- revert to the original state
! DELETE FROM clstr_1;
! DELETE FROM clstr_2;
! DELETE FROM clstr_3;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! INSERT INTO clstr_2 VALUES (2);
! INSERT INTO clstr_2 VALUES (1);
! INSERT INTO clstr_3 VALUES (2);
! INSERT INTO clstr_3 VALUES (1);
! -- this user can only cluster clstr_1 and clstr_3, but the latter
! -- has not been clustered
! SET SESSION AUTHORIZATION clstr_user;
! CLUSTER;
! SELECT * FROM clstr_1 UNION ALL
!   SELECT * FROM clstr_2 UNION ALL
!   SELECT * FROM clstr_3;
!  a 
! ---
!  1
!  2
!  2
!  1
!  2
!  1
! (6 rows)
! 
! -- cluster a single table using the indisclustered bit previously set
! DELETE FROM clstr_1;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! CLUSTER clstr_1;
! SELECT * FROM clstr_1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- Test MVCC-safety of cluster. There isn't much we can do to verify the
! -- results with a single backend...
! CREATE TABLE clustertest (key int PRIMARY KEY);
! INSERT INTO clustertest VALUES (10);
! INSERT INTO clustertest VALUES (20);
! INSERT INTO clustertest VALUES (30);
! INSERT INTO clustertest VALUES (40);
! INSERT INTO clustertest VALUES (50);
! -- Use a transaction so that updates are not committed when CLUSTER sees 'em
! BEGIN;
! -- Test update where the old row version is found first in the scan
! UPDATE clustertest SET key = 100 WHERE key = 10;
! -- Test update where the new row version is found first in the scan
! UPDATE clustertest SET key = 35 WHERE key = 40;
! -- Test longer update chain
! UPDATE clustertest SET key = 60 WHERE key = 50;
! UPDATE clustertest SET key = 70 WHERE key = 60;
! UPDATE clustertest SET key = 80 WHERE key = 70;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!  100
!   35
!   80
! (5 rows)
! 
! CLUSTER clustertest_pkey ON clustertest;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
! COMMIT;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
! -- check that temp tables can be clustered
! create temp table clstr_temp (col1 int primary key, col2 text);
! insert into clstr_temp values (2, 'two'), (1, 'one');
! cluster clstr_temp using clstr_temp_pkey;
! select * from clstr_temp;
!  col1 | col2 
! ------+------
!     1 | one
!     2 | two
! (2 rows)
! 
! drop table clstr_temp;
! -- clean up
! \c -
! DROP TABLE clustertest;
! DROP TABLE clstr_1;
! DROP TABLE clstr_2;
! DROP TABLE clstr_3;
! DROP USER clstr_user;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/dependency.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/dependency.out	2015-01-10 10:11:47.039649472 +0300
***************
*** 1,114 ****
! --
! -- DEPENDENCIES
! --
! CREATE USER regression_user;
! CREATE USER regression_user2;
! CREATE USER regression_user3;
! CREATE GROUP regression_group;
! CREATE TABLE deptest (f1 serial primary key, f2 text);
! GRANT SELECT ON TABLE deptest TO GROUP regression_group;
! GRANT ALL ON TABLE deptest TO regression_user, regression_user2;
! -- can't drop neither because they have privileges somewhere
! DROP USER regression_user;
! ERROR:  role "regression_user" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! DROP GROUP regression_group;
! ERROR:  role "regression_group" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! -- if we revoke the privileges we can drop the group
! REVOKE SELECT ON deptest FROM GROUP regression_group;
! DROP GROUP regression_group;
! -- can't drop the user if we revoke the privileges partially
! REVOKE SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES ON deptest FROM regression_user;
! DROP USER regression_user;
! ERROR:  role "regression_user" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! -- now we are OK to drop him
! REVOKE TRIGGER ON deptest FROM regression_user;
! DROP USER regression_user;
! -- we are OK too if we drop the privileges all at once
! REVOKE ALL ON deptest FROM regression_user2;
! DROP USER regression_user2;
! -- can't drop the owner of an object
! -- the error message detail here would include a pg_toast_nnn name that
! -- is not constant, so suppress it
! \set VERBOSITY terse
! ALTER TABLE deptest OWNER TO regression_user3;
! DROP USER regression_user3;
! ERROR:  role "regression_user3" cannot be dropped because some objects depend on it
! \set VERBOSITY default
! -- if we drop the object, we can drop the user too
! DROP TABLE deptest;
! DROP USER regression_user3;
! -- Test DROP OWNED
! CREATE USER regression_user0;
! CREATE USER regression_user1;
! CREATE USER regression_user2;
! SET SESSION AUTHORIZATION regression_user0;
! -- permission denied
! DROP OWNED BY regression_user1;
! ERROR:  permission denied to drop objects
! DROP OWNED BY regression_user0, regression_user2;
! ERROR:  permission denied to drop objects
! REASSIGN OWNED BY regression_user0 TO regression_user1;
! ERROR:  permission denied to reassign objects
! REASSIGN OWNED BY regression_user1 TO regression_user0;
! ERROR:  permission denied to reassign objects
! -- this one is allowed
! DROP OWNED BY regression_user0;
! CREATE TABLE deptest1 (f1 int unique);
! GRANT ALL ON deptest1 TO regression_user1 WITH GRANT OPTION;
! SET SESSION AUTHORIZATION regression_user1;
! CREATE TABLE deptest (a serial primary key, b text);
! GRANT ALL ON deptest1 TO regression_user2;
! RESET SESSION AUTHORIZATION;
! \z deptest1
!                                               Access privileges
!  Schema |   Name   | Type  |                Access privileges                 | Column privileges | Policies 
! --------+----------+-------+--------------------------------------------------+-------------------+----------
!  public | deptest1 | table | regression_user0=arwdDxt/regression_user0       +|                   | 
!         |          |       | regression_user1=a*r*w*d*D*x*t*/regression_user0+|                   | 
!         |          |       | regression_user2=arwdDxt/regression_user1        |                   | 
! (1 row)
! 
! DROP OWNED BY regression_user1;
! -- all grants revoked
! \z deptest1
!                                           Access privileges
!  Schema |   Name   | Type  |             Access privileges             | Column privileges | Policies 
! --------+----------+-------+-------------------------------------------+-------------------+----------
!  public | deptest1 | table | regression_user0=arwdDxt/regression_user0 |                   | 
! (1 row)
! 
! -- table was dropped
! \d deptest
! -- Test REASSIGN OWNED
! GRANT ALL ON deptest1 TO regression_user1;
! SET SESSION AUTHORIZATION regression_user1;
! CREATE TABLE deptest (a serial primary key, b text);
! CREATE TABLE deptest2 (f1 int);
! -- make a serial column the hard way
! CREATE SEQUENCE ss1;
! ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
! ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
! RESET SESSION AUTHORIZATION;
! REASSIGN OWNED BY regression_user1 TO regression_user2;
! \dt deptest
!               List of relations
!  Schema |  Name   | Type  |      Owner       
! --------+---------+-------+------------------
!  public | deptest | table | regression_user2
! (1 row)
! 
! -- doesn't work: grant still exists
! DROP USER regression_user1;
! ERROR:  role "regression_user1" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest1
! DROP OWNED BY regression_user1;
! DROP USER regression_user1;
! \set VERBOSITY terse
! DROP USER regression_user2;
! ERROR:  role "regression_user2" cannot be dropped because some objects depend on it
! DROP OWNED BY regression_user2, regression_user0;
! DROP USER regression_user2;
! DROP USER regression_user0;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/bitmapops.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/bitmapops.out	2015-01-10 10:11:47.039649472 +0300
***************
*** 1,38 ****
! -- Test bitmap AND and OR
! -- Generate enough data that we can test the lossy bitmaps.
! -- There's 55 tuples per page in the table. 53 is just
! -- below 55, so that an index scan with qual a = constant
! -- will return at least one hit per page. 59 is just above
! -- 55, so that an index scan with qual b = constant will return
! -- hits on most but not all pages. 53 and 59 are prime, so that
! -- there's a maximum number of a,b combinations in the table.
! -- That allows us to test all the different combinations of
! -- lossy and non-lossy pages with the minimum amount of data
! CREATE TABLE bmscantest (a int, b int, t text);
! INSERT INTO bmscantest
!   SELECT (r%53), (r%59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
!   FROM generate_series(1,70000) r;
! CREATE INDEX i_bmtest_a ON bmscantest(a);
! CREATE INDEX i_bmtest_b ON bmscantest(b);
! -- We want to use bitmapscans. With default settings, the planner currently
! -- chooses a bitmap scan for the queries below anyway, but let's make sure.
! set enable_indexscan=false;
! set enable_seqscan=false;
! -- Lower work_mem to trigger use of lossy bitmaps
! set work_mem = 64;
! -- Test bitmap-and.
! SELECT count(*) FROM bmscantest WHERE a = 1 AND b = 1;
!  count 
! -------
!     23
! (1 row)
! 
! -- Test bitmap-or.
! SELECT count(*) FROM bmscantest WHERE a = 1 OR b = 1;
!  count 
! -------
!   2485
! (1 row)
! 
! -- clean up
! DROP TABLE bmscantest;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/combocid.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/combocid.out	2015-01-10 10:11:47.047649473 +0300
***************
*** 1,142 ****
! --
! -- Tests for some likely failure cases with combo cmin/cmax mechanism
! --
! CREATE TEMP TABLE combocidtest (foobar int);
! BEGIN;
! -- a few dummy ops to push up the CommandId counter
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest VALUES (1);
! INSERT INTO combocidtest VALUES (2);
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   10 |      1
!  (0,2) |   11 |      2
! (2 rows)
! 
! SAVEPOINT s1;
! UPDATE combocidtest SET foobar = foobar + 10;
! -- here we should see only updated tuples
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,3) |   12 |     11
!  (0,4) |   12 |     12
! (2 rows)
! 
! ROLLBACK TO s1;
! -- now we should see old tuples, but with combo CIDs starting at 0
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    0 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! COMMIT;
! -- combo data is not there anymore, but should still see tuples
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    0 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! -- Test combo cids with portals
! BEGIN;
! INSERT INTO combocidtest VALUES (333);
! DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
! DELETE FROM combocidtest;
! FETCH ALL FROM c;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,5) |    0 |    333
! (3 rows)
! 
! ROLLBACK;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! -- check behavior with locked tuples
! BEGIN;
! -- a few dummy ops to push up the CommandId counter
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest VALUES (444);
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! SAVEPOINT s1;
! -- this doesn't affect cmin
! SELECT ctid,cmin,* FROM combocidtest FOR UPDATE;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! -- but this does
! UPDATE combocidtest SET foobar = foobar + 10;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,7) |   12 |     11
!  (0,8) |   12 |     12
!  (0,9) |   12 |    454
! (3 rows)
! 
! ROLLBACK TO s1;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   12 |      1
!  (0,2) |   12 |      2
!  (0,6) |    0 |    444
! (3 rows)
! 
! COMMIT;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   12 |      1
!  (0,2) |   12 |      2
!  (0,6) |    0 |    444
! (3 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/tsearch.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/tsearch.out	2015-01-10 10:11:47.035649472 +0300
***************
*** 1,1128 ****
! --
! -- Sanity checks for text search catalogs
! --
! -- NB: we assume the oidjoins test will have caught any dangling links,
! -- that is OID or REGPROC fields that are not zero and do not match some
! -- row in the linked-to table.  However, if we want to enforce that a link
! -- field can't be 0, we have to check it here.
! -- Find unexpected zero link entries
! SELECT oid, prsname
! FROM pg_ts_parser
! WHERE prsnamespace = 0 OR prsstart = 0 OR prstoken = 0 OR prsend = 0 OR
!       -- prsheadline is optional
!       prslextype = 0;
!  oid | prsname 
! -----+---------
! (0 rows)
! 
! SELECT oid, dictname
! FROM pg_ts_dict
! WHERE dictnamespace = 0 OR dictowner = 0 OR dicttemplate = 0;
!  oid | dictname 
! -----+----------
! (0 rows)
! 
! SELECT oid, tmplname
! FROM pg_ts_template
! WHERE tmplnamespace = 0 OR tmpllexize = 0;  -- tmplinit is optional
!  oid | tmplname 
! -----+----------
! (0 rows)
! 
! SELECT oid, cfgname
! FROM pg_ts_config
! WHERE cfgnamespace = 0 OR cfgowner = 0 OR cfgparser = 0;
!  oid | cfgname 
! -----+---------
! (0 rows)
! 
! SELECT mapcfg, maptokentype, mapseqno
! FROM pg_ts_config_map
! WHERE mapcfg = 0 OR mapdict = 0;
!  mapcfg | maptokentype | mapseqno 
! --------+--------------+----------
! (0 rows)
! 
! -- Look for pg_ts_config_map entries that aren't one of parser's token types
! SELECT * FROM
!   ( SELECT oid AS cfgid, (ts_token_type(cfgparser)).tokid AS tokid
!     FROM pg_ts_config ) AS tt
! RIGHT JOIN pg_ts_config_map AS m
!     ON (tt.cfgid=m.mapcfg AND tt.tokid=m.maptokentype)
! WHERE
!     tt.cfgid IS NULL OR tt.tokid IS NULL;
!  cfgid | tokid | mapcfg | maptokentype | mapseqno | mapdict 
! -------+-------+--------+--------------+----------+---------
! (0 rows)
! 
! -- test basic text search behavior without indexes, then with
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! create index wowidx on test_tsvector using gist (a);
! SET enable_seqscan=OFF;
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
!  count 
! -------
!    158
! (1 row)
! 
! RESET enable_seqscan;
! DROP INDEX wowidx;
! CREATE INDEX wowidx ON test_tsvector USING gin (a);
! SET enable_seqscan=OFF;
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
!  count 
! -------
!    158
! (1 row)
! 
! RESET enable_seqscan;
! INSERT INTO test_tsvector VALUES ('???', 'DFG:1A,2B,6C,10 FGH');
! SELECT * FROM ts_stat('SELECT a FROM test_tsvector') ORDER BY ndoc DESC, nentry DESC, word LIMIT 10;
!  word | ndoc | nentry 
! ------+------+--------
!  qq   |  108 |    108
!  qt   |  102 |    102
!  qe   |  100 |    100
!  qh   |   98 |     98
!  qw   |   98 |     98
!  qa   |   97 |     97
!  ql   |   94 |     94
!  qs   |   94 |     94
!  qi   |   92 |     92
!  qr   |   92 |     92
! (10 rows)
! 
! SELECT * FROM ts_stat('SELECT a FROM test_tsvector', 'AB') ORDER BY ndoc DESC, nentry DESC, word;
!  word | ndoc | nentry 
! ------+------+--------
!  DFG  |    1 |      2
! (1 row)
! 
! --dictionaries and to_tsvector
! SELECT ts_lexize('english_stem', 'skies');
!  ts_lexize 
! -----------
!  {sky}
! (1 row)
! 
! SELECT ts_lexize('english_stem', 'identity');
!  ts_lexize 
! -----------
!  {ident}
! (1 row)
! 
! SELECT * FROM ts_token_type('default');
!  tokid |      alias      |               description                
! -------+-----------------+------------------------------------------
!      1 | asciiword       | Word, all ASCII
!      2 | word            | Word, all letters
!      3 | numword         | Word, letters and digits
!      4 | email           | Email address
!      5 | url             | URL
!      6 | host            | Host
!      7 | sfloat          | Scientific notation
!      8 | version         | Version number
!      9 | hword_numpart   | Hyphenated word part, letters and digits
!     10 | hword_part      | Hyphenated word part, all letters
!     11 | hword_asciipart | Hyphenated word part, all ASCII
!     12 | blank           | Space symbols
!     13 | tag             | XML tag
!     14 | protocol        | Protocol head
!     15 | numhword        | Hyphenated word, letters and digits
!     16 | asciihword      | Hyphenated word, all ASCII
!     17 | hword           | Hyphenated word, all letters
!     18 | url_path        | URL path
!     19 | file            | File or path name
!     20 | float           | Decimal notation
!     21 | int             | Signed integer
!     22 | uint            | Unsigned integer
!     23 | entity          | XML entity
! (23 rows)
! 
! SELECT * FROM ts_parse('default', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty');
!  tokid |                token                 
! -------+--------------------------------------
!     22 | 345
!     12 |  
!      1 | qwe
!     12 | @
!     19 | efd.r
!     12 |  ' 
!     14 | http://
!      6 | www.com
!     12 | / 
!     14 | http://
!      5 | aew.werc.ewr/?ad=qwe&dw
!      6 | aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!      5 | 1aew.werc.ewr/?ad=qwe&dw
!      6 | 1aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!      6 | 2aew.werc.ewr
!     12 |  
!     14 | http://
!      5 | 3aew.werc.ewr/?ad=qwe&dw
!      6 | 3aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!     14 | http://
!      6 | 4aew.werc.ewr
!     12 |  
!     14 | http://
!      5 | 5aew.werc.ewr:8100/?
!      6 | 5aew.werc.ewr:8100
!     18 | /?
!     12 |   
!      1 | ad
!     12 | =
!      1 | qwe
!     12 | &
!      1 | dw
!     12 |  
!      5 | 6aew.werc.ewr:8100/?ad=qwe&dw
!      6 | 6aew.werc.ewr:8100
!     18 | /?ad=qwe&dw
!     12 |  
!      5 | 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32
!      6 | 7aew.werc.ewr:8100
!     18 | /?ad=qwe&dw=%20%32
!     12 |  
!      7 | +4.0e-10
!     12 |  
!      1 | qwe
!     12 |  
!      1 | qwe
!     12 |  
!      1 | qwqwe
!     12 |  
!     20 | 234.435
!     12 |  
!     22 | 455
!     12 |  
!     20 | 5.005
!     12 |  
!      4 | teodor@stack.net
!     12 |  
!     16 | qwe-wer
!     11 | qwe
!     12 | -
!     11 | wer
!     12 |  
!      1 | asdf
!     12 |  
!     13 | <fr>
!      1 | qwer
!     12 |  
!      1 | jf
!     12 |  
!      1 | sdjk
!     12 | <
!      1 | we
!     12 |  
!      1 | hjwer
!     12 |  
!     13 | <werrwe>
!     12 |  
!      3 | ewr1
!     12 | > 
!      3 | ewri2
!     12 |  
!     13 | <a href="qwe<qwe>">
!     12 |                                     +
!        | 
!     19 | /usr/local/fff
!     12 |  
!     19 | /awdf/dwqe/4325
!     12 |  
!     19 | rewt/ewr
!     12 |  
!      1 | wefjn
!     12 |  
!     19 | /wqe-324/ewr
!     12 |  
!     19 | gist.h
!     12 |  
!     19 | gist.h.c
!     12 |  
!     19 | gist.c
!     12 | . 
!      1 | readline
!     12 |  
!     20 | 4.2
!     12 |  
!     20 | 4.2
!     12 | . 
!     20 | 4.2
!     12 | , 
!      1 | readline
!     20 | -4.2
!     12 |  
!      1 | readline
!     20 | -4.2
!     12 | . 
!     22 | 234
!     12 |                                     +
!        | 
!     12 | <
!      1 | i
!     12 |  
!     13 | <b>
!     12 |  
!      1 | wow
!     12 |   
!     12 | < 
!      1 | jqw
!     12 |  
!     12 | <> 
!      1 | qwerty
! (133 rows)
! 
! SELECT to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty');
!                                                                                                                                                                                                                                                                                                                                                                                                                                        to_tsvector                                                                                                                                                                                                                                                                                                                                                                                                                                        
! ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  '+4.0e-10':28 '-4.2':60,62 '/?':18 '/?ad=qwe&dw':7,10,14,24 '/?ad=qwe&dw=%20%32':27 '/awdf/dwqe/4325':48 '/usr/local/fff':47 '/wqe-324/ewr':51 '1aew.werc.ewr':9 '1aew.werc.ewr/?ad=qwe&dw':8 '234':63 '234.435':32 '2aew.werc.ewr':11 '345':1 '3aew.werc.ewr':13 '3aew.werc.ewr/?ad=qwe&dw':12 '4.2':56,57,58 '455':33 '4aew.werc.ewr':15 '5.005':34 '5aew.werc.ewr:8100':17 '5aew.werc.ewr:8100/?':16 '6aew.werc.ewr:8100':23 '6aew.werc.ewr:8100/?ad=qwe&dw':22 '7aew.werc.ewr:8100':26 '7aew.werc.ewr:8100/?ad=qwe&dw=%20%32':25 'ad':19 'aew.werc.ewr':6 'aew.werc.ewr/?ad=qwe&dw':5 'asdf':39 'dw':21 'efd.r':3 'ewr1':45 'ewri2':46 'gist.c':54 'gist.h':52 'gist.h.c':53 'hjwer':44 'jf':41 'jqw':66 'qwe':2,20,29,30,37 'qwe-wer':36 'qwer':40 'qwerti':67 'qwqwe':31 'readlin':55,59,61 'rewt/ewr':49 'sdjk':42 'teodor@stack.net':35 'wefjn':50 'wer':38 'wow':65 'www.com':4
! (1 row)
! 
! SELECT length(to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty'));
!  length 
! --------
!      53
! (1 row)
! 
! -- ts_debug
! SELECT * from ts_debug('english', '<myns:foo-bar_baz.blurfl>abc&nm1;def&#xa9;ghi&#245;jkl</myns:foo-bar_baz.blurfl>');
!    alias   |   description   |           token            |  dictionaries  |  dictionary  | lexemes 
! -----------+-----------------+----------------------------+----------------+--------------+---------
!  tag       | XML tag         | <myns:foo-bar_baz.blurfl>  | {}             |              | 
!  asciiword | Word, all ASCII | abc                        | {english_stem} | english_stem | {abc}
!  entity    | XML entity      | &nm1;                      | {}             |              | 
!  asciiword | Word, all ASCII | def                        | {english_stem} | english_stem | {def}
!  entity    | XML entity      | &#xa9;                     | {}             |              | 
!  asciiword | Word, all ASCII | ghi                        | {english_stem} | english_stem | {ghi}
!  entity    | XML entity      | &#245;                     | {}             |              | 
!  asciiword | Word, all ASCII | jkl                        | {english_stem} | english_stem | {jkl}
!  tag       | XML tag         | </myns:foo-bar_baz.blurfl> | {}             |              | 
! (9 rows)
! 
! -- check parsing of URLs
! SELECT * from ts_debug('english', 'http://www.harewoodsolutions.co.uk/press.aspx</span>');
!   alias   |  description  |                 token                  | dictionaries | dictionary |                 lexemes                  
! ----------+---------------+----------------------------------------+--------------+------------+------------------------------------------
!  protocol | Protocol head | http://                                | {}           |            | 
!  url      | URL           | www.harewoodsolutions.co.uk/press.aspx | {simple}     | simple     | {www.harewoodsolutions.co.uk/press.aspx}
!  host     | Host          | www.harewoodsolutions.co.uk            | {simple}     | simple     | {www.harewoodsolutions.co.uk}
!  url_path | URL path      | /press.aspx                            | {simple}     | simple     | {/press.aspx}
!  tag      | XML tag       | </span>                                | {}           |            | 
! (5 rows)
! 
! SELECT * from ts_debug('english', 'http://aew.wer0c.ewr/id?ad=qwe&dw<span>');
!   alias   |  description  |           token            | dictionaries | dictionary |           lexemes            
! ----------+---------------+----------------------------+--------------+------------+------------------------------
!  protocol | Protocol head | http://                    | {}           |            | 
!  url      | URL           | aew.wer0c.ewr/id?ad=qwe&dw | {simple}     | simple     | {aew.wer0c.ewr/id?ad=qwe&dw}
!  host     | Host          | aew.wer0c.ewr              | {simple}     | simple     | {aew.wer0c.ewr}
!  url_path | URL path      | /id?ad=qwe&dw              | {simple}     | simple     | {/id?ad=qwe&dw}
!  tag      | XML tag       | <span>                     | {}           |            | 
! (5 rows)
! 
! SELECT * from ts_debug('english', 'http://5aew.werc.ewr:8100/?');
!   alias   |  description  |        token         | dictionaries | dictionary |        lexemes         
! ----------+---------------+----------------------+--------------+------------+------------------------
!  protocol | Protocol head | http://              | {}           |            | 
!  url      | URL           | 5aew.werc.ewr:8100/? | {simple}     | simple     | {5aew.werc.ewr:8100/?}
!  host     | Host          | 5aew.werc.ewr:8100   | {simple}     | simple     | {5aew.werc.ewr:8100}
!  url_path | URL path      | /?                   | {simple}     | simple     | {/?}
! (4 rows)
! 
! SELECT * from ts_debug('english', '5aew.werc.ewr:8100/?xx');
!   alias   | description |         token          | dictionaries | dictionary |         lexemes          
! ----------+-------------+------------------------+--------------+------------+--------------------------
!  url      | URL         | 5aew.werc.ewr:8100/?xx | {simple}     | simple     | {5aew.werc.ewr:8100/?xx}
!  host     | Host        | 5aew.werc.ewr:8100     | {simple}     | simple     | {5aew.werc.ewr:8100}
!  url_path | URL path    | /?xx                   | {simple}     | simple     | {/?xx}
! (3 rows)
! 
! -- to_tsquery
! SELECT to_tsquery('english', 'qwe & sKies ');
!   to_tsquery   
! ---------------
!  'qwe' & 'sky'
! (1 row)
! 
! SELECT to_tsquery('simple', 'qwe & sKies ');
!    to_tsquery    
! -----------------
!  'qwe' & 'skies'
! (1 row)
! 
! SELECT to_tsquery('english', '''the wether'':dc & ''           sKies '':BC ');
!        to_tsquery       
! ------------------------
!  'wether':CD & 'sky':BC
! (1 row)
! 
! SELECT to_tsquery('english', 'asd&(and|fghj)');
!    to_tsquery   
! ----------------
!  'asd' & 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(asd&and)|fghj');
!    to_tsquery   
! ----------------
!  'asd' | 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(asd&!and)|fghj');
!    to_tsquery   
! ----------------
!  'asd' | 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(the|and&(i&1))&fghj');
!   to_tsquery  
! --------------
!  '1' & 'fghj'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'the and z 1))& fghj');
!   plainto_tsquery   
! --------------------
!  'z' & '1' & 'fghj'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') && plainto_tsquery('english', 'asd');
!        ?column?        
! -----------------------
!  'foo' & 'bar' & 'asd'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') || plainto_tsquery('english', 'asd fg');
!            ?column?           
! ------------------------------
!  'foo' & 'bar' | 'asd' & 'fg'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') || !!plainto_tsquery('english', 'asd fg');
!              ?column?              
! -----------------------------------
!  'foo' & 'bar' | !( 'asd' & 'fg' )
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') && 'asd | fg';
!              ?column?             
! ----------------------------------
!  'foo' & 'bar' & ( 'asd' | 'fg' )
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'paint&water'));
!  ts_rank_cd 
! ------------
!        0.05
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'breath&motion&water'));
!  ts_rank_cd 
! ------------
!  0.00833333
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'ocean'));
!  ts_rank_cd 
! ------------
!         0.1
! (1 row)
! 
! SELECT ts_rank_cd(strip(to_tsvector('both stripped')),
!                   to_tsquery('both & stripped'));
!  ts_rank_cd 
! ------------
!           0
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('unstripped') || strip(to_tsvector('stripped')),
!                   to_tsquery('unstripped & stripped'));
!  ts_rank_cd 
! ------------
!           0
! (1 row)
! 
! --headline tests
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'paint&water'));
!                ts_headline               
! -----------------------------------------
!  <b>painted</b> Ocean.                  +
!  <b>Water</b>, <b>water</b>, every where+
!    And all the boards did shrink;       +
!  <b>Water</b>, <b>water</b>, every
! (1 row)
! 
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'breath&motion&water'));
!            ts_headline            
! ----------------------------------
!  <b>breath</b> nor <b>motion</b>,+
!  As idle as a painted Ship       +
!    Upon a painted Ocean.         +
!  <b>Water</b>, <b>water</b>
! (1 row)
! 
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean'));
!            ts_headline            
! ----------------------------------
!  <b>Ocean</b>.                   +
!  Water, water, every where       +
!    And all the boards did shrink;+
!  Water, water, every where
! (1 row)
! 
! SELECT ts_headline('english', '
! <html>
! <!-- some comment -->
! <body>
! Sea view wow <u>foo bar</u> <i>qq</i>
! <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>
! ff-bg
! <script>
!        document.write(15);
! </script>
! </body>
! </html>',
! to_tsquery('english', 'sea&foo'), 'HighlightAll=true');
!                                  ts_headline                                 
! -----------------------------------------------------------------------------
!                                                                             +
!  <html>                                                                     +
!  <!-- some comment -->                                                      +
!  <body>                                                                     +
!  <b>Sea</b> view wow <u><b>foo</b> bar</u> <i>qq</i>                        +
!  <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>+
!  ff-bg                                                                      +
!  <script>                                                                   +
!         document.write(15);                                                 +
!  </script>                                                                  +
!  </body>                                                                    +
!  </html>
! (1 row)
! 
! --Check if headline fragments work
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean'), 'MaxFragments=1');
!             ts_headline             
! ------------------------------------
!  after day,                        +
!    We stuck, nor breath nor motion,+
!  As idle as a painted Ship         +
!    Upon a painted <b>Ocean</b>.    +
!  Water, water, every where         +
!    And all the boards did shrink;  +
!  Water, water, every where,        +
!    Nor any drop
! (1 row)
! 
! --Check if more than one fragments are displayed
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2');
!                  ts_headline                  
! ----------------------------------------------
!  after day, day after day,                   +
!    We <b>stuck</b>, nor breath nor motion,   +
!  As idle as a painted Ship                   +
!    Upon a painted Ocean.                     +
!  Water, water, every where                   +
!    And all the boards did shrink;            +
!  Water, water, every where ... drop to drink.+
!  S. T. <b>Coleridge</b>
! (1 row)
! 
! --Fragments when there all query words are not in the document
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean & seahorse'), 'MaxFragments=1');
!             ts_headline             
! ------------------------------------
!                                    +
!  Day after day, day after day,     +
!    We stuck, nor breath nor motion,+
!  As idle as
! (1 row)
! 
! --FragmentDelimiter option
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2,FragmentDelimiter=***');
!                 ts_headline                 
! --------------------------------------------
!  after day, day after day,                 +
!    We <b>stuck</b>, nor breath nor motion, +
!  As idle as a painted Ship                 +
!    Upon a painted Ocean.                   +
!  Water, water, every where                 +
!    And all the boards did shrink;          +
!  Water, water, every where***drop to drink.+
!  S. T. <b>Coleridge</b>
! (1 row)
! 
! --Rewrite sub system
! CREATE TABLE test_tsquery (txtkeyword TEXT, txtsample TEXT);
! \set ECHO none
! ALTER TABLE test_tsquery ADD COLUMN keyword tsquery;
! UPDATE test_tsquery SET keyword = to_tsquery('english', txtkeyword);
! ALTER TABLE test_tsquery ADD COLUMN sample tsquery;
! UPDATE test_tsquery SET sample = to_tsquery('english', txtsample::text);
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new & york';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! CREATE UNIQUE INDEX bt_tsq ON test_tsquery (keyword);
! SET enable_seqscan=OFF;
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new & york';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! RESET enable_seqscan;
! SELECT ts_rewrite('foo & bar & qq & new & york',  'new & york'::tsquery, 'big & apple | nyc | new & york & city');
!                                     ts_rewrite                                    
! ----------------------------------------------------------------------------------
!  'foo' & 'bar' & 'qq' & ( 'city' & 'new' & 'york' | ( 'nyc' | 'big' & 'apple' ) )
! (1 row)
! 
! SELECT ts_rewrite('moscow', 'SELECT keyword, sample FROM test_tsquery'::text );
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite('moscow & hotel', 'SELECT keyword, sample FROM test_tsquery'::text );
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite('bar & new & qq & foo & york', 'SELECT keyword, sample FROM test_tsquery'::text );
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( 'moscow', 'SELECT keyword, sample FROM test_tsquery');
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( 'moscow & hotel', 'SELECT keyword, sample FROM test_tsquery');
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( 'bar & new & qq & foo & york', 'SELECT keyword, sample FROM test_tsquery');
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
!     keyword     
! ----------------
!  'new' & 'york'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
!  keyword 
! ---------
! (0 rows)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar &  new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! CREATE INDEX qq ON test_tsquery USING gist (keyword tsquery_ops);
! SET enable_seqscan=OFF;
! SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
!     keyword     
! ----------------
!  'new' & 'york'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
!  keyword 
! ---------
! (0 rows)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar &  new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! RESET enable_seqscan;
! --test GUC
! SET default_text_search_config=simple;
! SELECT to_tsvector('SKIES My booKs');
!         to_tsvector         
! ----------------------------
!  'books':3 'my':2 'skies':1
! (1 row)
! 
! SELECT plainto_tsquery('SKIES My booKs');
!      plainto_tsquery      
! --------------------------
!  'skies' & 'my' & 'books'
! (1 row)
! 
! SELECT to_tsquery('SKIES & My | booKs');
!         to_tsquery        
! --------------------------
!  'skies' & 'my' | 'books'
! (1 row)
! 
! SET default_text_search_config=english;
! SELECT to_tsvector('SKIES My booKs');
!    to_tsvector    
! ------------------
!  'book':3 'sky':1
! (1 row)
! 
! SELECT plainto_tsquery('SKIES My booKs');
!  plainto_tsquery 
! -----------------
!  'sky' & 'book'
! (1 row)
! 
! SELECT to_tsquery('SKIES & My | booKs');
!    to_tsquery   
! ----------------
!  'sky' | 'book'
! (1 row)
! 
! --trigger
! CREATE TRIGGER tsvectorupdate
! BEFORE UPDATE OR INSERT ON test_tsvector
! FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      0
! (1 row)
! 
! INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      1
! (1 row)
! 
! UPDATE test_tsvector SET t = null WHERE t = '345 qwerty';
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      0
! (1 row)
! 
! INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      1
! (1 row)
! 
! -- test finding items in GIN's pending list
! create temp table pendtest (ts tsvector);
! create index pendtest_idx on pendtest using gin(ts);
! insert into pendtest values (to_tsvector('Lore ipsam'));
! insert into pendtest values (to_tsvector('Lore ipsum'));
! select * from pendtest where 'ipsu:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsum':2 'lore':1
! (1 row)
! 
! select * from pendtest where 'ipsa:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsam':2 'lore':1
! (1 row)
! 
! select * from pendtest where 'ips:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsam':2 'lore':1
!  'ipsum':2 'lore':1
! (2 rows)
! 
! select * from pendtest where 'ipt:*'::tsquery @@ ts;
!  ts 
! ----
! (0 rows)
! 
! select * from pendtest where 'ipi:*'::tsquery @@ ts;
!  ts 
! ----
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/foreign_data.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/foreign_data.out	2015-01-10 10:11:47.027649472 +0300
***************
*** 1,1266 ****
! --
! -- Test foreign-data wrapper and server management.
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when roles don't exist
! SET client_min_messages TO 'error';
! DROP ROLE IF EXISTS foreign_data_user, regress_test_role, regress_test_role2, regress_test_role_super, regress_test_indirect, unpriviled_role;
! RESET client_min_messages;
! CREATE ROLE foreign_data_user LOGIN SUPERUSER;
! SET SESSION AUTHORIZATION 'foreign_data_user';
! CREATE ROLE regress_test_role;
! CREATE ROLE regress_test_role2;
! CREATE ROLE regress_test_role_super SUPERUSER;
! CREATE ROLE regress_test_indirect;
! CREATE ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER dummy;
! COMMENT ON FOREIGN DATA WRAPPER dummy IS 'useless';
! CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
! -- At this point we should have 2 built-in wrappers and no servers.
! SELECT fdwname, fdwhandler::regproc, fdwvalidator::regproc, fdwoptions FROM pg_foreign_data_wrapper ORDER BY 1, 2, 3;
!   fdwname   | fdwhandler |       fdwvalidator       | fdwoptions 
! ------------+------------+--------------------------+------------
!  dummy      | -          | -                        | 
!  postgresql | -          | postgresql_fdw_validator | 
! (2 rows)
! 
! SELECT srvname, srvoptions FROM pg_foreign_server;
!  srvname | srvoptions 
! ---------+------------
! (0 rows)
! 
! SELECT * FROM pg_user_mapping;
!  umuser | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
! -- CREATE FOREIGN DATA WRAPPER
! CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERROR
! ERROR:  function bar(text[], oid) does not exist
! CREATE FOREIGN DATA WRAPPER foo;
! \dew
!                     List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         
! ------------+-------------------+---------+--------------------------
!  dummy      | foreign_data_user | -       | -
!  foo        | foreign_data_user | -       | -
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator
! (3 rows)
! 
! CREATE FOREIGN DATA WRAPPER foo; -- duplicate
! ERROR:  foreign-data wrapper "foo" already exists
! DROP FOREIGN DATA WRAPPER foo;
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options  | Description 
! ------------+-------------------+---------+--------------------------+-------------------+---------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |               | useless
!  foo        | foreign_data_user | -       | -                        |                   | (testing '1') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |               | 
! (3 rows)
! 
! DROP FOREIGN DATA WRAPPER foo;
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERROR
! ERROR:  option "testing" provided more than once
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
! \dew+
!                                                    List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |        FDW Options         | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                            | useless
!  foo        | foreign_data_user | -       | -                        |                   | (testing '1', another '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                            | 
! (3 rows)
! 
! DROP FOREIGN DATA WRAPPER foo;
! SET ROLE regress_test_role;
! CREATE FOREIGN DATA WRAPPER foo; -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foo"
! HINT:  Must be superuser to create a foreign-data wrapper.
! RESET ROLE;
! CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! -- ALTER FOREIGN DATA WRAPPER
! ALTER FOREIGN DATA WRAPPER foo;                             -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: ALTER FOREIGN DATA WRAPPER foo;
!                                       ^
! ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERROR
! ERROR:  function bar(text[], oid) does not exist
! ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | -                        |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERROR
! ERROR:  option "c" not found
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERROR
! ERROR:  option "c" not found
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options   | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                | useless
!  foo        | foreign_data_user | -       | -                        |                   | (a '1', b '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP a, SET b '3', ADD c '4');
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options   | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERROR
! ERROR:  option "b" provided more than once
! \dew+
!                                                  List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |      FDW Options      | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-----------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                       | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4', a '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                       | 
! (3 rows)
! 
! SET ROLE regress_test_role;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! SET ROLE regress_test_role_super;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
! \dew+
!                                                     List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                              | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role;  -- ERROR
! ERROR:  permission denied to change owner of foreign-data wrapper "foo"
! HINT:  The owner of a foreign-data wrapper must be a superuser.
! ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role_super;
! ALTER ROLE regress_test_role_super NOSUPERUSER;
! SET ROLE regress_test_role_super;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! RESET ROLE;
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo        | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo RENAME TO foo1;
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo1       | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo1 RENAME TO foo;
! -- DROP FOREIGN DATA WRAPPER
! DROP FOREIGN DATA WRAPPER nonexistent;                      -- ERROR
! ERROR:  foreign-data wrapper "nonexistent" does not exist
! DROP FOREIGN DATA WRAPPER IF EXISTS nonexistent;
! NOTICE:  foreign-data wrapper "nonexistent" does not exist, skipping
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo        | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! DROP ROLE regress_test_role_super;                          -- ERROR
! ERROR:  role "regress_test_role_super" cannot be dropped because some objects depend on it
! DETAIL:  owner of foreign-data wrapper foo
! SET ROLE regress_test_role_super;
! DROP FOREIGN DATA WRAPPER foo;
! RESET ROLE;
! DROP ROLE regress_test_role_super;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (2 rows)
! 
! CREATE FOREIGN DATA WRAPPER foo;
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
! COMMENT ON SERVER s1 IS 'foreign server';
! CREATE USER MAPPING FOR current_user SERVER s1;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | -                        |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! \des+
!                                                List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges | Type | Version | FDW Options |  Description   
! ------+-------------------+----------------------+-------------------+------+---------+-------------+----------------
!  s1   | foreign_data_user | foo                  |                   |      |         |             | foreign server
! (1 row)
! 
! \deu+
!           List of user mappings
!  Server |     User name     | FDW Options 
! --------+-------------------+-------------
!  s1     | foreign_data_user | 
! (1 row)
! 
! DROP FOREIGN DATA WRAPPER foo;                              -- ERROR
! ERROR:  cannot drop foreign-data wrapper foo because other objects depend on it
! DETAIL:  server s1 depends on foreign-data wrapper foo
! user mapping for foreign_data_user depends on server s1
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! SET ROLE regress_test_role;
! DROP FOREIGN DATA WRAPPER foo CASCADE;                      -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! RESET ROLE;
! DROP FOREIGN DATA WRAPPER foo CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to server s1
! drop cascades to user mapping for foreign_data_user
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (2 rows)
! 
! \des+
!                                        List of foreign servers
!  Name | Owner | Foreign-data wrapper | Access privileges | Type | Version | FDW Options | Description 
! ------+-------+----------------------+-------------------+------+---------+-------------+-------------
! (0 rows)
! 
! \deu+
!       List of user mappings
!  Server | User name | FDW Options 
! --------+-----------+-------------
! (0 rows)
! 
! -- exercise CREATE SERVER
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  foreign-data wrapper "foo" does not exist
! CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  server "s1" already exists
! CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s3 TYPE 'oracle' FOREIGN DATA WRAPPER foo;
! CREATE SERVER s4 TYPE 'oracle' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s5 VERSION '15.0' FOREIGN DATA WRAPPER foo;
! CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1'); -- ERROR
! ERROR:  invalid option "foo"
! HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
! CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
! (8 rows)
! 
! SET ROLE regress_test_role;
! CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDW
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! SET ROLE regress_test_role;
! CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
! RESET ROLE;
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                   |        |         |                                   | 
! (9 rows)
! 
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_test_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! GRANT regress_test_indirect TO regress_test_role;
! SET ROLE regress_test_role;
! CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                   |        |         |                                   | 
!  t2   | regress_test_role | foo                  |                   |        |         |                                   | 
! (10 rows)
! 
! RESET ROLE;
! REVOKE regress_test_indirect FROM regress_test_role;
! -- ALTER SERVER
! ALTER SERVER s0;                                            -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: ALTER SERVER s0;
!                        ^
! ALTER SERVER s0 OPTIONS (a '1');                            -- ERROR
! ERROR:  server "s0" does not exist
! ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
! ALTER SERVER s2 VERSION '1.1';
! ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
! GRANT USAGE ON FOREIGN SERVER s1 TO regress_test_role;
! GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role2 WITH GRANT OPTION;
! \des+
!                                                                     List of foreign servers
!  Name |       Owner       | Foreign-data wrapper |            Access privileges            |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-----------------------------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.0     | (servername 's1')                 | 
!       |                   |                      | regress_test_role=U/foreign_data_user   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')  | 
!  s4   | foreign_data_user | foo                  |                                         | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                                         |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')            | 
!       |                   |                      | regress_test_role2=U*/foreign_data_user |        |         |                                   | 
!  s7   | foreign_data_user | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                                         |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                                         |        |         |                                   | 
!  t2   | regress_test_role | foo                  |                                         |        |         |                                   | 
! (10 rows)
! 
! SET ROLE regress_test_role;
! ALTER SERVER s1 VERSION '1.1';                              -- ERROR
! ERROR:  must be owner of foreign server s1
! ALTER SERVER s1 OWNER TO regress_test_role;                 -- ERROR
! ERROR:  must be owner of foreign server s1
! RESET ROLE;
! ALTER SERVER s1 OWNER TO regress_test_role;
! GRANT regress_test_role2 TO regress_test_role;
! SET ROLE regress_test_role;
! ALTER SERVER s1 VERSION '1.1';
! ALTER SERVER s1 OWNER TO regress_test_role2;                -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! ALTER SERVER s8 OPTIONS (foo '1');                          -- ERROR option validation
! ERROR:  invalid option "foo"
! HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
! ALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;             -- ERROR
! ERROR:  must be member of role "regress_test_indirect"
! RESET ROLE;
! GRANT regress_test_indirect TO regress_test_role;
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;
! RESET ROLE;
! DROP ROLE regress_test_indirect;                            -- ERROR
! ERROR:  role "regress_test_indirect" cannot be dropped because some objects depend on it
! DETAIL:  owner of server s1
! privileges for foreign-data wrapper foo
! \des+
!                                                                         List of foreign servers
!  Name |         Owner         | Foreign-data wrapper |            Access privileges            |  Type  | Version |             FDW Options              | Description 
! ------+-----------------------+----------------------+-----------------------------------------+--------+---------+--------------------------------------+-------------
!  s1   | regress_test_indirect | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.1     | (servername 's1')                    | 
!       |                       |                      | regress_test_role=U/foreign_data_user   |        |         |                                      | 
!  s2   | foreign_data_user     | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')               | 
!  s3   | foreign_data_user     | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')     | 
!  s4   | foreign_data_user     | foo                  |                                         | oracle |         | (host 'a', dbname 'b')               | 
!  s5   | foreign_data_user     | foo                  |                                         |        | 15.0    |                                      | 
!  s6   | foreign_data_user     | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')               | 
!       |                       |                      | regress_test_role2=U*/foreign_data_user |        |         |                                      | 
!  s7   | foreign_data_user     | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')               | 
!  s8   | foreign_data_user     | postgresql           |                                         |        |         | (dbname 'db1', connect_timeout '30') | 
!  t1   | regress_test_role     | foo                  |                                         |        |         |                                      | 
!  t2   | regress_test_role     | foo                  |                                         |        |         |                                      | 
! (10 rows)
! 
! ALTER SERVER s8 RENAME to s8new;
! \des+
!                                                                         List of foreign servers
!  Name  |         Owner         | Foreign-data wrapper |            Access privileges            |  Type  | Version |             FDW Options              | Description 
! -------+-----------------------+----------------------+-----------------------------------------+--------+---------+--------------------------------------+-------------
!  s1    | regress_test_indirect | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.1     | (servername 's1')                    | 
!        |                       |                      | regress_test_role=U/foreign_data_user   |        |         |                                      | 
!  s2    | foreign_data_user     | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')               | 
!  s3    | foreign_data_user     | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')     | 
!  s4    | foreign_data_user     | foo                  |                                         | oracle |         | (host 'a', dbname 'b')               | 
!  s5    | foreign_data_user     | foo                  |                                         |        | 15.0    |                                      | 
!  s6    | foreign_data_user     | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')               | 
!        |                       |                      | regress_test_role2=U*/foreign_data_user |        |         |                                      | 
!  s7    | foreign_data_user     | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')               | 
!  s8new | foreign_data_user     | postgresql           |                                         |        |         | (dbname 'db1', connect_timeout '30') | 
!  t1    | regress_test_role     | foo                  |                                         |        |         |                                      | 
!  t2    | regress_test_role     | foo                  |                                         |        |         |                                      | 
! (10 rows)
! 
! ALTER SERVER s8new RENAME to s8;
! -- DROP SERVER
! DROP SERVER nonexistent;                                    -- ERROR
! ERROR:  server "nonexistent" does not exist
! DROP SERVER IF EXISTS nonexistent;
! NOTICE:  server "nonexistent" does not exist, skipping
! \des
!                List of foreign servers
!  Name |         Owner         | Foreign-data wrapper 
! ------+-----------------------+----------------------
!  s1   | regress_test_indirect | foo
!  s2   | foreign_data_user     | foo
!  s3   | foreign_data_user     | foo
!  s4   | foreign_data_user     | foo
!  s5   | foreign_data_user     | foo
!  s6   | foreign_data_user     | foo
!  s7   | foreign_data_user     | foo
!  s8   | foreign_data_user     | postgresql
!  t1   | regress_test_role     | foo
!  t2   | regress_test_role     | foo
! (10 rows)
! 
! SET ROLE regress_test_role;
! DROP SERVER s2;                                             -- ERROR
! ERROR:  must be owner of foreign server s2
! DROP SERVER s1;
! RESET ROLE;
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s2   | foreign_data_user | foo
!  s3   | foreign_data_user | foo
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (9 rows)
! 
! ALTER SERVER s2 OWNER TO regress_test_role;
! SET ROLE regress_test_role;
! DROP SERVER s2;
! RESET ROLE;
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s3   | foreign_data_user | foo
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (8 rows)
! 
! CREATE USER MAPPING FOR current_user SERVER s3;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s3     | foreign_data_user
! (1 row)
! 
! DROP SERVER s3;                                             -- ERROR
! ERROR:  cannot drop server s3 because other objects depend on it
! DETAIL:  user mapping for foreign_data_user depends on server s3
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP SERVER s3 CASCADE;
! NOTICE:  drop cascades to user mapping for foreign_data_user
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (7 rows)
! 
! \deu
! List of user mappings
!  Server | User name 
! --------+-----------
! (0 rows)
! 
! -- CREATE USER MAPPING
! CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! CREATE USER MAPPING FOR current_user SERVER s1;             -- ERROR
! ERROR:  server "s1" does not exist
! CREATE USER MAPPING FOR current_user SERVER s4;
! CREATE USER MAPPING FOR user SERVER s4;                     -- ERROR duplicate
! ERROR:  user mapping "foreign_data_user" already exists for server s4
! CREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
! CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');    -- ERROR
! ERROR:  invalid option "username"
! HINT:  Valid options in this context are: user, password
! CREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
! ALTER SERVER s5 OWNER TO regress_test_role;
! ALTER SERVER s6 OWNER TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER s5;
! CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
! CREATE USER MAPPING FOR current_user SERVER s7;             -- ERROR
! ERROR:  permission denied for foreign server s7
! CREATE USER MAPPING FOR public SERVER s8;                   -- ERROR
! ERROR:  must be owner of foreign server s8
! RESET ROLE;
! ALTER SERVER t1 OWNER TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER t1 OPTIONS (username 'bob', password 'boo');
! CREATE USER MAPPING FOR public SERVER t1;
! RESET ROLE;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s4     | foreign_data_user
!  s4     | public
!  s5     | regress_test_role
!  s6     | regress_test_role
!  s8     | foreign_data_user
!  t1     | public
!  t1     | regress_test_role
! (7 rows)
! 
! -- ALTER USER MAPPING
! ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  server "ss4" does not exist
! ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');            -- ERROR
! ERROR:  user mapping "public" does not exist for the server
! ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');    -- ERROR
! ERROR:  invalid option "username"
! HINT:  Valid options in this context are: user, password
! ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
! SET ROLE regress_test_role;
! ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
! ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1'); -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
! RESET ROLE;
! \deu+
!                      List of user mappings
!  Server |     User name     |           FDW Options            
! --------+-------------------+----------------------------------
!  s4     | foreign_data_user | 
!  s4     | public            | ("this mapping" 'is public')
!  s5     | regress_test_role | (modified '1')
!  s6     | regress_test_role | (username 'test')
!  s8     | foreign_data_user | (password 'public')
!  t1     | public            | (modified '1')
!  t1     | regress_test_role | (username 'bob', password 'boo')
! (7 rows)
! 
! -- DROP USER MAPPING
! DROP USER MAPPING FOR regress_test_missing_role SERVER s4;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! DROP USER MAPPING FOR user SERVER ss4;
! ERROR:  server "ss4" does not exist
! DROP USER MAPPING FOR public SERVER s7;                     -- ERROR
! ERROR:  user mapping "public" does not exist for the server
! DROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
! NOTICE:  role "regress_test_missing_role" does not exist, skipping
! DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
! NOTICE:  server does not exist, skipping
! DROP USER MAPPING IF EXISTS FOR public SERVER s7;
! NOTICE:  user mapping "public" does not exist for the server, skipping
! CREATE USER MAPPING FOR public SERVER s8;
! SET ROLE regress_test_role;
! DROP USER MAPPING FOR public SERVER s8;                     -- ERROR
! ERROR:  must be owner of foreign server s8
! RESET ROLE;
! DROP SERVER s7;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s4     | foreign_data_user
!  s4     | public
!  s5     | regress_test_role
!  s6     | regress_test_role
!  s8     | foreign_data_user
!  s8     | public
!  t1     | public
!  t1     | regress_test_role
! (8 rows)
! 
! -- CREATE FOREIGN TABLE
! CREATE SCHEMA foreign_schema;
! CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
! CREATE FOREIGN TABLE ft1 ();                                    -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: CREATE FOREIGN TABLE ft1 ();
!                                    ^
! CREATE FOREIGN TABLE ft1 () SERVER no_server;                   -- ERROR
! ERROR:  server "no_server" does not exist
! CREATE FOREIGN TABLE ft1 () SERVER s0 WITH OIDS;                -- ERROR
! ERROR:  syntax error at or near "WITH OIDS"
! LINE 1: CREATE FOREIGN TABLE ft1 () SERVER s0 WITH OIDS;
!                                               ^
! CREATE FOREIGN TABLE ft1 (
! 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL,
! 	c2 text OPTIONS (param2 'val2', param3 'val3'),
! 	c3 date
! ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
! COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
! COMMENT ON COLUMN ft1.c1 IS 'ft1.c1';
! \d+ ft1
!                                       Foreign table "public.ft1"
!  Column |  Type   | Modifiers |          FDW Options           | Storage  | Stats target | Description 
! --------+---------+-----------+--------------------------------+----------+--------------+-------------
!  c1     | integer | not null  | ("param 1" 'val1')             | plain    |              | ft1.c1
!  c2     | text    |           | (param2 'val2', param3 'val3') | extended |              | 
!  c3     | date    |           |                                | plain    |              | 
! Server: s0
! FDW Options: (delimiter ',', quote '"', "be quoted" 'value')
! 
! \det+
!                                  List of foreign tables
!  Schema | Table | Server |                   FDW Options                   | Description 
! --------+-------+--------+-------------------------------------------------+-------------
!  public | ft1   | s0     | (delimiter ',', quote '"', "be quoted" 'value') | ft1
! (1 row)
! 
! CREATE INDEX id_ft1_c2 ON ft1 (c2);                             -- ERROR
! ERROR:  cannot create index on foreign table "ft1"
! SELECT * FROM ft1;                                              -- ERROR
! ERROR:  foreign-data wrapper "dummy" has no handler
! EXPLAIN SELECT * FROM ft1;                                      -- ERROR
! ERROR:  foreign-data wrapper "dummy" has no handler
! -- ALTER FOREIGN TABLE
! COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
! COMMENT ON FOREIGN TABLE ft1 IS NULL;
! COMMENT ON COLUMN ft1.c1 IS 'foreign column';
! COMMENT ON COLUMN ft1.c1 IS NULL;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0'; -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1'); -- ERROR
! ERROR:  cannot alter system column "xmin"
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
!                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
! \d+ ft1
!                                       Foreign table "public.ft1"
!  Column |  Type   | Modifiers |          FDW Options           | Storage  | Stats target | Description 
! --------+---------+-----------+--------------------------------+----------+--------------+-------------
!  c1     | integer | not null  | ("param 1" 'val1')             | plain    | 10000        | 
!  c2     | text    |           | (param2 'val2', param3 'val3') | extended |              | 
!  c3     | date    |           |                                | plain    |              | 
!  c4     | integer | default 0 |                                | plain    |              | 
!  c5     | integer |           |                                | plain    |              | 
!  c6     | integer | not null  |                                | plain    |              | 
!  c7     | integer |           | (p1 'v1', p2 'v2')             | plain    |              | 
!  c8     | text    |           | (p2 'V2')                      | extended |              | 
!  c9     | integer |           |                                | plain    |              | 
!  c10    | integer |           | (p1 'v1')                      | plain    |              | 
! Server: s0
! FDW Options: (delimiter ',', quote '"', "be quoted" 'value')
! 
! -- can't change the column type if it's used elsewhere
! CREATE TABLE use_ft1_column_type (x ft1);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;	-- ERROR
! ERROR:  cannot alter foreign table "ft1" because column "use_ft1_column_type.x" uses its row type
! DROP TABLE use_ft1_column_type;
! ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0); -- ERROR
! ERROR:  constraints are not supported on foreign tables
! LINE 1: ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c...
!                                     ^
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;               -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c1_check;
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 SET WITH OIDS;                          -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
! ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
! ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;                  -- ERROR
! ERROR:  column "no_column" of relation "ft1" does not exist
! ALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
! NOTICE:  column "no_column" of relation "ft1" does not exist, skipping
! ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
! ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
! ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;                      -- ERROR
! ERROR:  relation "ft1" does not exist
! ALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
! ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
! \d foreign_schema.foreign_table_1
!              Foreign table "foreign_schema.foreign_table_1"
!       Column      |  Type   | Modifiers |          FDW Options           
! ------------------+---------+-----------+--------------------------------
!  foreign_column_1 | integer | not null  | ("param 1" 'val1')
!  c2               | text    |           | (param2 'val2', param3 'val3')
!  c3               | date    |           | 
!  c4               | integer | default 0 | 
!  c5               | integer |           | 
!  c6               | integer | not null  | 
!  c7               | integer |           | (p1 'v1', p2 'v2')
!  c8               | text    |           | (p2 'V2')
!  c10              | integer |           | (p1 'v1')
! Server: s0
! FDW Options: (quote '~', "be quoted" 'value', escape '@')
! 
! -- alter noexisting table
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c4 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
!                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! -- Information schema
! SELECT * FROM information_schema.foreign_data_wrappers ORDER BY 1, 2;
!  foreign_data_wrapper_catalog | foreign_data_wrapper_name | authorization_identifier | library_name | foreign_data_wrapper_language 
! ------------------------------+---------------------------+--------------------------+--------------+-------------------------------
!  regression                   | dummy                     | foreign_data_user        |              | c
!  regression                   | foo                       | foreign_data_user        |              | c
!  regression                   | postgresql                | foreign_data_user        |              | c
! (3 rows)
! 
! SELECT * FROM information_schema.foreign_data_wrapper_options ORDER BY 1, 2, 3;
!  foreign_data_wrapper_catalog | foreign_data_wrapper_name | option_name  | option_value 
! ------------------------------+---------------------------+--------------+--------------
!  regression                   | foo                       | test wrapper | true
! (1 row)
! 
! SELECT * FROM information_schema.foreign_servers ORDER BY 1, 2;
!  foreign_server_catalog | foreign_server_name | foreign_data_wrapper_catalog | foreign_data_wrapper_name | foreign_server_type | foreign_server_version | authorization_identifier 
! ------------------------+---------------------+------------------------------+---------------------------+---------------------+------------------------+--------------------------
!  regression             | s0                  | regression                   | dummy                     |                     |                        | foreign_data_user
!  regression             | s4                  | regression                   | foo                       | oracle              |                        | foreign_data_user
!  regression             | s5                  | regression                   | foo                       |                     | 15.0                   | regress_test_role
!  regression             | s6                  | regression                   | foo                       |                     | 16.0                   | regress_test_indirect
!  regression             | s8                  | regression                   | postgresql                |                     |                        | foreign_data_user
!  regression             | t1                  | regression                   | foo                       |                     |                        | regress_test_indirect
!  regression             | t2                  | regression                   | foo                       |                     |                        | regress_test_role
! (7 rows)
! 
! SELECT * FROM information_schema.foreign_server_options ORDER BY 1, 2, 3;
!  foreign_server_catalog | foreign_server_name |   option_name   | option_value 
! ------------------------+---------------------+-----------------+--------------
!  regression             | s4                  | dbname          | b
!  regression             | s4                  | host            | a
!  regression             | s6                  | dbname          | b
!  regression             | s6                  | host            | a
!  regression             | s8                  | connect_timeout | 30
!  regression             | s8                  | dbname          | db1
! (6 rows)
! 
! SELECT * FROM information_schema.user_mappings ORDER BY lower(authorization_identifier), 2, 3;
!  authorization_identifier | foreign_server_catalog | foreign_server_name 
! --------------------------+------------------------+---------------------
!  foreign_data_user        | regression             | s4
!  foreign_data_user        | regression             | s8
!  PUBLIC                   | regression             | s4
!  PUBLIC                   | regression             | s8
!  PUBLIC                   | regression             | t1
!  regress_test_role        | regression             | s5
!  regress_test_role        | regression             | s6
!  regress_test_role        | regression             | t1
! (8 rows)
! 
! SELECT * FROM information_schema.user_mapping_options ORDER BY lower(authorization_identifier), 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name  | option_value 
! --------------------------+------------------------+---------------------+--------------+--------------
!  foreign_data_user        | regression             | s8                  | password     | public
!  PUBLIC                   | regression             | s4                  | this mapping | is public
!  PUBLIC                   | regression             | t1                  | modified     | 1
!  regress_test_role        | regression             | s5                  | modified     | 1
!  regress_test_role        | regression             | s6                  | username     | test
!  regress_test_role        | regression             | t1                  | password     | boo
!  regress_test_role        | regression             | t1                  | username     | bob
! (7 rows)
! 
! SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | foreign_data_user     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
!  foreign_data_user | foreign_data_user     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (4 rows)
! 
! SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | foreign_data_user     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
!  foreign_data_user | foreign_data_user     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (4 rows)
! 
! SELECT * FROM information_schema.foreign_tables ORDER BY 1, 2, 3;
!  foreign_table_catalog | foreign_table_schema | foreign_table_name | foreign_server_catalog | foreign_server_name 
! -----------------------+----------------------+--------------------+------------------------+---------------------
!  regression            | foreign_schema       | foreign_table_1    | regression             | s0
! (1 row)
! 
! SELECT * FROM information_schema.foreign_table_options ORDER BY 1, 2, 3, 4;
!  foreign_table_catalog | foreign_table_schema | foreign_table_name | option_name | option_value 
! -----------------------+----------------------+--------------------+-------------+--------------
!  regression            | foreign_schema       | foreign_table_1    | be quoted   | value
!  regression            | foreign_schema       | foreign_table_1    | escape      | @
!  regression            | foreign_schema       | foreign_table_1    | quote       | ~
! (3 rows)
! 
! SET ROLE regress_test_role;
! SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
! --------------------------+------------------------+---------------------+-------------+--------------
!  PUBLIC                   | regression             | t1                  | modified    | 1
!  regress_test_role        | regression             | s5                  | modified    | 1
!  regress_test_role        | regression             | s6                  | username    | test
!  regress_test_role        | regression             | t1                  | password    | boo
!  regress_test_role        | regression             | t1                  | username    | bob
! (5 rows)
! 
! SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (2 rows)
! 
! SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (2 rows)
! 
! DROP USER MAPPING FOR current_user SERVER t1;
! SET ROLE regress_test_role2;
! SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
! --------------------------+------------------------+---------------------+-------------+--------------
!  regress_test_role        | regression             | s6                  | username    | 
! (1 row)
! 
! RESET ROLE;
! -- has_foreign_data_wrapper_privilege
! SELECT has_foreign_data_wrapper_privilege('regress_test_role',
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege('foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! -- has_server_privilege
! SELECT has_server_privilege('regress_test_role',
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege('s8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! GRANT USAGE ON FOREIGN SERVER s8 TO regress_test_role;
! SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! REVOKE USAGE ON FOREIGN SERVER s8 FROM regress_test_role;
! GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
! DROP USER MAPPING FOR public SERVER s4;
! ALTER SERVER s6 OPTIONS (DROP host, DROP dbname);
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (DROP username);
! ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
! WARNING:  changing the foreign-data wrapper validator can cause the options for dependent objects to become invalid
! -- Privileges
! SET ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
! HINT:  Must be superuser to create a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OWNER TO unprivileged_role;      -- ERROR
! ERROR:  permission denied to change owner of foreign-data wrapper "foo"
! HINT:  Must be superuser to change owner of a foreign-data wrapper.
! DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! ALTER SERVER s4 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER SERVER s4 OWNER TO unprivileged_role;                     -- ERROR
! ERROR:  must be owner of foreign server s4
! DROP SERVER s4;                                                 -- ERROR
! ERROR:  must be owner of foreign server s4
! GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR
! ERROR:  permission denied for foreign server s4
! CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO unprivileged_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO unprivileged_role WITH GRANT OPTION;
! SET ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
! HINT:  Must be superuser to create a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role; -- WARNING
! WARNING:  no privileges were granted for "postgresql"
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
! ALTER SERVER s6 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP SERVER s6;                                                 -- ERROR
! ERROR:  must be owner of foreign server s6
! GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERROR
! ERROR:  permission denied for foreign server s6
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
! CREATE USER MAPPING FOR public SERVER s6;                       -- ERROR
! ERROR:  must be owner of foreign server s6
! CREATE USER MAPPING FOR public SERVER s9;
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
! RESET ROLE;
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM unprivileged_role; -- ERROR
! ERROR:  dependent privileges exist
! HINT:  Use CASCADE to revoke them too.
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM unprivileged_role CASCADE;
! SET ROLE unprivileged_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! CREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! ALTER SERVER s9 VERSION '1.1';
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER s9;
! DROP SERVER s9 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to user mapping for public
! drop cascades to user mapping for unprivileged_role
! RESET ROLE;
! CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
! GRANT USAGE ON FOREIGN SERVER s9 TO unprivileged_role;
! SET ROLE unprivileged_role;
! ALTER SERVER s9 VERSION '1.2';                                  -- ERROR
! ERROR:  must be owner of foreign server s9
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNING
! WARNING:  no privileges were granted for "s9"
! CREATE USER MAPPING FOR current_user SERVER s9;
! DROP SERVER s9 CASCADE;                                         -- ERROR
! ERROR:  must be owner of foreign server s9
! RESET ROLE;
! -- Triggers
! CREATE FUNCTION dummy_trigger() RETURNS TRIGGER AS $$
!   BEGIN
!     RETURN NULL;
!   END
! $$ language plpgsql;
! CREATE TRIGGER trigtest_before_stmt BEFORE INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH STATEMENT
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH STATEMENT
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! ERROR:  "foreign_table_1" is a foreign table
! DETAIL:  Foreign tables cannot have constraint triggers.
! ALTER FOREIGN TABLE foreign_schema.foreign_table_1
! 	DISABLE TRIGGER trigtest_before_stmt;
! ALTER FOREIGN TABLE foreign_schema.foreign_table_1
! 	ENABLE TRIGGER trigtest_before_stmt;
! DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
! DROP FUNCTION dummy_trigger();
! -- IMPORT FOREIGN SCHEMA
! IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public; -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public; --ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public; -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO public
! OPTIONS (option1 'value1', option2 'value2'); -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! -- DROP FOREIGN TABLE
! DROP FOREIGN TABLE no_table;                                    -- ERROR
! ERROR:  foreign table "no_table" does not exist
! DROP FOREIGN TABLE IF EXISTS no_table;
! NOTICE:  foreign table "no_table" does not exist, skipping
! DROP FOREIGN TABLE foreign_schema.foreign_table_1;
! -- Cleanup
! DROP SCHEMA foreign_schema CASCADE;
! DROP ROLE regress_test_role;                                -- ERROR
! ERROR:  role "regress_test_role" cannot be dropped because some objects depend on it
! DETAIL:  privileges for server s4
! privileges for foreign-data wrapper foo
! owner of user mapping for regress_test_role
! owner of user mapping for regress_test_role
! owner of server s5
! owner of server t2
! DROP SERVER s5 CASCADE;
! NOTICE:  drop cascades to user mapping for regress_test_role
! DROP SERVER t1 CASCADE;
! NOTICE:  drop cascades to user mapping for public
! DROP SERVER t2;
! DROP USER MAPPING FOR regress_test_role SERVER s6;
! -- This test causes some order dependent cascade detail output,
! -- so switch to terse mode for it.
! \set VERBOSITY terse
! DROP FOREIGN DATA WRAPPER foo CASCADE;
! NOTICE:  drop cascades to 5 other objects
! \set VERBOSITY default
! DROP SERVER s8 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to user mapping for foreign_data_user
! drop cascades to user mapping for public
! DROP ROLE regress_test_indirect;
! DROP ROLE regress_test_role;
! DROP ROLE unprivileged_role;                                -- ERROR
! ERROR:  role "unprivileged_role" cannot be dropped because some objects depend on it
! DETAIL:  privileges for foreign-data wrapper postgresql
! REVOKE ALL ON FOREIGN DATA WRAPPER postgresql FROM unprivileged_role;
! DROP ROLE unprivileged_role;
! DROP ROLE regress_test_role2;
! DROP FOREIGN DATA WRAPPER postgresql CASCADE;
! DROP FOREIGN DATA WRAPPER dummy CASCADE;
! NOTICE:  drop cascades to server s0
! \c
! DROP ROLE foreign_data_user;
! -- At this point we should have no wrappers, no servers, and no mappings.
! SELECT fdwname, fdwhandler, fdwvalidator, fdwoptions FROM pg_foreign_data_wrapper;
!  fdwname | fdwhandler | fdwvalidator | fdwoptions 
! ---------+------------+--------------+------------
! (0 rows)
! 
! SELECT srvname, srvoptions FROM pg_foreign_server;
!  srvname | srvoptions 
! ---------+------------
! (0 rows)
! 
! SELECT * FROM pg_user_mapping;
!  umuser | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/window.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/window.out	2015-01-10 10:11:47.027649472 +0300
***************
*** 1,1824 ****
! --
! -- WINDOW FUNCTIONS
! --
! CREATE TEMPORARY TABLE empsalary (
!     depname varchar,
!     empno bigint,
!     salary int,
!     enroll_date date
! );
! INSERT INTO empsalary VALUES
! ('develop', 10, 5200, '2007-08-01'),
! ('sales', 1, 5000, '2006-10-01'),
! ('personnel', 5, 3500, '2007-12-10'),
! ('sales', 4, 4800, '2007-08-08'),
! ('personnel', 2, 3900, '2006-12-23'),
! ('develop', 7, 4200, '2008-01-01'),
! ('develop', 9, 4500, '2008-01-01'),
! ('sales', 3, 4800, '2007-08-01'),
! ('develop', 8, 6000, '2006-10-01'),
! ('develop', 11, 5200, '2007-08-15');
! SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;
!   depname  | empno | salary |  sum  
! -----------+-------+--------+-------
!  develop   |     7 |   4200 | 25100
!  develop   |     9 |   4500 | 25100
!  develop   |    11 |   5200 | 25100
!  develop   |    10 |   5200 | 25100
!  develop   |     8 |   6000 | 25100
!  personnel |     5 |   3500 |  7400
!  personnel |     2 |   3900 |  7400
!  sales     |     3 |   4800 | 14600
!  sales     |     4 |   4800 | 14600
!  sales     |     1 |   5000 | 14600
! (10 rows)
! 
! SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;
!   depname  | empno | salary | rank 
! -----------+-------+--------+------
!  develop   |     7 |   4200 |    1
!  develop   |     9 |   4500 |    2
!  develop   |    11 |   5200 |    3
!  develop   |    10 |   5200 |    3
!  develop   |     8 |   6000 |    5
!  personnel |     5 |   3500 |    1
!  personnel |     2 |   3900 |    2
!  sales     |     3 |   4800 |    1
!  sales     |     4 |   4800 |    1
!  sales     |     1 |   5000 |    3
! (10 rows)
! 
! -- with GROUP BY
! SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1
! GROUP BY four, ten ORDER BY four, ten;
!  four | ten | sum  |          avg           
! ------+-----+------+------------------------
!     0 |   0 |    0 | 0.00000000000000000000
!     0 |   2 |    0 |     2.0000000000000000
!     0 |   4 |    0 |     4.0000000000000000
!     0 |   6 |    0 |     6.0000000000000000
!     0 |   8 |    0 |     8.0000000000000000
!     1 |   1 | 2500 | 1.00000000000000000000
!     1 |   3 | 2500 |     3.0000000000000000
!     1 |   5 | 2500 |     5.0000000000000000
!     1 |   7 | 2500 |     7.0000000000000000
!     1 |   9 | 2500 |     9.0000000000000000
!     2 |   0 | 5000 | 0.00000000000000000000
!     2 |   2 | 5000 |     2.0000000000000000
!     2 |   4 | 5000 |     4.0000000000000000
!     2 |   6 | 5000 |     6.0000000000000000
!     2 |   8 | 5000 |     8.0000000000000000
!     3 |   1 | 7500 | 1.00000000000000000000
!     3 |   3 | 7500 |     3.0000000000000000
!     3 |   5 | 7500 |     5.0000000000000000
!     3 |   7 | 7500 |     7.0000000000000000
!     3 |   9 | 7500 |     9.0000000000000000
! (20 rows)
! 
! SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);
!   depname  | empno | salary |  sum  
! -----------+-------+--------+-------
!  develop   |    11 |   5200 | 25100
!  develop   |     7 |   4200 | 25100
!  develop   |     9 |   4500 | 25100
!  develop   |     8 |   6000 | 25100
!  develop   |    10 |   5200 | 25100
!  personnel |     5 |   3500 |  7400
!  personnel |     2 |   3900 |  7400
!  sales     |     3 |   4800 | 14600
!  sales     |     1 |   5000 | 14600
!  sales     |     4 |   4800 | 14600
! (10 rows)
! 
! SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;
!   depname  | empno | salary | rank 
! -----------+-------+--------+------
!  develop   |     7 |   4200 |    1
!  personnel |     5 |   3500 |    1
!  sales     |     3 |   4800 |    1
!  sales     |     4 |   4800 |    1
!  personnel |     2 |   3900 |    2
!  develop   |     9 |   4500 |    2
!  sales     |     1 |   5000 |    3
!  develop   |    11 |   5200 |    3
!  develop   |    10 |   5200 |    3
!  develop   |     8 |   6000 |    5
! (10 rows)
! 
! -- empty window specification
! SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;
!  count 
! -------
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
! (10 rows)
! 
! SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();
!  count 
! -------
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
! (10 rows)
! 
! -- no window operation
! SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);
!  four 
! ------
! (0 rows)
! 
! -- cumulative aggregate
! SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;
!  sum_1 | ten | four 
! -------+-----+------
!      0 |   0 |    0
!      0 |   0 |    0
!      2 |   0 |    2
!      3 |   1 |    3
!      4 |   1 |    1
!      5 |   1 |    1
!      3 |   3 |    3
!      0 |   4 |    0
!      1 |   7 |    1
!      1 |   9 |    1
! (10 rows)
! 
! SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;
!  row_number 
! ------------
!           1
!           2
!           3
!           4
!           5
!           6
!           7
!           8
!           9
!          10
! (10 rows)
! 
! SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;
!  rank_1 | ten | four 
! --------+-----+------
!       1 |   0 |    0
!       1 |   0 |    0
!       3 |   4 |    0
!       1 |   1 |    1
!       1 |   1 |    1
!       3 |   7 |    1
!       4 |   9 |    1
!       1 |   0 |    2
!       1 |   1 |    3
!       2 |   3 |    3
! (10 rows)
! 
! SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  dense_rank | ten | four 
! ------------+-----+------
!           1 |   0 |    0
!           1 |   0 |    0
!           2 |   4 |    0
!           1 |   1 |    1
!           1 |   1 |    1
!           2 |   7 |    1
!           3 |   9 |    1
!           1 |   0 |    2
!           1 |   1 |    3
!           2 |   3 |    3
! (10 rows)
! 
! SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!    percent_rank    | ten | four 
! -------------------+-----+------
!                  0 |   0 |    0
!                  0 |   0 |    0
!                  1 |   4 |    0
!                  0 |   1 |    1
!                  0 |   1 |    1
!  0.666666666666667 |   7 |    1
!                  1 |   9 |    1
!                  0 |   0 |    2
!                  0 |   1 |    3
!                  1 |   3 |    3
! (10 rows)
! 
! SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!      cume_dist     | ten | four 
! -------------------+-----+------
!  0.666666666666667 |   0 |    0
!  0.666666666666667 |   0 |    0
!                  1 |   4 |    0
!                0.5 |   1 |    1
!                0.5 |   1 |    1
!               0.75 |   7 |    1
!                  1 |   9 |    1
!                  1 |   0 |    2
!                0.5 |   1 |    3
!                  1 |   3 |    3
! (10 rows)
! 
! SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;
!  ntile | ten | four 
! -------+-----+------
!      1 |   0 |    0
!      1 |   0 |    0
!      1 |   0 |    2
!      1 |   1 |    1
!      2 |   1 |    1
!      2 |   1 |    3
!      2 |   3 |    3
!      3 |   4 |    0
!      3 |   7 |    1
!      3 |   9 |    1
! (10 rows)
! 
! SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;
!  ntile | ten | four 
! -------+-----+------
!        |   0 |    0
!        |   0 |    0
! (2 rows)
! 
! SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!      |   0 |    0
!    0 |   0 |    0
!    0 |   4 |    0
!      |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!      |   0 |    2
!      |   1 |    3
!    1 |   3 |    3
! (10 rows)
! 
! SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!    0 |   0 |    0
!    0 |   0 |    0
!    4 |   4 |    0
!      |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!      |   0 |    2
!      |   1 |    3
!      |   3 |    3
! (10 rows)
! 
! SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!    0 |   0 |    0
!    0 |   0 |    0
!    4 |   4 |    0
!    0 |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!    0 |   0 |    2
!    0 |   1 |    3
!    0 |   3 |    3
! (10 rows)
! 
! SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     4 |   0 |    0
!       |   4 |    0
!     1 |   1 |    1
!     7 |   1 |    1
!     9 |   7 |    1
!       |   9 |    1
!       |   0 |    2
!     3 |   1 |    3
!       |   3 |    3
! (10 rows)
! 
! SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     8 |   0 |    0
!       |   4 |    0
!     2 |   1 |    1
!    14 |   1 |    1
!    18 |   7 |    1
!       |   9 |    1
!       |   0 |    2
!     6 |   1 |    3
!       |   3 |    3
! (10 rows)
! 
! SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     8 |   0 |    0
!    -1 |   4 |    0
!     2 |   1 |    1
!    14 |   1 |    1
!    18 |   7 |    1
!    -1 |   9 |    1
!    -1 |   0 |    2
!     6 |   1 |    3
!    -1 |   3 |    3
! (10 rows)
! 
! SELECT first_value(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  first_value | ten | four 
! -------------+-----+------
!            0 |   0 |    0
!            0 |   0 |    0
!            0 |   4 |    0
!            1 |   1 |    1
!            1 |   1 |    1
!            1 |   7 |    1
!            1 |   9 |    1
!            0 |   0 |    2
!            1 |   1 |    3
!            1 |   3 |    3
! (10 rows)
! 
! -- last_value returns the last row of the frame, which is CURRENT ROW in ORDER BY window.
! SELECT last_value(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  last_value | ten | four 
! ------------+-----+------
!           0 |   0 |    0
!           0 |   0 |    2
!           0 |   0 |    0
!           1 |   1 |    1
!           1 |   1 |    3
!           1 |   1 |    1
!           3 |   3 |    3
!           0 |   4 |    0
!           1 |   7 |    1
!           1 |   9 |    1
! (10 rows)
! 
! SELECT last_value(ten) OVER (PARTITION BY four), ten, four FROM
! 	(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s
! 	ORDER BY four, ten;
!  last_value | ten | four 
! ------------+-----+------
!           4 |   0 |    0
!           4 |   0 |    0
!           4 |   4 |    0
!           9 |   1 |    1
!           9 |   1 |    1
!           9 |   7 |    1
!           9 |   9 |    1
!           0 |   0 |    2
!           3 |   1 |    3
!           3 |   3 |    3
! (10 rows)
! 
! SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four
! 	FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;
!  nth_value | ten | four 
! -----------+-----+------
!          0 |   0 |    0
!          0 |   0 |    0
!          0 |   4 |    0
!          1 |   1 |    1
!          1 |   1 |    1
!          1 |   7 |    1
!          1 |   9 |    1
!            |   0 |    2
!            |   1 |    3
!            |   3 |    3
! (10 rows)
! 
! SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum
! FROM tenk1 GROUP BY ten, two;
!  ten | two | gsum  |  wsum  
! -----+-----+-------+--------
!    0 |   0 | 45000 |  45000
!    2 |   0 | 47000 |  92000
!    4 |   0 | 49000 | 141000
!    6 |   0 | 51000 | 192000
!    8 |   0 | 53000 | 245000
!    1 |   1 | 46000 |  46000
!    3 |   1 | 48000 |  94000
!    5 |   1 | 50000 | 144000
!    7 |   1 | 52000 | 196000
!    9 |   1 | 54000 | 250000
! (10 rows)
! 
! SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;
!  count | four 
! -------+------
!      4 |    1
!      4 |    1
!      4 |    1
!      4 |    1
!      2 |    3
!      2 |    3
! (6 rows)
! 
! SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +
!   sum(hundred) OVER (PARTITION BY four ORDER BY ten))::varchar AS cntsum
!   FROM tenk1 WHERE unique2 < 10;
!  cntsum 
! --------
!  22
!  22
!  87
!  24
!  24
!  82
!  92
!  51
!  92
!  136
! (10 rows)
! 
! -- opexpr with different windows evaluation.
! SELECT * FROM(
!   SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +
!     sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,
!     count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,
!     sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum
!     FROM tenk1
! )sub
! WHERE total <> fourcount + twosum;
!  total | fourcount | twosum 
! -------+-----------+--------
! (0 rows)
! 
! SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;
!           avg           
! ------------------------
!  0.00000000000000000000
!  0.00000000000000000000
!  0.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!      2.0000000000000000
!      3.0000000000000000
!      3.0000000000000000
! (10 rows)
! 
! SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum
! FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);
!  ten | two | gsum  |  wsum  
! -----+-----+-------+--------
!    0 |   0 | 45000 |  45000
!    2 |   0 | 47000 |  92000
!    4 |   0 | 49000 | 141000
!    6 |   0 | 51000 | 192000
!    8 |   0 | 53000 | 245000
!    1 |   1 | 46000 |  46000
!    3 |   1 | 48000 |  94000
!    5 |   1 | 50000 | 144000
!    7 |   1 | 52000 | 196000
!    9 |   1 | 54000 | 250000
! (10 rows)
! 
! -- more than one window with GROUP BY
! SELECT sum(salary),
! 	row_number() OVER (ORDER BY depname),
! 	sum(sum(salary)) OVER (ORDER BY depname DESC)
! FROM empsalary GROUP BY depname;
!   sum  | row_number |  sum  
! -------+------------+-------
!  14600 |          3 | 14600
!   7400 |          2 | 22000
!  25100 |          1 | 47100
! (3 rows)
! 
! -- identical windows with different names
! SELECT sum(salary) OVER w1, count(*) OVER w2
! FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);
!   sum  | count 
! -------+-------
!   3500 |     1
!   7400 |     2
!  11600 |     3
!  16100 |     4
!  25700 |     6
!  25700 |     6
!  30700 |     7
!  41100 |     9
!  41100 |     9
!  47100 |    10
! (10 rows)
! 
! -- subplan
! SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)
! FROM tenk1 s WHERE unique2 < 10;
!  lead 
! ------
!     0
!     0
!     4
!     1
!     7
!     9
!      
!     0
!     3
!      
! (10 rows)
! 
! -- empty table
! SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;
!  count 
! -------
! (0 rows)
! 
! -- mixture of agg/wfunc in the same window
! SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
!   sum  | rank 
! -------+------
!   6000 |    1
!  16400 |    2
!  16400 |    2
!  20900 |    4
!  25100 |    5
!   3900 |    1
!   7400 |    2
!   5000 |    1
!  14600 |    2
!  14600 |    2
! (10 rows)
! 
! -- strict aggs
! SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(
! 	SELECT *,
! 		CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(YEAR FROM enroll_date) END * 500 AS bonus,
! 		CASE WHEN
! 			AVG(salary) OVER (PARTITION BY depname) < salary
! 		THEN 200 END AS depadj FROM empsalary
! )s;
!  empno |  depname  | salary | bonus | depadj | min  | max 
! -------+-----------+--------+-------+--------+------+-----
!      1 | sales     |   5000 |  1000 |    200 | 1000 | 200
!      2 | personnel |   3900 |  1000 |    200 | 1000 | 200
!      3 | sales     |   4800 |   500 |        |  500 | 200
!      4 | sales     |   4800 |   500 |        |  500 | 200
!      5 | personnel |   3500 |   500 |        |  500 | 200
!      7 | develop   |   4200 |       |        |  500 | 200
!      8 | develop   |   6000 |  1000 |    200 |  500 | 200
!      9 | develop   |   4500 |       |        |  500 | 200
!     10 | develop   |   5200 |   500 |    200 |  500 | 200
!     11 | develop   |   5200 |   500 |    200 |  500 | 200
! (10 rows)
! 
! -- window function over ungrouped agg over empty row set (bug before 9.1)
! SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;
!  sum 
! -----
!    0
! (1 row)
! 
! -- window function with ORDER BY an expression involving aggregates (9.1 bug)
! select ten,
!   sum(unique1) + sum(unique2) as res,
!   rank() over (order by sum(unique1) + sum(unique2)) as rank
! from tenk1
! group by ten order by ten;
!  ten |   res    | rank 
! -----+----------+------
!    0 |  9976146 |    4
!    1 | 10114187 |    9
!    2 | 10059554 |    8
!    3 |  9878541 |    1
!    4 |  9881005 |    2
!    5 |  9981670 |    5
!    6 |  9947099 |    3
!    7 | 10120309 |   10
!    8 |  9991305 |    6
!    9 | 10040184 |    7
! (10 rows)
! 
! -- window and aggregate with GROUP BY expression (9.2 bug)
! explain (costs off)
! select first_value(max(x)) over (), y
!   from (select unique1 as x, ten+four as y from tenk1) ss
!   group by y;
!                  QUERY PLAN                  
! ---------------------------------------------
!  WindowAgg
!    ->  HashAggregate
!          Group Key: (tenk1.ten + tenk1.four)
!          ->  Seq Scan on tenk1
! (4 rows)
! 
! -- test non-default frame specifications
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten),
! 	last_value(ten) over (partition by four order by ten)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   2 |   2 |          2
!     0 |   4 |   6 |          4
!     0 |   6 |  12 |          6
!     0 |   8 |  20 |          8
!     1 |   1 |   1 |          1
!     1 |   3 |   4 |          3
!     1 |   5 |   9 |          5
!     1 |   7 |  16 |          7
!     1 |   9 |  25 |          9
!     2 |   0 |   0 |          0
!     2 |   2 |   2 |          2
!     2 |   4 |   6 |          4
!     2 |   6 |  12 |          6
!     2 |   8 |  20 |          8
!     3 |   1 |   1 |          1
!     3 |   3 |   4 |          3
!     3 |   5 |   9 |          5
!     3 |   7 |  16 |          7
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten range between unbounded preceding and current row),
! 	last_value(ten) over (partition by four order by ten range between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   2 |   2 |          2
!     0 |   4 |   6 |          4
!     0 |   6 |  12 |          6
!     0 |   8 |  20 |          8
!     1 |   1 |   1 |          1
!     1 |   3 |   4 |          3
!     1 |   5 |   9 |          5
!     1 |   7 |  16 |          7
!     1 |   9 |  25 |          9
!     2 |   0 |   0 |          0
!     2 |   2 |   2 |          2
!     2 |   4 |   6 |          4
!     2 |   6 |  12 |          6
!     2 |   8 |  20 |          8
!     3 |   1 |   1 |          1
!     3 |   3 |   4 |          3
!     3 |   5 |   9 |          5
!     3 |   7 |  16 |          7
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),
! 	last_value(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |  20 |          8
!     0 |   2 |  20 |          8
!     0 |   4 |  20 |          8
!     0 |   6 |  20 |          8
!     0 |   8 |  20 |          8
!     1 |   1 |  25 |          9
!     1 |   3 |  25 |          9
!     1 |   5 |  25 |          9
!     1 |   7 |  25 |          9
!     1 |   9 |  25 |          9
!     2 |   0 |  20 |          8
!     2 |   2 |  20 |          8
!     2 |   4 |  20 |          8
!     2 |   6 |  20 |          8
!     2 |   8 |  20 |          8
!     3 |   1 |  25 |          9
!     3 |   3 |  25 |          9
!     3 |   5 |  25 |          9
!     3 |   7 |  25 |          9
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten/4 as two,
! 	sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),
! 	last_value(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | two | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   0 |   0 |          0
!     0 |   1 |   2 |          1
!     0 |   1 |   2 |          1
!     0 |   2 |   4 |          2
!     1 |   0 |   0 |          0
!     1 |   0 |   0 |          0
!     1 |   1 |   2 |          1
!     1 |   1 |   2 |          1
!     1 |   2 |   4 |          2
!     2 |   0 |   0 |          0
!     2 |   0 |   0 |          0
!     2 |   1 |   2 |          1
!     2 |   1 |   2 |          1
!     2 |   2 |   4 |          2
!     3 |   0 |   0 |          0
!     3 |   0 |   0 |          0
!     3 |   1 |   2 |          1
!     3 |   1 |   2 |          1
!     3 |   2 |   4 |          2
! (20 rows)
! 
! SELECT four, ten/4 as two,
! 	sum(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row),
! 	last_value(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | two | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   0 |   0 |          0
!     0 |   1 |   1 |          1
!     0 |   1 |   2 |          1
!     0 |   2 |   4 |          2
!     1 |   0 |   0 |          0
!     1 |   0 |   0 |          0
!     1 |   1 |   1 |          1
!     1 |   1 |   2 |          1
!     1 |   2 |   4 |          2
!     2 |   0 |   0 |          0
!     2 |   0 |   0 |          0
!     2 |   1 |   1 |          1
!     2 |   1 |   2 |          1
!     2 |   2 |   4 |          2
!     3 |   0 |   0 |          0
!     3 |   0 |   0 |          0
!     3 |   1 |   1 |          1
!     3 |   1 |   2 |          1
!     3 |   2 |   4 |          2
! (20 rows)
! 
! SELECT sum(unique1) over (order by four range between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!   45 |       0 |    0
!   45 |       8 |    0
!   45 |       4 |    0
!   33 |       5 |    1
!   33 |       9 |    1
!   33 |       1 |    1
!   18 |       6 |    2
!   18 |       2 |    2
!   10 |       3 |    3
!   10 |       7 |    3
! (10 rows)
! 
! SELECT sum(unique1) over (rows between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!   45 |       4 |    0
!   41 |       2 |    2
!   39 |       1 |    1
!   38 |       6 |    2
!   32 |       9 |    1
!   23 |       8 |    0
!   15 |       5 |    1
!   10 |       3 |    3
!    7 |       7 |    3
!    0 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 2 preceding and 2 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    7 |       4 |    0
!   13 |       2 |    2
!   22 |       1 |    1
!   26 |       6 |    2
!   29 |       9 |    1
!   31 |       8 |    0
!   32 |       5 |    1
!   23 |       3 |    3
!   15 |       7 |    3
!   10 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 2 preceding and 1 preceding),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!      |       4 |    0
!    4 |       2 |    2
!    6 |       1 |    1
!    3 |       6 |    2
!    7 |       9 |    1
!   15 |       8 |    0
!   17 |       5 |    1
!   13 |       3 |    3
!    8 |       7 |    3
!   10 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 1 following and 3 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    9 |       4 |    0
!   16 |       2 |    2
!   23 |       1 |    1
!   22 |       6 |    2
!   16 |       9 |    1
!   15 |       8 |    0
!   10 |       5 |    1
!    7 |       3 |    3
!    0 |       7 |    3
!      |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between unbounded preceding and 1 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    6 |       4 |    0
!    7 |       2 |    2
!   13 |       1 |    1
!   22 |       6 |    2
!   30 |       9 |    1
!   35 |       8 |    0
!   38 |       5 |    1
!   45 |       3 |    3
!   45 |       7 |    3
!   45 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (w range between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
!  sum | unique1 | four 
! -----+---------+------
!   45 |       0 |    0
!   45 |       8 |    0
!   45 |       4 |    0
!   33 |       5 |    1
!   33 |       9 |    1
!   33 |       1 |    1
!   18 |       6 |    2
!   18 |       2 |    2
!   10 |       3 |    3
!   10 |       7 |    3
! (10 rows)
! 
! -- fail: not implemented yet
! SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
! ERROR:  RANGE PRECEDING is only supported with UNBOUNDED
! LINE 1: SELECT sum(unique1) over (order by four range between 2::int...
!                                                 ^
! SELECT first_value(unique1) over w,
! 	nth_value(unique1, 2) over w AS nth_2,
! 	last_value(unique1) over w, unique1, four
! FROM tenk1 WHERE unique1 < 10
! WINDOW w AS (order by four range between current row and unbounded following);
!  first_value | nth_2 | last_value | unique1 | four 
! -------------+-------+------------+---------+------
!            0 |     8 |          7 |       0 |    0
!            0 |     8 |          7 |       8 |    0
!            0 |     8 |          7 |       4 |    0
!            5 |     9 |          7 |       5 |    1
!            5 |     9 |          7 |       9 |    1
!            5 |     9 |          7 |       1 |    1
!            6 |     2 |          7 |       6 |    2
!            6 |     2 |          7 |       2 |    2
!            3 |     7 |          7 |       3 |    3
!            3 |     7 |          7 |       7 |    3
! (10 rows)
! 
! SELECT sum(unique1) over
! 	(order by unique1
! 	 rows (SELECT unique1 FROM tenk1 ORDER BY unique1 LIMIT 1) + 1 PRECEDING),
! 	unique1
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 
! -----+---------
!    0 |       0
!    1 |       1
!    3 |       2
!    5 |       3
!    7 |       4
!    9 |       5
!   11 |       6
!   13 |       7
!   15 |       8
!   17 |       9
! (10 rows)
! 
! CREATE TEMP VIEW v_window AS
! 	SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following) as sum_rows
! 	FROM generate_series(1, 10) i;
! SELECT * FROM v_window;
!  i  | sum_rows 
! ----+----------
!   1 |        3
!   2 |        6
!   3 |        9
!   4 |       12
!   5 |       15
!   6 |       18
!   7 |       21
!   8 |       24
!   9 |       27
!  10 |       19
! (10 rows)
! 
! SELECT pg_get_viewdef('v_window');
!                                     pg_get_viewdef                                     
! ---------------------------------------------------------------------------------------
!   SELECT i.i,                                                                         +
!      sum(i.i) OVER (ORDER BY i.i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS sum_rows+
!     FROM generate_series(1, 10) i(i);
! (1 row)
! 
! -- with UNION
! SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 UNION ALL SELECT * FROM tenk2)s LIMIT 0;
!  count 
! -------
! (0 rows)
! 
! -- ordering by a non-integer constant is allowed
! SELECT rank() OVER (ORDER BY length('abc'));
!  rank 
! ------
!     1
! (1 row)
! 
! -- can't order by another window function
! SELECT rank() OVER (ORDER BY rank() OVER (ORDER BY random()));
! ERROR:  window functions are not allowed in window definitions
! LINE 1: SELECT rank() OVER (ORDER BY rank() OVER (ORDER BY random())...
!                                      ^
! -- some other errors
! SELECT * FROM empsalary WHERE row_number() OVER (ORDER BY salary) < 10;
! ERROR:  window functions are not allowed in WHERE
! LINE 1: SELECT * FROM empsalary WHERE row_number() OVER (ORDER BY sa...
!                                       ^
! SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVER (ORDER BY salary) < 10;
! ERROR:  window functions are not allowed in JOIN conditions
! LINE 1: SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVE...
!                                                     ^
! SELECT rank() OVER (ORDER BY 1), count(*) FROM empsalary GROUP BY 1;
! ERROR:  window functions are not allowed in GROUP BY
! LINE 1: SELECT rank() OVER (ORDER BY 1), count(*) FROM empsalary GRO...
!                ^
! SELECT * FROM rank() OVER (ORDER BY random());
! ERROR:  syntax error at or near "ORDER"
! LINE 1: SELECT * FROM rank() OVER (ORDER BY random());
!                                    ^
! DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())) > 10;
! ERROR:  window functions are not allowed in WHERE
! LINE 1: DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())...
!                                      ^
! DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random());
! ERROR:  window functions are not allowed in RETURNING
! LINE 1: DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random...
!                                         ^
! SELECT count(*) OVER w FROM tenk1 WINDOW w AS (ORDER BY unique1), w AS (ORDER BY unique1);
! ERROR:  window "w" is already defined
! LINE 1: ...w FROM tenk1 WINDOW w AS (ORDER BY unique1), w AS (ORDER BY ...
!                                                              ^
! SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM tenk1;
! ERROR:  syntax error at or near "ORDER"
! LINE 1: SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM te...
!                                                ^
! SELECT count() OVER () FROM tenk1;
! ERROR:  count(*) must be used to call a parameterless aggregate function
! LINE 1: SELECT count() OVER () FROM tenk1;
!                ^
! SELECT generate_series(1, 100) OVER () FROM empsalary;
! ERROR:  OVER specified, but generate_series is not a window function nor an aggregate function
! LINE 1: SELECT generate_series(1, 100) OVER () FROM empsalary;
!                ^
! SELECT ntile(0) OVER (ORDER BY ten), ten, four FROM tenk1;
! ERROR:  argument of ntile must be greater than zero
! SELECT nth_value(four, 0) OVER (ORDER BY ten), ten, four FROM tenk1;
! ERROR:  argument of nth_value must be greater than zero
! -- filter
! SELECT sum(salary), row_number() OVER (ORDER BY depname), sum(
!     sum(salary) FILTER (WHERE enroll_date > '2007-01-01')
! ) FILTER (WHERE depname <> 'sales') OVER (ORDER BY depname DESC) AS "filtered_sum",
!     depname
! FROM empsalary GROUP BY depname;
!   sum  | row_number | filtered_sum |  depname  
! -------+------------+--------------+-----------
!  14600 |          3 |              | sales
!   7400 |          2 |         3500 | personnel
!  25100 |          1 |        22600 | develop
! (3 rows)
! 
! -- Test pushdown of quals into a subquery containing window functions
! -- pushdown is safe because all PARTITION BY clauses include depname:
! EXPLAIN (COSTS OFF)
! SELECT * FROM
!   (SELECT depname,
!           sum(salary) OVER (PARTITION BY depname) depsalary,
!           min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary
!    FROM empsalary) emp
! WHERE depname = 'sales';
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Subquery Scan on emp
!    ->  WindowAgg
!          ->  Sort
!                Sort Key: (((empsalary.depname)::text || 'A'::text))
!                ->  WindowAgg
!                      ->  Seq Scan on empsalary
!                            Filter: ((depname)::text = 'sales'::text)
! (7 rows)
! 
! -- pushdown is unsafe because there's a PARTITION BY clause without depname:
! EXPLAIN (COSTS OFF)
! SELECT * FROM
!   (SELECT depname,
!           sum(salary) OVER (PARTITION BY enroll_date) enroll_salary,
!           min(salary) OVER (PARTITION BY depname) depminsalary
!    FROM empsalary) emp
! WHERE depname = 'sales';
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Subquery Scan on emp
!    Filter: ((emp.depname)::text = 'sales'::text)
!    ->  WindowAgg
!          ->  Sort
!                Sort Key: empsalary.depname
!                ->  WindowAgg
!                      ->  Sort
!                            Sort Key: empsalary.enroll_date
!                            ->  Seq Scan on empsalary
! (9 rows)
! 
! -- cleanup
! DROP TABLE empsalary;
! -- test user-defined window function with named args and default args
! CREATE FUNCTION nth_value_def(val anyelement, n integer = 1) RETURNS anyelement
!   LANGUAGE internal WINDOW IMMUTABLE STRICT AS 'window_nth_value';
! SELECT nth_value_def(n := 2, val := ten) OVER (PARTITION BY four), ten, four
!   FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
!  nth_value_def | ten | four 
! ---------------+-----+------
!              0 |   0 |    0
!              0 |   0 |    0
!              0 |   4 |    0
!              1 |   1 |    1
!              1 |   1 |    1
!              1 |   7 |    1
!              1 |   9 |    1
!                |   0 |    2
!              3 |   1 |    3
!              3 |   3 |    3
! (10 rows)
! 
! SELECT nth_value_def(ten) OVER (PARTITION BY four), ten, four
!   FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
!  nth_value_def | ten | four 
! ---------------+-----+------
!              0 |   0 |    0
!              0 |   0 |    0
!              0 |   4 |    0
!              1 |   1 |    1
!              1 |   1 |    1
!              1 |   7 |    1
!              1 |   9 |    1
!              0 |   0 |    2
!              1 |   1 |    3
!              1 |   3 |    3
! (10 rows)
! 
! --
! -- Test the basic moving-aggregate machinery
! --
! -- create aggregates that record the series of transform calls (these are
! -- intentionally not true inverses)
! CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '-' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE AGGREGATE logging_agg_nonstrict (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_nonstrict,
! 	mstype = text,
! 	msfunc = logging_msfunc_nonstrict,
! 	minvfunc = logging_minvfunc_nonstrict
! );
! CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_nonstrict,
! 	mstype = text,
! 	msfunc = logging_msfunc_nonstrict,
! 	minvfunc = logging_minvfunc_nonstrict,
! 	initcond = 'I',
! 	minitcond = 'MI'
! );
! CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '*' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '+' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '-' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE AGGREGATE logging_agg_strict (text)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_strict,
! 	mstype = text,
! 	msfunc = logging_msfunc_strict,
! 	minvfunc = logging_minvfunc_strict
! );
! CREATE AGGREGATE logging_agg_strict_initcond (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_strict,
! 	mstype = text,
! 	msfunc = logging_msfunc_strict,
! 	minvfunc = logging_minvfunc_strict,
! 	initcond = 'I',
! 	minitcond = 'MI'
! );
! -- test strict and non-strict cases
! SELECT
! 	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row,
! 	logging_agg_nonstrict(v) over wnd as nstrict,
! 	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init,
! 	logging_agg_strict(v::text) over wnd as strict,
! 	logging_agg_strict_initcond(v) over wnd as strict_init
! FROM (VALUES
! 	(1, 1, NULL),
! 	(1, 2, 'a'),
! 	(1, 3, 'b'),
! 	(1, 4, NULL),
! 	(1, 5, NULL),
! 	(1, 6, 'c'),
! 	(2, 1, NULL),
! 	(2, 2, 'x'),
! 	(3, 1, 'z')
! ) AS t(p, i, v)
! WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY p, i;
!    row    |                    nstrict                    |                  nstrict_init                   |  strict   |  strict_init   
! ----------+-----------------------------------------------+-------------------------------------------------+-----------+----------------
!  1,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
!  1,2:a    | +NULL+'a'                                     | MI+NULL+'a'                                     | a         | MI+'a'
!  1,3:b    | +NULL+'a'-NULL+'b'                            | MI+NULL+'a'-NULL+'b'                            | a+'b'     | MI+'a'+'b'
!  1,4:NULL | +NULL+'a'-NULL+'b'-'a'+NULL                   | MI+NULL+'a'-NULL+'b'-'a'+NULL                   | a+'b'-'a' | MI+'a'+'b'-'a'
!  1,5:NULL | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          |           | MI
!  1,6:c    | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | c         | MI+'c'
!  2,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
!  2,2:x    | +NULL+'x'                                     | MI+NULL+'x'                                     | x         | MI+'x'
!  3,1:z    | +'z'                                          | MI+'z'                                          | z         | MI+'z'
! (9 rows)
! 
! -- and again, but with filter
! SELECT
! 	p::text || ',' || i::text || ':' ||
! 		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row,
! 	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt,
! 	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt,
! 	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt,
! 	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filt
! FROM (VALUES
! 	(1, 1, true,  NULL),
! 	(1, 2, false, 'a'),
! 	(1, 3, true,  'b'),
! 	(1, 4, false, NULL),
! 	(1, 5, false, NULL),
! 	(1, 6, false, 'c'),
! 	(2, 1, false, NULL),
! 	(2, 2, true,  'x'),
! 	(3, 1, true,  'z')
! ) AS t(p, i, f, v)
! WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY p, i;
!    row    | nstrict_filt | nstrict_init_filt | strict_filt | strict_init_filt 
! ----------+--------------+-------------------+-------------+------------------
!  1,1:NULL | +NULL        | MI+NULL           |             | MI
!  1,2:-    | +NULL        | MI+NULL           |             | MI
!  1,3:b    | +'b'         | MI+'b'            | b           | MI+'b'
!  1,4:-    | +'b'         | MI+'b'            | b           | MI+'b'
!  1,5:-    |              | MI                |             | MI
!  1,6:-    |              | MI                |             | MI
!  2,1:-    |              | MI                |             | MI
!  2,2:x    | +'x'         | MI+'x'            | x           | MI+'x'
!  3,1:z    | +'z'         | MI+'z'            | z           | MI+'z'
! (9 rows)
! 
! -- test that volatile arguments disable moving-aggregate mode
! SELECT
! 	i::text || ':' || COALESCE(v::text, 'NULL') as row,
! 	logging_agg_strict(v::text)
! 		over wnd as inverse,
! 	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END)
! 		over wnd as noinverse
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY i;
!  row |    inverse    | noinverse 
! -----+---------------+-----------
!  1:a | a             | a
!  2:b | a+'b'         | a*'b'
!  3:c | a+'b'-'a'+'c' | b*'c'
! (3 rows)
! 
! SELECT
! 	i::text || ':' || COALESCE(v::text, 'NULL') as row,
! 	logging_agg_strict(v::text) filter(where true)
! 		over wnd as inverse,
! 	logging_agg_strict(v::text) filter(where random() >= 0)
! 		over wnd as noinverse
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY i;
!  row |    inverse    | noinverse 
! -----+---------------+-----------
!  1:a | a             | a
!  2:b | a+'b'         | a*'b'
!  3:c | a+'b'-'a'+'c' | b*'c'
! (3 rows)
! 
! -- test that non-overlapping windows don't use inverse transitions
! SELECT
! 	logging_agg_strict(v::text) OVER wnd
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
! ORDER BY i;
!  logging_agg_strict 
! --------------------
!  a
!  b
!  c
! (3 rows)
! 
! -- test that returning NULL from the inverse transition functions
! -- restarts the aggregation from scratch. The second aggregate is supposed
! -- to test cases where only some aggregates restart, the third one checks
! -- that one aggregate restarting doesn't cause others to restart.
! CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS
! $$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$
! LANGUAGE SQL STRICT;
! CREATE AGGREGATE sum_int_randomrestart (int4)
! (
! 	stype = int4,
! 	sfunc = int4pl,
! 	mstype = int4,
! 	msfunc = int4pl,
! 	minvfunc = sum_int_randrestart_minvfunc
! );
! WITH
! vs AS (
! 	SELECT i, (random() * 100)::int4 AS v
! 	FROM generate_series(1, 100) AS i
! ),
! sum_following AS (
! 	SELECT i, SUM(v) OVER
! 		(ORDER BY i DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s
! 	FROM vs
! )
! SELECT DISTINCT
! 	sum_following.s = sum_int_randomrestart(v) OVER fwd AS eq1,
! 	-sum_following.s = sum_int_randomrestart(-v) OVER fwd AS eq2,
! 	100*3+(vs.i-1)*3 = length(logging_agg_nonstrict(''::text) OVER fwd) AS eq3
! FROM vs
! JOIN sum_following ON sum_following.i = vs.i
! WINDOW fwd AS (
! 	ORDER BY vs.i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
! );
!  eq1 | eq2 | eq3 
! -----+-----+-----
!  t   | t   | t
! (1 row)
! 
! --
! -- Test various built-in aggregates that have moving-aggregate support
! --
! -- test inverse transition functions handle NULLs properly
! SELECT i,AVG(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.5),(2,2.5),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 2.0000000000000000
!  2 | 2.5000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
!  i |    avg     
! ---+------------
!  1 | @ 1.5 secs
!  2 | @ 2 secs
!  3 | 
!  4 | 
! (4 rows)
! 
! SELECT i,SUM(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::money) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1.10'),(2,'2.20'),(3,NULL),(4,NULL)) t(i,v);
!  i |  sum  
! ---+-------
!  1 | $3.30
!  2 | $2.20
!  3 |      
!  4 |      
! (4 rows)
! 
! SELECT i,SUM(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
!  i |   sum    
! ---+----------
!  1 | @ 3 secs
!  2 | @ 2 secs
!  3 | 
!  4 | 
! (4 rows)
! 
! SELECT i,SUM(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.1),(2,2.2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 | 3.3
!  2 | 2.2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT SUM(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.01),(2,2),(3,3)) v(i,n);
!  sum  
! ------
!  6.01
!     5
!     3
! (3 rows)
! 
! SELECT i,COUNT(v) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | count 
! ---+-------
!  1 |     2
!  2 |     1
!  3 |     0
!  4 |     0
! (4 rows)
! 
! SELECT i,COUNT(*) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | count 
! ---+-------
!  1 |     4
!  2 |     3
!  3 |     2
!  4 |     1
! (4 rows)
! 
! SELECT VAR_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT STDDEV_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! -- test that inverse transition functions work with various frame options
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   1
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,3),(4,4)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   6
!  3 |   9
!  4 |   7
! (4 rows)
! 
! -- ensure aggregate over numeric properly recovers from NaN values
! SELECT a, b,
!        SUM(b) OVER(ORDER BY A ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! FROM (VALUES(1,1::numeric),(2,2),(3,'NaN'),(4,3),(5,4)) t(a,b);
!  a |  b  | sum 
! ---+-----+-----
!  1 |   1 |   1
!  2 |   2 |   3
!  3 | NaN | NaN
!  4 |   3 | NaN
!  5 |   4 |   7
! (5 rows)
! 
! -- It might be tempting for someone to add an inverse trans function for
! -- float and double precision. This should not be done as it can give incorrect
! -- results. This test should fail if anyone ever does this without thinking too
! -- hard about it.
! SELECT to_char(SUM(n::float8) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING),'999999999999999999999D9')
!   FROM (VALUES(1,1e20),(2,1)) n(i,n);
!          to_char          
! --------------------------
!   100000000000000000000
!                       1.0
! (2 rows)
! 
! SELECT i, b, bool_and(b) OVER w, bool_or(b) OVER w
!   FROM (VALUES (1,true), (2,true), (3,false), (4,false), (5,true)) v(i,b)
!   WINDOW w AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING);
!  i | b | bool_and | bool_or 
! ---+---+----------+---------
!  1 | t | t        | t
!  2 | t | f        | t
!  3 | f | f        | f
!  4 | f | f        | t
!  5 | t | t        | t
! (5 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/xmlmap_1.out	2014-11-21 01:48:04.367437000 +0300
--- /home/orion/postgres/src/test/regress/results/xmlmap.out	2015-01-10 10:11:47.027649472 +0300
***************
*** 1,125 ****
! CREATE SCHEMA testxmlschema;
! CREATE TABLE testxmlschema.test1 (a int, b text);
! INSERT INTO testxmlschema.test1 VALUES (1, 'one'), (2, 'two'), (-1, null);
! CREATE DOMAIN testxmldomain AS varchar;
! CREATE TABLE testxmlschema.test2 (z int, y varchar(500), x char(6), w numeric(9,2), v smallint, u bigint, t real, s time, r timestamp, q date, p xml, o testxmldomain, n bool, m bytea, aaa text);
! ALTER TABLE testxmlschema.test2 DROP COLUMN aaa;
! INSERT INTO testxmlschema.test2 VALUES (55, 'abc', 'def', 98.6, 2, 999, 0, '21:07', '2009-06-08 21:07:30', '2009-06-08', NULL, 'ABC', true, 'XYZ');
! SELECT table_to_xml('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', true, false, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test2', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', false, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test2', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xml('SELECT * FROM testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xmlschema('SELECT * FROM testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xml_and_xmlschema('SELECT * FROM testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
! SELECT cursor_to_xml('xc'::refcursor, 5, false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! MOVE FIRST IN xc;
! SELECT cursor_to_xml('xc'::refcursor, 5, true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT cursor_to_xmlschema('xc'::refcursor, true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml('testxmlschema', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml('testxmlschema', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xmlschema('testxmlschema', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xmlschema('testxmlschema', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml_and_xmlschema('testxmlschema', true, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- test that domains are transformed like their base types
! CREATE DOMAIN testboolxmldomain AS bool;
! CREATE DOMAIN testdatexmldomain AS date;
! CREATE TABLE testxmlschema.test3
!     AS SELECT true c1,
!               true::testboolxmldomain c2,
!               '2013-02-21'::date c3,
!               '2013-02-21'::testdatexmldomain c4;
! SELECT xmlforest(c1, c2, c3, c4) FROM testxmlschema.test3;
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test3', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/functional_deps.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/functional_deps.out	2015-01-10 10:11:47.031649472 +0300
***************
*** 1,232 ****
! -- from http://www.depesz.com/index.php/2010/04/19/getting-unique-elements/
! CREATE TEMP TABLE articles (
!     id int CONSTRAINT articles_pkey PRIMARY KEY,
!     keywords text,
!     title text UNIQUE NOT NULL,
!     body text UNIQUE,
!     created date
! );
! CREATE TEMP TABLE articles_in_category (
!     article_id int,
!     category_id int,
!     changed date,
!     PRIMARY KEY (article_id, category_id)
! );
! -- test functional dependencies based on primary keys/unique constraints
! -- base tables
! -- group by primary key (OK)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by unique not null (fail/todo)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY title;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- group by unique nullable (fail)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY body;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- group by something else (fail)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY keywords;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- multiple tables
! -- group by primary key (OK)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a, articles_in_category AS aic
! WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
! GROUP BY a.id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by something else (fail)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a, articles_in_category AS aic
! WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id, aic.category_id;
! ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
!                ^
! -- JOIN syntax
! -- group by left table's primary key (OK)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY a.id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by something else (fail)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id, aic.category_id;
! ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
!                ^
! -- group by right table's (composite) primary key (OK)
! SELECT aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.category_id, aic.article_id;
!  changed 
! ---------
! (0 rows)
! 
! -- group by right table's partial primary key (fail)
! SELECT aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id;
! ERROR:  column "aic.changed" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT aic.changed
!                ^
! -- example from documentation
! CREATE TEMP TABLE products (product_id int, name text, price numeric);
! CREATE TEMP TABLE sales (product_id int, units int);
! -- OK
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id, p.name, p.price;
!  product_id | name | sales 
! ------------+------+-------
! (0 rows)
! 
! -- fail
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id;
! ERROR:  column "p.name" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!                            ^
! ALTER TABLE products ADD PRIMARY KEY (product_id);
! -- OK now
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id;
!  product_id | name | sales 
! ------------+------+-------
! (0 rows)
! 
! -- Drupal example, http://drupal.org/node/555530
! CREATE TEMP TABLE node (
!     nid SERIAL,
!     vid integer NOT NULL default '0',
!     type varchar(32) NOT NULL default '',
!     title varchar(128) NOT NULL default '',
!     uid integer NOT NULL default '0',
!     status integer NOT NULL default '1',
!     created integer NOT NULL default '0',
!     -- snip
!     PRIMARY KEY (nid, vid)
! );
! CREATE TEMP TABLE users (
!     uid integer NOT NULL default '0',
!     name varchar(60) NOT NULL default '',
!     pass varchar(32) NOT NULL default '',
!     -- snip
!     PRIMARY KEY (uid),
!     UNIQUE (name)
! );
! -- OK
! SELECT u.uid, u.name FROM node n
! INNER JOIN users u ON u.uid = n.uid
! WHERE n.type = 'blog' AND n.status = 1
! GROUP BY u.uid, u.name;
!  uid | name 
! -----+------
! (0 rows)
! 
! -- OK
! SELECT u.uid, u.name FROM node n
! INNER JOIN users u ON u.uid = n.uid
! WHERE n.type = 'blog' AND n.status = 1
! GROUP BY u.uid;
!  uid | name 
! -----+------
! (0 rows)
! 
! -- Check views and dependencies
! -- fail
! CREATE TEMP VIEW fdv1 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY body;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 2: SELECT id, keywords, title, body, created
!                ^
! -- OK
! CREATE TEMP VIEW fdv1 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
! -- fail
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv1 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv1;
! -- multiple dependencies
! CREATE TEMP VIEW fdv2 AS
! SELECT a.id, a.keywords, a.title, aic.category_id, aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY a.id, aic.category_id, aic.article_id;
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv2 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! ALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT; --fail
! ERROR:  cannot drop constraint articles_in_category_pkey on table articles_in_category because other objects depend on it
! DETAIL:  view fdv2 depends on constraint articles_in_category_pkey on table articles_in_category
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv2;
! -- nested queries
! CREATE TEMP VIEW fdv3 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id
! UNION
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv3 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv3;
! CREATE TEMP VIEW fdv4 AS
! SELECT * FROM articles WHERE title IN (SELECT title FROM articles GROUP BY id);
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv4 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv4;
! -- prepared query plans: this results in failure on reuse
! PREPARE foo AS
!   SELECT id, keywords, title, body, created
!   FROM articles
!   GROUP BY id;
! EXECUTE foo;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
! EXECUTE foo;  -- fail
! ERROR:  column "articles.keywords" must appear in the GROUP BY clause or be used in an aggregate function
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/advisory_lock.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/advisory_lock.out	2015-01-10 10:11:47.023649472 +0300
***************
*** 1,275 ****
! --
! -- ADVISORY LOCKS
! --
! BEGIN;
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- pg_advisory_unlock_all() shouldn't release xact locks
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      4
! (1 row)
! 
! -- can't unlock xact locks
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock_shared(2, 2);
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
!  pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock_shared 
! --------------------+---------------------------+--------------------+---------------------------
!  f                  | f                         | f                  | f
! (1 row)
! 
! -- automatically release xact locks at commit
! COMMIT;
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- holding both session and xact locks on the same objects, xact first
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock_shared 
! ------------------+-------------------------+------------------+-------------------------
!                   |                         |                  | 
! (1 row)
! 
! ROLLBACK;
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- unlocking session locks
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock(1),
! 	pg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),
! 	pg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
!  pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared 
! --------------------+--------------------+---------------------------+---------------------------+--------------------+--------------------+---------------------------+---------------------------
!  t                  | f                  | t                         | f                         | t                  | f                  | t                         | f
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- holding both session and xact locks on the same objects, session first
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock_shared 
! ------------------+-------------------------+------------------+-------------------------
!                   |                         |                  | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! ROLLBACK;
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- releasing all session locks
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- grabbing txn locks multiple times
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock(1),
! 	pg_advisory_xact_lock_shared(2), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock(1, 1),
! 	pg_advisory_xact_lock_shared(2, 2), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock_shared 
! -----------------------+-----------------------+------------------------------+------------------------------+-----------------------+-----------------------+------------------------------+------------------------------
!                        |                       |                              |                              |                       |                       |                              | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! COMMIT;
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! -- grabbing session locks multiple times
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock(1),
! 	pg_advisory_lock_shared(2), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock(1, 1),
! 	pg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared 
! ------------------+------------------+-------------------------+-------------------------+------------------+------------------+-------------------------+-------------------------
!                   |                  |                         |                         |                  |                  |                         | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock(1),
! 	pg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),
! 	pg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);
!  pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared 
! --------------------+--------------------+---------------------------+---------------------------+--------------------+--------------------+---------------------------+---------------------------
!  t                  | t                  | t                         | t                         | t                  | t                  | t                         | t
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! -- .. and releasing them all at once
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock(1),
! 	pg_advisory_lock_shared(2), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock(1, 1),
! 	pg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared 
! ------------------+------------------+-------------------------+-------------------------+------------------+------------------+-------------------------+-------------------------
!                   |                  |                         |                         |                  |                  |                         | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/json_1.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/json.out	2015-01-10 10:11:47.023649472 +0300
***************
*** 1,1584 ****
! -- Strings.
! SELECT '""'::json;				-- OK.
!  json 
! ------
!  ""
! (1 row)
! 
! SELECT $$''$$::json;			-- ERROR, single quotes are not allowed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT $$''$$::json;
!                ^
! DETAIL:  Token "'" is invalid.
! CONTEXT:  JSON data, line 1: '...
! SELECT '"abc"'::json;			-- OK
!  json  
! -------
!  "abc"
! (1 row)
! 
! SELECT '"abc'::json;			-- ERROR, quotes not closed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc'::json;
!                ^
! DETAIL:  Token ""abc" is invalid.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"abc
! def"'::json;					-- ERROR, unescaped newline in string constant
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc
!                ^
! DETAIL:  Character with value 0x0a must be escaped.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"\n\"\\"'::json;		-- OK, legal escapes
!    json   
! ----------
!  "\n\"\\"
! (1 row)
! 
! SELECT '"\v"'::json;			-- ERROR, not a valid JSON escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\v"'::json;
!                ^
! DETAIL:  Escape sequence "\v" is invalid.
! CONTEXT:  JSON data, line 1: "\v...
! SELECT '"\u"'::json;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u"
! SELECT '"\u00"'::json;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u00"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u00"
! SELECT '"\u000g"'::json;		-- ERROR, g is not a hex digit
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u000g"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u000g...
! SELECT '"\u0000"'::json;		-- OK, legal escape
!    json   
! ----------
!  "\u0000"
! (1 row)
! 
! SELECT '"\uaBcD"'::json;		-- OK, uppercase and lower case both OK
!    json   
! ----------
!  "\uaBcD"
! (1 row)
! 
! -- Numbers.
! SELECT '1'::json;				-- OK
!  json 
! ------
!  1
! (1 row)
! 
! SELECT '0'::json;				-- OK
!  json 
! ------
!  0
! (1 row)
! 
! SELECT '01'::json;				-- ERROR, not valid according to JSON spec
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '01'::json;
!                ^
! DETAIL:  Token "01" is invalid.
! CONTEXT:  JSON data, line 1: 01
! SELECT '0.1'::json;				-- OK
!  json 
! ------
!  0.1
! (1 row)
! 
! SELECT '9223372036854775808'::json;	-- OK, even though it's too large for int8
!         json         
! ---------------------
!  9223372036854775808
! (1 row)
! 
! SELECT '1e100'::json;			-- OK
!  json  
! -------
!  1e100
! (1 row)
! 
! SELECT '1.3e100'::json;			-- OK
!   json   
! ---------
!  1.3e100
! (1 row)
! 
! SELECT '1f2'::json;				-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1f2'::json;
!                ^
! DETAIL:  Token "1f2" is invalid.
! CONTEXT:  JSON data, line 1: 1f2
! SELECT '0.x1'::json;			-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '0.x1'::json;
!                ^
! DETAIL:  Token "0.x1" is invalid.
! CONTEXT:  JSON data, line 1: 0.x1
! SELECT '1.3ex100'::json;		-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1.3ex100'::json;
!                ^
! DETAIL:  Token "1.3ex100" is invalid.
! CONTEXT:  JSON data, line 1: 1.3ex100
! -- Arrays.
! SELECT '[]'::json;				-- OK
!  json 
! ------
!  []
! (1 row)
! 
! SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::json;  -- OK
!                                                                                                    json                                                                                                   
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
! (1 row)
! 
! SELECT '[1,2]'::json;			-- OK
!  json  
! -------
!  [1,2]
! (1 row)
! 
! SELECT '[1,2,]'::json;			-- ERROR, trailing comma
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2,]'::json;
!                ^
! DETAIL:  Expected JSON value, but found "]".
! CONTEXT:  JSON data, line 1: [1,2,]
! SELECT '[1,2'::json;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2'::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,2
! SELECT '[1,[2]'::json;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,[2]'::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,[2]
! -- Objects.
! SELECT '{}'::json;				-- OK
!  json 
! ------
!  {}
! (1 row)
! 
! SELECT '{"abc"}'::json;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"}'::json;
!                ^
! DETAIL:  Expected ":", but found "}".
! CONTEXT:  JSON data, line 1: {"abc"}
! SELECT '{"abc":1}'::json;		-- OK
!    json    
! -----------
!  {"abc":1}
! (1 row)
! 
! SELECT '{1:"abc"}'::json;		-- ERROR, keys must be strings
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{1:"abc"}'::json;
!                ^
! DETAIL:  Expected string or "}", but found "1".
! CONTEXT:  JSON data, line 1: {1...
! SELECT '{"abc",1}'::json;		-- ERROR, wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc",1}'::json;
!                ^
! DETAIL:  Expected ":", but found ",".
! CONTEXT:  JSON data, line 1: {"abc",...
! SELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"=1}'::json;
!                ^
! DETAIL:  Token "=" is invalid.
! CONTEXT:  JSON data, line 1: {"abc"=...
! SELECT '{"abc"::1}'::json;		-- ERROR, another wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"::1}'::json;
!                ^
! DETAIL:  Expected JSON value, but found ":".
! CONTEXT:  JSON data, line 1: {"abc"::...
! SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::json; -- OK
!                           json                           
! ---------------------------------------------------------
!  {"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}
! (1 row)
! 
! SELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spot
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1:2}'::json;
!                ^
! DETAIL:  Expected "," or "}", but found ":".
! CONTEXT:  JSON data, line 1: {"abc":1:...
! SELECT '{"abc":1,3}'::json;		-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1,3}'::json;
!                ^
! DETAIL:  Expected string, but found "3".
! CONTEXT:  JSON data, line 1: {"abc":1,3...
! -- Miscellaneous stuff.
! SELECT 'true'::json;			-- OK
!  json 
! ------
!  true
! (1 row)
! 
! SELECT 'false'::json;			-- OK
!  json  
! -------
!  false
! (1 row)
! 
! SELECT 'null'::json;			-- OK
!  json 
! ------
!  null
! (1 row)
! 
! SELECT ' true '::json;			-- OK, even with extra whitespace
!   json  
! --------
!   true 
! (1 row)
! 
! SELECT 'true false'::json;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true false'::json;
!                ^
! DETAIL:  Expected end of input, but found "false".
! CONTEXT:  JSON data, line 1: true false
! SELECT 'true, false'::json;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true, false'::json;
!                ^
! DETAIL:  Expected end of input, but found ",".
! CONTEXT:  JSON data, line 1: true,...
! SELECT 'truf'::json;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'truf'::json;
!                ^
! DETAIL:  Token "truf" is invalid.
! CONTEXT:  JSON data, line 1: truf
! SELECT 'trues'::json;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'trues'::json;
!                ^
! DETAIL:  Token "trues" is invalid.
! CONTEXT:  JSON data, line 1: trues
! SELECT ''::json;				-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT ''::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: 
! SELECT '    '::json;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '    '::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1:     
! --constructors
! -- array_to_json
! SELECT array_to_json(array(select 1 as a));
!  array_to_json 
! ---------------
!  [1]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
!                 array_to_json                
! ---------------------------------------------
!  [{"b":1,"c":2},{"b":2,"c":4},{"b":3,"c":6}]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
!   array_to_json  
! -----------------
!  [{"b":1,"c":2},+
!   {"b":2,"c":4},+
!   {"b":3,"c":6}]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),false)
!   FROM ( SELECT $$a$$ || x AS b, y AS c,
!                ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!          FROM generate_series(1,2) x,
!               generate_series(4,5) y) q;
!                                                                                                                                  array_to_json                                                                                                                                 
! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [{"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]},{"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]},{"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]},{"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}]
! (1 row)
! 
! SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
!  array_to_json  
! ----------------
!  [5,6,7,8,9,10]
! (1 row)
! 
! SELECT array_to_json('{{1,5},{99,100}}'::int[]);
!   array_to_json   
! ------------------
!  [[1,5],[99,100]]
! (1 row)
! 
! -- row_to_json
! SELECT row_to_json(row(1,'foo'));
!      row_to_json     
! ---------------------
!  {"f1":1,"f2":"foo"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT $$a$$ || x AS b,
!          y AS c,
!          ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!       FROM generate_series(1,2) x,
!            generate_series(4,5) y) q;
!                             row_to_json                             
! --------------------------------------------------------------------
!  {"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
!  {"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
! (4 rows)
! 
! SELECT row_to_json(q,true)
! FROM (SELECT $$a$$ || x AS b,
!          y AS c,
!          ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!       FROM generate_series(1,2) x,
!            generate_series(4,5) y) q;
!                      row_to_json                     
! -----------------------------------------------------
!  {"b":"a1",                                         +
!   "c":4,                                            +
!   "z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a1",                                         +
!   "c":5,                                            +
!   "z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
!  {"b":"a2",                                         +
!   "c":4,                                            +
!   "z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a2",                                         +
!   "c":5,                                            +
!   "z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
! (4 rows)
! 
! CREATE TEMP TABLE rows AS
! SELECT x, 'txt' || x as y
! FROM generate_series(1,3) AS x;
! SELECT row_to_json(q,true)
! FROM rows q;
!  row_to_json  
! --------------
!  {"x":1,     +
!   "y":"txt1"}
!  {"x":2,     +
!   "y":"txt2"}
!  {"x":3,     +
!   "y":"txt3"}
! (3 rows)
! 
! SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
!       row_to_json      
! -----------------------
!  {"f1":[5,6,7,8,9,10]}
! (1 row)
! 
! -- to_json, timestamps
! select to_json(timestamp '2014-05-28 12:22:35.614298');
!            to_json            
! ------------------------------
!  "2014-05-28T12:22:35.614298"
! (1 row)
! 
! BEGIN;
! SET LOCAL TIME ZONE 10.5;
! select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
!               to_json               
! ------------------------------------
!  "2014-05-29T02:52:35.614298+10:30"
! (1 row)
! 
! SET LOCAL TIME ZONE -8;
! select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
!               to_json               
! ------------------------------------
!  "2014-05-28T08:22:35.614298-08:00"
! (1 row)
! 
! COMMIT;
! -- unicode escape - backslash is not escaped
! select to_json(text '\uabcd');
!  to_json  
! ----------
!  "\uabcd"
! (1 row)
! 
! -- any other backslash is escaped
! select to_json(text '\abcd');
!  to_json  
! ----------
!  "\\abcd"
! (1 row)
! 
! --json_agg
! SELECT json_agg(q)
!   FROM ( SELECT $$a$$ || x AS b, y AS c,
!                ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!          FROM generate_series(1,2) x,
!               generate_series(4,5) y) q;
!                                json_agg                                
! -----------------------------------------------------------------------
!  [{"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}, +
!   {"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}, +
!   {"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}, +
!   {"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}]
! (1 row)
! 
! SELECT json_agg(q)
!   FROM rows q;
!        json_agg        
! -----------------------
!  [{"x":1,"y":"txt1"}, +
!   {"x":2,"y":"txt2"}, +
!   {"x":3,"y":"txt3"}]
! (1 row)
! 
! -- non-numeric output
! SELECT row_to_json(q)
! FROM (SELECT 'NaN'::float8 AS "float8field") q;
!       row_to_json      
! -----------------------
!  {"float8field":"NaN"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT 'Infinity'::float8 AS "float8field") q;
!         row_to_json         
! ----------------------------
!  {"float8field":"Infinity"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT '-Infinity'::float8 AS "float8field") q;
!          row_to_json         
! -----------------------------
!  {"float8field":"-Infinity"}
! (1 row)
! 
! -- json input
! SELECT row_to_json(q)
! FROM (SELECT '{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}'::json AS "jsonfield") q;
!                            row_to_json                            
! ------------------------------------------------------------------
!  {"jsonfield":{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}}
! (1 row)
! 
! -- json extraction functions
! CREATE TEMP TABLE test_json (
!        json_type text,
!        test_json json
! );
! INSERT INTO test_json VALUES
! ('scalar','"a scalar"'),
! ('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
! ('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json->'field2'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  "val2"
! (1 row)
! 
! SELECT test_json->>'field2'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  val2
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  "two"
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json->>2
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  two
! (1 row)
! 
! SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
!  ?column? 
! ----------
!  {"f1":9}
! (1 row)
! 
! SELECT test_json ->> 'field4' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  4
! (1 row)
! 
! SELECT test_json ->> 'field5' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! SELECT test_json ->> 'field6' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  {"f1":9}
! (1 row)
! 
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'scalar';
! ERROR:  cannot call json_object_keys on a scalar
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'array';
! ERROR:  cannot call json_object_keys on an array
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'object';
!  json_object_keys 
! ------------------
!  field1
!  field2
!  field3
!  field4
!  field5
!  field6
! (6 rows)
! 
! -- test extending object_keys resultset - initial resultset size is 256
! select count(*) from
!     (select json_object_keys(json_object(array_agg(g)))
!      from (select unnest(array['f'||n,n::text])as g
!            from generate_series(1,300) as n) x ) y;
!  count 
! -------
!    300
! (1 row)
! 
! -- nulls
! select (test_json->'field3') is null as expect_false
! from test_json
! where json_type = 'object';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select (test_json->>'field3') is null as expect_true
! from test_json
! where json_type = 'object';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! select (test_json->3) is null as expect_false
! from test_json
! where json_type = 'array';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select (test_json->>3) is null as expect_true
! from test_json
! where json_type = 'array';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- corner cases
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::json -> 'b';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::json -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::json ->> 'b';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array length
! SELECT json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
!  json_array_length 
! -------------------
!                  5
! (1 row)
! 
! SELECT json_array_length('[]');
!  json_array_length 
! -------------------
!                  0
! (1 row)
! 
! SELECT json_array_length('{"f1":1,"f2":[5,6]}');
! ERROR:  cannot get array length of a non-array
! SELECT json_array_length('4');
! ERROR:  cannot get array length of a scalar
! -- each
! select json_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
!      json_each     
! -------------------
!  (f1,"[1,2,3]")
!  (f2,"{""f3"":1}")
!  (f4,null)
! (3 rows)
! 
! select * from json_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1,2,3]
!  f2  | {"f3":1}
!  f4  | null
!  f5  | 99
!  f6  | "stringy"
! (5 rows)
! 
! select json_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
!   json_each_text   
! -------------------
!  (f1,"[1,2,3]")
!  (f2,"{""f3"":1}")
!  (f4,)
!  (f5,null)
! (4 rows)
! 
! select * from json_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |  value   
! -----+----------
!  f1  | [1,2,3]
!  f2  | {"f3":1}
!  f4  | 
!  f5  | 99
!  f6  | stringy
! (5 rows)
! 
! -- extract_path, extract_path_as_text
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  json_extract_path 
! -------------------
!  "stringy"
! (1 row)
! 
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  json_extract_path 
! -------------------
!  {"f3":1}
! (1 row)
! 
! select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  json_extract_path 
! -------------------
!  "f3"
! (1 row)
! 
! select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  json_extract_path 
! -------------------
!  1
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  json_extract_path_text 
! ------------------------
!  stringy
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  json_extract_path_text 
! ------------------------
!  {"f3":1}
! (1 row)
! 
! select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  json_extract_path_text 
! ------------------------
!  f3
! (1 row)
! 
! select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  json_extract_path_text 
! ------------------------
!  1
! (1 row)
! 
! -- extract_path nulls
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') is null as expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') is null as expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! select json_extract_path('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') is null as expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') is null as expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- extract_path operators
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f4','f6'];
!  ?column?  
! -----------
!  "stringy"
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2'];
!  ?column? 
! ----------
!  {"f3":1}
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','0'];
!  ?column? 
! ----------
!  "f3"
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f4','f6'];
!  ?column? 
! ----------
!  stringy
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2'];
!  ?column? 
! ----------
!  {"f3":1}
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','0'];
!  ?column? 
! ----------
!  f3
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! -- corner cases for same
! select '{"a": {"b":{"c": "foo"}}}'::json #> '{}';
!          ?column?          
! ---------------------------
!  {"a": {"b":{"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::json #> '{}';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! select '"foo"'::json #> '{}';
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '42'::json #> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::json #> '{}';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a'];
!       ?column?      
! --------------------
!  {"b":{"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c'];
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #> array['1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::json #> array['1','b'];
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::json #> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> '{}';
!          ?column?          
! ---------------------------
!  {"a": {"b":{"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::json #>> '{}';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! select '"foo"'::json #>> '{}';
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '42'::json #>> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::json #>> '{}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a'];
!       ?column?      
! --------------------
!  {"b":{"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c'];
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::json #>> array['1','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json #>> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #>> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #>> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array_elements
! select json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!   json_array_elements  
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  null
!  {"f1":1,"f2":[7,8,9]}
!  false
!  "stringy"
! (7 rows)
! 
! select * from json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!          value         
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  null
!  {"f1":1,"f2":[7,8,9]}
!  false
!  "stringy"
! (7 rows)
! 
! select json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!  json_array_elements_text 
! --------------------------
!  1
!  true
!  [1,[2,3]]
!  
!  {"f1":1,"f2":[7,8,9]}
!  false
!  stringy
! (7 rows)
! 
! select * from json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!          value         
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  
!  {"f1":1,"f2":[7,8,9]}
!  false
!  stringy
! (7 rows)
! 
! -- populate_record
! create type jpop as (a text, b int, c timestamp);
! select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(null::jpop,'{"a":[100,200,false],"x":43.2}') q;
!         a        | b | c 
! -----------------+---+---
!  [100,200,false] |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":[100,200,false],"x":43.2}') q;
!         a        | b |            c             
! -----------------+---+--------------------------
!  [100,200,false] | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"c":[100,200,false],"x":43.2}') q;
! ERROR:  invalid input syntax for type timestamp: "[100,200,false]"
! -- populate_recordset
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!        a       | b  |            c             
! ---------------+----+--------------------------
!  [100,200,300] | 99 | 
!  {"z":true}    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
! ERROR:  invalid input syntax for type timestamp: "[100,200,300]"
! create type jpop2 as (a int, b json, c int, d int);
! select * from json_populate_recordset(null::jpop2, '[{"a":2,"c":3,"b":{"z":4},"d":6}]') q;
!  a |    b    | c | d 
! ---+---------+---+---
!  2 | {"z":4} | 3 | 6
! (1 row)
! 
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!        a       | b  |            c             
! ---------------+----+--------------------------
!  [100,200,300] | 99 | 
!  {"z":true}    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! -- handling of unicode surrogate pairs
! select json '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a' as correct_in_utf8;
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a row
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode high surrogate must not follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong order
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogate
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogate
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! --handling of simple unicode escapes
! select json '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' as correct_in_utf8;
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "dollar \u0024 character" }' ->> 'a' as correct_everywhere;
!  correct_everywhere 
! --------------------
!  dollar $ character
! (1 row)
! 
! select json '{ "a":  "null \u0000 escape" }' ->> 'a' as not_unescaped;
!    not_unescaped    
! --------------------
!  null \u0000 escape
! (1 row)
! 
! --json_typeof() function
! select value, json_typeof(value)
!   from (values (json '123.4'),
!                (json '-1'),
!                (json '"foo"'),
!                (json 'true'),
!                (json 'false'),
!                (json 'null'),
!                (json '[1, 2, 3]'),
!                (json '[]'),
!                (json '{"x":"foo", "y":123}'),
!                (json '{}'),
!                (NULL::json))
!       as data(value);
!         value         | json_typeof 
! ----------------------+-------------
!  123.4                | number
!  -1                   | number
!  "foo"                | string
!  true                 | boolean
!  false                | boolean
!  null                 | null
!  [1, 2, 3]            | array
!  []                   | array
!  {"x":"foo", "y":123} | object
!  {}                   | object
!                       | 
! (11 rows)
! 
! -- json_build_array, json_build_object, json_object_agg
! SELECT json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
!                            json_build_array                            
! -----------------------------------------------------------------------
!  ["a", 1, "b", 1.2, "c", true, "d", null, "e", {"x": 3, "y": [1,2,3]}]
! (1 row)
! 
! SELECT json_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
!                              json_build_object                              
! ----------------------------------------------------------------------------
!  {"a" : 1, "b" : 1.2, "c" : true, "d" : null, "e" : {"x": 3, "y": [1,2,3]}}
! (1 row)
! 
! SELECT json_build_object(
!        'a', json_build_object('b',false,'c',99),
!        'd', json_build_object('e',array[9,8,7]::int[],
!            'f', (select row_to_json(r) from ( select relkind, oid::regclass as name from pg_class where relname = 'pg_class') r)));
!                                         json_build_object                                        
! -------------------------------------------------------------------------------------------------
!  {"a" : {"b" : false, "c" : 99}, "d" : {"e" : [9,8,7], "f" : {"relkind":"r","name":"pg_class"}}}
! (1 row)
! 
! -- empty objects/arrays
! SELECT json_build_array();
!  json_build_array 
! ------------------
!  []
! (1 row)
! 
! SELECT json_build_object();
!  json_build_object 
! -------------------
!  {}
! (1 row)
! 
! -- make sure keys are quoted
! SELECT json_build_object(1,2);
!  json_build_object 
! -------------------
!  {"1" : 2}
! (1 row)
! 
! -- keys must be scalar and not null
! SELECT json_build_object(null,2);
! ERROR:  argument 1 cannot be null
! HINT:  Object keys should be text.
! SELECT json_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
! ERROR:  key value must be scalar, not array, composite, or json
! SELECT json_build_object(json '{"a":1,"b":2}', 3);
! ERROR:  key value must be scalar, not array, composite, or json
! SELECT json_build_object('{1,2,3}'::int[], 3);
! ERROR:  key value must be scalar, not array, composite, or json
! CREATE TEMP TABLE foo (serial_num int, name text, type text);
! INSERT INTO foo VALUES (847001,'t15','GE1043');
! INSERT INTO foo VALUES (847002,'t16','GE1043');
! INSERT INTO foo VALUES (847003,'sub-alpha','GESS90');
! SELECT json_build_object('turbines',json_object_agg(serial_num,json_build_object('name',name,'type',type)))
! FROM foo;
!                                                                             json_build_object                                                                            
! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  {"turbines" : { "847001" : {"name" : "t15", "type" : "GE1043"}, "847002" : {"name" : "t16", "type" : "GE1043"}, "847003" : {"name" : "sub-alpha", "type" : "GESS90"} }}
! (1 row)
! 
! -- json_object
! -- one dimension
! SELECT json_object('{a,1,b,2,3,NULL,"d e f","a b c"}');
!                       json_object                      
! -------------------------------------------------------
!  {"a" : "1", "b" : "2", "3" : null, "d e f" : "a b c"}
! (1 row)
! 
! -- same but with two dimensions
! SELECT json_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
!                       json_object                      
! -------------------------------------------------------
!  {"a" : "1", "b" : "2", "3" : null, "d e f" : "a b c"}
! (1 row)
! 
! -- odd number error
! SELECT json_object('{a,b,c}');
! ERROR:  array must have even number of elements
! -- one column error
! SELECT json_object('{{a},{b}}');
! ERROR:  array must have two columns
! -- too many columns error
! SELECT json_object('{{a,b,c},{b,c,d}}');
! ERROR:  array must have two columns
! -- too many dimensions error
! SELECT json_object('{{{a,b},{c,d}},{{b,c},{d,e}}}');
! ERROR:  wrong number of array subscripts
! --two argument form of json_object
! select json_object('{a,b,c,"d e f"}','{1,2,3,"a b c"}');
!                      json_object                      
! ------------------------------------------------------
!  {"a" : "1", "b" : "2", "c" : "3", "d e f" : "a b c"}
! (1 row)
! 
! -- too many dimensions
! SELECT json_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
! ERROR:  wrong number of array subscripts
! -- mismatched dimensions
! select json_object('{a,b,c,"d e f",g}','{1,2,3,"a b c"}');
! ERROR:  mismatched array dimensions
! select json_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
! ERROR:  mismatched array dimensions
! -- null key error
! select json_object('{a,b,NULL,"d e f"}','{1,2,3,"a b c"}');
! ERROR:  null value not allowed for object key
! -- empty key is allowed
! select json_object('{a,b,"","d e f"}','{1,2,3,"a b c"}');
!                      json_object                     
! -----------------------------------------------------
!  {"a" : "1", "b" : "2", "" : "3", "d e f" : "a b c"}
! (1 row)
! 
! -- json_to_record and json_to_recordset
! select * from json_to_record('{"a":1,"b":"foo","c":"bar"}')
!     as x(a int, b text, d text);
!  a |  b  | d 
! ---+-----+---
!  1 | foo | 
! (1 row)
! 
! select * from json_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
!     as x(a int, b text, c boolean);
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 
!  2 | bar | t
! (2 rows)
! 
! select * from json_to_recordset('[{"a":1,"b":{"d":"foo"},"c":true},{"a":2,"c":false,"b":{"d":"bar"}}]')
!     as x(a int, b json, c boolean);
!  a |      b      | c 
! ---+-------------+---
!  1 | {"d":"foo"} | t
!  2 | {"d":"bar"} | f
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/jsonb.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/jsonb.out	2015-01-10 10:11:47.003649472 +0300
***************
*** 1,2474 ****
! -- Strings.
! SELECT '""'::jsonb;				-- OK.
!  jsonb 
! -------
!  ""
! (1 row)
! 
! SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT $$''$$::jsonb;
!                ^
! DETAIL:  Token "'" is invalid.
! CONTEXT:  JSON data, line 1: '...
! SELECT '"abc"'::jsonb;			-- OK
!  jsonb 
! -------
!  "abc"
! (1 row)
! 
! SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc'::jsonb;
!                ^
! DETAIL:  Token ""abc" is invalid.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"abc
! def"'::jsonb;					-- ERROR, unescaped newline in string constant
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc
!                ^
! DETAIL:  Character with value 0x0a must be escaped.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"\n\"\\"'::jsonb;		-- OK, legal escapes
!   jsonb   
! ----------
!  "\n\"\\"
! (1 row)
! 
! SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\v"'::jsonb;
!                ^
! DETAIL:  Escape sequence "\v" is invalid.
! CONTEXT:  JSON data, line 1: "\v...
! SELECT '"\u"'::jsonb;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u"
! SELECT '"\u00"'::jsonb;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u00"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u00"
! SELECT '"\u000g"'::jsonb;		-- ERROR, g is not a hex digit
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u000g"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u000g...
! SELECT '"\u0000"'::jsonb;		-- OK, legal escape
!   jsonb   
! ----------
!  "\u0000"
! (1 row)
! 
! -- use octet_length here so we don't get an odd unicode char in the
! -- output
! SELECT octet_length('"\uaBcD"'::jsonb::text); -- OK, uppercase and lower case both OK
!  octet_length 
! --------------
!             5
! (1 row)
! 
! -- Numbers.
! SELECT '1'::jsonb;				-- OK
!  jsonb 
! -------
!  1
! (1 row)
! 
! SELECT '0'::jsonb;				-- OK
!  jsonb 
! -------
!  0
! (1 row)
! 
! SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '01'::jsonb;
!                ^
! DETAIL:  Token "01" is invalid.
! CONTEXT:  JSON data, line 1: 01
! SELECT '0.1'::jsonb;				-- OK
!  jsonb 
! -------
!  0.1
! (1 row)
! 
! SELECT '9223372036854775808'::jsonb;	-- OK, even though it's too large for int8
!         jsonb        
! ---------------------
!  9223372036854775808
! (1 row)
! 
! SELECT '1e100'::jsonb;			-- OK
!                                                  jsonb                                                 
! -------------------------------------------------------------------------------------------------------
!  10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
! (1 row)
! 
! SELECT '1.3e100'::jsonb;			-- OK
!                                                  jsonb                                                 
! -------------------------------------------------------------------------------------------------------
!  13000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
! (1 row)
! 
! SELECT '1f2'::jsonb;				-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1f2'::jsonb;
!                ^
! DETAIL:  Token "1f2" is invalid.
! CONTEXT:  JSON data, line 1: 1f2
! SELECT '0.x1'::jsonb;			-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '0.x1'::jsonb;
!                ^
! DETAIL:  Token "0.x1" is invalid.
! CONTEXT:  JSON data, line 1: 0.x1
! SELECT '1.3ex100'::jsonb;		-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1.3ex100'::jsonb;
!                ^
! DETAIL:  Token "1.3ex100" is invalid.
! CONTEXT:  JSON data, line 1: 1.3ex100
! -- Arrays.
! SELECT '[]'::jsonb;				-- OK
!  jsonb 
! -------
!  []
! (1 row)
! 
! SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::jsonb;  -- OK
!                                                                                                   jsonb                                                                                                   
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
! (1 row)
! 
! SELECT '[1,2]'::jsonb;			-- OK
!  jsonb  
! --------
!  [1, 2]
! (1 row)
! 
! SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2,]'::jsonb;
!                ^
! DETAIL:  Expected JSON value, but found "]".
! CONTEXT:  JSON data, line 1: [1,2,]
! SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2'::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,2
! SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,[2]'::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,[2]
! -- Objects.
! SELECT '{}'::jsonb;				-- OK
!  jsonb 
! -------
!  {}
! (1 row)
! 
! SELECT '{"abc"}'::jsonb;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"}'::jsonb;
!                ^
! DETAIL:  Expected ":", but found "}".
! CONTEXT:  JSON data, line 1: {"abc"}
! SELECT '{"abc":1}'::jsonb;		-- OK
!    jsonb    
! ------------
!  {"abc": 1}
! (1 row)
! 
! SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{1:"abc"}'::jsonb;
!                ^
! DETAIL:  Expected string or "}", but found "1".
! CONTEXT:  JSON data, line 1: {1...
! SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc",1}'::jsonb;
!                ^
! DETAIL:  Expected ":", but found ",".
! CONTEXT:  JSON data, line 1: {"abc",...
! SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"=1}'::jsonb;
!                ^
! DETAIL:  Token "=" is invalid.
! CONTEXT:  JSON data, line 1: {"abc"=...
! SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"::1}'::jsonb;
!                ^
! DETAIL:  Expected JSON value, but found ":".
! CONTEXT:  JSON data, line 1: {"abc"::...
! SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::jsonb; -- OK
!                                jsonb                                
! --------------------------------------------------------------------
!  {"abc": 1, "def": 2, "ghi": [3, 4], "hij": {"klm": 5, "nop": [6]}}
! (1 row)
! 
! SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1:2}'::jsonb;
!                ^
! DETAIL:  Expected "," or "}", but found ":".
! CONTEXT:  JSON data, line 1: {"abc":1:...
! SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1,3}'::jsonb;
!                ^
! DETAIL:  Expected string, but found "3".
! CONTEXT:  JSON data, line 1: {"abc":1,3...
! -- Miscellaneous stuff.
! SELECT 'true'::jsonb;			-- OK
!  jsonb 
! -------
!  true
! (1 row)
! 
! SELECT 'false'::jsonb;			-- OK
!  jsonb 
! -------
!  false
! (1 row)
! 
! SELECT 'null'::jsonb;			-- OK
!  jsonb 
! -------
!  null
! (1 row)
! 
! SELECT ' true '::jsonb;			-- OK, even with extra whitespace
!  jsonb 
! -------
!  true
! (1 row)
! 
! SELECT 'true false'::jsonb;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true false'::jsonb;
!                ^
! DETAIL:  Expected end of input, but found "false".
! CONTEXT:  JSON data, line 1: true false
! SELECT 'true, false'::jsonb;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true, false'::jsonb;
!                ^
! DETAIL:  Expected end of input, but found ",".
! CONTEXT:  JSON data, line 1: true,...
! SELECT 'truf'::jsonb;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'truf'::jsonb;
!                ^
! DETAIL:  Token "truf" is invalid.
! CONTEXT:  JSON data, line 1: truf
! SELECT 'trues'::jsonb;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'trues'::jsonb;
!                ^
! DETAIL:  Token "trues" is invalid.
! CONTEXT:  JSON data, line 1: trues
! SELECT ''::jsonb;				-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT ''::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: 
! SELECT '    '::jsonb;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '    '::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1:     
! -- make sure jsonb is passed through json generators without being escaped
! SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
!       array_to_json       
! --------------------------
!  [{"a": 1},{"b": [2, 3]}]
! (1 row)
! 
! -- jsonb extraction functions
! CREATE TEMP TABLE test_jsonb (
!        json_type text,
!        test_json jsonb
! );
! INSERT INTO test_jsonb VALUES
! ('scalar','"a scalar"'),
! ('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
! ('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'field2' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  "val2"
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  val2
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  "two"
! (1 row)
! 
! SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
!  ?column?  
! -----------
!  {"f1": 9}
! (1 row)
! 
! SELECT test_json ->> 'field4' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  4
! (1 row)
! 
! SELECT test_json ->> 'field5' FROM test_jsonb WHERE json_type = 'object';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT test_json ->> 'field6' FROM test_jsonb WHERE json_type = 'object';
!  ?column?  
! -----------
!  {"f1": 9}
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  two
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
! ERROR:  cannot call jsonb_object_keys on a scalar
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
! ERROR:  cannot call jsonb_object_keys on an array
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
!  jsonb_object_keys 
! -------------------
!  field1
!  field2
!  field3
!  field4
!  field5
!  field6
! (6 rows)
! 
! -- nulls
! SELECT (test_json->'field3') IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'object';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT (test_json->>'field3') IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'object';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- corner cases
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::jsonb -> 'b';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::jsonb -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::jsonb ->> 'b';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- equality and inequality
! SELECT '{"x":"y"}'::jsonb = '{"x":"y"}'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb = '{"x":"z"}'::jsonb;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb <> '{"x":"y"}'::jsonb;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb <> '{"x":"z"}'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- containment
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":null}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "g":null}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"g":null}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"c"}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":"q"}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "g":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"g":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"c"}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":"q"}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '[1,2]'::jsonb @> '[1,2,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,1,2]'::jsonb @> '[1,2,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[[1,2]]'::jsonb @> '[[1,2,2]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,2,2]'::jsonb <@ '[1,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,2,2]'::jsonb <@ '[1,1,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[[1,2,2]]'::jsonb <@ '[[1,2]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "c":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "g":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"g":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"a":"c"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "c":"q"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "c":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"c"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "c":"q"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- Raw scalar may contain another raw scalar, array may contain a raw scalar
! SELECT '[5]'::jsonb @> '[5]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '5'::jsonb @> '5';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[5]'::jsonb @> '5';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- But a raw scalar cannot contain an array
! SELECT '5'::jsonb @> '[5]';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- In general, one thing should always contain itself. Test array containment:
! SELECT '["9", ["7", "3"], 1]'::jsonb @> '["9", ["7", "3"], 1]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["9", ["7", "3"], ["1"]]'::jsonb @> '["9", ["7", "3"], ["1"]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- array containment string matching confusion bug
! SELECT '{ "name": "Bob", "tags": [ "enim", "qui"]}'::jsonb @> '{"tags":["qu"]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- array length
! SELECT jsonb_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
!  jsonb_array_length 
! --------------------
!                   5
! (1 row)
! 
! SELECT jsonb_array_length('[]');
!  jsonb_array_length 
! --------------------
!                   0
! (1 row)
! 
! SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
! ERROR:  cannot get array length of a non-array
! SELECT jsonb_array_length('4');
! ERROR:  cannot get array length of a scalar
! -- each
! SELECT jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
!      jsonb_each     
! --------------------
!  (f1,"[1, 2, 3]")
!  (f2,"{""f3"": 1}")
!  (f4,null)
! (3 rows)
! 
! SELECT jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!                           q                           
! ------------------------------------------------------
!  (1,"""first""")
!  (a,"{""1"": ""first"", ""b"": ""c"", ""c"": ""b""}")
!  (b,"[1, 2]")
!  (c,"""cc""")
!  (n,null)
! (5 rows)
! 
! SELECT * FROM jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1, 2, 3]
!  f2  | {"f3": 1}
!  f4  | null
!  f5  | 99
!  f6  | "stringy"
! (5 rows)
! 
! SELECT * FROM jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!  key |               value                
! -----+------------------------------------
!  1   | "first"
!  a   | {"1": "first", "b": "c", "c": "b"}
!  b   | [1, 2]
!  c   | "cc"
!  n   | null
! (5 rows)
! 
! SELECT jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
!   jsonb_each_text   
! --------------------
!  (f1,"[1, 2, 3]")
!  (f2,"{""f3"": 1}")
!  (f4,)
!  (f5,null)
! (4 rows)
! 
! SELECT jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!                           q                           
! ------------------------------------------------------
!  (1,first)
!  (a,"{""1"": ""first"", ""b"": ""c"", ""c"": ""b""}")
!  (b,"[1, 2]")
!  (c,cc)
!  (n,)
! (5 rows)
! 
! SELECT * FROM jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1, 2, 3]
!  f2  | {"f3": 1}
!  f4  | 
!  f5  | 99
!  f6  | stringy
! (5 rows)
! 
! SELECT * FROM jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!  key |               value                
! -----+------------------------------------
!  1   | first
!  a   | {"1": "first", "b": "c", "c": "b"}
!  b   | [1, 2]
!  c   | cc
!  n   | 
! (5 rows)
! 
! -- exists
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'a');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'b');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'c');
!  jsonb_exists 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_exists('{"a":"null", "b":"qq"}', 'a');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'b';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'c';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":"null", "b":"qq"}' ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- array exists - array elements should behave as keys
! SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
! -- type sensitive array exists - should return no rows (since "exists" only
! -- matches strings that are either object keys or array elements)
! SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
! -- However, a raw scalar is *contained* within the array
! SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['a','b']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['b','a']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','a']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','d']);
!  jsonb_exists_any 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', '{}'::text[]);
!  jsonb_exists_any 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['a','b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['b','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','d'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| '{}'::text[];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['a','b']);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['b','a']);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','a']);
!  jsonb_exists_all 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','d']);
!  jsonb_exists_all 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', '{}'::text[]);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['b','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','a'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','d'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','a', 'b', 'b', 'b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& '{}'::text[];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- typeof
! SELECT jsonb_typeof('{}') AS object;
!  object 
! --------
!  object
! (1 row)
! 
! SELECT jsonb_typeof('{"c":3,"p":"o"}') AS object;
!  object 
! --------
!  object
! (1 row)
! 
! SELECT jsonb_typeof('[]') AS array;
!  array 
! -------
!  array
! (1 row)
! 
! SELECT jsonb_typeof('["a", 1]') AS array;
!  array 
! -------
!  array
! (1 row)
! 
! SELECT jsonb_typeof('null') AS "null";
!  null 
! ------
!  null
! (1 row)
! 
! SELECT jsonb_typeof('1') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('-1') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('1.0') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('1e2') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('-1.0') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('true') AS boolean;
!  boolean 
! ---------
!  boolean
! (1 row)
! 
! SELECT jsonb_typeof('false') AS boolean;
!  boolean 
! ---------
!  boolean
! (1 row)
! 
! SELECT jsonb_typeof('"hello"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! SELECT jsonb_typeof('"true"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! SELECT jsonb_typeof('"1.0"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! -- extract_path, extract_path_as_text
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  jsonb_extract_path 
! --------------------
!  "stringy"
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  jsonb_extract_path 
! --------------------
!  {"f3": 1}
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  jsonb_extract_path 
! --------------------
!  "f3"
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  jsonb_extract_path 
! --------------------
!  1
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  jsonb_extract_path_text 
! -------------------------
!  stringy
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  jsonb_extract_path_text 
! -------------------------
!  {"f3": 1}
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  jsonb_extract_path_text 
! -------------------------
!  f3
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  jsonb_extract_path_text 
! -------------------------
!  1
! (1 row)
! 
! -- extract_path nulls
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- extract_path operators
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
!  ?column?  
! -----------
!  "stringy"
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
!  ?column?  
! -----------
!  {"f3": 1}
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
!  ?column? 
! ----------
!  "f3"
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
!  ?column? 
! ----------
!  stringy
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
!  ?column?  
! -----------
!  {"f3": 1}
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
!  ?column? 
! ----------
!  f3
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! -- corner cases for same
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
!           ?column?          
! ----------------------------
!  {"a": {"b": {"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::jsonb #> '{}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! select '"foo"'::jsonb #> '{}';
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '42'::jsonb #> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::jsonb #> '{}';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
!       ?column?       
! ---------------------
!  {"b": {"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::jsonb #> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
!           ?column?          
! ----------------------------
!  {"a": {"b": {"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::jsonb #>> '{}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! select '"foo"'::jsonb #>> '{}';
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '42'::jsonb #>> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::jsonb #>> '{}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
!       ?column?       
! ---------------------
!  {"b": {"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb #>> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #>> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #>> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array_elements
! SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
!     jsonb_array_elements    
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  null
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
! (6 rows)
! 
! SELECT * FROM jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]') q;
!            value            
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  null
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
! (6 rows)
! 
! SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!  jsonb_array_elements_text  
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
!  stringy
! (7 rows)
! 
! SELECT * FROM jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!            value            
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
!  stringy
! (7 rows)
! 
! -- populate_record
! CREATE TYPE jbpop AS (a text, b int, c timestamp);
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":[100,200,false],"x":43.2}') q;
!          a         | b | c 
! -------------------+---+---
!  [100, 200, false] |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":[100,200,false],"x":43.2}') q;
!          a         | b |            c             
! -------------------+---+--------------------------
!  [100, 200, false] | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
! ERROR:  invalid input syntax for type timestamp: "[100, 200, false]"
! -- populate_recordset
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!         a        | b  |            c             
! -----------------+----+--------------------------
!  [100, 200, 300] | 99 | 
!  {"z": true}     |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
! ERROR:  invalid input syntax for type timestamp: "[100, 200, 300]"
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!         a        | b  |            c             
! -----------------+----+--------------------------
!  [100, 200, 300] | 99 | 
!  {"z": true}     |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! -- handling of unicode surrogate pairs
! SELECT octet_length((jsonb '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a')::text) AS correct_in_utf8;
!  correct_in_utf8 
! -----------------
!               10
! (1 row)
! 
! SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a row
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a';
!                      ^
! DETAIL:  Unicode high surrogate must not follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong order
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogate
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ud83dX" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogate
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ude04X" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! -- handling of simple unicode escapes
! SELECT jsonb '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' AS correct_in_utf8;
!    correct_in_utf8    
! ----------------------
!  the Copyright  sign
! (1 row)
! 
! SELECT jsonb '{ "a":  "dollar \u0024 character" }' ->> 'a' AS correct_everyWHERE;
!  correct_everywhere 
! --------------------
!  dollar $ character
! (1 row)
! 
! SELECT jsonb '{ "a":  "null \u0000 escape" }' ->> 'a' AS not_unescaped;
!    not_unescaped    
! --------------------
!  null \u0000 escape
! (1 row)
! 
! -- jsonb_to_record and jsonb_to_recordset
! select * from jsonb_to_record('{"a":1,"b":"foo","c":"bar"}')
!     as x(a int, b text, d text);
!  a |  b  | d 
! ---+-----+---
!  1 | foo | 
! (1 row)
! 
! select * from jsonb_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
!     as x(a int, b text, c boolean);
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 
!  2 | bar | t
! (2 rows)
! 
! -- indexing
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
! CREATE INDEX jidx ON testjsonb USING gin (j);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
!  count 
! -------
!      3
! (1 row)
! 
! -- excercise GIN_SEARCH_MODE_ALL
! SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
! -- array exists - array elements should behave as keys (for GIN index scans too)
! CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
! SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
! -- type sensitive array exists - should return no rows (since "exists" only
! -- matches strings that are either object keys or array elements)
! SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
! -- However, a raw scalar is *contained* within the array
! SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
! RESET enable_seqscan;
! SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
!  count 
! -------
!   4791
! (1 row)
! 
! SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
!     key    | count 
! -----------+-------
!  line      |   884
!  query     |   207
!  pos       |   203
!  node      |   202
!  space     |   197
!  status    |   195
!  public    |   194
!  title     |   190
!  wait      |   190
!  org       |   189
!  user      |   189
!  coauthors |   188
!  disabled  |   185
!  indexed   |   184
!  cleaned   |   180
!  bad       |   179
!  date      |   179
!  world     |   176
!  state     |   172
!  subtitle  |   169
!  auth      |   168
!  abstract  |   161
!  array     |     5
!  age       |     2
!  foo       |     2
!  fool      |     1
! (26 rows)
! 
! -- sort/hash
! SELECT count(distinct j) FROM testjsonb;
!  count 
! -------
!    894
! (1 row)
! 
! SET enable_hashagg = off;
! SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
! SET enable_hashagg = on;
! SET enable_sort = off;
! SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
! SELECT distinct * FROM (values (jsonb '{}' || ''),('{}')) v(j);
!  j  
! ----
!  {}
! (1 row)
! 
! SET enable_sort = on;
! RESET enable_hashagg;
! RESET enable_sort;
! DROP INDEX jidx;
! DROP INDEX jidx_array;
! -- btree
! CREATE INDEX jidx ON testjsonb USING btree (j);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
!  count 
! -------
!    884
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
!  count 
! -------
!      1
! (1 row)
! 
! --gin path opclass
! DROP INDEX jidx;
! CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! -- excercise GIN_SEARCH_MODE_ALL
! SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
! RESET enable_seqscan;
! DROP INDEX jidx;
! -- nested tests
! SELECT '{"ff":{"a":12,"b":16}}'::jsonb;
!            jsonb            
! ----------------------------
!  {"ff": {"a": 12, "b": 16}}
! (1 row)
! 
! SELECT '{"ff":{"a":12,"b":16},"qq":123}'::jsonb;
!                  jsonb                 
! ---------------------------------------
!  {"ff": {"a": 12, "b": 16}, "qq": 123}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":12,"b":16,"c":["c1","c2"],"d":{"d1":"d1","d2":"d2","d1":"d3"}}}'::jsonb;
!                                               jsonb                                               
! --------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": 12, "b": 16, "c": ["c1", "c2"], "d": {"d1": "d3", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2"],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
!                                                 jsonb                                                 
! ------------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": "12", "b": "16", "c": ["c1", "c2"], "d": {"d1": "d1", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2",["c3"],{"c4":4}],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
!                                                           jsonb                                                          
! -------------------------------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": "12", "b": "16", "c": ["c1", "c2", ["c3"], {"c4": 4}], "d": {"d1": "d1", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"ff":["a","aaa"]}'::jsonb;
!         jsonb         
! ----------------------
!  {"ff": ["a", "aaa"]}
! (1 row)
! 
! SELECT
!   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'ff',
!   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'qq',
!   ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'Y') IS NULL AS f,
!   ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb ->> 'Y') IS NULL AS t,
!    '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'x';
!       ?column?      | ?column? | f | t | ?column? 
! --------------------+----------+---+---+----------
!  {"a": 12, "b": 16} | 123      | f | t | [1, 2]
! (1 row)
! 
! -- nested containment
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[2,1],"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '["a","b"]'::jsonb @> '["a","b","c","b"]';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '["a","b","c","b"]'::jsonb @> '["a","b"]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["a","b","c",[1,2]]'::jsonb @> '["a",[1,2]]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["a","b","c",[1,2]]'::jsonb @> '["b",[1,2]]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[3]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"c":3}]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4}]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},3]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},1]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- nested object field / array index lookup
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'n';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'a';
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'b';
!  ?column? 
! ----------
!  [1, 2]
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'c';
!  ?column? 
! ----------
!  {"1": 2}
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd';
!    ?column?    
! ---------------
!  {"1": [2, 3]}
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd' -> '1';
!  ?column? 
! ----------
!  [2, 3]
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'e';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 0; --expecting error
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 0;
!  ?column? 
! ----------
!  "a"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 1;
!  ?column? 
! ----------
!  "b"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 2;
!  ?column? 
! ----------
!  "c"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 3;
!  ?column? 
! ----------
!  [1, 2]
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 3 -> 1;
!  ?column? 
! ----------
!  2
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 4;
!  ?column? 
! ----------
!  null
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 5;
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> -1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! --nested path extraction
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
!  ?column? 
! ----------
!  "b"
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
!  ?column? 
! ----------
!  2
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
!  ?column? 
! ----------
!  3
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
!  ?column? 
! ----------
!  0
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
!  ?column? 
! ----------
!  [3, 4]
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
!    ?column?    
! ---------------
!  {"5": "five"}
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
!  ?column? 
! ----------
!  "five"
! (1 row)
! 
! --nested exists
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'n';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'b';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'c';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'd';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'e';
!  ?column? 
! ----------
!  f
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/indirect_toast.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/indirect_toast.out	2015-01-10 10:11:47.011649472 +0300
***************
*** 1,151 ****
! CREATE TABLE toasttest(descr text, cnt int DEFAULT 0, f1 text, f2 text);
! INSERT INTO toasttest(descr, f1, f2) VALUES('two-compressed', repeat('1234567890',1000), repeat('1234567890',1000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('two-toasted', repeat('1234567890',30000), repeat('1234567890',50000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-compressed,one-null', NULL, repeat('1234567890',1000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-toasted,one-null', NULL, repeat('1234567890',50000));
! -- check whether indirect tuples works on the most basic level
! SELECT descr, substring(make_tuple_indirect(toasttest)::text, 1, 200) FROM toasttest;
!           descr          |                                                                                                substring                                                                                                 
! -------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  two-compressed          | (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  two-toasted             | (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  one-compressed,one-null | ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  one-toasted,one-null    | ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without changing varlenas
! UPDATE toasttest SET cnt = cnt +1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without modifying asigned value
! UPDATE toasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification modifying, but effectively not changing
! UPDATE toasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! UPDATE toasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- check we didn't screw with main/toast tuple visiblity
! VACUUM FREEZE toasttest;
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- now create a trigger that forces all Datums to be indirect ones
! CREATE FUNCTION update_using_indirect()
!         RETURNS trigger
!         LANGUAGE plpgsql AS $$
! BEGIN
!     NEW := make_tuple_indirect(NEW);
!     RETURN NEW;
! END$$;
! CREATE TRIGGER toasttest_update_indirect
!         BEFORE INSERT OR UPDATE
!         ON toasttest
!         FOR EACH ROW
!         EXECUTE PROCEDURE update_using_indirect();
! -- modification without changing varlenas
! UPDATE toasttest SET cnt = cnt +1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without modifying asigned value
! UPDATE toasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification modifying, but effectively not changing
! UPDATE toasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! UPDATE toasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-toasted,one-null, via indirect', repeat('1234567890',30000), NULL);
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
! (5 rows)
! 
! -- check we didn't screw with main/toast tuple visiblity
! VACUUM FREEZE toasttest;
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
! (5 rows)
! 
! DROP TABLE toasttest;
! DROP FUNCTION update_using_indirect();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/equivclass.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/equivclass.out	2015-01-10 10:11:47.007649472 +0300
***************
*** 1,383 ****
! --
! -- Tests for the planner's "equivalence class" mechanism
! --
! -- One thing that's not tested well during normal querying is the logic
! -- for handling "broken" ECs.  This is because an EC can only become broken
! -- if its underlying btree operator family doesn't include a complete set
! -- of cross-type equality operators.  There are not (and should not be)
! -- any such families built into Postgres; so we have to hack things up
! -- to create one.  We do this by making two alias types that are really
! -- int8 (so we need no new C code) and adding only some operators for them
! -- into the standard integer_ops opfamily.
! create type int8alias1;
! create function int8alias1in(cstring) returns int8alias1
!   strict immutable language internal as 'int8in';
! NOTICE:  return type int8alias1 is only a shell
! create function int8alias1out(int8alias1) returns cstring
!   strict immutable language internal as 'int8out';
! NOTICE:  argument type int8alias1 is only a shell
! create type int8alias1 (
!     input = int8alias1in,
!     output = int8alias1out,
!     like = int8
! );
! create type int8alias2;
! create function int8alias2in(cstring) returns int8alias2
!   strict immutable language internal as 'int8in';
! NOTICE:  return type int8alias2 is only a shell
! create function int8alias2out(int8alias2) returns cstring
!   strict immutable language internal as 'int8out';
! NOTICE:  argument type int8alias2 is only a shell
! create type int8alias2 (
!     input = int8alias2in,
!     output = int8alias2out,
!     like = int8
! );
! create cast (int8 as int8alias1) without function;
! create cast (int8 as int8alias2) without function;
! create cast (int8alias1 as int8) without function;
! create cast (int8alias2 as int8) without function;
! create function int8alias1eq(int8alias1, int8alias1) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8alias1, rightarg = int8alias1,
!     commutator = =,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias1, int8alias1);
! create function int8alias2eq(int8alias2, int8alias2) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias2eq,
!     leftarg = int8alias2, rightarg = int8alias2,
!     commutator = =,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias2, int8alias2);
! create function int8alias1eq(int8, int8alias1) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8, rightarg = int8alias1,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8, int8alias1);
! create function int8alias1eq(int8alias1, int8alias2) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8alias1, rightarg = int8alias2,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias1, int8alias2);
! create function int8alias1lt(int8alias1, int8alias1) returns bool
!   strict immutable language internal as 'int8lt';
! create operator < (
!     procedure = int8alias1lt,
!     leftarg = int8alias1, rightarg = int8alias1
! );
! alter operator family integer_ops using btree add
!   operator 1 < (int8alias1, int8alias1);
! create function int8alias1cmp(int8, int8alias1) returns int
!   strict immutable language internal as 'btint8cmp';
! alter operator family integer_ops using btree add
!   function 1 int8alias1cmp (int8, int8alias1);
! create table ec0 (ff int8 primary key, f1 int8, f2 int8);
! create table ec1 (ff int8 primary key, f1 int8alias1, f2 int8alias2);
! create table ec2 (xf int8 primary key, x1 int8alias1, x2 int8alias2);
! -- for the moment we only want to look at nestloop plans
! set enable_hashjoin = off;
! set enable_mergejoin = off;
! --
! -- Note that for cases where there's a missing operator, we don't care so
! -- much whether the plan is ideal as that we don't fail or generate an
! -- outright incorrect plan.
! --
! explain (costs off)
!   select * from ec0 where ff = f1 and f1 = '42'::int8;
!             QUERY PLAN            
! ----------------------------------
!  Index Scan using ec0_pkey on ec0
!    Index Cond: (ff = 42::bigint)
!    Filter: (f1 = 42::bigint)
! (3 rows)
! 
! explain (costs off)
!   select * from ec0 where ff = f1 and f1 = '42'::int8alias1;
!               QUERY PLAN               
! ---------------------------------------
!  Index Scan using ec0_pkey on ec0
!    Index Cond: (ff = '42'::int8alias1)
!    Filter: (f1 = '42'::int8alias1)
! (3 rows)
! 
! explain (costs off)
!   select * from ec1 where ff = f1 and f1 = '42'::int8alias1;
!               QUERY PLAN               
! ---------------------------------------
!  Index Scan using ec1_pkey on ec1
!    Index Cond: (ff = '42'::int8alias1)
!    Filter: (f1 = '42'::int8alias1)
! (3 rows)
! 
! explain (costs off)
!   select * from ec1 where ff = f1 and f1 = '42'::int8alias2;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Seq Scan on ec1
!    Filter: ((ff = f1) AND (f1 = '42'::int8alias2))
! (2 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and ff = '42'::int8;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Nested Loop
!    Join Filter: (ec1.ff = ec2.x1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: ((ff = 42::bigint) AND (ff = 42::bigint))
!    ->  Seq Scan on ec2
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and ff = '42'::int8alias1;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = '42'::int8alias1)
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias1)
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and '42'::int8 = x1;
!                QUERY PLAN               
! ----------------------------------------
!  Nested Loop
!    Join Filter: (ec1.ff = ec2.x1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Seq Scan on ec2
!          Filter: (42::bigint = x1)
! (6 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias1;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = '42'::int8alias1)
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias1)
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias2;
!                QUERY PLAN                
! -----------------------------------------
!  Nested Loop
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias2)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = ec2.x1)
! (5 rows)
! 
! create unique index ec1_expr1 on ec1((ff + 1));
! create unique index ec1_expr2 on ec1((ff + 2 + 1));
! create unique index ec1_expr3 on ec1((ff + 3 + 1));
! create unique index ec1_expr4 on ec1((ff + 4));
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                Index Cond: (((ff + 3) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = ec1.f1)
! (10 rows)
! 
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8 and ec1.ff = ec1.f1;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Nested Loop
!    Join Filter: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: ((ff = 42::bigint) AND (ff = 42::bigint))
!          Filter: (ff = f1)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = 42::bigint)
!          ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                Index Cond: (((ff + 3) + 1) = 42::bigint)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = 42::bigint)
! (12 rows)
! 
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss2
!   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Nested Loop
!    ->  Nested Loop
!          ->  Index Scan using ec1_pkey on ec1
!                Index Cond: (ff = 42::bigint)
!          ->  Append
!                ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                      Index Cond: (((ff + 2) + 1) = ec1.f1)
!                ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                      Index Cond: (((ff + 3) + 1) = ec1.f1)
!                ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                      Index Cond: ((ff + 4) = ec1.f1)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_4
!                Index Cond: (((ff + 2) + 1) = (((ec1_1.ff + 2) + 1)))
!          ->  Index Scan using ec1_expr3 on ec1 ec1_5
!                Index Cond: (((ff + 3) + 1) = (((ec1_1.ff + 2) + 1)))
!          ->  Index Scan using ec1_expr4 on ec1 ec1_6
!                Index Cond: ((ff + 4) = (((ec1_1.ff + 2) + 1)))
! (18 rows)
! 
! -- let's try that as a mergejoin
! set enable_mergejoin = on;
! set enable_nestloop = off;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss2
!   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Merge Join
!    Merge Cond: ((((ec1_4.ff + 2) + 1)) = (((ec1_1.ff + 2) + 1)))
!    ->  Merge Append
!          Sort Key: (((ec1_4.ff + 2) + 1))
!          ->  Index Scan using ec1_expr2 on ec1 ec1_4
!          ->  Index Scan using ec1_expr3 on ec1 ec1_5
!          ->  Index Scan using ec1_expr4 on ec1 ec1_6
!    ->  Materialize
!          ->  Merge Join
!                Merge Cond: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!                ->  Merge Append
!                      Sort Key: (((ec1_1.ff + 2) + 1))
!                      ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                      ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                      ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                ->  Materialize
!                      ->  Sort
!                            Sort Key: ec1.f1
!                            ->  Index Scan using ec1_pkey on ec1
!                                  Index Cond: (ff = 42::bigint)
! (20 rows)
! 
! -- check partially indexed scan
! set enable_nestloop = on;
! set enable_mergejoin = off;
! drop index ec1_expr3;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = ec1.f1)
!          ->  Seq Scan on ec1 ec1_2
!                Filter: (((ff + 3) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = ec1.f1)
! (10 rows)
! 
! -- let's try that as a mergejoin
! set enable_mergejoin = on;
! set enable_nestloop = off;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Merge Join
!    Merge Cond: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!    ->  Merge Append
!          Sort Key: (((ec1_1.ff + 2) + 1))
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!          ->  Sort
!                Sort Key: (((ec1_2.ff + 3) + 1))
!                ->  Seq Scan on ec1 ec1_2
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!    ->  Materialize
!          ->  Sort
!                Sort Key: ec1.f1
!                ->  Index Scan using ec1_pkey on ec1
!                      Index Cond: (ff = 42::bigint)
! (14 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rowtypes.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/rowtypes.out	2015-01-10 10:11:47.831649492 +0300
***************
*** 240,250 ****
  select thousand, tenthous from tenk1
  where (thousand, tenthous) >= (997, 5000)
  order by thousand, tenthous;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Index Only Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: (ROW(thousand, tenthous) >= ROW(997, 5000))
! (2 rows)
  
  select thousand, tenthous from tenk1
  where (thousand, tenthous) >= (997, 5000)
--- 240,254 ----
  select thousand, tenthous from tenk1
  where (thousand, tenthous) >= (997, 5000)
  order by thousand, tenthous;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Sort
!    Sort Key: thousand, tenthous
!    ->  Bitmap Heap Scan on tenk1
!          Recheck Cond: (ROW(thousand, tenthous) >= ROW(997, 5000))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: (ROW(thousand, tenthous) >= ROW(997, 5000))
! (6 rows)
  
  select thousand, tenthous from tenk1
  where (thousand, tenthous) >= (997, 5000)
***************
*** 589,608 ****
  select row_to_json(q) from
    (select thousand, tenthous from tenk1
     where thousand = 42 and tenthous < 2000 offset 0) q;
!                          QUERY PLAN                          
! -------------------------------------------------------------
   Subquery Scan on q
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!          Index Cond: ((thousand = 42) AND (tenthous < 2000))
! (3 rows)
  
  select row_to_json(q) from
    (select thousand, tenthous from tenk1
     where thousand = 42 and tenthous < 2000 offset 0) q;
             row_to_json           
  ---------------------------------
-  {"thousand":42,"tenthous":42}
   {"thousand":42,"tenthous":1042}
  (2 rows)
  
  select row_to_json(q) from
--- 593,614 ----
  select row_to_json(q) from
    (select thousand, tenthous from tenk1
     where thousand = 42 and tenthous < 2000 offset 0) q;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
   Subquery Scan on q
!    ->  Bitmap Heap Scan on tenk1
!          Recheck Cond: ((thousand = 42) AND (tenthous < 2000))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous < 2000))
! (5 rows)
  
  select row_to_json(q) from
    (select thousand, tenthous from tenk1
     where thousand = 42 and tenthous < 2000 offset 0) q;
             row_to_json           
  ---------------------------------
   {"thousand":42,"tenthous":1042}
+  {"thousand":42,"tenthous":42}
  (2 rows)
  
  select row_to_json(q) from
***************
*** 610,617 ****
     where thousand = 42 and tenthous < 2000 offset 0) q;
      row_to_json    
  -------------------
-  {"x":42,"y":42}
   {"x":42,"y":1042}
  (2 rows)
  
  select row_to_json(q) from
--- 616,623 ----
     where thousand = 42 and tenthous < 2000 offset 0) q;
      row_to_json    
  -------------------
   {"x":42,"y":1042}
+  {"x":42,"y":42}
  (2 rows)
  
  select row_to_json(q) from
***************
*** 619,626 ****
     where thousand = 42 and tenthous < 2000 offset 0) q(a,b);
      row_to_json    
  -------------------
-  {"a":42,"b":42}
   {"a":42,"b":1042}
  (2 rows)
  
  create temp table tt1 as select * from int8_tbl limit 2;
--- 625,632 ----
     where thousand = 42 and tenthous < 2000 offset 0) q(a,b);
      row_to_json    
  -------------------
   {"a":42,"b":1042}
+  {"a":42,"b":42}
  (2 rows)
  
  create temp table tt1 as select * from int8_tbl limit 2;

======================================================================

*** /home/orion/postgres/src/test/regress/expected/with.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/with.out	2015-01-10 10:11:47.947649495 +0300
***************
*** 2083,2126 ****
  EXPLAIN (VERBOSE, COSTS OFF)
  WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )
  DELETE FROM a USING wcte WHERE aa = q2;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Delete on public.a
!    CTE wcte
!      ->  Insert on public.int8_tbl
!            Output: int8_tbl.q2
!            ->  Result
!                  Output: 42::bigint, 47::bigint
!    ->  Nested Loop
!          Output: a.ctid, wcte.*
!          Join Filter: (a.aa = wcte.q2)
!          ->  Seq Scan on public.a
!                Output: a.ctid, a.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: b.ctid, wcte.*
!          Join Filter: (b.aa = wcte.q2)
!          ->  Seq Scan on public.b
!                Output: b.ctid, b.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: c.ctid, wcte.*
!          Join Filter: (c.aa = wcte.q2)
!          ->  Seq Scan on public.c
!                Output: c.ctid, c.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: d.ctid, wcte.*
!          Join Filter: (d.aa = wcte.q2)
!          ->  Seq Scan on public.d
!                Output: d.ctid, d.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
! (34 rows)
! 
  -- error cases
  -- data-modifying WITH tries to use its own output
  WITH RECURSIVE t AS (
--- 2083,2091 ----
  EXPLAIN (VERBOSE, COSTS OFF)
  WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )
  DELETE FROM a USING wcte WHERE aa = q2;
! ERROR:  relation "a" does not exist
! LINE 3: DELETE FROM a USING wcte WHERE aa = q2;
!                     ^
  -- error cases
  -- data-modifying WITH tries to use its own output
  WITH RECURSIVE t AS (

======================================================================

