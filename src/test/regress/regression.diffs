*** /home/orion/postgres/src/test/regress/expected/create_index.out	2014-11-21 01:48:04.319414000 +0300
<<<<<<< HEAD
--- /home/orion/postgres/src/test/regress/results/create_index.out	2015-01-27 11:37:29.378131772 +0300
***************
*** 1697,1702 ****
--- 1697,1808 ----
  SET enable_indexscan = OFF;
  SET enable_bitmapscan = ON;
  CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
+ NOTICE:  REGISTER.slot = 0, gen = 1
+ NOTICE:  works 0
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 863794791 still referenced
  explain (costs off)
  SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
                       QUERY PLAN                     
***************
*** 1710,1913 ****
  (6 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
=======
--- /home/orion/postgres/src/test/regress/results/create_index.out	2015-01-26 12:33:23.243031273 +0300
***************
*** 1697,2833 ****
  SET enable_indexscan = OFF;
  SET enable_bitmapscan = ON;
  CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
! explain (costs off)
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Sort
!    Sort Key: seqno
!    ->  Bitmap Heap Scan on array_index_op_test
!          Recheck Cond: (i @> '{32}'::integer[])
!          ->  Bitmap Index Scan on intarrayidx
!                Index Cond: (i @> '{32}'::integer[])
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (3 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (11 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |       i       |                                                             t                                                              
! -------+---------------+----------------------------------------------------------------------------------------------------------------------------
!     40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    101 | {}            | {}
! (4 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |    i    |                                                        t                                                        
! -------+---------+-----------------------------------------------------------------------------------------------------------------
!     95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
   seqno | i | t 
--- 1816,1869 ----
  (6 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
   seqno | i | t 
***************
*** 1915,1924 ****
  (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
   seqno |   i    |   t    
--- 1871,1879 ----
  (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
   seqno |   i    |   t    
***************
*** 1943,1948 ****
--- 1898,2009 ----
  (1 row)
  
  CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
+ NOTICE:  REGISTER.slot = 0, gen = 2
+ NOTICE:  works 0
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 81212946 still referenced
  explain (costs off)
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
                           QUERY PLAN                         
***************
*** 1956,2137 ****
  (6 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
=======
! 
! CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
! explain (costs off)
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Sort
!    Sort Key: seqno
!    ->  Bitmap Heap Scan on array_index_op_test
!          Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
!          ->  Bitmap Index Scan on textarrayidx
!                Index Cond: (t @> '{AAAAAAAA72908}'::text[])
! (6 rows)
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |  i   |                                 t                                  
! -------+------+--------------------------------------------------------------------
!     79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
! (6 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |         i          |                                                     t                                                     
! -------+--------------------+-----------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
!     45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!    101 | {}                 | {}
! (3 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |     i      |           t            
! -------+------------+------------------------
!     96 | {23,97,43} | {AAAAAAAAAA646,A87088}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
   seqno | i | t 
--- 2017,2070 ----
  (6 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
   seqno | i | t 
***************
*** 2139,2215 ****
  (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
<<<<<<< HEAD
  
  -- And try it with a multicolumn GIN index
  DROP INDEX intarrayidx, textarrayidx;
  CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
  SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
=======
! 
! -- And try it with a multicolumn GIN index
! DROP INDEX intarrayidx, textarrayidx;
! CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
! SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |               i                |                                                                              t                                                                              
! -------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
!     19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!    100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (7 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |               i                |                                                                              t                                                                              
! -------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
!     19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!    100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (7 rows)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |              i              |                                      t                                       
! -------+-----------------------------+------------------------------------------------------------------------------
!    100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno |              i              |                                      t                                       
! -------+-----------------------------+------------------------------------------------------------------------------
!    100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
=======
! 
! SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
<<<<<<< HEAD
  
  SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
   seqno |   i    |   t    
--- 2072,2327 ----
  (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  -- And try it with a multicolumn GIN index
  DROP INDEX intarrayidx, textarrayidx;
  CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
+ NOTICE:  REGISTER.slot = 0, gen = 3
+ NOTICE:  works 0
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 993732425 still referenced
  SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
  
  SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
   seqno |   i    |   t    
***************
*** 2233,2242 ****
  CREATE TABLE array_gin_test (a int[]);
  INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
  CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
  SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
   count 
  -------
!   2000
  (1 row)
  
  DROP TABLE array_gin_test;
--- 2345,12357 ----
  CREATE TABLE array_gin_test (a int[]);
  INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
  CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
+ NOTICE:  REGISTER.slot = 0, gen = 4
+ NOTICE:  works 0
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ WARNING:  dynamic shared memory leak: segment 1516772886 still referenced
  SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
   count 
  -------
!      0
  (1 row)
  
  DROP TABLE array_gin_test;
***************
*** 2245,2250 ****
--- 12360,12471 ----
  --
  CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
    WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
+ NOTICE:  REGISTER.slot = 0, gen = 5
+ NOTICE:  works 0
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 1959366183 still referenced
  \d+ gin_relopts_test
       Index "public.gin_relopts_test"
   Column |  Type   | Definition | Storage 

======================================================================

*** /home/orion/postgres/src/test/regress/expected/gin.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/gin.out	2015-01-27 11:37:36.017449561 +0300
***************
*** 6,11 ****
--- 6,14 ----
  -- Create and populate a test table with a GIN index.
  create table gin_test_tbl(i int4[]);
  create index gin_test_idx on gin_test_tbl using gin (i) with (fastupdate = on);
+ NOTICE:  REGISTER.slot = 0, gen = 6
+ NOTICE:  works 0
+ WARNING:  dynamic shared memory leak: segment 335759464 still referenced
  insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
  insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
  vacuum gin_test_tbl; -- flush the fastupdate buffers

======================================================================

*** /home/orion/postgres/src/test/regress/expected/tsearch.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/tsearch.out	2015-01-27 11:37:38.390635485 +0300
***************
*** 151,203 ****
  RESET enable_seqscan;
  DROP INDEX wowidx;
  CREATE INDEX wowidx ON test_tsvector USING gin (a);
  SET enable_seqscan=OFF;
  SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
   count 
  -------
!    158
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
   count 
  -------
!     17
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
   count 
  -------
!      6
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
   count 
  -------
!     98
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
   count 
  -------
!     23
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
   count 
  -------
!     39
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
   count 
  -------
!    494
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
   count 
  -------
!    158
  (1 row)
  
  RESET enable_seqscan;
--- 151,714 ----
  RESET enable_seqscan;
  DROP INDEX wowidx;
  CREATE INDEX wowidx ON test_tsvector USING gin (a);
+ NOTICE:  REGISTER.slot = 0, gen = 7
+ NOTICE:  works 0
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 60
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 37
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 23
+ NOTICE:  nentries = 22
+ NOTICE:  nentries = 91
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 37
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 21
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 92
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 105
+ NOTICE:  nentries = 25
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 60
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 49
+ NOTICE:  nentries = 80
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 46
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 64
+ NOTICE:  nentries = 50
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 21
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 67
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 51
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 81
+ NOTICE:  nentries = 47
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 82
+ NOTICE:  nentries = 23
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 78
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 25
+ NOTICE:  nentries = 47
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 61
+ NOTICE:  nentries = 61
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 99
+ NOTICE:  nentries = 89
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 50
+ NOTICE:  nentries = 48
+ NOTICE:  nentries = 27
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 79
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 63
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 64
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 84
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 37
+ NOTICE:  nentries = 50
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 63
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 105
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 61
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 59
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 25
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 36
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 73
+ NOTICE:  nentries = 33
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 75
+ NOTICE:  nentries = 99
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 93
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 78
+ NOTICE:  nentries = 37
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 99
+ NOTICE:  nentries = 27
+ NOTICE:  nentries = 93
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 64
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 102
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 25
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 60
+ NOTICE:  nentries = 59
+ NOTICE:  nentries = 23
+ NOTICE:  nentries = 47
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 26
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 27
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 86
+ NOTICE:  nentries = 86
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 60
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 86
+ NOTICE:  nentries = 26
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 108
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 82
+ NOTICE:  nentries = 92
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 61
+ NOTICE:  nentries = 28
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 93
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 91
+ NOTICE:  nentries = 82
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 74
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 91
+ NOTICE:  nentries = 101
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 92
+ NOTICE:  nentries = 77
+ NOTICE:  nentries = 103
+ NOTICE:  nentries = 79
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 63
+ NOTICE:  nentries = 47
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 77
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 93
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 76
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 91
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 46
+ NOTICE:  nentries = 79
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 66
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 46
+ NOTICE:  nentries = 80
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 56
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 25
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 26
+ NOTICE:  nentries = 101
+ NOTICE:  nentries = 27
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 46
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 103
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 66
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 51
+ NOTICE:  nentries = 37
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 46
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 60
+ NOTICE:  nentries = 64
+ NOTICE:  nentries = 63
+ NOTICE:  nentries = 80
+ NOTICE:  nentries = 48
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 48
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 21
+ NOTICE:  nentries = 101
+ NOTICE:  nentries = 22
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 81
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 50
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 33
+ NOTICE:  nentries = 81
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 56
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 38
+ NOTICE:  nentries = 58
+ NOTICE:  nentries = 34
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 102
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 55
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 58
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 69
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 76
+ NOTICE:  nentries = 58
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 76
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 56
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 77
+ NOTICE:  nentries = 27
+ NOTICE:  nentries = 48
+ NOTICE:  nentries = 48
+ NOTICE:  nentries = 105
+ NOTICE:  nentries = 61
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 80
+ NOTICE:  nentries = 83
+ NOTICE:  nentries = 51
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 39
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 36
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 92
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 73
+ NOTICE:  nentries = 78
+ NOTICE:  nentries = 42
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 95
+ NOTICE:  nentries = 50
+ NOTICE:  nentries = 33
+ NOTICE:  nentries = 81
+ NOTICE:  nentries = 36
+ NOTICE:  nentries = 64
+ NOTICE:  nentries = 31
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 100
+ NOTICE:  nentries = 51
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 23
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 26
+ NOTICE:  nentries = 21
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 28
+ NOTICE:  nentries = 73
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 56
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 56
+ NOTICE:  nentries = 21
+ NOTICE:  nentries = 30
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 79
+ NOTICE:  nentries = 76
+ NOTICE:  nentries = 38
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 103
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 32
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 72
+ NOTICE:  nentries = 43
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 59
+ NOTICE:  nentries = 105
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 70
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 35
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 101
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 62
+ NOTICE:  nentries = 74
+ NOTICE:  nentries = 75
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 68
+ NOTICE:  nentries = 28
+ NOTICE:  nentries = 47
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 80
+ NOTICE:  nentries = 86
+ NOTICE:  nentries = 89
+ NOTICE:  nentries = 74
+ NOTICE:  nentries = 29
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 103
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 74
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 98
+ NOTICE:  nentries = 28
+ NOTICE:  nentries = 59
+ NOTICE:  nentries = 62
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 41
+ NOTICE:  nentries = 26
+ NOTICE:  nentries = 53
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 30
+ NOTICE:  nentries = 44
+ NOTICE:  nentries = 40
+ NOTICE:  nentries = 94
+ NOTICE:  nentries = 49
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 84
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 71
+ NOTICE:  nentries = 57
+ NOTICE:  nentries = 90
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 101
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 88
+ NOTICE:  nentries = 24
+ NOTICE:  nentries = 65
+ NOTICE:  nentries = 52
+ NOTICE:  nentries = 97
+ NOTICE:  nentries = 102
+ NOTICE:  nentries = 54
+ NOTICE:  nentries = 93
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 96
+ NOTICE:  nentries = 45
+ NOTICE:  nentries = 107
+ NOTICE:  nentries = 85
+ NOTICE:  nentries = 87
+ NOTICE:  nentries = 79
+ NOTICE:  nentries = 30
+ WARNING:  dynamic shared memory leak: segment 464695670 still referenced
  SET enable_seqscan=OFF;
  SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
   count 
  -------
!      0
  (1 row)
  
  RESET enable_seqscan;
***************
*** 1095,1100 ****
--- 1606,1614 ----
  -- test finding items in GIN's pending list
  create temp table pendtest (ts tsvector);
  create index pendtest_idx on pendtest using gin(ts);
+ NOTICE:  REGISTER.slot = 0, gen = 8
+ NOTICE:  works 0
+ WARNING:  dynamic shared memory leak: segment 1350775787 still referenced
  insert into pendtest values (to_tsvector('Lore ipsam'));
  insert into pendtest values (to_tsvector('Lore ipsum'));
  select * from pendtest where 'ipsu:*'::tsquery @@ ts;

======================================================================

*** /home/orion/postgres/src/test/regress/expected/jsonb.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/jsonb.out	2015-01-27 11:37:38.810845471 +0300
***************
*** 1888,1947 ****
  (1 row)
  
  CREATE INDEX jidx ON testjsonb USING gin (j);
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
   count 
  -------
!      1
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
   count 
  -------
!     15
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
   count 
  -------
!      2
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
   count 
  -------
!      2
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
   count 
  -------
!      2
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
   count 
  -------
!      3
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
   count 
  -------
!      3
  (1 row)
  
  -- excercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
   count 
  -------
!   1012
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
   count 
  -------
!    194
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
--- 1888,2962 ----
  (1 row)
  
  CREATE INDEX jidx ON testjsonb USING gin (j);
+ NOTICE:  REGISTER.slot = 0, gen = 9
+ NOTICE:  works 0
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 20
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 19
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 15
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 18
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 12
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 13
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 14
+ NOTICE:  nentries = 17
+ NOTICE:  nentries = 16
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 11
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 242386456 still referenced
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
   count 
  -------
!      0
  (1 row)
  
  -- excercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
***************
*** 1953,1973 ****
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
   count 
  -------
!    337
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
   count 
  -------
!     42
  (1 row)
  
  -- array exists - array elements should behave as keys (for GIN index scans too)
  CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
   count 
  -------
!      3
  (1 row)
  
  -- type sensitive array exists - should return no rows (since "exists" only
--- 2968,4003 ----
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
   count 
  -------
!      0
  (1 row)
  
  -- array exists - array elements should behave as keys (for GIN index scans too)
  CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
+ NOTICE:  REGISTER.slot = 0, gen = 10
+ NOTICE:  works 0
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 1843902256 still referenced
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
   count 
  -------
!      0
  (1 row)
  
  -- type sensitive array exists - should return no rows (since "exists" only
***************
*** 1982,1988 ****
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
   count 
  -------
!      1
  (1 row)
  
  RESET enable_seqscan;
--- 4012,4018 ----
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
   count 
  -------
!      0
  (1 row)
  
  RESET enable_seqscan;
***************
*** 2074,2115 ****
  --gin path opclass
  DROP INDEX jidx;
  CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
   count 
  -------
!      1
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
   count 
  -------
!     15
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
   count 
  -------
!      2
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
   count 
  -------
!      2
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
   count 
  -------
!      2
  (1 row)
  
  -- excercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
   count 
  -------
!   1012
  (1 row)
  
  RESET enable_seqscan;
--- 4104,5160 ----
  --gin path opclass
  DROP INDEX jidx;
  CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
+ NOTICE:  REGISTER.slot = 0, gen = 11
+ NOTICE:  works 0
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 10
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 3
+ NOTICE:  nentries = 4
+ NOTICE:  nentries = 7
+ NOTICE:  nentries = 9
+ NOTICE:  nentries = 8
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 5
+ NOTICE:  nentries = 6
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 2
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ NOTICE:  nentries = 1
+ WARNING:  dynamic shared memory leak: segment 6664983 still referenced
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
   count 
  -------
!      0
  (1 row)
  
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
   count 
  -------
!      0
  (1 row)
  
  -- excercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
   count 
  -------
!      0
  (1 row)
  
  RESET enable_seqscan;
=======
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! RESET enable_seqscan;
! RESET enable_indexscan;
! RESET enable_bitmapscan;
! --
! -- Try a GIN index with a lot of items with same key. (GIN creates a posting
! -- tree when there are enough duplicates)
! --
! CREATE TABLE array_gin_test (a int[]);
! INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
! CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
! SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
!  count 
! -------
!   2000
! (1 row)
! 
! DROP TABLE array_gin_test;
! --
! -- Test GIN index's reloptions
! --
! CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
!   WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
! \d+ gin_relopts_test
!      Index "public.gin_relopts_test"
!  Column |  Type   | Definition | Storage 
! --------+---------+------------+---------
!  i      | integer | i          | plain
! gin, for table "public.array_index_op_test"
! Options: fastupdate=on, gin_pending_list_limit=128
! 
! --
! -- HASH
! --
! CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! -- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
! --
! -- Test functional index
! --
! CREATE TABLE func_index_heap (f1 text, f2 text);
! CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
! INSERT INTO func_index_heap VALUES('ABC','DEF');
! INSERT INTO func_index_heap VALUES('AB','CDEFG');
! INSERT INTO func_index_heap VALUES('QWE','RTY');
! -- this should fail because of unique index:
! INSERT INTO func_index_heap VALUES('ABCD', 'EF');
! ERROR:  duplicate key value violates unique constraint "func_index_index"
! DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
! -- but this shouldn't:
! INSERT INTO func_index_heap VALUES('QWERTY');
! --
! -- Same test, expressional index
! --
! DROP TABLE func_index_heap;
! CREATE TABLE func_index_heap (f1 text, f2 text);
! CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
! INSERT INTO func_index_heap VALUES('ABC','DEF');
! INSERT INTO func_index_heap VALUES('AB','CDEFG');
! INSERT INTO func_index_heap VALUES('QWE','RTY');
! -- this should fail because of unique index:
! INSERT INTO func_index_heap VALUES('ABCD', 'EF');
! ERROR:  duplicate key value violates unique constraint "func_index_index"
! DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
! -- but this shouldn't:
! INSERT INTO func_index_heap VALUES('QWERTY');
! --
! -- Also try building functional, expressional, and partial indexes on
! -- tables that already contain data.
! --
! create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
! create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
! create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
! --
! -- Try some concurrent index builds
! --
! -- Unfortunately this only tests about half the code paths because there are
! -- no concurrent updates happening to the table at the same time.
! CREATE TABLE concur_heap (f1 text, f2 text);
! -- empty table
! CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
! CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! NOTICE:  relation "concur_index1" already exists, skipping
! INSERT INTO concur_heap VALUES  ('a','b');
! INSERT INTO concur_heap VALUES  ('b','b');
! -- unique index
! CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
! CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! NOTICE:  relation "concur_index2" already exists, skipping
! -- check if constraint is set up properly to be enforced
! INSERT INTO concur_heap VALUES ('b','x');
! ERROR:  duplicate key value violates unique constraint "concur_index2"
! DETAIL:  Key (f1)=(b) already exists.
! -- check if constraint is enforced properly at build time
! CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  could not create unique index "concur_index3"
! DETAIL:  Key (f2)=(b) is duplicated.
! -- test that expression indexes and partial indexes work concurrently
! CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
! CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
! -- here we also check that you can default the index name
! CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
! -- You can't do a concurrent index build in a transaction
! BEGIN;
! CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
! ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
! COMMIT;
! -- But you can do a regular index build in a transaction
! BEGIN;
! CREATE INDEX std_index on concur_heap(f2);
! COMMIT;
! -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
! VACUUM FULL concur_heap;
! REINDEX TABLE concur_heap;
! ERROR:  could not create unique index "concur_index3"
! DETAIL:  Key (f2)=(b) is duplicated.
! DELETE FROM concur_heap WHERE f1 = 'b';
! VACUUM FULL concur_heap;
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "concur_index2" UNIQUE, btree (f1)
!     "concur_index3" UNIQUE, btree (f2) INVALID
!     "concur_heap_expr_idx" btree ((f2 || f1))
!     "concur_index1" btree (f2, f1)
!     "concur_index4" btree (f2) WHERE f1 = 'a'::text
!     "concur_index5" btree (f2) WHERE f1 = 'x'::text
!     "std_index" btree (f2)
! 
! REINDEX TABLE concur_heap;
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "concur_index2" UNIQUE, btree (f1)
!     "concur_index3" UNIQUE, btree (f2)
!     "concur_heap_expr_idx" btree ((f2 || f1))
!     "concur_index1" btree (f2, f1)
!     "concur_index4" btree (f2) WHERE f1 = 'a'::text
!     "concur_index5" btree (f2) WHERE f1 = 'x'::text
!     "std_index" btree (f2)
! 
! --
! -- Try some concurrent index drops
! --
! DROP INDEX CONCURRENTLY "concur_index2";				-- works
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
! NOTICE:  index "concur_index2" does not exist, skipping
! -- failures
! DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
! ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
! BEGIN;
! DROP INDEX CONCURRENTLY "concur_index5";
! ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
! ROLLBACK;
! -- successes
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
! DROP INDEX CONCURRENTLY "concur_index4";
! DROP INDEX CONCURRENTLY "concur_index5";
! DROP INDEX CONCURRENTLY "concur_index1";
! DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
! \d concur_heap
! Table "public.concur_heap"
!  Column | Type | Modifiers 
! --------+------+-----------
!  f1     | text | 
!  f2     | text | 
! Indexes:
!     "std_index" btree (f2)
! 
! DROP TABLE concur_heap;
! --
! -- Test ADD CONSTRAINT USING INDEX
! --
! CREATE TABLE cwi_test( a int , b varchar(10), c char);
! -- add some data so that all tests have something to work with.
! INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
! CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
! ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
! \d cwi_test
!           Table "public.cwi_test"
!  Column |         Type          | Modifiers 
! --------+-----------------------+-----------
!  a      | integer               | not null
!  b      | character varying(10) | not null
!  c      | character(1)          | 
! Indexes:
!     "cwi_uniq_idx" PRIMARY KEY, btree (a, b)
! 
! \d cwi_uniq_idx
!          Index "public.cwi_uniq_idx"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  a      | integer               | a
!  b      | character varying(10) | b
! primary key, btree, for table "public.cwi_test"
! 
! CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
! ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
! 	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
! 		USING INDEX cwi_uniq2_idx;
! NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
! \d cwi_test
!           Table "public.cwi_test"
!  Column |         Type          | Modifiers 
! --------+-----------------------+-----------
!  a      | integer               | not null
!  b      | character varying(10) | not null
!  c      | character(1)          | 
! Indexes:
!     "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)
! 
! \d cwi_replaced_pkey
!       Index "public.cwi_replaced_pkey"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  b      | character varying(10) | b
!  a      | integer               | a
! primary key, btree, for table "public.cwi_test"
! 
! DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
! ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
! HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
! DROP TABLE cwi_test;
! --
! -- Tests for IS NULL/IS NOT NULL with b-tree indexes
! --
! SELECT unique1, unique2 INTO onek_with_null FROM onek;
! INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = ON;
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
!  count 
! -------
!    499
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
!  count 
! -------
!      0
! (1 row)
! 
! DROP INDEX onek_nulltest;
! -- Check initial-positioning logic too
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = OFF;
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      147 |       0
!      931 |       1
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |        
!      278 |     999
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      278 |     999
!        0 |     998
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!        0 |     998
!      744 |     997
! (2 rows)
! 
! RESET enable_seqscan;
! RESET enable_indexscan;
! RESET enable_bitmapscan;
! DROP TABLE onek_with_null;
! --
! -- Check bitmap index path planning
! --
! EXPLAIN (COSTS OFF)
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!                                                                QUERY PLAN                                                                
! -----------------------------------------------------------------------------------------------------------------------------------------
!  Bitmap Heap Scan on tenk1
!    Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
!    ->  BitmapOr
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 1))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 3))
!          ->  Bitmap Index Scan on tenk1_thous_tenthous
!                Index Cond: ((thousand = 42) AND (tenthous = 42))
! (9 rows)
! 
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
! (1 row)
! 
! EXPLAIN (COSTS OFF)
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Aggregate
!    ->  Bitmap Heap Scan on tenk1
!          Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
!          ->  BitmapAnd
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 42)
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (thousand = 42)
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (thousand = 99)
! (11 rows)
! 
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Check behavior with duplicate index column contents
! --
! CREATE TABLE dupindexcols AS
!   SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
! CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
! ANALYZE dupindexcols;
! EXPLAIN (COSTS OFF)
!   SELECT count(*) FROM dupindexcols
!     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!                                                    QUERY PLAN                                                   
! ----------------------------------------------------------------------------------------------------------------
!  Aggregate
!    ->  Bitmap Heap Scan on dupindexcols
!          Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
!          ->  Bitmap Index Scan on dupindexcols_i
!                Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
! (5 rows)
! 
! SELECT count(*) FROM dupindexcols
!   WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!  count 
! -------
!     97
! (1 row)
! 
! --
! -- Check ordering of =ANY indexqual results (bug in 9.2.0)
! --
! vacuum tenk1;		-- ensure we get consistent plans here
! explain (costs off)
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Index Only Scan using tenk1_unique1 on tenk1
!    Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
! (2 rows)
! 
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!  unique1 
! ---------
!        1
!        7
!       42
! (3 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Index Only Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: (thousand < 2)
!    Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
! (3 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! SET enable_indexonlyscan = OFF;
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Sort
!    Sort Key: thousand
!    ->  Index Scan using tenk1_thous_tenthous on tenk1
!          Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
! (4 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! RESET enable_indexscan;
! --
! -- Check elimination of constant-NULL subexpressions
! --
! explain (costs off)
!   select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Index Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: ((thousand = 1) AND (tenthous = 1001))
! (2 rows)
! 
--- 1697,1712 ----
  SET enable_indexscan = OFF;
  SET enable_bitmapscan = ON;
  CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
! NOTICE:  REGISTER.slot = 0, gen = 1
! NOTICE:  works 0
! NOTICE:  REGISTER.slot = 1, gen = 1
! NOTICE:  works 1
! NOTICE:  REGISTER.slot = 2, gen = 1
! NOTICE:  works 2
! NOTICE:  REGISTER.slot = 3, gen = 1
! NOTICE:  works 3
! NOTICE:  nentries = 6
! server closed the connection unexpectedly
! 	This probably means the server terminated abnormally
! 	before or while processing the request.
! connection to server was lost

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_aggregate.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_aggregate.out	2015-01-26 12:33:23.291031275 +0300
***************
*** 1,129 ****
! --
! -- CREATE_AGGREGATE
! --
! -- all functions CREATEd
! CREATE AGGREGATE newavg (
!    sfunc = int4_avg_accum, basetype = int4, stype = _int8,
!    finalfunc = int8_avg,
!    initcond1 = '{0,0}'
! );
! -- test comments
! COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
! ERROR:  aggregate newavg_wrong(integer) does not exist
! COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
! COMMENT ON AGGREGATE newavg (int4) IS NULL;
! -- without finalfunc; test obsolete spellings 'sfunc1' etc
! CREATE AGGREGATE newsum (
!    sfunc1 = int4pl, basetype = int4, stype1 = int4,
!    initcond1 = '0'
! );
! -- zero-argument aggregate
! CREATE AGGREGATE newcnt (*) (
!    sfunc = int8inc, stype = int8,
!    initcond = '0'
! );
! -- old-style spelling of same
! CREATE AGGREGATE oldcnt (
!    sfunc = int8inc, basetype = 'ANY', stype = int8,
!    initcond = '0'
! );
! -- aggregate that only cares about null/nonnull input
! CREATE AGGREGATE newcnt ("any") (
!    sfunc = int8inc_any, stype = int8,
!    initcond = '0'
! );
! COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
! ERROR:  aggregate nosuchagg(*) does not exist
! COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
! COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
! -- multi-argument aggregate
! create function sum3(int8,int8,int8) returns int8 as
! 'select $1 + $2 + $3' language sql strict immutable;
! create aggregate sum2(int8,int8) (
!    sfunc = sum3, stype = int8,
!    initcond = '0'
! );
! -- multi-argument aggregates sensitive to distinct/order, strict/nonstrict
! create type aggtype as (a integer, b integer, c text);
! create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql strict immutable;
! create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql immutable;
! create aggregate aggfstr(integer,integer,text) (
!    sfunc = aggf_trans, stype = aggtype[],
!    initcond = '{}'
! );
! create aggregate aggfns(integer,integer,text) (
!    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,
!    initcond = '{}'
! );
! -- variadic aggregate
! create function least_accum(anyelement, variadic anyarray)
! returns anyelement language sql as
!   'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
! create aggregate least_agg(variadic items anyarray) (
!   stype = anyelement, sfunc = least_accum
! );
! -- test ordered-set aggs using built-in support functions
! create aggregate my_percentile_disc(float8 ORDER BY anyelement) (
!   stype = internal,
!   sfunc = ordered_set_transition,
!   finalfunc = percentile_disc_final,
!   finalfunc_extra = true
! );
! create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (
!   stype = internal,
!   sfunc = ordered_set_transition_multi,
!   finalfunc = rank_final,
!   finalfunc_extra = true,
!   hypothetical
! );
! alter aggregate my_percentile_disc(float8 ORDER BY anyelement)
!   rename to test_percentile_disc;
! alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
!   rename to test_rank;
! \da test_*
!                                        List of aggregate functions
!  Schema |         Name         | Result data type |          Argument data types           | Description 
! --------+----------------------+------------------+----------------------------------------+-------------
!  public | test_percentile_disc | anyelement       | double precision ORDER BY anyelement   | 
!  public | test_rank            | bigint           | VARIADIC "any" ORDER BY VARIADIC "any" | 
! (2 rows)
! 
! -- moving-aggregate options
! CREATE AGGREGATE sumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi
! );
! -- invalid: nonstrict inverse with strict forward function
! CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
! $$ SELECT $1 - $2; $$
! LANGUAGE SQL;
! CREATE AGGREGATE invalidsumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_n
! );
! ERROR:  strictness of aggregate's forward and inverse transition functions must match
! -- invalid: non-matching result types
! CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
! $$ SELECT CAST($1 - $2 AS INT); $$
! LANGUAGE SQL;
! CREATE AGGREGATE wrongreturntype (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_int
! );
! ERROR:  return type of inverse transition function float8mi_int is not double precision
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_function_3.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_function_3.out	2015-01-26 12:33:23.291031275 +0300
***************
*** 1,243 ****
! --
! -- CREATE FUNCTION
! --
! -- sanity check of pg_proc catalog to the given parameters
! --
! CREATE USER regtest_unpriv_user;
! CREATE SCHEMA temp_func_test;
! GRANT ALL ON SCHEMA temp_func_test TO public;
! SET search_path TO temp_func_test, public;
! --
! -- ARGUMENT and RETURN TYPES
! --
! CREATE FUNCTION functest_A_1(text, date) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
! CREATE FUNCTION functest_A_2(text[]) RETURNS int LANGUAGE 'sql'
!        AS 'SELECT $1[0]::int';
! CREATE FUNCTION functest_A_3() RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT false';
! SELECT proname, prorettype::regtype, proargtypes::regtype[] FROM pg_proc
!        WHERE oid in ('functest_A_1'::regproc,
!                      'functest_A_2'::regproc,
!                      'functest_A_3'::regproc) ORDER BY proname;
!    proname    | prorettype |    proargtypes    
! --------------+------------+-------------------
!  functest_a_1 | boolean    | [0:1]={text,date}
!  functest_a_2 | integer    | [0:0]={text[]}
!  functest_a_3 | boolean    | {}
! (3 rows)
! 
! --
! -- IMMUTABLE | STABLE | VOLATILE
! --
! CREATE FUNCTION functest_B_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_2(int) RETURNS bool LANGUAGE 'sql'
!        IMMUTABLE AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_3(int) RETURNS bool LANGUAGE 'sql'
!        STABLE AS 'SELECT $1 = 0';
! CREATE FUNCTION functest_B_4(int) RETURNS bool LANGUAGE 'sql'
!        VOLATILE AS 'SELECT $1 < 0';
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | i
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! ALTER FUNCTION functest_B_2(int) VOLATILE;
! ALTER FUNCTION functest_B_3(int) COST 100;	-- unrelated change, no effect
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | v
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! --
! -- SECURITY DEFINER | INVOKER
! --
! CREATE FUNCTION functext_C_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functext_C_2(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY DEFINER AS 'SELECT $1 = 0';
! CREATE FUNCTION functext_C_3(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY INVOKER AS 'SELECT $1 < 0';
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | t
!  functext_c_3 | f
! (3 rows)
! 
! ALTER FUNCTION functext_C_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_C_2(int) SECURITY INVOKER;
! ALTER FUNCTION functext_C_3(int) SECURITY DEFINER;
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | f
!  functext_c_3 | t
! (3 rows)
! 
! --
! -- LEAKPROOF
! --
! CREATE FUNCTION functext_E_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 100';
! CREATE FUNCTION functext_E_2(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 > 100';
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | f
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_1(int) LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) STABLE;	-- unrelated change, no effect
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_2(int) NOT LEAKPROOF;	-- remove leakproog attribute
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | f
! (2 rows)
! 
! -- it takes superuser privilege to turn on leakproof, but not for turn off
! ALTER FUNCTION functext_E_1(int) OWNER TO regtest_unpriv_user;
! ALTER FUNCTION functext_E_2(int) OWNER TO regtest_unpriv_user;
! SET SESSION AUTHORIZATION regtest_unpriv_user;
! SET search_path TO temp_func_test, public;
! ALTER FUNCTION functext_E_1(int) NOT LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) LEAKPROOF;
! ERROR:  only superuser can define a leakproof function
! CREATE FUNCTION functext_E_3(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 < 200';	-- failed
! ERROR:  only superuser can define a leakproof function
! RESET SESSION AUTHORIZATION;
! --
! -- CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
! --
! CREATE FUNCTION functext_F_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 50';
! CREATE FUNCTION functext_F_2(int) RETURNS bool LANGUAGE 'sql'
!        CALLED ON NULL INPUT AS 'SELECT $1 = 50';
! CREATE FUNCTION functext_F_3(int) RETURNS bool LANGUAGE 'sql'
!        RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
! CREATE FUNCTION functext_F_4(int) RETURNS bool LANGUAGE 'sql'
!        STRICT AS 'SELECT $1 = 50';
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | f
!  functext_f_3 | t
!  functext_f_4 | t
! (4 rows)
! 
! ALTER FUNCTION functext_F_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_F_2(int) STRICT;
! ALTER FUNCTION functext_F_3(int) CALLED ON NULL INPUT;
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | t
!  functext_f_3 | f
!  functext_f_4 | t
! (4 rows)
! 
! -- information_schema tests
! CREATE FUNCTION functest_IS_1(a int, b int default 1, c text default 'foo')
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1 + $2';
! CREATE FUNCTION functest_IS_2(out a int, b int default 1)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! CREATE FUNCTION functest_IS_3(a int default 1, out b int)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! SELECT routine_name, ordinal_position, parameter_name, parameter_default
!     FROM information_schema.parameters JOIN information_schema.routines USING (specific_schema, specific_name)
!     WHERE routine_schema = 'temp_func_test' AND routine_name ~ '^functest_is_'
!     ORDER BY 1, 2;
!  routine_name  | ordinal_position | parameter_name | parameter_default 
! ---------------+------------------+----------------+-------------------
!  functest_is_1 |                1 | a              | 
!  functest_is_1 |                2 | b              | 1
!  functest_is_1 |                3 | c              | 'foo'::text
!  functest_is_2 |                1 | a              | 
!  functest_is_2 |                2 | b              | 1
!  functest_is_3 |                1 | a              | 1
!  functest_is_3 |                2 | b              | 
! (7 rows)
! 
! -- Cleanups
! DROP SCHEMA temp_func_test CASCADE;
! NOTICE:  drop cascades to 19 other objects
! DETAIL:  drop cascades to function functest_a_1(text,date)
! drop cascades to function functest_a_2(text[])
! drop cascades to function functest_a_3()
! drop cascades to function functest_b_1(integer)
! drop cascades to function functest_b_2(integer)
! drop cascades to function functest_b_3(integer)
! drop cascades to function functest_b_4(integer)
! drop cascades to function functext_c_1(integer)
! drop cascades to function functext_c_2(integer)
! drop cascades to function functext_c_3(integer)
! drop cascades to function functext_e_1(integer)
! drop cascades to function functext_e_2(integer)
! drop cascades to function functext_f_1(integer)
! drop cascades to function functext_f_2(integer)
! drop cascades to function functext_f_3(integer)
! drop cascades to function functext_f_4(integer)
! drop cascades to function functest_is_1(integer,integer,text)
! drop cascades to function functest_is_2(integer)
! drop cascades to function functest_is_3(integer)
! DROP USER regtest_unpriv_user;
! RESET search_path;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_cast.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/create_cast.out	2015-01-26 12:33:23.291031275 +0300
***************
*** 1,74 ****
! --
! -- CREATE_CAST
! --
! -- Create some types to test with
! CREATE TYPE casttesttype;
! CREATE FUNCTION casttesttype_in(cstring)
!    RETURNS casttesttype
!    AS 'textin'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  return type casttesttype is only a shell
! CREATE FUNCTION casttesttype_out(casttesttype)
!    RETURNS cstring
!    AS 'textout'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  argument type casttesttype is only a shell
! CREATE TYPE casttesttype (
!    internallength = variable,
!    input = casttesttype_in,
!    output = casttesttype_out,
!    alignment = int4
! );
! -- a dummy function to test with
! CREATE FUNCTION casttestfunc(casttesttype) RETURNS int4 LANGUAGE SQL AS
! $$ SELECT 1; $$;
! SELECT casttestfunc('foo'::text); -- fails, as there's no cast
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! -- Try binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
! SELECT casttestfunc('foo'::text); -- doesn't work, as the cast is explicit
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT casttestfunc('foo'::text::casttesttype); -- should work
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! DROP CAST (text AS casttesttype); -- cleanup
! -- Try IMPLICIT binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION AS IMPLICIT;
! SELECT casttestfunc('foo'::text); -- Should work now
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! -- Try I/O conversion cast.
! SELECT 1234::int4::casttesttype; -- No cast yet, should fail
! ERROR:  cannot cast type integer to casttesttype
! LINE 1: SELECT 1234::int4::casttesttype;
!                          ^
! CREATE CAST (int4 AS casttesttype) WITH INOUT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  1234
! (1 row)
! 
! DROP CAST (int4 AS casttesttype);
! -- Try cast with a function
! CREATE FUNCTION int4_casttesttype(int4) RETURNS casttesttype LANGUAGE SQL AS
! $$ SELECT ('foo'::text || $1::text)::casttesttype; $$;
! CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  foo1234
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/constraints.out	2015-01-26 12:33:13.751030776 +0300
--- /home/orion/postgres/src/test/regress/results/constraints.out	2015-01-26 12:33:23.299031276 +0300
***************
*** 1,647 ****
! --
! -- CONSTRAINTS
! -- Constraints can be specified with:
! --  - DEFAULT clause
! --  - CHECK clauses
! --  - PRIMARY KEY clauses
! --  - UNIQUE clauses
! --  - EXCLUDE clauses
! --
! --
! -- DEFAULT syntax
! --
! CREATE TABLE DEFAULT_TBL (i int DEFAULT 100,
! 	x text DEFAULT 'vadim', f float8 DEFAULT 123.456);
! INSERT INTO DEFAULT_TBL VALUES (1, 'thomas', 57.0613);
! INSERT INTO DEFAULT_TBL VALUES (1, 'bruce');
! INSERT INTO DEFAULT_TBL (i, f) VALUES (2, 987.654);
! INSERT INTO DEFAULT_TBL (x) VALUES ('marc');
! INSERT INTO DEFAULT_TBL VALUES (3, null, 1.0);
! SELECT '' AS five, * FROM DEFAULT_TBL;
!  five |  i  |   x    |    f    
! ------+-----+--------+---------
!       |   1 | thomas | 57.0613
!       |   1 | bruce  | 123.456
!       |   2 | vadim  | 987.654
!       | 100 | marc   | 123.456
!       |   3 |        |       1
! (5 rows)
! 
! CREATE SEQUENCE DEFAULT_SEQ;
! CREATE TABLE DEFAULTEXPR_TBL (i1 int DEFAULT 100 + (200-199) * 2,
! 	i2 int DEFAULT nextval('default_seq'));
! INSERT INTO DEFAULTEXPR_TBL VALUES (-1, -2);
! INSERT INTO DEFAULTEXPR_TBL (i1) VALUES (-3);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (-4);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (NULL);
! SELECT '' AS four, * FROM DEFAULTEXPR_TBL;
!  four | i1  | i2 
! ------+-----+----
!       |  -1 | -2
!       |  -3 |  1
!       | 102 | -4
!       | 102 |   
! (4 rows)
! 
! -- syntax errors
! --  test for extraneous comma
! CREATE TABLE error_tbl (i int DEFAULT (100, ));
! ERROR:  syntax error at or near ")"
! LINE 1: CREATE TABLE error_tbl (i int DEFAULT (100, ));
!                                                     ^
! --  this will fail because gram.y uses b_expr not a_expr for defaults,
! --  to avoid a shift/reduce conflict that arises from NOT NULL being
! --  part of the column definition syntax:
! CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
! ERROR:  syntax error at or near "IN"
! LINE 1: CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
!                                                   ^
! --  this should work, however:
! CREATE TABLE error_tbl (b1 bool DEFAULT (1 IN (1, 2)));
! DROP TABLE error_tbl;
! --
! -- CHECK syntax
! --
! CREATE TABLE CHECK_TBL (x int,
! 	CONSTRAINT CHECK_CON CHECK (x > 3));
! INSERT INTO CHECK_TBL VALUES (5);
! INSERT INTO CHECK_TBL VALUES (4);
! INSERT INTO CHECK_TBL VALUES (3);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (3).
! INSERT INTO CHECK_TBL VALUES (2);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (2).
! INSERT INTO CHECK_TBL VALUES (6);
! INSERT INTO CHECK_TBL VALUES (1);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (1).
! SELECT '' AS three, * FROM CHECK_TBL;
!  three | x 
! -------+---
!        | 5
!        | 4
!        | 6
! (3 rows)
! 
! CREATE SEQUENCE CHECK_SEQ;
! CREATE TABLE CHECK2_TBL (x int, y text, z int,
! 	CONSTRAINT SEQUENCE_CON
! 	CHECK (x > 3 and y <> 'check failed' and z < 8));
! INSERT INTO CHECK2_TBL VALUES (4, 'check ok', -2);
! INSERT INTO CHECK2_TBL VALUES (1, 'x check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (1, x check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (5, 'z check failed', 10);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (5, z check failed, 10).
! INSERT INTO CHECK2_TBL VALUES (0, 'check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (0, check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (6, 'check failed', 11);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (6, check failed, 11).
! INSERT INTO CHECK2_TBL VALUES (7, 'check ok', 7);
! SELECT '' AS two, * from CHECK2_TBL;
!  two | x |    y     | z  
! -----+---+----------+----
!      | 4 | check ok | -2
!      | 7 | check ok |  7
! (2 rows)
! 
! --
! -- Check constraints on INSERT
! --
! CREATE SEQUENCE INSERT_SEQ;
! CREATE TABLE INSERT_TBL (x INT DEFAULT nextval('insert_seq'),
! 	y TEXT DEFAULT '-NULL-',
! 	z INT DEFAULT -1 * currval('insert_seq'),
! 	CONSTRAINT INSERT_CON CHECK (x >= 3 AND y <> 'check failed' AND x < 8),
! 	CHECK (x + z = 0));
! INSERT INTO INSERT_TBL(x,z) VALUES (2, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, -NULL-, -2).
! SELECT '' AS zero, * FROM INSERT_TBL;
!  zero | x | y | z 
! ------+---+---+---
! (0 rows)
! 
! SELECT 'one' AS one, nextval('insert_seq');
!  one | nextval 
! -----+---------
!  one |       1
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, Y, -2).
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! INSERT INTO INSERT_TBL(x,z) VALUES (1, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (1, -NULL-, -2).
! INSERT INTO INSERT_TBL(z,x) VALUES (-7,  7);
! INSERT INTO INSERT_TBL VALUES (5, 'check failed', -5);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL VALUES (7, '!check failed', -7);
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS four, * FROM INSERT_TBL;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 7 | -NULL-        | -7
!       | 7 | !check failed | -7
!       | 4 | -!NULL-       | -4
! (4 rows)
! 
! INSERT INTO INSERT_TBL(y,z) VALUES ('check failed', 4);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (5, check failed, 4).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, 'check failed');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, '!check failed');
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS six, * FROM INSERT_TBL;
!  six | x |       y       | z  
! -----+---+---------------+----
!      | 3 | Y             | -3
!      | 7 | -NULL-        | -7
!      | 7 | !check failed | -7
!      | 4 | -!NULL-       | -4
!      | 5 | !check failed | -5
!      | 6 | -!NULL-       | -6
! (6 rows)
! 
! SELECT 'seven' AS one, nextval('insert_seq');
!   one  | nextval 
! -------+---------
!  seven |       7
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, Y, -8).
! SELECT 'eight' AS one, currval('insert_seq');
!   one  | currval 
! -------+---------
!  eight |       8
! (1 row)
! 
! -- According to SQL, it is OK to insert a record that gives rise to NULL
! -- constraint-condition results.  Postgres used to reject this, but it
! -- was wrong:
! INSERT INTO INSERT_TBL VALUES (null, null, null);
! SELECT '' AS nine, * FROM INSERT_TBL;
!  nine | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 7 | -NULL-        | -7
!       | 7 | !check failed | -7
!       | 4 | -!NULL-       | -4
!       | 5 | !check failed | -5
!       | 6 | -!NULL-       | -6
!       |   |               |   
! (7 rows)
! 
! --
! -- Check constraints on system columns
! --
! CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,
!                   altitude int,
!                   CHECK (NOT (is_capital AND tableoid::regclass::text = 'sys_col_check_tbl')));
! INSERT INTO SYS_COL_CHECK_TBL VALUES ('Seattle', 'Washington', false, 100);
! INSERT INTO SYS_COL_CHECK_TBL VALUES ('Olympia', 'Washington', true, 100);
! ERROR:  new row for relation "sys_col_check_tbl" violates check constraint "sys_col_check_tbl_check"
! DETAIL:  Failing row contains (Olympia, Washington, t, 100).
! SELECT *, tableoid::regclass::text FROM SYS_COL_CHECK_TBL;
!   city   |   state    | is_capital | altitude |     tableoid      
! ---------+------------+------------+----------+-------------------
!  Seattle | Washington | f          |      100 | sys_col_check_tbl
! (1 row)
! 
! DROP TABLE SYS_COL_CHECK_TBL;
! --
! -- Check constraints on system columns other then TableOid should return error
! --
! CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,
!                   altitude int,
! 				  CHECK (NOT (is_capital AND ctid::text = 'sys_col_check_tbl')));
! ERROR:  system column "ctid" reference in check constraint is invalid
! --
! -- Check inheritance of defaults and constraints
! --
! CREATE TABLE INSERT_CHILD (cx INT default 42,
! 	cy INT CHECK (cy > x))
! 	INHERITS (INSERT_TBL);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,11);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,6);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_child_check"
! DETAIL:  Failing row contains (7, -NULL-, -7, 42, 6).
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (6,-7,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (6, -NULL-, -7, 42, 7).
! INSERT INTO INSERT_CHILD(x,y,z,cy) VALUES (6,'check failed',-6,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_con"
! DETAIL:  Failing row contains (6, check failed, -6, 42, 7).
! SELECT * FROM INSERT_CHILD;
!  x |   y    | z  | cx | cy 
! ---+--------+----+----+----
!  7 | -NULL- | -7 | 42 | 11
! (1 row)
! 
! DROP TABLE INSERT_CHILD;
! --
! -- Check NO INHERIT type of constraints and inheritance
! --
! CREATE TABLE ATACC1 (TEST INT
! 	CHECK (TEST > 0) NO INHERIT);
! CREATE TABLE ATACC2 (TEST2 INT) INHERITS (ATACC1);
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! CREATE TABLE ATACC1 (TEST INT, TEST2 INT
! 	CHECK (TEST > 0), CHECK (TEST2 > 10) NO INHERIT);
! CREATE TABLE ATACC2 () INHERITS (ATACC1);
! -- check constraint is there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc2" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST2) VALUES (3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST2) VALUES (3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test2_check"
! DETAIL:  Failing row contains (null, 3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! --
! -- Check constraints on INSERT INTO
! --
! DELETE FROM INSERT_TBL;
! ALTER SEQUENCE INSERT_SEQ RESTART WITH 4;
! CREATE TABLE tmp (xd INT, yd TEXT, zd INT);
! INSERT INTO tmp VALUES (null, 'Y', null);
! INSERT INTO tmp VALUES (5, '!check failed', null);
! INSERT INTO tmp VALUES (null, 'try again', null);
! INSERT INTO INSERT_TBL(y) select yd from tmp;
! SELECT '' AS three, * FROM INSERT_TBL;
!  three | x |       y       | z  
! -------+---+---------------+----
!        | 4 | Y             | -4
!        | 5 | !check failed | -5
!        | 6 | try again     | -6
! (3 rows)
! 
! INSERT INTO INSERT_TBL SELECT * FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -7 FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -8 FROM tmp WHERE yd = 'try again';
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, try again, -8).
! SELECT '' AS four, * FROM INSERT_TBL;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 4 | Y             | -4
!       | 5 | !check failed | -5
!       | 6 | try again     | -6
!       |   | try again     |   
!       | 7 | try again     | -7
! (5 rows)
! 
! DROP TABLE tmp;
! --
! -- Check constraints on UPDATE
! --
! UPDATE INSERT_TBL SET x = NULL WHERE x = 5;
! UPDATE INSERT_TBL SET x = 6 WHERE x = 6;
! UPDATE INSERT_TBL SET x = -z, z = -x;
! UPDATE INSERT_TBL SET x = z, z = x;
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (-4, Y, 4).
! SELECT * FROM INSERT_TBL;
!  x |       y       | z  
! ---+---------------+----
!  4 | Y             | -4
!    | try again     |   
!  7 | try again     | -7
!  5 | !check failed |   
!  6 | try again     | -6
! (5 rows)
! 
! -- DROP TABLE INSERT_TBL;
! --
! -- Check constraints on COPY FROM
! --
! CREATE TABLE COPY_TBL (x INT, y TEXT, z INT,
! 	CONSTRAINT COPY_CON
! 	CHECK (x > 3 AND y <> 'check failed' AND x < 7 ));
! COPY COPY_TBL FROM '/home/orion/postgres/src/test/regress/data/constro.data';
! SELECT '' AS two, * FROM COPY_TBL;
!  two | x |       y       | z 
! -----+---+---------------+---
!      | 4 | !check failed | 5
!      | 6 | OK            | 4
! (2 rows)
! 
! COPY COPY_TBL FROM '/home/orion/postgres/src/test/regress/data/constrf.data';
! ERROR:  new row for relation "copy_tbl" violates check constraint "copy_con"
! DETAIL:  Failing row contains (7, check failed, 6).
! CONTEXT:  COPY copy_tbl, line 2: "7	check failed	6"
! SELECT * FROM COPY_TBL;
!  x |       y       | z 
! ---+---------------+---
!  4 | !check failed | 5
!  6 | OK            | 4
! (2 rows)
! 
! --
! -- Primary keys
! --
! CREATE TABLE PRIMARY_TBL (i int PRIMARY KEY, t text);
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "primary_tbl_pkey"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS four, * FROM PRIMARY_TBL;
!  four | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | three
!       | 5 | one
! (4 rows)
! 
! DROP TABLE PRIMARY_TBL;
! CREATE TABLE PRIMARY_TBL (i int, t text,
! 	PRIMARY KEY(i,t));
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS three, * FROM PRIMARY_TBL;
!  three | i |   t   
! -------+---+-------
!        | 1 | one
!        | 2 | two
!        | 1 | three
!        | 4 | three
!        | 5 | one
! (5 rows)
! 
! DROP TABLE PRIMARY_TBL;
! --
! -- Unique keys
! --
! CREATE TABLE UNIQUE_TBL (i int UNIQUE, t text);
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO UNIQUE_TBL VALUES (4, 'four');
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! INSERT INTO UNIQUE_TBL (t) VALUES ('seven');
! SELECT '' AS five, * FROM UNIQUE_TBL;
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | four
!       | 5 | one
!       |   | six
!       |   | seven
! (6 rows)
! 
! DROP TABLE UNIQUE_TBL;
! CREATE TABLE UNIQUE_TBL (i int, t text,
! 	UNIQUE(i,t));
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_t_key"
! DETAIL:  Key (i, t)=(1, one) already exists.
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! SELECT '' AS five, * FROM UNIQUE_TBL;
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 1 | three
!       | 5 | one
!       |   | six
! (5 rows)
! 
! DROP TABLE UNIQUE_TBL;
! --
! -- Deferrable unique constraints
! --
! CREATE TABLE unique_tbl (i int UNIQUE DEFERRABLE, t text);
! INSERT INTO unique_tbl VALUES (0, 'one');
! INSERT INTO unique_tbl VALUES (1, 'two');
! INSERT INTO unique_tbl VALUES (2, 'tree');
! INSERT INTO unique_tbl VALUES (3, 'four');
! INSERT INTO unique_tbl VALUES (4, 'five');
! BEGIN;
! -- default is immediate so this should fail right away
! UPDATE unique_tbl SET i = 1 WHERE i = 0;
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! ROLLBACK;
! -- check is done at end of statement, so this should succeed
! UPDATE unique_tbl SET i = i+1;
! SELECT * FROM unique_tbl;
!  i |  t   
! ---+------
!  1 | one
!  2 | two
!  3 | tree
!  4 | four
!  5 | five
! (5 rows)
! 
! -- explicitly defer the constraint
! BEGIN;
! SET CONSTRAINTS unique_tbl_i_key DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'three');
! DELETE FROM unique_tbl WHERE t = 'tree'; -- makes constraint valid again
! COMMIT; -- should succeed
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  1 | one
!  2 | two
!  4 | four
!  5 | five
!  3 | three
! (5 rows)
! 
! -- try adding an initially deferred constraint
! ALTER TABLE unique_tbl DROP CONSTRAINT unique_tbl_i_key;
! ALTER TABLE unique_tbl ADD CONSTRAINT unique_tbl_i_key
! 	UNIQUE (i) DEFERRABLE INITIALLY DEFERRED;
! BEGIN;
! INSERT INTO unique_tbl VALUES (1, 'five');
! INSERT INTO unique_tbl VALUES (5, 'one');
! UPDATE unique_tbl SET i = 4 WHERE i = 2;
! UPDATE unique_tbl SET i = 2 WHERE i = 4 AND t = 'four';
! DELETE FROM unique_tbl WHERE i = 1 AND t = 'one';
! DELETE FROM unique_tbl WHERE i = 5 AND t = 'five';
! COMMIT;
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  3 | three
!  1 | five
!  5 | one
!  4 | two
!  2 | four
! (5 rows)
! 
! -- should fail at commit-time
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! -- make constraint check immediate
! BEGIN;
! SET CONSTRAINTS ALL IMMEDIATE;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- forced check when SET CONSTRAINTS is called
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! SET CONSTRAINTS ALL IMMEDIATE; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- test a HOT update that invalidates the conflicting tuple.
! -- the trigger should still fire and catch the violation
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! UPDATE unique_tbl SET t = 'THREE' WHERE i = 3 AND t = 'Three';
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! SELECT * FROM unique_tbl;
!  i |   t   
! ---+-------
!  3 | three
!  1 | five
!  5 | one
!  4 | two
!  2 | four
! (5 rows)
! 
! -- test a HOT update that modifies the newly inserted tuple,
! -- but should succeed because we then remove the other conflicting tuple.
! BEGIN;
! INSERT INTO unique_tbl VALUES(3, 'tree'); -- should succeed for now
! UPDATE unique_tbl SET t = 'threex' WHERE t = 'tree';
! DELETE FROM unique_tbl WHERE t = 'three';
! SELECT * FROM unique_tbl;
!  i |   t    
! ---+--------
!  1 | five
!  5 | one
!  4 | two
!  2 | four
!  3 | threex
! (5 rows)
! 
! COMMIT;
! SELECT * FROM unique_tbl;
!  i |   t    
! ---+--------
!  1 | five
!  5 | one
!  4 | two
!  2 | four
!  3 | threex
! (5 rows)
! 
! DROP TABLE unique_tbl;
! --
! -- EXCLUDE constraints
! --
! CREATE TABLE circles (
!   c1 CIRCLE,
!   c2 TEXT,
!   EXCLUDE USING gist
!     (c1 WITH &&, (c2::circle) WITH &&)
!     WHERE (circle_center(c1) <> '(0,0)')
! );
! -- these should succeed because they don't match the index predicate
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 5>');
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 4>');
! -- succeed
! INSERT INTO circles VALUES('<(10,10), 10>', '<(0,0), 5>');
! -- fail, overlaps
! INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>');
! ERROR:  conflicting key value violates exclusion constraint "circles_c1_c2_excl"
! DETAIL:  Key (c1, (c2::circle))=(<(20,20),10>, <(0,0),4>) conflicts with existing key (c1, (c2::circle))=(<(10,10),10>, <(0,0),5>).
! -- succeed because c1 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 1>', '<(0,0), 5>');
! -- succeed because c2 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 10>', '<(10,10), 5>');
! -- should fail on existing data without the WHERE clause
! ALTER TABLE circles ADD EXCLUDE USING gist
!   (c1 WITH &&, (c2::circle) WITH &&);
! ERROR:  could not create exclusion constraint "circles_c1_c2_excl1"
! DETAIL:  Key (c1, (c2::circle))=(<(0,0),5>, <(0,0),5>) conflicts with key (c1, (c2::circle))=(<(0,0),5>, <(0,0),4>).
! -- try reindexing an existing constraint
! REINDEX INDEX circles_c1_c2_excl;
! DROP TABLE circles;
! -- Check deferred exclusion constraint
! CREATE TABLE deferred_excl (
!   f1 int,
!   CONSTRAINT deferred_excl_con EXCLUDE (f1 WITH =) INITIALLY DEFERRED
! );
! INSERT INTO deferred_excl VALUES(1);
! INSERT INTO deferred_excl VALUES(2);
! INSERT INTO deferred_excl VALUES(1); -- fail
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(1) conflicts with existing key (f1)=(1).
! BEGIN;
! INSERT INTO deferred_excl VALUES(2); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(2) conflicts with existing key (f1)=(2).
! BEGIN;
! INSERT INTO deferred_excl VALUES(3);
! INSERT INTO deferred_excl VALUES(3); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(3) conflicts with existing key (f1)=(3).
! ALTER TABLE deferred_excl DROP CONSTRAINT deferred_excl_con;
! -- This should fail, but worth testing because of HOT updates
! UPDATE deferred_excl SET f1 = 3;
! ALTER TABLE deferred_excl ADD EXCLUDE (f1 WITH =);
! ERROR:  could not create exclusion constraint "deferred_excl_f1_excl"
! DETAIL:  Key (f1)=(3) conflicts with key (f1)=(3).
! DROP TABLE deferred_excl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/triggers.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/triggers.out	2015-01-26 12:33:23.295031275 +0300
***************
*** 1,1733 ****
! --
! -- TRIGGERS
! --
! create table pkeys (pkey1 int4 not null, pkey2 text not null);
! create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
! create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
! create index fkeys_i on fkeys (fkey1, fkey2);
! create index fkeys2_i on fkeys2 (fkey21, fkey22);
! create index fkeys2p_i on fkeys2 (pkey23);
! insert into pkeys values (10, '1');
! insert into pkeys values (20, '2');
! insert into pkeys values (30, '3');
! insert into pkeys values (40, '4');
! insert into pkeys values (50, '5');
! insert into pkeys values (60, '6');
! create unique index pkeys_i on pkeys (pkey1, pkey2);
! --
! -- For fkeys:
! -- 	(fkey1, fkey2)	--> pkeys (pkey1, pkey2)
! -- 	(fkey3)		--> fkeys2 (pkey23)
! --
! create trigger check_fkeys_pkey_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
! create trigger check_fkeys_pkey2_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure check_primary_key ('fkey3', 'fkeys2', 'pkey23');
! --
! -- For fkeys2:
! -- 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2)
! --
! create trigger check_fkeys2_pkey_exist
! 	before insert or update on fkeys2
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
! -- Test comments
! COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
! ERROR:  trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
! --
! -- For pkeys:
! -- 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE:
! -- 		fkeys (fkey1, fkey2) and fkeys2 (fkey21, fkey22)
! --
! create trigger check_pkeys_fkey_cascade
! 	before delete or update on pkeys
! 	for each row
! 	execute procedure
! 	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',
! 	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
! --
! -- For fkeys2:
! -- 	ON DELETE/UPDATE (pkey23) RESTRICT:
! -- 		fkeys (fkey3)
! --
! create trigger check_fkeys2_fkey_restrict
! 	before delete or update on fkeys2
! 	for each row
! 	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
! insert into fkeys2 values (10, '1', 1);
! insert into fkeys2 values (30, '3', 2);
! insert into fkeys2 values (40, '4', 5);
! insert into fkeys2 values (50, '5', 3);
! -- no key in pkeys
! insert into fkeys2 values (70, '5', 3);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys2_pkey_exist" found tuple referencing non-existent key in "pkeys".
! insert into fkeys values (10, '1', 2);
! insert into fkeys values (30, '3', 3);
! insert into fkeys values (40, '4', 2);
! insert into fkeys values (50, '5', 2);
! -- no key in pkeys
! insert into fkeys values (70, '5', 1);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys_pkey_exist" found tuple referencing non-existent key in "pkeys".
! -- no key in fkeys2
! insert into fkeys values (60, '6', 4);
! ERROR:  tuple references non-existent key
! DETAIL:  Trigger "check_fkeys_pkey2_exist" found tuple referencing non-existent key in "fkeys2".
! delete from pkeys where pkey1 = 30 and pkey2 = '3';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
! CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
! delete from pkeys where pkey1 = 40 and pkey2 = '4';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
! CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 10 and pkey2 = '1';
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
! NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
! DROP TABLE pkeys;
! DROP TABLE fkeys;
! DROP TABLE fkeys2;
! -- -- I've disabled the funny_dup17 test because the new semantics
! -- -- of AFTER ROW triggers, which get now fired at the end of a
! -- -- query always, cause funny_dup17 to enter an endless loop.
! -- --
! -- --      Jan
! --
! -- create table dup17 (x int4);
! --
! -- create trigger dup17_before
! -- 	before insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! --
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! --
! -- drop trigger dup17_before on dup17;
! --
! -- create trigger dup17_after
! -- 	after insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! --
! -- DROP TABLE dup17;
! create sequence ttdummy_seq increment 10 start 0 minvalue 0;
! create table tttest (
! 	price_id	int4,
! 	price_val	int4,
! 	price_on	int4,
! 	price_off	int4 default 999999
! );
! create trigger ttdummy
! 	before delete or update on tttest
! 	for each row
! 	execute procedure
! 	ttdummy (price_on, price_off);
! create trigger ttserial
! 	before insert or update on tttest
! 	for each row
! 	execute procedure
! 	autoinc (price_on, ttdummy_seq);
! insert into tttest values (1, 1, null);
! insert into tttest values (2, 2, null);
! insert into tttest values (3, 3, 0);
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |    999999
!         3 |         3 |       30 |    999999
! (3 rows)
! 
! delete from tttest where price_id = 2;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         3 |         3 |       30 |    999999
!         2 |         2 |       20 |        40
! (3 rows)
! 
! -- what do we see ?
! -- get current prices
! select * from tttest where price_off = 999999;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         3 |         3 |       30 |    999999
! (2 rows)
! 
! -- change price for price_id == 3
! update tttest set price_val = 30 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |        30 |       50 |    999999
!         3 |         3 |       30 |        50
! (4 rows)
! 
! -- now we want to change pric_id in ALL tuples
! -- this gets us not what we need
! update tttest set price_id = 5 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |         3 |       30 |        50
!         5 |        30 |       60 |    999999
!         3 |        30 |       50 |        60
! (5 rows)
! 
! -- restore data as before last update:
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! delete from tttest where price_id = 5;
! update tttest set price_off = 999999 where price_val = 30;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         3 |         3 |       30 |        50
!         3 |        30 |       50 |    999999
! (4 rows)
! 
! -- and try change price_id now!
! update tttest set price_id = 5 where price_id = 3;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       10 |    999999
!         2 |         2 |       20 |        40
!         5 |         3 |       30 |        50
!         5 |        30 |       50 |    999999
! (4 rows)
! 
! -- isn't it what we need ?
! select set_ttdummy(1);
!  set_ttdummy 
! -------------
!            0
! (1 row)
! 
! -- we want to correct some "date"
! update tttest set price_on = -1 where price_id = 1;
! ERROR:  ttdummy (tttest): you cannot change price_on and/or price_off columns (use set_ttdummy)
! -- but this doesn't work
! -- try in this way
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! update tttest set price_on = -1 where price_id = 1;
! select * from tttest;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         2 |         2 |       20 |        40
!         5 |         3 |       30 |        50
!         5 |        30 |       50 |    999999
!         1 |         1 |       -1 |    999999
! (4 rows)
! 
! -- isn't it what we need ?
! -- get price for price_id == 5 as it was @ "date" 35
! select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         5 |         3 |       30 |        50
! (1 row)
! 
! drop table tttest;
! drop sequence ttdummy_seq;
! --
! -- tests for per-statement triggers
! --
! CREATE TABLE log_table (tstamp timestamp default timeofday()::timestamp);
! CREATE TABLE main_table (a int, b int);
! COPY main_table (a,b) FROM stdin;
! CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS '
! BEGIN
! 	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
! 	RETURN NULL;
! END;';
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
! --
! -- if neither 'FOR EACH ROW' nor 'FOR EACH STATEMENT' was specified,
! -- CREATE TRIGGER should default to 'FOR EACH STATEMENT'
! --
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table
! EXECUTE PROCEDURE trigger_func('after_upd_stmt');
! CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
! INSERT INTO main_table DEFAULT VALUES;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! UPDATE main_table SET a = a + 1 WHERE b < 30;
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! -- UPDATE that effects zero rows should still call per-statement trigger
! UPDATE main_table SET a = a + 2 WHERE b > 100;
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! -- COPY should fire per-row and per-statement INSERT triggers
! COPY main_table (a, b) FROM stdin;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   6 | 10
!  21 | 20
!  30 | 40
!  31 | 10
!  50 | 35
!  50 | 60
!  81 | 15
!     |   
! (8 rows)
! 
! --
! -- test triggers with WHEN clause
! --
! CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
! CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
! CREATE TRIGGER insert_a AFTER INSERT ON main_table
! FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
! CREATE TRIGGER delete_a AFTER DELETE ON main_table
! FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
! CREATE TRIGGER insert_when BEFORE INSERT ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
! CREATE TRIGGER delete_when AFTER DELETE ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
! INSERT INTO main_table (a) VALUES (123), (456);
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! COPY main_table FROM stdin;
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! DELETE FROM main_table WHERE a IN (123, 456);
! NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
! NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
! NOTICE:  trigger_func(delete_when) called: action = DELETE, when = AFTER, level = STATEMENT
! UPDATE main_table SET a = 50, b = 60;
! NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   6 | 10
!  21 | 20
!  30 | 40
!  31 | 10
!  50 | 35
!  50 | 60
!  81 | 15
!     |   
! (8 rows)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!                                                              pg_get_triggerdef                                                              
! --------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.a <> new.a) EXECUTE PROCEDURE trigger_func('modified_a')
! (1 row)
! 
! SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!                                                               pg_get_triggerdef                                                               
! ----------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
! (1 row)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
!                                                                       pg_get_triggerdef                                                                       
! --------------------------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.* IS DISTINCT FROM new.*) EXECUTE PROCEDURE trigger_func('modified_any')
! (1 row)
! 
! DROP TRIGGER modified_a ON main_table;
! DROP TRIGGER modified_any ON main_table;
! DROP TRIGGER insert_a ON main_table;
! DROP TRIGGER delete_a ON main_table;
! DROP TRIGGER insert_when ON main_table;
! DROP TRIGGER delete_when ON main_table;
! -- Test column-level triggers
! DROP TRIGGER after_upd_row_trig ON main_table;
! CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
! CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
! CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
! CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
! CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
! SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
!                                                              pg_get_triggerdef                                                             
! -------------------------------------------------------------------------------------------------------------------------------------------
!  CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
! (1 row)
! 
! UPDATE main_table SET a = 50;
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! UPDATE main_table SET b = 10;
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! --
! -- Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN
! --
! CREATE TABLE some_t (some_col boolean NOT NULL);
! CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$
! BEGIN
!   RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',
!     TG_ARGV[0], TG_OP, OLD, NEW;
!   RETURN NEW;
! END;
! $$ LANGUAGE plpgsql;
! CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW
!   EXECUTE PROCEDURE dummy_update_func('before');
! CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT OLD.some_col AND NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('aftera');
! CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('afterb');
! INSERT INTO some_t VALUES (TRUE);
! UPDATE some_t SET some_col = TRUE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (t)
! UPDATE some_t SET some_col = FALSE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (f)
! NOTICE:  dummy_update_func(afterb) called: action = UPDATE, old = (t), new = (f)
! UPDATE some_t SET some_col = TRUE;
! NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (f), new = (t)
! NOTICE:  dummy_update_func(aftera) called: action = UPDATE, old = (f), new = (t)
! DROP TABLE some_t;
! -- bogus cases
! CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
! ERROR:  duplicate trigger events specified at or near "ON"
! LINE 1: ...ER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_ta...
!                                                              ^
! CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
! ERROR:  column "a" specified more than once
! CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
! ERROR:  syntax error at or near "OF"
! LINE 1: CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
!                                                  ^
! CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_ins_old');
! ERROR:  INSERT trigger's WHEN condition cannot reference OLD values
! LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
!                            ^
! CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_del_new');
! ERROR:  DELETE trigger's WHEN condition cannot reference NEW values
! LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
!                                     ^
! CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (NEW.tableoid <> 0)
! EXECUTE PROCEDURE trigger_func('error_when_sys_column');
! ERROR:  BEFORE trigger's WHEN condition cannot reference NEW system columns
! LINE 2: FOR EACH ROW WHEN (NEW.tableoid <> 0)
!                            ^
! CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
! EXECUTE PROCEDURE trigger_func('error_stmt_when');
! ERROR:  statement trigger's WHEN condition cannot reference column values
! LINE 2: FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
!                                  ^
! -- check dependency restrictions
! ALTER TABLE main_table DROP COLUMN b;
! ERROR:  cannot drop table main_table column b because other objects depend on it
! DETAIL:  trigger after_upd_b_row_trig on table main_table depends on table main_table column b
! trigger after_upd_a_b_row_trig on table main_table depends on table main_table column b
! trigger after_upd_b_stmt_trig on table main_table depends on table main_table column b
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- this should succeed, but we'll roll it back to keep the triggers around
! begin;
! DROP TRIGGER after_upd_a_b_row_trig ON main_table;
! DROP TRIGGER after_upd_b_row_trig ON main_table;
! DROP TRIGGER after_upd_b_stmt_trig ON main_table;
! ALTER TABLE main_table DROP COLUMN b;
! rollback;
! -- Test enable/disable triggers
! create table trigtest (i serial primary key);
! -- test that disabling RI triggers works
! create table trigtest2 (i int references trigtest(i) on delete cascade);
! create function trigtest() returns trigger as $$
! begin
! 	raise notice '% % % %', TG_RELNAME, TG_OP, TG_WHEN, TG_LEVEL;
! 	return new;
! end;$$ language plpgsql;
! create trigger trigtest_b_row_tg before insert or update or delete on trigtest
! for each row execute procedure trigtest();
! create trigger trigtest_a_row_tg after insert or update or delete on trigtest
! for each row execute procedure trigtest();
! create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! insert into trigtest default values;
! NOTICE:  trigtest INSERT BEFORE STATEMENT
! NOTICE:  trigtest INSERT BEFORE ROW
! NOTICE:  trigtest INSERT AFTER ROW
! NOTICE:  trigtest INSERT AFTER STATEMENT
! alter table trigtest disable trigger trigtest_b_row_tg;
! insert into trigtest default values;
! NOTICE:  trigtest INSERT BEFORE STATEMENT
! NOTICE:  trigtest INSERT AFTER ROW
! NOTICE:  trigtest INSERT AFTER STATEMENT
! alter table trigtest disable trigger user;
! insert into trigtest default values;
! alter table trigtest enable trigger trigtest_a_stmt_tg;
! insert into trigtest default values;
! NOTICE:  trigtest INSERT AFTER STATEMENT
! insert into trigtest2 values(1);
! insert into trigtest2 values(2);
! delete from trigtest where i=2;
! NOTICE:  trigtest DELETE AFTER STATEMENT
! select * from trigtest2;
!  i 
! ---
!  1
! (1 row)
! 
! alter table trigtest disable trigger all;
! delete from trigtest where i=1;
! select * from trigtest2;
!  i 
! ---
!  1
! (1 row)
! 
! -- ensure we still insert, even when all triggers are disabled
! insert into trigtest default values;
! select *  from trigtest;
!  i 
! ---
!  3
!  4
!  5
! (3 rows)
! 
! drop table trigtest2;
! drop table trigtest;
! -- dump trigger data
! CREATE TABLE trigger_test (
!         i int,
!         v varchar
! );
! CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
! LANGUAGE plpgsql AS $$
! 
! declare
! 
! 	argstr text;
! 	relid text;
! 
! begin
! 
! 	relid := TG_relid::regclass;
! 
! 	-- plpgsql can't discover its trigger data in a hash like perl and python
! 	-- can, or by a sort of reflection like tcl can,
! 	-- so we have to hard code the names.
! 	raise NOTICE 'TG_NAME: %', TG_name;
! 	raise NOTICE 'TG_WHEN: %', TG_when;
! 	raise NOTICE 'TG_LEVEL: %', TG_level;
! 	raise NOTICE 'TG_OP: %', TG_op;
! 	raise NOTICE 'TG_RELID::regclass: %', relid;
! 	raise NOTICE 'TG_RELNAME: %', TG_relname;
! 	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name;
! 	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema;
! 	raise NOTICE 'TG_NARGS: %', TG_nargs;
! 
! 	argstr := '[';
! 	for i in 0 .. TG_nargs - 1 loop
! 		if i > 0 then
! 			argstr := argstr || ', ';
! 		end if;
! 		argstr := argstr || TG_argv[i];
! 	end loop;
! 	argstr := argstr || ']';
! 	raise NOTICE 'TG_ARGV: %', argstr;
! 
! 	if TG_OP != 'INSERT' then
! 		raise NOTICE 'OLD: %', OLD;
! 	end if;
! 
! 	if TG_OP != 'DELETE' then
! 		raise NOTICE 'NEW: %', NEW;
! 	end if;
! 
! 	if TG_OP = 'DELETE' then
! 		return OLD;
! 	else
! 		return NEW;
! 	end if;
! 
! end;
! $$;
! CREATE TRIGGER show_trigger_data_trig
! BEFORE INSERT OR UPDATE OR DELETE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
! insert into trigger_test values(1,'insert');
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: INSERT
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  NEW: (1,insert)
! update trigger_test set v = 'update' where i = 1;
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: UPDATE
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  OLD: (1,insert)
! NOTICE:  NEW: (1,update)
! delete from trigger_test;
! NOTICE:  TG_NAME: show_trigger_data_trig
! NOTICE:  TG_WHEN: BEFORE
! NOTICE:  TG_LEVEL: ROW
! NOTICE:  TG_OP: DELETE
! NOTICE:  TG_RELID::regclass: trigger_test
! NOTICE:  TG_RELNAME: trigger_test
! NOTICE:  TG_TABLE_NAME: trigger_test
! NOTICE:  TG_TABLE_SCHEMA: public
! NOTICE:  TG_NARGS: 2
! NOTICE:  TG_ARGV: [23, skidoo]
! NOTICE:  OLD: (1,update)
! DROP TRIGGER show_trigger_data_trig on trigger_test;
! DROP FUNCTION trigger_data();
! DROP TABLE trigger_test;
! --
! -- Test use of row comparisons on OLD/NEW
! --
! CREATE TABLE trigger_test (f1 int, f2 text, f3 text);
! -- this is the obvious (and wrong...) way to compare rows
! CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) = row(new.*) then
! 		raise notice 'row % not changed', new.f1;
! 	else
! 		raise notice 'row % changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! CREATE TRIGGER t
! BEFORE UPDATE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE mytrigger();
! INSERT INTO trigger_test VALUES(1, 'foo', 'bar');
! INSERT INTO trigger_test VALUES(2, 'baz', 'quux');
! UPDATE trigger_test SET f3 = 'bar';
! NOTICE:  row 1 not changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! -- this demonstrates that the above isn't really working as desired:
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! -- the right way when considering nulls is
! CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) is distinct from row(new.*) then
! 		raise notice 'row % changed', new.f1;
! 	else
! 		raise notice 'row % not changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! UPDATE trigger_test SET f3 = 'bar';
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 changed
! NOTICE:  row 2 changed
! UPDATE trigger_test SET f3 = NULL;
! NOTICE:  row 1 not changed
! NOTICE:  row 2 not changed
! DROP TABLE trigger_test;
! DROP FUNCTION mytrigger();
! -- Test snapshot management in serializable transactions involving triggers
! -- per bug report in 6bc73d4c0910042358k3d1adff3qa36f8df75198ecea@mail.gmail.com
! CREATE FUNCTION serializable_update_trig() RETURNS trigger LANGUAGE plpgsql AS
! $$
! declare
! 	rec record;
! begin
! 	new.description = 'updated in trigger';
! 	return new;
! end;
! $$;
! CREATE TABLE serializable_update_tab (
! 	id int,
! 	filler  text,
! 	description text
! );
! CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab
! 	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
! INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new'
! 	FROM generate_series(1, 50) a;
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE serializable_update_tab SET description = 'no no', id = 1 WHERE id = 1;
! COMMIT;
! SELECT description FROM serializable_update_tab WHERE id = 1;
!     description     
! --------------------
!  updated in trigger
! (1 row)
! 
! DROP TABLE serializable_update_tab;
! -- minimal update trigger
! CREATE TABLE min_updates_test (
! 	f1	text,
! 	f2 int,
! 	f3 int);
! CREATE TABLE min_updates_test_oids (
! 	f1	text,
! 	f2 int,
! 	f3 int) WITH OIDS;
! INSERT INTO min_updates_test VALUES ('a',1,2),('b','2',null);
! INSERT INTO min_updates_test_oids VALUES ('a',1,2),('b','2',null);
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test_oids
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! \set QUIET false
! UPDATE min_updates_test SET f1 = f1;
! UPDATE 0
! UPDATE min_updates_test SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! UPDATE min_updates_test_oids SET f1 = f1;
! UPDATE 0
! UPDATE min_updates_test_oids SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test_oids SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! \set QUIET true
! SELECT * FROM min_updates_test;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! SELECT * FROM min_updates_test_oids;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! DROP TABLE min_updates_test;
! DROP TABLE min_updates_test_oids;
! --
! -- Test triggers on views
! --
! CREATE VIEW main_view AS SELECT a, b FROM main_table;
! -- VIEW trigger function
! CREATE OR REPLACE FUNCTION view_trigger() RETURNS trigger
! LANGUAGE plpgsql AS $$
! declare
!     argstr text := '';
! begin
!     for i in 0 .. TG_nargs - 1 loop
!         if i > 0 then
!             argstr := argstr || ', ';
!         end if;
!         argstr := argstr || TG_argv[i];
!     end loop;
! 
!     raise notice '% % % % (%)', TG_RELNAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;
! 
!     if TG_LEVEL = 'ROW' then
!         if TG_OP = 'INSERT' then
!             raise NOTICE 'NEW: %', NEW;
!             INSERT INTO main_table VALUES (NEW.a, NEW.b);
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'UPDATE' then
!             raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
!             UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'DELETE' then
!             raise NOTICE 'OLD: %', OLD;
!             DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN OLD;
!         end if;
!     end if;
! 
!     RETURN NULL;
! end;
! $$;
! -- Before row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! -- After row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
! -- Truncate triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have TRUNCATE triggers.
! CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  "main_view" is a view
! DETAIL:  Views cannot have TRUNCATE triggers.
! -- INSTEAD OF triggers aren't allowed on tables
! CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! ERROR:  "main_table" is a table
! DETAIL:  Tables cannot have INSTEAD OF triggers.
! -- Don't support WHEN clauses with INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers cannot have WHEN conditions
! -- Don't support column-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers cannot have column lists
! -- Don't support statement-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  INSTEAD OF triggers must be FOR EACH ROW
! -- Valid INSTEAD OF triggers
! CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! -- Valid BEFORE statement VIEW triggers
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
! CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
! CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
! -- Valid AFTER statement VIEW triggers
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
! CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
! \set QUIET false
! -- Insert into view using trigger
! INSERT INTO main_view VALUES (20, 30);
! NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
! NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
! NOTICE:  NEW: (20,30)
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
! INSERT 0 1
! INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
! NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
! NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
! NOTICE:  NEW: (21,31)
! NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "INSERT INTO main_table VALUES (NEW.a, NEW.b)"
! PL/pgSQL function view_trigger() line 17 at SQL statement
! NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
!  a  | b  
! ----+----
!  21 | 31
! (1 row)
! 
! INSERT 0 1
! -- Table trigger will prevent updates
! UPDATE main_view SET b = 31 WHERE a = 20;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (20,30), NEW: (20,31)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 0
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (21,31), NEW: (21,32)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
!  a | b 
! ---+---
! (0 rows)
! 
! UPDATE 0
! -- Remove table trigger to allow updates
! DROP TRIGGER before_upd_a_row_trig ON main_table;
! DROP TRIGGER
! UPDATE main_view SET b = 31 WHERE a = 20;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (20,30), NEW: (20,31)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 1
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
! NOTICE:  OLD: (21,31), NEW: (21,32)
! NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
! CONTEXT:  SQL statement "UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b"
! PL/pgSQL function view_trigger() line 23 at SQL statement
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
!  a  | b  
! ----+----
!  21 | 32
! (1 row)
! 
! UPDATE 1
! -- Before and after stmt triggers should fire even when no rows are affected
! UPDATE main_view SET b = 0 WHERE false;
! NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
! NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
! UPDATE 0
! -- Delete from view using trigger
! DELETE FROM main_view WHERE a IN (20,21);
! NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (21,10)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (20,31)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (21,32)
! NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
! DELETE 3
! DELETE FROM main_view WHERE a = 31 RETURNING a, b;
! NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
! NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
! NOTICE:  OLD: (31,10)
! NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
!  a  | b  
! ----+----
!  31 | 10
! (1 row)
! 
! DELETE 1
! \set QUIET true
! -- Describe view should list triggers
! \d main_view
!    View "public.main_view"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
! Triggers:
!     after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt')
!     after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt')
!     after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt')
!     before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt')
!     before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt')
!     before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt')
!     instead_of_delete_trig INSTEAD OF DELETE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del')
!     instead_of_insert_trig INSTEAD OF INSERT ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins')
!     instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd')
! 
! -- Test dropping view triggers
! DROP TRIGGER instead_of_insert_trig ON main_view;
! DROP TRIGGER instead_of_delete_trig ON main_view;
! \d+ main_view
!                View "public.main_view"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
!  b      | integer |           | plain   | 
! View definition:
!  SELECT main_table.a,
!     main_table.b
!    FROM main_table;
! Triggers:
!     after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt')
!     after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt')
!     after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt')
!     before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt')
!     before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt')
!     before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt')
!     instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd')
! 
! DROP VIEW main_view;
! --
! -- Test triggers on a join view
! --
! CREATE TABLE country_table (
!     country_id        serial primary key,
!     country_name    text unique not null,
!     continent        text not null
! );
! INSERT INTO country_table (country_name, continent)
!     VALUES ('Japan', 'Asia'),
!            ('UK', 'Europe'),
!            ('USA', 'North America')
!     RETURNING *;
!  country_id | country_name |   continent   
! ------------+--------------+---------------
!           1 | Japan        | Asia
!           2 | UK           | Europe
!           3 | USA          | North America
! (3 rows)
! 
! CREATE TABLE city_table (
!     city_id        serial primary key,
!     city_name    text not null,
!     population    bigint,
!     country_id    int references country_table
! );
! CREATE VIEW city_view AS
!     SELECT city_id, city_name, population, country_name, continent
!     FROM city_table ci
!     LEFT JOIN country_table co ON co.country_id = ci.country_id;
! CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS NOT NULL then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
!     else
!         NEW.continent := NULL;
!     end if;
! 
!     if NEW.city_id IS NOT NULL then
!         INSERT INTO city_table
!             VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
!     else
!         INSERT INTO city_table(city_name, population, country_id)
!             VALUES(NEW.city_name, NEW.population, ctry_id)
!             RETURNING city_id INTO NEW.city_id;
!     end if;
! 
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_insert();
! CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
! begin
!     DELETE FROM city_table WHERE city_id = OLD.city_id;
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN OLD;
! end;
! $$;
! CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_delete();
! CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS DISTINCT FROM OLD.country_name then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
! 
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population,
!                               country_id = ctry_id
!             WHERE city_id = OLD.city_id;
!     else
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population
!             WHERE city_id = OLD.city_id;
!         NEW.continent := OLD.continent;
!     end if;
! 
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_update();
! \set QUIET false
! -- INSERT .. RETURNING
! INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |            |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        2 | London    |    7556900 |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
!  city_id |   city_name   | population | country_name |   continent   
! ---------+---------------+------------+--------------+---------------
!        3 | Washington DC |            | USA          | North America
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!   123456 | New York  |            |              | 
! (1 row)
! 
! INSERT 0 1
! INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! INSERT 0 1
! -- UPDATE .. RETURNING
! UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- error
! ERROR:  No such country: "Japon"
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no match
! UPDATE 0
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OK
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |            | Japan        | Asia
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        1 | Tokyo     |   13010279 | Japan        | Asia
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!   123456 | New York  |            | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
!  city_id | city_name | population | country_name |   continent   
! ---------+-----------+------------+--------------+---------------
!   123456 | New York  |    8391881 | USA          | North America
! (1 row)
! 
! UPDATE 1
! UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
!     WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
!  city_id | city_name | population | country_name | continent | city_id | city_name  | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------+---------+------------+------------+--------------+-----------
!        2 | London    |    7556900 | UK           | Europe    |  234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! -- DELETE .. RETURNING
! DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
!  city_id | city_name  | population | country_name | continent 
! ---------+------------+------------+--------------+-----------
!   234567 | Birmingham |    1016800 | UK           | Europe
! (1 row)
! 
! DELETE 1
! \set QUIET true
! -- read-only view with WHERE clause
! CREATE VIEW european_city_view AS
!     SELECT * FROM city_view WHERE continent = 'Europe';
! SELECT count(*) FROM european_city_view;
!  count 
! -------
!      1
! (1 row)
! 
! CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
! AS 'begin RETURN NULL; end';
! CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
! ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
! \set QUIET false
! INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
! INSERT 0 0
! UPDATE european_city_view SET population = 10000;
! UPDATE 0
! DELETE FROM european_city_view;
! DELETE 0
! \set QUIET true
! -- rules bypassing no-op triggers
! CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
! DO INSTEAD INSERT INTO city_view
! VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
! RETURNING *;
! CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
! DO INSTEAD UPDATE city_view SET
!     city_name = NEW.city_name,
!     population = NEW.population,
!     country_name = NEW.country_name
! WHERE city_id = OLD.city_id
! RETURNING NEW.*;
! CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
! DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
! \set QUIET false
! -- INSERT not limited by view's WHERE clause, but UPDATE AND DELETE are
! INSERT INTO european_city_view(city_name, country_name)
!     VALUES ('Cambridge', 'USA') RETURNING *;
!  city_id | city_name | population | country_name |   continent   
! ---------+-----------+------------+--------------+---------------
!        4 | Cambridge |            | USA          | North America
! (1 row)
! 
! INSERT 0 1
! UPDATE european_city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge';
! UPDATE 0
! DELETE FROM european_city_view WHERE city_name = 'Cambridge';
! DELETE 0
! -- UPDATE and DELETE via rule and trigger
! UPDATE city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |            | UK           | Europe
! (1 row)
! 
! UPDATE 1
! UPDATE european_city_view SET population = 122800
!     WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |     122800 | UK           | Europe
! (1 row)
! 
! UPDATE 1
! DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
!        4 | Cambridge |     122800 | UK           | Europe
! (1 row)
! 
! DELETE 1
! -- join UPDATE test
! UPDATE city_view v SET population = 599657
!     FROM city_table ci, country_table co
!     WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'
!     AND v.city_id = ci.city_id AND v.country_name = co.country_name
!     RETURNING co.country_id, v.country_name,
!               v.city_id, v.city_name, v.population;
!  country_id | country_name | city_id |   city_name   | population 
! ------------+--------------+---------+---------------+------------
!           3 | USA          |       3 | Washington DC |     599657
! (1 row)
! 
! UPDATE 1
! \set QUIET true
! SELECT * FROM city_view;
!  city_id |   city_name   | population | country_name |   continent   
! ---------+---------------+------------+--------------+---------------
!        1 | Tokyo         |   13010279 | Japan        | Asia
!   123456 | New York      |    8391881 | USA          | North America
!        2 | London        |    7556900 | UK           | Europe
!        3 | Washington DC |     599657 | USA          | North America
! (4 rows)
! 
! DROP TABLE city_table CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view city_view
! drop cascades to view european_city_view
! DROP TABLE country_table;
! -- Test pg_trigger_depth()
! create table depth_a (id int not null primary key);
! create table depth_b (id int not null primary key);
! create table depth_c (id int not null primary key);
! create function depth_a_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   insert into depth_b values (new.id);
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_a_tr before insert on depth_a
!   for each row execute procedure depth_a_tf();
! create function depth_b_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   begin
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   exception
!     when sqlstate 'U9999' then
!       raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
!   end;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   end if;
!   return new;
! end;
! $$;
! create trigger depth_b_tr before insert on depth_b
!   for each row execute procedure depth_b_tf();
! create function depth_c_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     raise exception sqlstate 'U9999';
!   end if;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_c_tr before insert on depth_c
!   for each row execute procedure depth_c_tf();
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (1);
! NOTICE:  depth_a_tr: depth = 1
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  SQLSTATE = U9999: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 12 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! ERROR:  U9999
! CONTEXT:  SQL statement "insert into depth_c values (1)"
! PL/pgSQL function depth_b_tf() line 12 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (2);
! NOTICE:  depth_a_tr: depth = 1
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (2)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_c_tr: depth = 3
! CONTEXT:  SQL statement "insert into depth_c values (2)"
! PL/pgSQL function depth_b_tf() line 5 at EXECUTE statement
! SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_b_tr: depth = 2
! CONTEXT:  SQL statement "insert into depth_b values (new.id)"
! PL/pgSQL function depth_a_tf() line 4 at SQL statement
! NOTICE:  depth_a_tr: depth = 1
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! drop table depth_a, depth_b, depth_c;
! drop function depth_a_tf();
! drop function depth_b_tf();
! drop function depth_c_tf();
! --
! -- Test updates to rows during firing of BEFORE ROW triggers.
! -- As of 9.2, such cases should be rejected (see bug #6123).
! --
! create temp table parent (
!     aid int not null primary key,
!     val1 text,
!     val2 text,
!     val3 text,
!     val4 text,
!     bcnt int not null default 0);
! create temp table child (
!     bid int not null primary key,
!     aid int not null,
!     val1 text);
! create function parent_upd_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.val1 <> new.val1 then
!     new.val2 = new.val1;
!     delete from child where child.aid = new.aid and child.val1 = new.val1;
!   end if;
!   return new;
! end;
! $$;
! create trigger parent_upd_trig before update on parent
!   for each row execute procedure parent_upd_func();
! create function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger parent_del_trig before delete on parent
!   for each row execute procedure parent_del_func();
! create function child_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt + 1 where aid = new.aid;
!   return new;
! end;
! $$;
! create trigger child_ins_trig after insert on child
!   for each row execute procedure child_ins_func();
! create function child_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt - 1 where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger child_del_trig after delete on child
!   for each row execute procedure child_del_func();
! insert into parent values (1, 'a', 'a', 'a', 'a', 0);
! insert into child values (10, 1, 'b');
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! update parent set val1 = 'b' where aid = 1; -- should fail
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! delete from parent where aid = 1; -- should fail
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    1
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! -- replace the trigger function with one that restarts the deletion after
! -- having modified a child
! create or replace function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   if found then
!     delete from parent where aid = old.aid;
!     return null; -- cancel outer deletion
!   end if;
!   return old;
! end;
! $$;
! delete from parent where aid = 1;
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
! (0 rows)
! 
!  bid | aid | val1 
! -----+-----+------
! (0 rows)
! 
! drop table parent, child;
! drop function parent_upd_func();
! drop function parent_del_func();
! drop function child_ins_func();
! drop function child_del_func();
! -- similar case, but with a self-referencing FK so that parent and child
! -- rows can be affected by a single operation
! create temp table self_ref_trigger (
!     id int primary key,
!     parent int references self_ref_trigger,
!     data text,
!     nchildren int not null default 0
! );
! create function self_ref_trigger_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if new.parent is not null then
!     update self_ref_trigger set nchildren = nchildren + 1
!       where id = new.parent;
!   end if;
!   return new;
! end;
! $$;
! create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
!   for each row execute procedure self_ref_trigger_ins_func();
! create function self_ref_trigger_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.parent is not null then
!     update self_ref_trigger set nchildren = nchildren - 1
!       where id = old.parent;
!   end if;
!   return old;
! end;
! $$;
! create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
!   for each row execute procedure self_ref_trigger_del_func();
! insert into self_ref_trigger values (1, null, 'root');
! insert into self_ref_trigger values (2, 1, 'root child A');
! insert into self_ref_trigger values (3, 1, 'root child B');
! insert into self_ref_trigger values (4, 2, 'grandchild 1');
! insert into self_ref_trigger values (5, 3, 'grandchild 2');
! update self_ref_trigger set data = 'root!' where id = 1;
! select * from self_ref_trigger;
!  id | parent |     data     | nchildren 
! ----+--------+--------------+-----------
!   2 |      1 | root child A |         1
!   4 |      2 | grandchild 1 |         0
!   3 |      1 | root child B |         1
!   5 |      3 | grandchild 2 |         0
!   1 |        | root!        |         2
! (5 rows)
! 
! delete from self_ref_trigger;
! ERROR:  tuple to be updated was already modified by an operation triggered by the current command
! HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
! select * from self_ref_trigger;
!  id | parent |     data     | nchildren 
! ----+--------+--------------+-----------
!   2 |      1 | root child A |         1
!   4 |      2 | grandchild 1 |         0
!   3 |      1 | root child B |         1
!   5 |      3 | grandchild 2 |         0
!   1 |        | root!        |         2
! (5 rows)
! 
! drop table self_ref_trigger;
! drop function self_ref_trigger_ins_func();
! drop function self_ref_trigger_del_func();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/inherit.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/inherit.out	2015-01-26 12:33:23.295031275 +0300
***************
*** 1,1457 ****
! --
! -- Test inheritance features
! --
! CREATE TABLE a (aa TEXT);
! CREATE TABLE b (bb TEXT) INHERITS (a);
! CREATE TABLE c (cc TEXT) INHERITS (a);
! CREATE TABLE d (dd TEXT) INHERITS (b,c,a);
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "aa"
! INSERT INTO a(aa) VALUES('aaa');
! INSERT INTO a(aa) VALUES('aaaa');
! INSERT INTO a(aa) VALUES('aaaaa');
! INSERT INTO a(aa) VALUES('aaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaaa');
! INSERT INTO b(aa) VALUES('bbb');
! INSERT INTO b(aa) VALUES('bbbb');
! INSERT INTO b(aa) VALUES('bbbbb');
! INSERT INTO b(aa) VALUES('bbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbbb');
! INSERT INTO c(aa) VALUES('ccc');
! INSERT INTO c(aa) VALUES('cccc');
! INSERT INTO c(aa) VALUES('ccccc');
! INSERT INTO c(aa) VALUES('cccccc');
! INSERT INTO c(aa) VALUES('ccccccc');
! INSERT INTO c(aa) VALUES('cccccccc');
! INSERT INTO d(aa) VALUES('ddd');
! INSERT INTO d(aa) VALUES('dddd');
! INSERT INTO d(aa) VALUES('ddddd');
! INSERT INTO d(aa) VALUES('dddddd');
! INSERT INTO d(aa) VALUES('ddddddd');
! INSERT INTO d(aa) VALUES('dddddddd');
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | aaa
!  a       | aaaa
!  a       | aaaaa
!  a       | aaaaaa
!  a       | aaaaaaa
!  a       | aaaaaaaa
!  b       | bbb
!  b       | bbbb
!  b       | bbbbb
!  b       | bbbbbb
!  b       | bbbbbbb
!  b       | bbbbbbbb
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | ddd
!  d       | dddd
!  d       | ddddd
!  d       | dddddd
!  d       | ddddddd
!  d       | dddddddd
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | aaa
!  a       | aaaa
!  a       | aaaaa
!  a       | aaaaaa
!  a       | aaaaaaa
!  a       | aaaaaaaa
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='zzzz' WHERE aa='aaaa';
! UPDATE ONLY a SET aa='zzzzz' WHERE aa='aaaaa';
! UPDATE b SET aa='zzz' WHERE aa='aaa';
! UPDATE ONLY b SET aa='zzz' WHERE aa='aaa';
! UPDATE a SET aa='zzzzzz' WHERE aa LIKE 'aaa%';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  b       | bbb
!  b       | bbbb
!  b       | bbbbb
!  b       | bbbbbb
!  b       | bbbbbbb
!  b       | bbbbbbbb
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | ddd
!  d       | dddd
!  d       | ddddd
!  d       | dddddd
!  d       | ddddddd
!  d       | dddddddd
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | ddd      | 
!  d       | dddd     | 
!  d       | ddddd    | 
!  d       | dddddd   | 
!  d       | ddddddd  | 
!  d       | dddddddd | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |   aa   
! ---------+--------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname |    aa    | bb 
! ---------+----------+----
!  b       | bbb      | 
!  b       | bbbb     | 
!  b       | bbbbb    | 
!  b       | bbbbbb   | 
!  b       | bbbbbbb  | 
!  b       | bbbbbbbb | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname |    aa    | bb | cc | dd 
! ---------+----------+----+----+----
!  d       | ddd      |    |    | 
!  d       | dddd     |    |    | 
!  d       | ddddd    |    |    | 
!  d       | dddddd   |    |    | 
!  d       | ddddddd  |    |    | 
!  d       | dddddddd |    |    | 
! (6 rows)
! 
! UPDATE b SET aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname |    aa    
! ---------+----------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  c       | ccc
!  c       | cccc
!  c       | ccccc
!  c       | cccccc
!  c       | ccccccc
!  c       | cccccccc
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
! (24 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
!  d       | new      | 
! (12 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname |   aa   
! ---------+--------
!  a       | zzzz
!  a       | zzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
!  a       | zzzzzz
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname |    aa    | cc 
! ---------+----------+----
!  c       | ccc      | 
!  c       | cccc     | 
!  c       | ccccc    | 
!  c       | cccccc   | 
!  c       | ccccccc  | 
!  c       | cccccccc | 
! (6 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='new';
! DELETE FROM ONLY c WHERE aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa  
! ---------+-----
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  b       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
!  d       | new
! (18 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (12 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa  | cc 
! ---------+-----+----
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
!  d       | new | 
! (6 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa  
! ---------+-----
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
!  a       | new
! (6 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa  | bb 
! ---------+-----+----
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
!  b       | new | 
! (6 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa  | bb | cc | dd 
! ---------+-----+----+----+----
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
!  d       | new |    |    | 
! (6 rows)
! 
! DELETE FROM a;
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- Confirm PRIMARY KEY adds NOT NULL constraint to child table
! CREATE TEMP TABLE z (b TEXT, PRIMARY KEY(aa, b)) inherits (a);
! INSERT INTO z VALUES (NULL, 'text'); -- should fail
! ERROR:  null value in column "aa" violates not-null constraint
! DETAIL:  Failing row contains (null, text).
! -- Check UPDATE with inherited target and an inherited source table
! create temp table foo(f1 int, f2 int);
! create temp table foo2(f3 int) inherits (foo);
! create temp table bar(f1 int, f2 int);
! create temp table bar2(f3 int) inherits (bar);
! insert into foo values(1,1);
! insert into foo values(3,3);
! insert into foo2 values(2,2,2);
! insert into foo2 values(3,3,3);
! insert into bar values(1,1);
! insert into bar values(2,2);
! insert into bar values(3,3);
! insert into bar values(4,4);
! insert into bar2 values(1,1,1);
! insert into bar2 values(2,2,2);
! insert into bar2 values(3,3,3);
! insert into bar2 values(4,4,4);
! update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
! select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
!  relname | f1 | f2  
! ---------+----+-----
!  bar     |  1 | 101
!  bar     |  2 | 102
!  bar     |  3 | 103
!  bar     |  4 |   4
!  bar2    |  1 | 101
!  bar2    |  2 | 102
!  bar2    |  3 | 103
!  bar2    |  4 |   4
! (8 rows)
! 
! -- Check UPDATE with inherited target and an appendrel subquery
! update bar set f2 = f2 + 100
! from
!   ( select f1 from foo union all select f1+3 from foo ) ss
! where bar.f1 = ss.f1;
! select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
!  relname | f1 | f2  
! ---------+----+-----
!  bar     |  1 | 201
!  bar     |  2 | 202
!  bar     |  3 | 203
!  bar     |  4 | 104
!  bar2    |  1 | 201
!  bar2    |  2 | 202
!  bar2    |  3 | 203
!  bar2    |  4 | 104
! (8 rows)
! 
! /* Test multiple inheritance of column defaults */
! CREATE TABLE firstparent (tomorrow date default now()::date + 1);
! CREATE TABLE secondparent (tomorrow date default  now() :: date  +  1);
! CREATE TABLE jointchild () INHERITS (firstparent, secondparent);  -- ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! CREATE TABLE thirdparent (tomorrow date default now()::date - 1);
! CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);  -- not ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! ERROR:  column "tomorrow" inherits conflicting default values
! HINT:  To resolve the conflict, specify a default explicitly.
! CREATE TABLE otherchild (tomorrow date default now())
!   INHERITS (firstparent, thirdparent);  -- ok, child resolves ambiguous default
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! NOTICE:  merging column "tomorrow" with inherited definition
! DROP TABLE firstparent, secondparent, jointchild, thirdparent, otherchild;
! -- Test changing the type of inherited columns
! insert into d values('test','one','two','three');
! alter table a alter column aa type integer using bit_length(aa);
! select * from d;
!  aa | bb  | cc  |  dd   
! ----+-----+-----+-------
!  32 | one | two | three
! (1 row)
! 
! -- Test non-inheritable parent constraints
! create table p1(ff1 int);
! alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
! alter table p1 add constraint p2chk check (ff1 > 10);
! -- connoinherit should be true for NO INHERIT constraint
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.connoinherit from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname = 'p1' order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | connoinherit 
! ---------+---------+---------+------------+-------------+--------------
!  p1      | p1chk   | c       | t          |           0 | t
!  p1      | p2chk   | c       | t          |           0 | f
! (2 rows)
! 
! -- Test that child does not inherit NO INHERIT constraints
! create table c1 () inherits (p1);
! \d p1
!       Table "public.p1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  ff1    | integer | 
! Check constraints:
!     "p1chk" CHECK (ff1 > 0) NO INHERIT
!     "p2chk" CHECK (ff1 > 10)
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d c1
!       Table "public.c1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  ff1    | integer | 
! Check constraints:
!     "p2chk" CHECK (ff1 > 10)
! Inherits: p1
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! -- Tests for casting between the rowtypes of parent and child
! -- tables. See the pgsql-hackers thread beginning Dec. 4/04
! create table base (i integer);
! create table derived () inherits (base);
! insert into derived (i) values (0);
! select derived::base from derived;
!  derived 
! ---------
!  (0)
! (1 row)
! 
! drop table derived;
! drop table base;
! create table p1(ff1 int);
! create table p2(f1 text);
! create function p2text(p2) returns text as 'select $1.f1' language sql;
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(123456789, 'hi', 42);
! select p2text(c1.*) from c1;
!  p2text 
! --------
!  hi
! (1 row)
! 
! drop function p2text(p2);
! drop table c1;
! drop table p2;
! drop table p1;
! CREATE TABLE ac (aa TEXT);
! alter table ac add constraint ac_check check (aa is not null);
! CREATE TABLE bc (bb TEXT) INHERITS (ac);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_check" of relation "bc"
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! -- try the unnamed-constraint case
! alter table ac add check (aa is not null);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname |   conname   | contype | conislocal | coninhcount |      consrc      
! ---------+-------------+---------+------------+-------------+------------------
!  ac      | ac_aa_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_aa_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_aa_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_aa_check" of relation "bc"
! alter table ac drop constraint ac_aa_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! alter table ac add constraint ac_check check (aa is not null);
! alter table bc no inherit ac;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (2 rows)
! 
! alter table bc drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (1 row)
! 
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0));
! create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging constraint "check_a" with inherited definition
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_a | c       | t          |           1 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
! (3 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0));
! create table bc (b int constraint check_b check (b <> 0));
! create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | f          |           1 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! alter table cc no inherit bc;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! drop table cc;
! drop table bc;
! drop table ac;
! create table p1(f1 int);
! create table p2(f2 int);
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(1,-1,2);
! alter table p2 add constraint cc check (f2>0);  -- fail
! ERROR:  check constraint "cc" is violated by some row
! alter table p2 add check (f2>0);  -- check it without a name, too
! ERROR:  check constraint "p2_f2_check" is violated by some row
! delete from c1;
! insert into c1 values(1,1,2);
! alter table p2 add check (f2>0);
! insert into c1 values(1,-1,2);  -- fail
! ERROR:  new row for relation "c1" violates check constraint "p2_f2_check"
! DETAIL:  Failing row contains (1, -1, 2).
! create table c2(f3 int) inherits(p1,p2);
! \d c2
!       Table "public.c2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | integer | 
!  f3     | integer | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: p1,
!           p2
! 
! create table c3 (f4 int) inherits(c1,c2);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "f2"
! NOTICE:  merging multiple inherited definitions of column "f3"
! \d c3
!       Table "public.c3"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | integer | 
!  f3     | integer | 
!  f4     | integer | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: c1,
!           c2
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table c1
! drop cascades to table c2
! drop cascades to table c3
! drop table p2 cascade;
! create table pp1 (f1 int);
! create table cc1 (f2 text, f3 int) inherits (pp1);
! alter table pp1 add column a1 int check (a1 > 0);
! \d cc1
!       Table "public.cc1"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  f1     | integer | 
!  f2     | text    | 
!  f3     | integer | 
!  a1     | integer | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1
! 
! create table cc2(f4 float) inherits(pp1,cc1);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "a1"
! \d cc2
!           Table "public.cc2"
!  Column |       Type       | Modifiers 
! --------+------------------+-----------
!  f1     | integer          | 
!  a1     | integer          | 
!  f2     | text             | 
!  f3     | integer          | 
!  f4     | double precision | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1,
!           cc1
! 
! alter table pp1 add column a2 int check (a2 > 0);
! NOTICE:  merging definition of column "a2" for child "cc2"
! NOTICE:  merging constraint "pp1_a2_check" with inherited definition
! \d cc2
!           Table "public.cc2"
!  Column |       Type       | Modifiers 
! --------+------------------+-----------
!  f1     | integer          | 
!  a1     | integer          | 
!  f2     | text             | 
!  f3     | integer          | 
!  f4     | double precision | 
!  a2     | integer          | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
!     "pp1_a2_check" CHECK (a2 > 0)
! Inherits: pp1,
!           cc1
! 
! drop table pp1 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table cc1
! drop cascades to table cc2
! -- Test for renaming in simple multiple inheritance
! CREATE TABLE inht1 (a int, b int);
! CREATE TABLE inhs1 (b int, c int);
! CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME a TO aa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! ALTER TABLE inhts RENAME aa TO aaa;      -- to be failed
! ERROR:  cannot rename inherited column "aa"
! ALTER TABLE inhts RENAME d TO dd;
! \d+ inhts
!                         Table "public.inhts"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aa     | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  c      | integer |           | plain   |              | 
!  dd     | integer |           | plain   |              | 
! Inherits: inht1,
!           inhs1
! 
! DROP TABLE inhts;
! -- Test for renaming in diamond inheritance
! CREATE TABLE inht2 (x int) INHERITS (inht1);
! CREATE TABLE inht3 (y int) INHERITS (inht1);
! CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aa TO aaa;
! \d+ inht4
!                         Table "public.inht4"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aaa    | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  x      | integer |           | plain   |              | 
!  y      | integer |           | plain   |              | 
!  z      | integer |           | plain   |              | 
! Inherits: inht2,
!           inht3
! 
! CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aaa TO aaaa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! \d+ inhts
!                         Table "public.inhts"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  aaaa   | integer |           | plain   |              | 
!  b      | integer |           | plain   |              | 
!  x      | integer |           | plain   |              | 
!  c      | integer |           | plain   |              | 
!  d      | integer |           | plain   |              | 
! Inherits: inht2,
!           inhs1
! 
! WITH RECURSIVE r AS (
!   SELECT 'inht1'::regclass AS inhrelid
! UNION ALL
!   SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparent
! )
! SELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected
!   FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits
!         WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e
!   JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal
!   ORDER BY a.attrelid::regclass::name, a.attnum;
!  attrelid | attname | attinhcount | expected 
! ----------+---------+-------------+----------
!  inht2    | aaaa    |           1 |        1
!  inht2    | b       |           1 |        1
!  inht3    | aaaa    |           1 |        1
!  inht3    | b       |           1 |        1
!  inht4    | aaaa    |           2 |        2
!  inht4    | b       |           2 |        2
!  inht4    | x       |           1 |        2
!  inht4    | y       |           1 |        2
!  inhts    | aaaa    |           1 |        1
!  inhts    | b       |           2 |        1
!  inhts    | x       |           1 |        1
!  inhts    | c       |           1 |        1
! (12 rows)
! 
! DROP TABLE inht1, inhs1 CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table inht2
! drop cascades to table inhts
! drop cascades to table inht3
! drop cascades to table inht4
! -- Test non-inheritable indices [UNIQUE, EXCLUDE] contraints
! CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
! CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
! \d+ test_constraints
!                         Table "public.test_constraints"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Indexes:
!     "test_constraints_val1_val2_key" UNIQUE CONSTRAINT, btree (val1, val2)
! Child tables: test_constraints_inh
! 
! ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
! \d+ test_constraints
!                         Table "public.test_constraints"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Child tables: test_constraints_inh
! 
! \d+ test_constraints_inh
!                       Table "public.test_constraints_inh"
!  Column |       Type        | Modifiers | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+--------------+-------------
!  id     | integer           |           | plain    |              | 
!  val1   | character varying |           | extended |              | 
!  val2   | integer           |           | plain    |              | 
! Inherits: test_constraints
! 
! DROP TABLE test_constraints_inh;
! DROP TABLE test_constraints;
! CREATE TABLE test_ex_constraints (
!     c circle,
!     EXCLUDE USING gist (c WITH &&)
! );
! CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
! \d+ test_ex_constraints
!                  Table "public.test_ex_constraints"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Indexes:
!     "test_ex_constraints_c_excl" EXCLUDE USING gist (c WITH &&)
! Child tables: test_ex_constraints_inh
! 
! ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
! \d+ test_ex_constraints
!                  Table "public.test_ex_constraints"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Child tables: test_ex_constraints_inh
! 
! \d+ test_ex_constraints_inh
!                Table "public.test_ex_constraints_inh"
!  Column |  Type  | Modifiers | Storage | Stats target | Description 
! --------+--------+-----------+---------+--------------+-------------
!  c      | circle |           | plain   |              | 
! Inherits: test_ex_constraints
! 
! DROP TABLE test_ex_constraints_inh;
! DROP TABLE test_ex_constraints;
! -- Test non-inheritable foreign key contraints
! CREATE TABLE test_primary_constraints(id int PRIMARY KEY);
! CREATE TABLE test_foreign_constraints(id1 int REFERENCES test_primary_constraints(id));
! CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
! \d+ test_primary_constraints
!                Table "public.test_primary_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id     | integer | not null  | plain   |              | 
! Indexes:
!     "test_primary_constraints_pkey" PRIMARY KEY, btree (id)
! Referenced by:
!     TABLE "test_foreign_constraints" CONSTRAINT "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! 
! \d+ test_foreign_constraints
!                Table "public.test_foreign_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Foreign-key constraints:
!     "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! Child tables: test_foreign_constraints_inh
! 
! ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
! \d+ test_foreign_constraints
!                Table "public.test_foreign_constraints"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Child tables: test_foreign_constraints_inh
! 
! \d+ test_foreign_constraints_inh
!              Table "public.test_foreign_constraints_inh"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  id1    | integer |           | plain   |              | 
! Inherits: test_foreign_constraints
! 
! DROP TABLE test_foreign_constraints_inh;
! DROP TABLE test_foreign_constraints;
! DROP TABLE test_primary_constraints;
! --
! -- Test parameterized append plans for inheritance trees
! --
! create temp table patest0 (id, x) as
!   select x, x from generate_series(0,1000) x;
! create temp table patest1() inherits (patest0);
! insert into patest1
!   select x, x from generate_series(0,1000) x;
! create temp table patest2() inherits (patest0);
! insert into patest2
!   select x, x from generate_series(0,1000) x;
! create index patest0i on patest0(id);
! create index patest1i on patest1(id);
! create index patest2i on patest2(id);
! analyze patest0;
! analyze patest1;
! analyze patest2;
! explain (costs off)
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using patest0i on patest0
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest1i on patest1
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest2i on patest2
!                Index Cond: (id = int4_tbl.f1)
! (10 rows)
! 
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop index patest2i;
! explain (costs off)
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using patest0i on patest0
!                Index Cond: (id = int4_tbl.f1)
!          ->  Index Scan using patest1i on patest1
!                Index Cond: (id = int4_tbl.f1)
!          ->  Seq Scan on patest2
!                Filter: (int4_tbl.f1 = id)
! (10 rows)
! 
! select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop table patest0 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table patest1
! drop cascades to table patest2
! --
! -- Test merge-append plans for inheritance trees
! --
! create table matest0 (id serial primary key, name text);
! create table matest1 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest2 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest3 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create index matest0i on matest0 ((1-id));
! create index matest1i on matest1 ((1-id));
! -- create index matest2i on matest2 ((1-id));  -- intentionally missing
! create index matest3i on matest3 ((1-id));
! insert into matest1 (name) values ('Test 1');
! insert into matest1 (name) values ('Test 2');
! insert into matest2 (name) values ('Test 3');
! insert into matest2 (name) values ('Test 4');
! insert into matest3 (name) values ('Test 5');
! insert into matest3 (name) values ('Test 6');
! set enable_indexscan = off;  -- force use of seqscan/sort, so no merge
! explain (verbose, costs off) select * from matest0 order by 1-id;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Sort
!    Output: matest0.id, matest0.name, ((1 - matest0.id))
!    Sort Key: ((1 - matest0.id))
!    ->  Result
!          Output: matest0.id, matest0.name, (1 - matest0.id)
!          ->  Append
!                ->  Seq Scan on public.matest0
!                      Output: matest0.id, matest0.name
!                ->  Seq Scan on public.matest1
!                      Output: matest1.id, matest1.name
!                ->  Seq Scan on public.matest2
!                      Output: matest2.id, matest2.name
!                ->  Seq Scan on public.matest3
!                      Output: matest3.id, matest3.name
! (14 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                QUERY PLAN               
! ----------------------------------------
!  Aggregate
!    Output: min((1 - matest0.id))
!    ->  Append
!          ->  Seq Scan on public.matest0
!                Output: matest0.id
!          ->  Seq Scan on public.matest1
!                Output: matest1.id
!          ->  Seq Scan on public.matest2
!                Output: matest2.id
!          ->  Seq Scan on public.matest3
!                Output: matest3.id
! (11 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_indexscan;
! set enable_seqscan = off;  -- plan with fewest seqscans should be merge
! explain (verbose, costs off) select * from matest0 order by 1-id;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Merge Append
!    Sort Key: ((1 - matest0.id))
!    ->  Index Scan using matest0i on public.matest0
!          Output: matest0.id, matest0.name, (1 - matest0.id)
!    ->  Index Scan using matest1i on public.matest1
!          Output: matest1.id, matest1.name, (1 - matest1.id)
!    ->  Sort
!          Output: matest2.id, matest2.name, ((1 - matest2.id))
!          Sort Key: ((1 - matest2.id))
!          ->  Seq Scan on public.matest2
!                Output: matest2.id, matest2.name, (1 - matest2.id)
!    ->  Index Scan using matest3i on public.matest3
!          Output: matest3.id, matest3.name, (1 - matest3.id)
! (13 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Result
!    Output: $0
!    InitPlan 1 (returns $0)
!      ->  Limit
!            Output: ((1 - matest0.id))
!            ->  Result
!                  Output: ((1 - matest0.id))
!                  ->  Merge Append
!                        Sort Key: ((1 - matest0.id))
!                        ->  Index Scan using matest0i on public.matest0
!                              Output: matest0.id, (1 - matest0.id)
!                              Index Cond: ((1 - matest0.id) IS NOT NULL)
!                        ->  Index Scan using matest1i on public.matest1
!                              Output: matest1.id, (1 - matest1.id)
!                              Index Cond: ((1 - matest1.id) IS NOT NULL)
!                        ->  Sort
!                              Output: matest2.id, ((1 - matest2.id))
!                              Sort Key: ((1 - matest2.id))
!                              ->  Bitmap Heap Scan on public.matest2
!                                    Output: matest2.id, (1 - matest2.id)
!                                    Filter: ((1 - matest2.id) IS NOT NULL)
!                                    ->  Bitmap Index Scan on matest2_pkey
!                        ->  Index Scan using matest3i on public.matest3
!                              Output: matest3.id, (1 - matest3.id)
!                              Index Cond: ((1 - matest3.id) IS NOT NULL)
! (25 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_seqscan;
! drop table matest0 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table matest1
! drop cascades to table matest2
! drop cascades to table matest3
! --
! -- Test merge-append for UNION ALL append relations
! --
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! -- Check handling of duplicated, constant, or volatile targetlist items
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, thousand FROM tenk1
! ORDER BY thousand, tenthous;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: tenk1_1.thousand, tenk1_1.thousand
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1
! UNION ALL
! SELECT 42, 42, hundred FROM tenk1
! ORDER BY thousand, tenthous;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: (42), (42)
!          ->  Index Only Scan using tenk1_hundred on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, random()::integer FROM tenk1
! ORDER BY thousand, tenthous;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Sort
!          Sort Key: tenk1_1.thousand, ((random())::integer)
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (6 rows)
! 
! -- Check min/max aggregate optimization
! explain (costs off)
! SELECT min(x) FROM
!   (SELECT unique1 AS x FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x FROM tenk1 b) s;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: a.unique1
!                  ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                        Index Cond: (unique1 IS NOT NULL)
!                  ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                        Index Cond: (unique2 IS NOT NULL)
! (9 rows)
! 
! explain (costs off)
! SELECT min(y) FROM
!   (SELECT unique1 AS x, unique1 AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: a.unique1
!                  ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                        Index Cond: (unique1 IS NOT NULL)
!                  ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                        Index Cond: (unique2 IS NOT NULL)
! (9 rows)
! 
! -- XXX planner doesn't recognize that index on unique2 is sufficiently sorted
! explain (costs off)
! SELECT x, y FROM
!   (SELECT thousand AS x, tenthous AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s
! ORDER BY x, y;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Merge Append
!    Sort Key: a.thousand, a.tenthous
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1 a
!    ->  Sort
!          Sort Key: b.unique2, b.unique2
!          ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (6 rows)
! 
! -- exercise rescan code path via a repeatedly-evaluated subquery
! explain (costs off)
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Function Scan on generate_series g
!    SubPlan 1
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: ((d.d + g.i))
!                  ->  Sort
!                        Sort Key: ((d.d + g.i))
!                        ->  Function Scan on generate_series d
!                  ->  Sort
!                        Sort Key: ((d_1.d + g.i))
!                        ->  Function Scan on generate_series d_1
! (11 rows)
! 
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!             array             
! ------------------------------
!  {1,5,6,8,11,11,14,16,17,20}
!  {2,6,7,9,12,12,15,17,18,21}
!  {3,7,8,10,13,13,16,18,19,22}
! (3 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/create_table_like.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/create_table_like.out	2015-01-26 12:33:23.295031275 +0300
***************
*** 1,230 ****
! /* Test inheritance of structure (LIKE) */
! CREATE TABLE inhx (xx text DEFAULT 'text');
! /*
!  * Test double inheritance
!  *
!  * Ensure that defaults are NOT included unless
!  * INCLUDING DEFAULTS is specified
!  */
! CREATE TABLE ctla (aa TEXT);
! CREATE TABLE ctlb (bb TEXT) INHERITS (ctla);
! CREATE TABLE foo (LIKE nonexistent);
! ERROR:  relation "nonexistent" does not exist
! LINE 1: CREATE TABLE foo (LIKE nonexistent);
!                                ^
! CREATE TABLE inhe (ee text, LIKE inhx) inherits (ctlb);
! INSERT INTO inhe VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
! SELECT * FROM inhe; /* Columns aa, bb, xx value NULL, ee */
!    aa    |   bb    | ee |   xx    
! ---------+---------+----+---------
!  ee-col1 | ee-col2 |    | ee-col4
! (1 row)
! 
! SELECT * FROM inhx; /* Empty set since LIKE inherits structure only */
!  xx 
! ----
! (0 rows)
! 
! SELECT * FROM ctlb; /* Has ee entry */
!    aa    |   bb    
! ---------+---------
!  ee-col1 | ee-col2
! (1 row)
! 
! SELECT * FROM ctla; /* Has ee entry */
!    aa    
! ---------
!  ee-col1
! (1 row)
! 
! CREATE TABLE inhf (LIKE inhx, LIKE inhx); /* Throw error */
! ERROR:  column "xx" specified more than once
! CREATE TABLE inhf (LIKE inhx INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
! INSERT INTO inhf DEFAULT VALUES;
! SELECT * FROM inhf; /* Single entry with value 'text' */
!   xx  
! ------
!  text
! (1 row)
! 
! ALTER TABLE inhx add constraint foo CHECK (xx = 'text');
! ALTER TABLE inhx ADD PRIMARY KEY (xx);
! CREATE TABLE inhg (LIKE inhx); /* Doesn't copy constraint */
! INSERT INTO inhg VALUES ('foo');
! DROP TABLE inhg;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING CONSTRAINTS, y text); /* Copies constraints */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds -- Unique constraints not copied */
! INSERT INTO inhg VALUES ('x', 'foo',  'y');  /* fails due to constraint */
! ERROR:  new row for relation "inhg" violates check constraint "foo"
! DETAIL:  Failing row contains (x, foo, y).
! SELECT * FROM inhg; /* Two records with three columns in order x=x, xx=text, y=y */
!  x |  xx  | y 
! ---+------+---
!  x | text | y
!  x | text | y
! (2 rows)
! 
! DROP TABLE inhg;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text); /* copies indexes */
! INSERT INTO inhg VALUES (5, 10);
! INSERT INTO inhg VALUES (20, 10); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_pkey"
! DETAIL:  Key (xx)=(10) already exists.
! DROP TABLE inhg;
! /* Multiple primary keys creation should fail */
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x)); /* fails */
! ERROR:  multiple primary keys for table "inhg" are not allowed
! CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE);
! CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
! /* Ok to create multiple unique indexes */
! CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES);
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 5, 10);
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 10, 15);
! INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_x_key"
! DETAIL:  Key (x)=(15) already exists.
! DROP TABLE inhg;
! DROP TABLE inhz;
! -- including storage and comments
! CREATE TABLE ctlt1 (a text CHECK (length(a) > 2) PRIMARY KEY, b text);
! CREATE INDEX ctlt1_b_key ON ctlt1 (b);
! CREATE INDEX ctlt1_fnidx ON ctlt1 ((a || b));
! COMMENT ON COLUMN ctlt1.a IS 'A';
! COMMENT ON COLUMN ctlt1.b IS 'B';
! COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
! COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
! COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
! ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
! CREATE TABLE ctlt2 (c text);
! ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
! COMMENT ON COLUMN ctlt2.c IS 'C';
! CREATE TABLE ctlt3 (a text CHECK (length(a) < 5), c text);
! ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
! ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
! COMMENT ON COLUMN ctlt3.a IS 'A3';
! COMMENT ON COLUMN ctlt3.c IS 'C';
! COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
! CREATE TABLE ctlt4 (a text, c text);
! ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
! CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
! \d+ ctlt12_storage
!                    Table "public.ctlt12_storage"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | 
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | 
! 
! CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
! \d+ ctlt12_comments
!                   Table "public.ctlt12_comments"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | extended |              | A
!  b      | text |           | extended |              | B
!  c      | text |           | extended |              | C
! 
! CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging column "b" with inherited definition
! NOTICE:  merging constraint "ctlt1_a_check" with inherited definition
! \d+ ctlt1_inh
!                      Table "public.ctlt1_inh"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A
!  b      | text |           | extended |              | B
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! Inherits: ctlt1
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
!  description 
! -------------
!  t1_a_check
! (1 row)
! 
! CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
! NOTICE:  merging multiple inherited definitions of column "a"
! \d+ ctlt13_inh
!                      Table "public.ctlt13_inh"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | 
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | 
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1,
!           ctlt3
! 
! CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! \d+ ctlt13_like
!                     Table "public.ctlt13_like"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A3
!  b      | text |           | extended |              | 
!  c      | text |           | external |              | C
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
!  description 
! -------------
!  t3_a_check
! (1 row)
! 
! CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
! \d+ ctlt_all
!                       Table "public.ctlt_all"
!  Column | Type | Modifiers | Storage  | Stats target | Description 
! --------+------+-----------+----------+--------------+-------------
!  a      | text | not null  | main     |              | A
!  b      | text |           | extended |              | B
! Indexes:
!     "ctlt_all_pkey" PRIMARY KEY, btree (a)
!     "ctlt_all_b_idx" btree (b)
!     "ctlt_all_expr_idx" btree ((a || b))
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! 
! SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
!     relname     | objsubid | description 
! ----------------+----------+-------------
!  ctlt_all_b_idx |        0 | index b_key
!  ctlt_all_pkey  |        0 | index pkey
! (2 rows)
! 
! CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
! NOTICE:  merging multiple inherited definitions of column "a"
! ERROR:  inherited column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! ERROR:  column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
! NOTICE:  drop cascades to table inhe
! /* LIKE with other relation kinds */
! CREATE TABLE ctlt4 (a int, b text);
! CREATE SEQUENCE ctlseq1;
! CREATE TABLE ctlt10 (LIKE ctlseq1);  -- fail
! ERROR:  "ctlseq1" is not a table, view, materialized view, composite type, or foreign table
! LINE 1: CREATE TABLE ctlt10 (LIKE ctlseq1);
!                                   ^
! CREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
! CREATE TABLE ctlt11 (LIKE ctlv1);
! CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
! CREATE TYPE ctlty1 AS (a int, b text);
! CREATE TABLE ctlt12 (LIKE ctlty1);
! DROP SEQUENCE ctlseq1;
! DROP TYPE ctlty1;
! DROP VIEW ctlv1;
! DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
! NOTICE:  table "ctlt10" does not exist, skipping
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/typed_table.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/typed_table.out	2015-01-26 12:33:23.295031275 +0300
***************
*** 1,108 ****
! CREATE TABLE ttable1 OF nothing;
! ERROR:  type "nothing" does not exist
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! CREATE TABLE IF NOT EXISTS persons OF person_type;
! NOTICE:  relation "persons" already exists, skipping
! SELECT * FROM persons;
!  id | name 
! ----+------
! (0 rows)
! 
! \d persons
!     Table "public.persons"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  id     | integer | 
!  name   | text    | 
! Typed table of type: person_type
! 
! CREATE FUNCTION get_all_persons() RETURNS SETOF person_type
! LANGUAGE SQL
! AS $$
!     SELECT * FROM persons;
! $$;
! SELECT * FROM get_all_persons();
!  id | name 
! ----+------
! (0 rows)
! 
! -- certain ALTER TABLE operations on typed tables are not allowed
! ALTER TABLE persons ADD COLUMN comment text;
! ERROR:  cannot add column to typed table
! ALTER TABLE persons DROP COLUMN name;
! ERROR:  cannot drop column from typed table
! ALTER TABLE persons RENAME COLUMN id TO num;
! ERROR:  cannot rename column of typed table
! ALTER TABLE persons ALTER COLUMN name TYPE varchar;
! ERROR:  cannot alter column type of typed table
! CREATE TABLE stuff (id int);
! ALTER TABLE persons INHERIT stuff;
! ERROR:  cannot change inheritance of typed table
! CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL); -- error
! ERROR:  column "myname" does not exist
! CREATE TABLE persons2 OF person_type (
!     id WITH OPTIONS PRIMARY KEY,
!     UNIQUE (name)
! );
! \d persons2
!    Table "public.persons2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  id     | integer | not null
!  name   | text    | 
! Indexes:
!     "persons2_pkey" PRIMARY KEY, btree (id)
!     "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
! Typed table of type: person_type
! 
! CREATE TABLE persons3 OF person_type (
!     PRIMARY KEY (id),
!     name WITH OPTIONS DEFAULT ''
! );
! \d persons3
!        Table "public.persons3"
!  Column |  Type   |    Modifiers     
! --------+---------+------------------
!  id     | integer | not null
!  name   | text    | default ''::text
! Indexes:
!     "persons3_pkey" PRIMARY KEY, btree (id)
! Typed table of type: person_type
! 
! CREATE TABLE persons4 OF person_type (
!     name WITH OPTIONS NOT NULL,
!     name WITH OPTIONS DEFAULT ''  -- error, specified more than once
! );
! ERROR:  column "name" specified more than once
! DROP TYPE person_type RESTRICT;
! ERROR:  cannot drop type person_type because other objects depend on it
! DETAIL:  table persons depends on type person_type
! function get_all_persons() depends on type person_type
! table persons2 depends on type person_type
! table persons3 depends on type person_type
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TYPE person_type CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table persons
! drop cascades to function get_all_persons()
! drop cascades to table persons2
! drop cascades to table persons3
! CREATE TABLE persons5 OF stuff; -- only CREATE TYPE AS types may be used
! ERROR:  type stuff is not a composite type
! DROP TABLE stuff;
! -- implicit casting
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! INSERT INTO persons VALUES (1, 'test');
! CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
! SELECT id, namelen(persons) FROM persons;
!  id | namelen 
! ----+---------
!   1 |       4
! (1 row)
! 
! DROP TYPE person_type CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table persons
! drop cascades to function namelen(person_type)
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/vacuum.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/vacuum.out	2015-01-26 12:33:23.291031275 +0300
***************
*** 1,71 ****
! --
! -- VACUUM
! --
! CREATE TABLE vactst (i INT);
! INSERT INTO vactst VALUES (1);
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! SELECT * FROM vactst;
!  i 
! ---
!  0
! (1 row)
! 
! VACUUM FULL vactst;
! UPDATE vactst SET i = i + 1;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! VACUUM (FULL) vactst;
! DELETE FROM vactst;
! SELECT * FROM vactst;
!  i 
! ---
! (0 rows)
! 
! VACUUM (FULL, FREEZE) vactst;
! VACUUM (ANALYZE, FULL) vactst;
! CREATE TABLE vaccluster (i INT PRIMARY KEY);
! ALTER TABLE vaccluster CLUSTER ON vaccluster_pkey;
! INSERT INTO vaccluster SELECT * FROM vactst;
! CLUSTER vaccluster;
! VACUUM FULL pg_am;
! VACUUM FULL pg_class;
! VACUUM FULL pg_database;
! VACUUM FULL vaccluster;
! VACUUM FULL vactst;
! DROP TABLE vaccluster;
! DROP TABLE vactst;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/drop_if_exists.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/drop_if_exists.out	2015-01-26 12:33:23.299031276 +0300
***************
*** 1,298 ****
! --
! -- IF EXISTS tests
! --
! -- table (will be really dropped at the end)
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! DROP TABLE IF EXISTS test_exists;
! NOTICE:  table "test_exists" does not exist, skipping
! CREATE TABLE test_exists (a int, b text);
! -- view
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! DROP VIEW IF EXISTS test_view_exists;
! NOTICE:  view "test_view_exists" does not exist, skipping
! CREATE VIEW test_view_exists AS select * from test_exists;
! DROP VIEW IF EXISTS test_view_exists;
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! -- index
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! DROP INDEX IF EXISTS test_index_exists;
! NOTICE:  index "test_index_exists" does not exist, skipping
! CREATE INDEX test_index_exists on test_exists(a);
! DROP INDEX IF EXISTS test_index_exists;
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! -- sequence
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! NOTICE:  sequence "test_sequence_exists" does not exist, skipping
! CREATE SEQUENCE test_sequence_exists;
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! -- schema
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! DROP SCHEMA IF EXISTS test_schema_exists;
! NOTICE:  schema "test_schema_exists" does not exist, skipping
! CREATE SCHEMA test_schema_exists;
! DROP SCHEMA IF EXISTS test_schema_exists;
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! -- type
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! DROP TYPE IF EXISTS test_type_exists;
! NOTICE:  type "test_type_exists" does not exist, skipping
! CREATE type test_type_exists as (a int, b text);
! DROP TYPE IF EXISTS test_type_exists;
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! -- domain
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! DROP DOMAIN IF EXISTS test_domain_exists;
! NOTICE:  type "test_domain_exists" does not exist, skipping
! CREATE domain test_domain_exists as int not null check (value > 0);
! DROP DOMAIN IF EXISTS test_domain_exists;
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! ---
! --- role/user/group
! ---
! CREATE USER tu1;
! CREATE ROLE tr1;
! CREATE GROUP tg1;
! DROP USER tu2;
! ERROR:  role "tu2" does not exist
! DROP USER IF EXISTS tu1, tu2;
! NOTICE:  role "tu2" does not exist, skipping
! DROP USER tu1;
! ERROR:  role "tu1" does not exist
! DROP ROLE tr2;
! ERROR:  role "tr2" does not exist
! DROP ROLE IF EXISTS tr1, tr2;
! NOTICE:  role "tr2" does not exist, skipping
! DROP ROLE tr1;
! ERROR:  role "tr1" does not exist
! DROP GROUP tg2;
! ERROR:  role "tg2" does not exist
! DROP GROUP IF EXISTS tg1, tg2;
! NOTICE:  role "tg2" does not exist, skipping
! DROP GROUP tg1;
! ERROR:  role "tg1" does not exist
! -- collation
! DROP COLLATION IF EXISTS test_collation_exists;
! NOTICE:  collation "test_collation_exists" does not exist, skipping
! -- conversion
! DROP CONVERSION test_conversion_exists;
! ERROR:  conversion "test_conversion_exists" does not exist
! DROP CONVERSION IF EXISTS test_conversion_exists;
! NOTICE:  conversion "test_conversion_exists" does not exist, skipping
! CREATE CONVERSION test_conversion_exists
!     FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! DROP CONVERSION test_conversion_exists;
! -- text search parser
! DROP TEXT SEARCH PARSER test_tsparser_exists;
! ERROR:  text search parser "test_tsparser_exists" does not exist
! DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
! NOTICE:  text search parser "test_tsparser_exists" does not exist, skipping
! -- text search dictionary
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! ERROR:  text search dictionary "test_tsdict_exists" does not exist
! DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
! NOTICE:  text search dictionary "test_tsdict_exists" does not exist, skipping
! CREATE TEXT SEARCH DICTIONARY test_tsdict_exists (
!         Template=ispell,
!         DictFile=ispell_sample,
!         AffFile=ispell_sample
! );
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! -- test search template
! DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
! ERROR:  text search template "test_tstemplate_exists" does not exist
! DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
! NOTICE:  text search template "test_tstemplate_exists" does not exist, skipping
! -- text search configuration
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! ERROR:  text search configuration "test_tsconfig_exists" does not exist
! DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
! NOTICE:  text search configuration "test_tsconfig_exists" does not exist, skipping
! CREATE TEXT SEARCH CONFIGURATION test_tsconfig_exists (COPY=english);
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! -- extension
! DROP EXTENSION test_extension_exists;
! ERROR:  extension "test_extension_exists" does not exist
! DROP EXTENSION IF EXISTS test_extension_exists;
! NOTICE:  extension "test_extension_exists" does not exist, skipping
! -- functions
! DROP FUNCTION test_function_exists();
! ERROR:  function test_function_exists() does not exist
! DROP FUNCTION IF EXISTS test_function_exists();
! NOTICE:  function test_function_exists() does not exist, skipping
! DROP FUNCTION test_function_exists(int, text, int[]);
! ERROR:  function test_function_exists(integer, text, integer[]) does not exist
! DROP FUNCTION IF EXISTS test_function_exists(int, text, int[]);
! NOTICE:  function test_function_exists(pg_catalog.int4,text,pg_catalog.int4[]) does not exist, skipping
! -- aggregate
! DROP AGGREGATE test_aggregate_exists(*);
! ERROR:  aggregate test_aggregate_exists(*) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
! NOTICE:  aggregate test_aggregate_exists() does not exist, skipping
! DROP AGGREGATE test_aggregate_exists(int);
! ERROR:  aggregate test_aggregate_exists(integer) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
! NOTICE:  aggregate test_aggregate_exists(pg_catalog.int4) does not exist, skipping
! -- operator
! DROP OPERATOR @#@ (int, int);
! ERROR:  operator does not exist: integer @#@ integer
! DROP OPERATOR IF EXISTS @#@ (int, int);
! NOTICE:  operator @#@ does not exist, skipping
! CREATE OPERATOR @#@
!         (leftarg = int8, rightarg = int8, procedure = int8xor);
! DROP OPERATOR @#@ (int8, int8);
! -- language
! DROP LANGUAGE test_language_exists;
! ERROR:  language "test_language_exists" does not exist
! DROP LANGUAGE IF EXISTS test_language_exists;
! NOTICE:  language "test_language_exists" does not exist, skipping
! -- cast
! DROP CAST (text AS text);
! ERROR:  cast from type text to type text does not exist
! DROP CAST IF EXISTS (text AS text);
! NOTICE:  cast from type text to type text does not exist, skipping
! -- trigger
! DROP TRIGGER test_trigger_exists ON test_exists;
! ERROR:  trigger "test_trigger_exists" for table "test_exists" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
! NOTICE:  trigger "test_trigger_exists" for relation "test_exists" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE TRIGGER test_trigger_exists
!     BEFORE UPDATE ON test_exists
!     FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! DROP TRIGGER test_trigger_exists ON test_exists;
! -- rule
! DROP RULE test_rule_exists ON test_exists;
! ERROR:  rule "test_rule_exists" for relation "test_exists" does not exist
! DROP RULE IF EXISTS test_rule_exists ON test_exists;
! NOTICE:  rule "test_rule_exists" for relation "test_exists" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE RULE test_rule_exists AS ON INSERT TO test_exists
!     DO INSTEAD
!     INSERT INTO test_exists VALUES (NEW.a, NEW.b || NEW.a::text);
! DROP RULE test_rule_exists ON test_exists;
! -- foreign data wrapper
! DROP FOREIGN DATA WRAPPER test_fdw_exists;
! ERROR:  foreign-data wrapper "test_fdw_exists" does not exist
! DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
! NOTICE:  foreign-data wrapper "test_fdw_exists" does not exist, skipping
! -- foreign server
! DROP SERVER test_server_exists;
! ERROR:  server "test_server_exists" does not exist
! DROP SERVER IF EXISTS test_server_exists;
! NOTICE:  server "test_server_exists" does not exist, skipping
! -- operator class
! DROP OPERATOR CLASS test_operator_class USING btree;
! ERROR:  operator class "test_operator_class" does not exist for access method "btree"
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
! NOTICE:  operator class "test_operator_class" does not exist for access method "btree", skipping
! DROP OPERATOR CLASS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- operator family
! DROP OPERATOR FAMILY test_operator_family USING btree;
! ERROR:  operator family "test_operator_family" does not exist for access method "btree"
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
! NOTICE:  operator family "test_operator_family" does not exist for access method "btree", skipping
! DROP OPERATOR FAMILY test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- drop the table
! DROP TABLE IF EXISTS test_exists;
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! -- be tolerant with missing schemas, types, etc
! DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_type2);
! NOTICE:  type "no_such_type2" does not exist, skipping
! DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
! NOTICE:  type "no_such_type1" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP COLLATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CONVERSION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP DOMAIN IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS no_such_schema.foo();
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP INDEX IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP RULE IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP SEQUENCE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TYPE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/updatable_views.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/updatable_views.out	2015-01-26 12:33:23.295031275 +0300
***************
*** 1,2266 ****
! --
! -- UPDATABLE VIEWS
! --
! -- check that non-updatable views and columns are rejected with useful error
! -- messages
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl; -- DISTINCT not supported
! CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b; -- GROUP BY not supported
! CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0; -- HAVING not supported
! CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl; -- Aggregate functions not supported
! CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl; -- Window functions not supported
! CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl; -- Set ops not supported
! CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t; -- WITH not supported
! CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1; -- OFFSET not supported
! CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1; -- LIMIT not supported
! CREATE VIEW ro_view10 AS SELECT 1 AS a; -- No base relations
! CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2; -- Multiple base relations
! CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a); -- SRF in rangetable
! CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t; -- Subselect in rangetable
! CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl; -- System columns may be part of an updatable view
! CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl; -- Expression/function may be part of an updatable view
! CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl; -- Repeated column may be part of an updatable view
! CREATE VIEW ro_view17 AS SELECT * FROM ro_view1; -- Base relation not updatable
! CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a); -- VALUES in rangetable
! CREATE SEQUENCE seq;
! CREATE VIEW ro_view19 AS SELECT * FROM seq; -- View based on a sequence
! CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl; -- SRF in targetlist not supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  ro_view1   | NO
!  ro_view10  | NO
!  ro_view11  | NO
!  ro_view12  | NO
!  ro_view13  | NO
!  ro_view17  | NO
!  ro_view18  | NO
!  ro_view19  | NO
!  ro_view2   | NO
!  ro_view20  | NO
!  ro_view3   | NO
!  ro_view4   | NO
!  ro_view5   | NO
!  ro_view6   | NO
!  ro_view7   | NO
!  ro_view8   | NO
!  ro_view9   | NO
!  rw_view14  | YES
!  rw_view15  | YES
!  rw_view16  | YES
! (20 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  ro_view1   | NO           | NO
!  ro_view10  | NO           | NO
!  ro_view11  | NO           | NO
!  ro_view12  | NO           | NO
!  ro_view13  | NO           | NO
!  ro_view17  | NO           | NO
!  ro_view18  | NO           | NO
!  ro_view19  | NO           | NO
!  ro_view2   | NO           | NO
!  ro_view20  | NO           | NO
!  ro_view3   | NO           | NO
!  ro_view4   | NO           | NO
!  ro_view5   | NO           | NO
!  ro_view6   | NO           | NO
!  ro_view7   | NO           | NO
!  ro_view8   | NO           | NO
!  ro_view9   | NO           | NO
!  rw_view14  | YES          | YES
!  rw_view15  | YES          | YES
!  rw_view16  | YES          | YES
! (20 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name |  column_name  | is_updatable 
! ------------+---------------+--------------
!  ro_view1   | a             | NO
!  ro_view1   | b             | NO
!  ro_view10  | a             | NO
!  ro_view11  | a             | NO
!  ro_view11  | b             | NO
!  ro_view12  | a             | NO
!  ro_view13  | a             | NO
!  ro_view13  | b             | NO
!  ro_view17  | a             | NO
!  ro_view17  | b             | NO
!  ro_view18  | a             | NO
!  ro_view19  | sequence_name | NO
!  ro_view19  | last_value    | NO
!  ro_view19  | start_value   | NO
!  ro_view19  | increment_by  | NO
!  ro_view19  | max_value     | NO
!  ro_view19  | min_value     | NO
!  ro_view19  | cache_value   | NO
!  ro_view19  | log_cnt       | NO
!  ro_view19  | is_cycled     | NO
!  ro_view19  | is_called     | NO
!  ro_view2   | a             | NO
!  ro_view2   | b             | NO
!  ro_view20  | a             | NO
!  ro_view20  | b             | NO
!  ro_view20  | g             | NO
!  ro_view3   | ?column?      | NO
!  ro_view4   | count         | NO
!  ro_view5   | a             | NO
!  ro_view5   | rank          | NO
!  ro_view6   | a             | NO
!  ro_view6   | b             | NO
!  ro_view7   | a             | NO
!  ro_view7   | b             | NO
!  ro_view8   | a             | NO
!  ro_view8   | b             | NO
!  ro_view9   | a             | NO
!  ro_view9   | b             | NO
!  rw_view14  | ctid          | NO
!  rw_view14  | a             | YES
!  rw_view14  | b             | YES
!  rw_view15  | a             | YES
!  rw_view15  | upper         | NO
!  rw_view16  | a             | YES
!  rw_view16  | b             | YES
!  rw_view16  | aa            | YES
! (46 rows)
! 
! -- Read-only views
! DELETE FROM ro_view1;
! ERROR:  cannot delete from view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view2;
! ERROR:  cannot delete from view "ro_view2"
! DETAIL:  Views containing GROUP BY are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view3;
! ERROR:  cannot delete from view "ro_view3"
! DETAIL:  Views containing HAVING are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view4;
! ERROR:  cannot delete from view "ro_view4"
! DETAIL:  Views that return aggregate functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view5;
! ERROR:  cannot delete from view "ro_view5"
! DETAIL:  Views that return window functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view6;
! ERROR:  cannot delete from view "ro_view6"
! DETAIL:  Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view7 SET a=a+1;
! ERROR:  cannot update view "ro_view7"
! DETAIL:  Views containing WITH are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view8 SET a=a+1;
! ERROR:  cannot update view "ro_view8"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view9 SET a=a+1;
! ERROR:  cannot update view "ro_view9"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view10 SET a=a+1;
! ERROR:  cannot update view "ro_view10"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view11 SET a=a+1;
! ERROR:  cannot update view "ro_view11"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view12 SET a=a+1;
! ERROR:  cannot update view "ro_view12"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! INSERT INTO ro_view13 VALUES (3, 'Row 3');
! ERROR:  cannot insert into view "ro_view13"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! -- Partially updatable view
! INSERT INTO rw_view14 VALUES (null, 3, 'Row 3'); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view14 SET ctid=null WHERE a=3; -- should fail
! ERROR:  cannot update column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! UPDATE rw_view14 SET b='ROW 3' WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   3 | ROW 3
! (6 rows)
! 
! DELETE FROM rw_view14 WHERE a=3; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view15 VALUES (3, 'ROW 3'); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view15 (a) VALUES (3); -- should be OK
! ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
! INSERT INTO rw_view15 (a) VALUES (4); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper='ROW 3' WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper=DEFAULT WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET a=4 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   4 | Unspecified
! (6 rows)
! 
! DELETE FROM rw_view15 WHERE a=4; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view16 VALUES (3, 'Row 3', 3); -- should fail
! ERROR:  multiple assignments to same column "a"
! INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3; -- should fail
! ERROR:  multiple assignments to same column "a"
! UPDATE rw_view16 SET aa=-3 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!  -3 | Row 3
! (6 rows)
! 
! DELETE FROM rw_view16 WHERE a=-3; -- should be OK
! -- Read-only views
! INSERT INTO ro_view17 VALUES (3, 'ROW 3');
! ERROR:  cannot insert into view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! DELETE FROM ro_view18;
! ERROR:  cannot delete from view "ro_view18"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view19 SET max_value=1000;
! ERROR:  cannot update view "ro_view19"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view20 SET b=upper(b);
! ERROR:  cannot update view "ro_view20"
! DETAIL:  Views that return set-returning functions are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 16 other objects
! DETAIL:  drop cascades to view ro_view1
! drop cascades to view ro_view17
! drop cascades to view ro_view2
! drop cascades to view ro_view3
! drop cascades to view ro_view5
! drop cascades to view ro_view6
! drop cascades to view ro_view7
! drop cascades to view ro_view8
! drop cascades to view ro_view9
! drop cascades to view ro_view11
! drop cascades to view ro_view13
! drop cascades to view rw_view15
! drop cascades to view rw_view16
! drop cascades to view ro_view20
! drop cascades to view ro_view4
! drop cascades to view rw_view14
! DROP VIEW ro_view10, ro_view12, ro_view18;
! DROP SEQUENCE seq CASCADE;
! NOTICE:  drop cascades to view ro_view19
! -- simple updatable view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
! (2 rows)
! 
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! INSERT INTO rw_view1 (a) VALUES (4);
! UPDATE rw_view1 SET a=5 WHERE a=4;
! DELETE FROM rw_view1 WHERE b='Row 2';
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   3 | Row 3
!   5 | Unspecified
! (6 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a > 0) AND (a = 5))
! (3 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Delete on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a > 0) AND (a = 5))
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- view on top of view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
! CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | aaa         | YES
!  rw_view2   | bbb         | YES
! (2 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3');
! INSERT INTO rw_view2 (aaa) VALUES (4);
! SELECT * FROM rw_view2;
!  aaa |     bbb     
! -----+-------------
!    1 | Row 1
!    2 | Row 2
!    3 | Row 3
!    4 | Unspecified
! (4 rows)
! 
! UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
! DELETE FROM rw_view2 WHERE aaa=2;
! SELECT * FROM rw_view2;
!  aaa |  bbb  
! -----+-------
!    1 | Row 1
!    3 | Row 3
!    4 | Row 4
! (3 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (3 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Delete on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with rules
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | NO
!  rw_view2   | NO           | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1
!   DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
!  rw_view2   | a           | YES
!  rw_view2   | b           | YES
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
!  a |   b   
! ---+-------
!  3 | Row 3
! (1 row)
! 
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |     b     
! ---+-----------
!  1 | Row 1
!  2 | Row 2
!  3 | Row three
! (3 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Update on base_tbl
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (a = 2)
!          ->  Subquery Scan on rw_view1
!                Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                      Recheck Cond: (a > 0)
!                      ->  Bitmap Index Scan on base_tbl_pkey
!                            Index Cond: (a > 0)
! (10 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Delete on base_tbl
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (a = 2)
!          ->  Subquery Scan on rw_view1
!                Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                      Recheck Cond: (a > 0)
!                      ->  Bitmap Index Scan on base_tbl_pkey
!                            Index Cond: (a > 0)
! (10 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | YES                  | NO                   | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | YES                  | YES                  | YES
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
!  a |   b   
! ---+-------
!  3 | Row 3
! (1 row)
! 
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |     b     
! ---+-----------
!  1 | Row 1
!  2 | Row 2
!  3 | Row three
! (3 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Update on rw_view1 rw_view1_1
!    ->  Subquery Scan on rw_view1
!          Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!          ->  Bitmap Heap Scan on base_tbl
!                Recheck Cond: (a > 0)
!                ->  Bitmap Index Scan on base_tbl_pkey
!                      Index Cond: (a > 0)
! (7 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Delete on rw_view1 rw_view1_1
!    ->  Subquery Scan on rw_view1
!          Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!          ->  Bitmap Heap Scan on base_tbl
!                Recheck Cond: (a > 0)
!                ->  Bitmap Index Scan on base_tbl_pkey
!                      Index Cond: (a > 0)
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! -- update using whole row from view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
! CREATE FUNCTION rw_view1_aa(x rw_view1)
!   RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!  rw_view1_aa |      bb       
! -------------+---------------
!            2 | Updated row 2
! (1 row)
! 
! SELECT * FROM base_tbl;
!  a  |       b       
! ----+---------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Updated row 2
! (5 rows)
! 
! EXPLAIN (costs off)
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Update on base_tbl
!    ->  Index Scan using base_tbl_pkey on base_tbl
!          Index Cond: (a = 2)
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to function rw_view1_aa(rw_view1)
! -- permissions checks
! CREATE USER view_user1;
! CREATE USER view_user2;
! SET SESSION AUTHORIZATION view_user1;
! CREATE TABLE base_tbl(a int, b text, c float);
! INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
! CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
! GRANT SELECT ON base_tbl TO view_user2;
! GRANT SELECT ON rw_view1 TO view_user2;
! GRANT UPDATE (a,c) ON base_tbl TO view_user2;
! GRANT UPDATE (bb,cc) ON rw_view1 TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! SELECT * FROM base_tbl; -- ok
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
!  2 | Row 2 | 2
! (2 rows)
! 
! SELECT * FROM rw_view1; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! SELECT * FROM rw_view2; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE base_tbl SET a=a, c=c; -- ok
! UPDATE base_tbl SET b=b; -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
! UPDATE rw_view1 SET aa=aa; -- not allowed
! ERROR:  permission denied for relation rw_view1
! UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
! UPDATE rw_view2 SET bb=bb; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2; -- not allowed
! ERROR:  permission denied for relation base_tbl
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user1;
! GRANT INSERT, DELETE ON base_tbl TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
! INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
! DELETE FROM base_tbl WHERE a=1; -- ok
! DELETE FROM rw_view1 WHERE aa=2; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2 WHERE aa=2; -- ok
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  3 | Row 3 | 3
!  4 | Row 4 | 4
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user1;
! REVOKE INSERT, DELETE ON base_tbl FROM view_user2;
! GRANT INSERT, DELETE ON rw_view1 TO view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION view_user2;
! INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
! INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl WHERE a=3; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1 WHERE aa=3; -- ok
! DELETE FROM rw_view2 WHERE aa=4; -- not allowed
! ERROR:  permission denied for relation base_tbl
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  4 | Row 4 | 4
!  5 | Row 5 | 5
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP USER view_user1;
! DROP USER view_user2;
! -- column defaults
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! INSERT INTO base_tbl VALUES (3);
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
! INSERT INTO rw_view1 VALUES (4, 'Row 4');
! INSERT INTO rw_view1 (aa) VALUES (5);
! SELECT * FROM base_tbl;
!  a |      b       | c 
! ---+--------------+---
!  1 | Row 1        | 1
!  2 | Row 2        | 2
!  3 | Unspecified  | 3
!  4 | Row 4        | 4
!  5 | View default | 5
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- Table having triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=1;
!     RETURN NULL;
!   END IF;
!   RETURN NULL;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! select * from base_tbl;
!  a |   b   
! ---+-------
!  2 | Row 2
!  3 | Row 3
!  1 | Row 3
! (3 rows)
! 
! DROP VIEW rw_view1;
! DROP TRIGGER rw_view1_ins_trig on base_tbl;
! DROP FUNCTION rw_view1_trig_fn();
! DROP TABLE base_tbl;
! -- view with ORDER BY
! CREATE TABLE base_tbl (a int, b int);
! INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  3 | -3
!  1 |  2
!  4 |  5
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (7,-8);
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -8
!  3 | -3
!  1 |  2
!  4 |  5
! (4 rows)
! 
! EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Update on public.base_tbl
!    Output: base_tbl.a, base_tbl.b
!    ->  Seq Scan on public.base_tbl
!          Output: base_tbl.a, (base_tbl.b + 1), base_tbl.ctid
! (4 rows)
! 
! UPDATE rw_view1 SET b = b + 1 RETURNING *;
!  a | b  
! ---+----
!  1 |  3
!  4 |  6
!  3 | -2
!  7 | -7
! (4 rows)
! 
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -7
!  3 | -2
!  1 |  3
!  4 |  6
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- multiple array-column updates
! CREATE TABLE base_tbl (a int, arr int[]);
! INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
! UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
! SELECT * FROM rw_view1;
!  a |   arr   
! ---+---------
!  1 | {2}
!  3 | {42,77}
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- views with updatable and non-updatable columns
! CREATE TABLE base_tbl(a float);
! INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
! CREATE VIEW rw_view1 AS
!   SELECT ctid, sin(a) s, a, cos(a) c
!   FROM base_tbl
!   WHERE a != 0
!   ORDER BY abs(a);
! INSERT INTO rw_view1 VALUES (null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view1"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c; -- OK
!   a  |         s         |         c         
! -----+-------------------+-------------------
!  1.1 | 0.891207360061435 | 0.453596121425577
! (1 row)
! 
! UPDATE rw_view1 SET s = s WHERE a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s; -- OK
!          s         
! -------------------
!  0.867423225594017
! (1 row)
! 
! DELETE FROM rw_view1 WHERE a = 1.05; -- OK
! CREATE VIEW rw_view2 AS
!   SELECT s, c, s/c t, a base_a, ctid
!   FROM rw_view1;
! INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t; -- OK
!         t         
! ------------------
!  1.96475965724865
! (1 row)
! 
! UPDATE rw_view2 SET s = s WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET t = t WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1; -- OK
! DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t; -- OK
!  base_a |         s         |         c         |        t         
! --------+-------------------+-------------------+------------------
!    1.05 | 0.867423225594017 | 0.497571047891727 | 1.74331530998317
! (1 row)
! 
! CREATE VIEW rw_view3 AS
!   SELECT s, c, s/c t, ctid
!   FROM rw_view1;
! INSERT INTO rw_view3 VALUES (null, null, null, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view3"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view3(s) VALUES (null); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view3 SET s = s; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! DELETE FROM rw_view3 WHERE s = sin(0.1); -- should be OK
! SELECT * FROM base_tbl ORDER BY a;
!   a  
! -----
!  0.2
!  0.3
!  0.4
!  0.5
!  0.6
!  0.7
!  0.8
!  0.9
!    1
! (9 rows)
! 
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
!  rw_view3   | NO
! (3 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
!  rw_view3   | NO           | NO
! (3 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | ctid        | NO
!  rw_view1   | s           | NO
!  rw_view1   | a           | YES
!  rw_view1   | c           | NO
!  rw_view2   | s           | NO
!  rw_view2   | c           | NO
!  rw_view2   | t           | NO
!  rw_view2   | base_a      | YES
!  rw_view2   | ctid        | NO
!  rw_view3   | s           | NO
!  rw_view3   | c           | NO
!  rw_view3   | t           | NO
!  rw_view3   | ctid        | NO
! (13 rows)
! 
! SELECT events & 4 != 0 AS upd,
!        events & 8 != 0 AS ins,
!        events & 16 != 0 AS del
!   FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
!  upd | ins | del 
! -----+-----+-----
!  f   | f   | t
! (1 row)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- inheritance tests
! CREATE TABLE base_tbl_parent (a int);
! CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
! INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
! INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
! CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
! SELECT * FROM rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM ONLY rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM rw_view2 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
! (8 rows)
! 
! INSERT INTO rw_view1 VALUES (-100), (100);
! INSERT INTO rw_view2 VALUES (-200), (200);
! UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1); -- Should produce -10 and 10
! UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2); -- Should produce -20 and 20
! UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3); -- Should produce -30 only
! UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4); -- Should produce -40 only
! DELETE FROM rw_view1 WHERE a IN (-5, 5); -- Should delete -5 and 5
! DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6); -- Should delete -6 and 6
! DELETE FROM rw_view2 WHERE a IN (-7, 7); -- Should delete -7 only
! DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8); -- Should delete -8 only
! SELECT * FROM ONLY base_tbl_parent ORDER BY a;
!   a   
! ------
!  -200
!  -100
!   -40
!   -30
!   -20
!   -10
!   100
!   200
! (8 rows)
! 
! SELECT * FROM base_tbl_child ORDER BY a;
!  a  
! ----
!   3
!   4
!   7
!   8
!  10
!  20
! (6 rows)
! 
! DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- simple WITH CHECK OPTION
! CREATE TABLE base_tbl (a int, b int DEFAULT 10);
! INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view1
!                 View "public.rw_view1"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
!  b      | integer |           | plain   | 
! View definition:
!  SELECT base_tbl.a,
!     base_tbl.b
!    FROM base_tbl
!   WHERE base_tbl.a < base_tbl.b;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
!  table_catalog | table_schema | table_name |          view_definition           | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+------------------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a,               +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |     base_tbl.b                    +|              |              |                    |                      |                      | 
!                |              |            |    FROM base_tbl                  +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (base_tbl.a < base_tbl.b); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view1 VALUES(3,4); -- ok
! INSERT INTO rw_view1 VALUES(4,3); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (4, 3).
! INSERT INTO rw_view1 VALUES(5,null); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (5, null).
! UPDATE rw_view1 SET b = 5 WHERE a = 3; -- ok
! UPDATE rw_view1 SET b = -5 WHERE a = 3; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (3, -5).
! INSERT INTO rw_view1(a) VALUES (9); -- ok
! INSERT INTO rw_view1(a) VALUES (10); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, 10).
! SELECT * FROM base_tbl;
!  a | b  
! ---+----
!  1 |  2
!  2 |  3
!  1 | -1
!  3 |  5
!  9 | 10
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH LOCAL/CASCADED CHECK OPTION
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH CHECK OPTION; -- implicitly cascaded
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=cascaded
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-5).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (15); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (15).
! SELECT * FROM base_tbl;
!  a 
! ---
!  5
! (1 row)
! 
! UPDATE rw_view2 SET a = a - 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-5).
! UPDATE rw_view2 SET a = a + 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (15).
! CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (20).
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
! (2 rows)
! 
! ALTER VIEW rw_view1 SET (check_option=here); -- invalid
! ERROR:  invalid value for "check_option" option
! DETAIL:  Valid values are "local" and "cascaded".
! ALTER VIEW rw_view1 SET (check_option=local);
! INSERT INTO rw_view2 VALUES (-20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (-20).
! INSERT INTO rw_view2 VALUES (30); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (30).
! ALTER VIEW rw_view2 RESET (check_option);
! \d+ rw_view2
!                 View "public.rw_view2"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (30); -- ok, but not in view
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
!   30
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- WITH CHECK OPTION with no local view qual
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
! CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
! SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
!  table_catalog | table_schema | table_name |      view_definition      | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+---------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM base_tbl;         |              |              |                    |                      |                      | 
!  regression    | public       | rw_view2   |  SELECT rw_view1.a       +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1         +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a > 0); |              |              |                    |                      |                      | 
!  regression    | public       | rw_view3   |  SELECT rw_view2.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view2;         |              |              |                    |                      |                      | 
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (-1); -- ok
! INSERT INTO rw_view1 VALUES (1); -- ok
! INSERT INTO rw_view2 VALUES (-2); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (2); -- ok
! INSERT INTO rw_view3 VALUES (-3); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-3).
! INSERT INTO rw_view3 VALUES (3); -- ok
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- WITH CHECK OPTION with scalar array ops
! CREATE TABLE base_tbl (a int, b int[]);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
!   WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]); -- ok
! INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1; -- ok
! UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (1, {-1,-2,3}).
! PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
! EXECUTE ins(2, ARRAY[1,2,3]); -- ok
! EXECUTE ins(10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! DEALLOCATE PREPARE ins;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with subquery
! CREATE TABLE base_tbl (a int);
! CREATE TABLE ref_tbl (a int PRIMARY KEY);
! INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
! CREATE VIEW rw_view1 AS
!   SELECT * FROM base_tbl b
!   WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
!   WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (5); -- ok
! INSERT INTO rw_view1 VALUES (15); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15).
! UPDATE rw_view1 SET a = a + 5; -- ok
! UPDATE rw_view1 SET a = a + 5; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15).
! EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Insert on base_tbl b
!    ->  Result
!          SubPlan 1
!            ->  Index Only Scan using ref_tbl_pkey on ref_tbl r
!                  Index Cond: (a = b.a)
!          SubPlan 2
!            ->  Seq Scan on ref_tbl r_1
! (7 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Update on base_tbl b
!    ->  Hash Semi Join
!          Hash Cond: (b.a = r.a)
!          ->  Seq Scan on base_tbl b
!          ->  Hash
!                ->  Seq Scan on ref_tbl r
!          SubPlan 1
!            ->  Index Only Scan using ref_tbl_pkey on ref_tbl r_1
!                  Index Cond: (a = b.a)
!          SubPlan 2
!            ->  Seq Scan on ref_tbl r_2
! (11 rows)
! 
! DROP TABLE base_tbl, ref_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with BEFORE trigger on base table
! CREATE TABLE base_tbl (a int, b int);
! CREATE FUNCTION base_tbl_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   NEW.b := 10;
!   RETURN NEW;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (5,0); -- ok
! INSERT INTO rw_view1 VALUES (15, 20); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (15, 10).
! UPDATE rw_view1 SET a = 20, b = 30; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view1"
! DETAIL:  Failing row contains (20, 10).
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! DROP FUNCTION base_tbl_trig_fn();
! -- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view
! CREATE TABLE base_tbl (a int, b int);
! CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, 10);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_trig
!   INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-5).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (50); -- ok, but not in view
! UPDATE rw_view2 SET a = a - 10; -- should fail
! ERROR:  new row violates WITH CHECK OPTION for "rw_view2"
! DETAIL:  Failing row contains (-5).
! SELECT * FROM base_tbl;
!  a  | b  
! ----+----
!   5 | 10
!  50 | 10
! (2 rows)
! 
! -- Check option won't cascade down to base view with INSTEAD OF triggers
! ALTER VIEW rw_view2 SET (check_option=cascaded);
! INSERT INTO rw_view2 VALUES (100); -- ok, but not in view (doesn't fail rw_view1's check)
! UPDATE rw_view2 SET a = 200 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! SELECT * FROM base_tbl;
!   a  | b  
! -----+----
!   50 | 10
!  100 | 10
!  200 | 10
! (3 rows)
! 
! -- Neither local nor cascaded check options work with INSTEAD rules
! DROP TRIGGER rw_view1_trig ON rw_view1;
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view (doesn't fail rw_view2's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (20); -- ok, but not in view (doesn't fail rw_view1's check)
! UPDATE rw_view2 SET a = 30 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! UPDATE rw_view2 SET a = -5 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view2's check)
! SELECT * FROM base_tbl;
!   a  | b  
! -----+----
!   50 | 10
!  100 | 10
!  200 | 10
!  -10 | 10
!   20 | 10
!   30 | 10
!   -5 | 10
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! CREATE TABLE base_tbl (a int);
! CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (2,3); -- ok, but not in view (doesn't fail rw_view2's check)
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view
! CREATE TABLE base_tbl (person text, visibility text);
! INSERT INTO base_tbl VALUES ('Tom', 'public'),
!                             ('Dick', 'private'),
!                             ('Harry', 'public');
! CREATE VIEW rw_view1 AS
!   SELECT person FROM base_tbl WHERE visibility = 'public';
! CREATE FUNCTION snoop(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RAISE NOTICE 'snooped value: %', $1;
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql COST 0.000001;
! CREATE OR REPLACE FUNCTION leakproof(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
! SELECT * FROM rw_view1 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! NOTICE:  snooped value: Dick
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! ALTER VIEW rw_view1 SET (security_barrier = true);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view1 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
!                   QUERY PLAN                   
! -----------------------------------------------
!  Subquery Scan on rw_view1
!    Filter: snoop(rw_view1.person)
!    ->  Seq Scan on base_tbl
!          Filter: (visibility = 'public'::text)
! (4 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: snoop(base_tbl.person)
!          ->  Seq Scan on base_tbl base_tbl_2
!                Filter: (visibility = 'public'::text)
! (5 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Delete on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: (NOT snoop(base_tbl.person))
!          ->  Seq Scan on base_tbl base_tbl_2
!                Filter: (visibility = 'public'::text)
! (5 rows)
! 
! -- security barrier view on top of security barrier view
! CREATE VIEW rw_view2 WITH (security_barrier = true) AS
!   SELECT * FROM rw_view1 WHERE snoop(person);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view2 WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view2 SET person=person WHERE snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
! DELETE FROM rw_view2 WHERE NOT snoop(person);
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Tom
! NOTICE:  snooped value: Harry
! NOTICE:  snooped value: Harry
! EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Subquery Scan on rw_view2
!    Filter: snoop(rw_view2.person)
!    ->  Subquery Scan on rw_view1
!          Filter: snoop(rw_view1.person)
!          ->  Seq Scan on base_tbl
!                Filter: (visibility = 'public'::text)
! (6 rows)
! 
! EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: snoop(base_tbl.person)
!          ->  Subquery Scan on base_tbl_2
!                Filter: snoop(base_tbl_2.person)
!                ->  Seq Scan on base_tbl base_tbl_3
!                      Filter: (visibility = 'public'::text)
! (7 rows)
! 
! EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Delete on base_tbl base_tbl_1
!    ->  Subquery Scan on base_tbl
!          Filter: (NOT snoop(base_tbl.person))
!          ->  Subquery Scan on base_tbl_2
!                Filter: snoop(base_tbl_2.person)
!                ->  Seq Scan on base_tbl base_tbl_3
!                      Filter: (visibility = 'public'::text)
! (7 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view on top of table with rules
! CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
! INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
! CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
!   WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
!   DO INSTEAD
!     UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
! CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
!   DO INSTEAD
!     UPDATE base_tbl SET deleted = true WHERE id = old.id;
! CREATE VIEW rw_view1 WITH (security_barrier=true) AS
!   SELECT id, data FROM base_tbl WHERE NOT deleted;
! SELECT * FROM rw_view1;
!  id | data  
! ----+-------
!   1 | Row 1
! (1 row)
! 
! EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Update on base_tbl base_tbl_1
!    ->  Nested Loop
!          ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_1
!                Index Cond: (id = 1)
!          ->  Subquery Scan on base_tbl
!                Filter: snoop(base_tbl.data)
!                ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_2
!                      Index Cond: (id = 1)
!                      Filter: (NOT deleted)
! (9 rows)
! 
! DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
! NOTICE:  snooped value: Row 1
! EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Insert on base_tbl
!    InitPlan 1 (returns $0)
!      ->  Index Only Scan using base_tbl_pkey on base_tbl t
!            Index Cond: (id = 2)
!    ->  Result
!          One-Time Filter: ($0 IS NOT TRUE)
!  
!  Update on base_tbl
!    InitPlan 1 (returns $0)
!      ->  Index Only Scan using base_tbl_pkey on base_tbl t
!            Index Cond: (id = 2)
!    ->  Result
!          One-Time Filter: $0
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (id = 2)
! (15 rows)
! 
! INSERT INTO rw_view1 VALUES (2, 'New row 2');
! SELECT * FROM base_tbl;
!  id |   data    | deleted 
! ----+-----------+---------
!   1 | Row 1     | t
!   2 | New row 2 | f
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- security barrier view based on inheiritance set
! CREATE TABLE t1 (a int, b float, c text);
! CREATE INDEX t1_a_idx ON t1(a);
! INSERT INTO t1
! SELECT i,i,'t1' FROM generate_series(1,10) g(i);
! ANALYZE t1;
! CREATE TABLE t11 (d text) INHERITS (t1);
! CREATE INDEX t11_a_idx ON t11(a);
! INSERT INTO t11
! SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
! ANALYZE t11;
! CREATE TABLE t12 (e int[]) INHERITS (t1);
! CREATE INDEX t12_a_idx ON t12(a);
! INSERT INTO t12
! SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t12;
! CREATE TABLE t111 () INHERITS (t11, t12);
! NOTICE:  merging multiple inherited definitions of column "a"
! NOTICE:  merging multiple inherited definitions of column "b"
! NOTICE:  merging multiple inherited definitions of column "c"
! CREATE INDEX t111_a_idx ON t111(a);
! INSERT INTO t111
! SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t111;
! CREATE VIEW v1 WITH (security_barrier=true) AS
! SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
! FROM t1
! WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
! SELECT * FROM v1 WHERE a=3; -- should not see anything
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM v1 WHERE a=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  8 | 8 | t1   | t11d
!  8 | 8 | t11  | t11d
!  8 | 8 | t12  | t11d
!  8 | 8 | t111 | t11d
! (4 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
!                                         QUERY PLAN                                         
! -------------------------------------------------------------------------------------------
!  Update on public.t1 t1_4
!    ->  Subquery Scan on t1
!          Output: 100, t1.b, t1.c, t1.ctid
!          Filter: snoop(t1.a)
!          ->  Nested Loop Semi Join
!                Output: t1_5.ctid, t1_5.a, t1_5.b, t1_5.c
!                ->  Seq Scan on public.t1 t1_5
!                      Output: t1_5.ctid, t1_5.a, t1_5.b, t1_5.c
!                      Filter: ((t1_5.a > 5) AND (t1_5.a = 3) AND leakproof(t1_5.a))
!                ->  Append
!                      ->  Seq Scan on public.t12
!                            Output: t12.a
!                            Filter: (t12.a = 3)
!                      ->  Seq Scan on public.t111
!                            Output: t111.a
!                            Filter: (t111.a = 3)
!    ->  Subquery Scan on t1_1
!          Output: 100, t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
!          Filter: snoop(t1_1.a)
!          ->  Nested Loop Semi Join
!                Output: t11.ctid, t11.a, t11.b, t11.c, t11.d
!                ->  Seq Scan on public.t11
!                      Output: t11.ctid, t11.a, t11.b, t11.c, t11.d
!                      Filter: ((t11.a > 5) AND (t11.a = 3) AND leakproof(t11.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_1
!                            Output: t12_1.a
!                            Filter: (t12_1.a = 3)
!                      ->  Seq Scan on public.t111 t111_1
!                            Output: t111_1.a
!                            Filter: (t111_1.a = 3)
!    ->  Subquery Scan on t1_2
!          Output: 100, t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
!          Filter: snoop(t1_2.a)
!          ->  Nested Loop Semi Join
!                Output: t12_2.ctid, t12_2.a, t12_2.b, t12_2.c, t12_2.e
!                ->  Seq Scan on public.t12 t12_2
!                      Output: t12_2.ctid, t12_2.a, t12_2.b, t12_2.c, t12_2.e
!                      Filter: ((t12_2.a > 5) AND (t12_2.a = 3) AND leakproof(t12_2.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_3
!                            Output: t12_3.a
!                            Filter: (t12_3.a = 3)
!                      ->  Seq Scan on public.t111 t111_2
!                            Output: t111_2.a
!                            Filter: (t111_2.a = 3)
!    ->  Subquery Scan on t1_3
!          Output: 100, t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
!          Filter: snoop(t1_3.a)
!          ->  Nested Loop Semi Join
!                Output: t111_3.ctid, t111_3.a, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                ->  Seq Scan on public.t111 t111_3
!                      Output: t111_3.ctid, t111_3.a, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                      Filter: ((t111_3.a > 5) AND (t111_3.a = 3) AND leakproof(t111_3.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_4
!                            Output: t12_4.a
!                            Filter: (t12_4.a = 3)
!                      ->  Seq Scan on public.t111 t111_4
!                            Output: t111_4.a
!                            Filter: (t111_4.a = 3)
! (61 rows)
! 
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
! SELECT * FROM v1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM t1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c 
! ---+---+---
! (0 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
!                                         QUERY PLAN                                         
! -------------------------------------------------------------------------------------------
!  Update on public.t1 t1_4
!    ->  Subquery Scan on t1
!          Output: (t1.a + 1), t1.b, t1.c, t1.ctid
!          Filter: snoop(t1.a)
!          ->  Nested Loop Semi Join
!                Output: t1_5.a, t1_5.ctid, t1_5.b, t1_5.c
!                ->  Seq Scan on public.t1 t1_5
!                      Output: t1_5.a, t1_5.ctid, t1_5.b, t1_5.c
!                      Filter: ((t1_5.a > 5) AND (t1_5.a = 8) AND leakproof(t1_5.a))
!                ->  Append
!                      ->  Seq Scan on public.t12
!                            Output: t12.a
!                            Filter: (t12.a = 8)
!                      ->  Seq Scan on public.t111
!                            Output: t111.a
!                            Filter: (t111.a = 8)
!    ->  Subquery Scan on t1_1
!          Output: (t1_1.a + 1), t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
!          Filter: snoop(t1_1.a)
!          ->  Nested Loop Semi Join
!                Output: t11.a, t11.ctid, t11.b, t11.c, t11.d
!                ->  Seq Scan on public.t11
!                      Output: t11.a, t11.ctid, t11.b, t11.c, t11.d
!                      Filter: ((t11.a > 5) AND (t11.a = 8) AND leakproof(t11.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_1
!                            Output: t12_1.a
!                            Filter: (t12_1.a = 8)
!                      ->  Seq Scan on public.t111 t111_1
!                            Output: t111_1.a
!                            Filter: (t111_1.a = 8)
!    ->  Subquery Scan on t1_2
!          Output: (t1_2.a + 1), t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
!          Filter: snoop(t1_2.a)
!          ->  Nested Loop Semi Join
!                Output: t12_2.a, t12_2.ctid, t12_2.b, t12_2.c, t12_2.e
!                ->  Seq Scan on public.t12 t12_2
!                      Output: t12_2.a, t12_2.ctid, t12_2.b, t12_2.c, t12_2.e
!                      Filter: ((t12_2.a > 5) AND (t12_2.a = 8) AND leakproof(t12_2.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_3
!                            Output: t12_3.a
!                            Filter: (t12_3.a = 8)
!                      ->  Seq Scan on public.t111 t111_2
!                            Output: t111_2.a
!                            Filter: (t111_2.a = 8)
!    ->  Subquery Scan on t1_3
!          Output: (t1_3.a + 1), t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
!          Filter: snoop(t1_3.a)
!          ->  Nested Loop Semi Join
!                Output: t111_3.a, t111_3.ctid, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                ->  Seq Scan on public.t111 t111_3
!                      Output: t111_3.a, t111_3.ctid, t111_3.b, t111_3.c, t111_3.d, t111_3.e
!                      Filter: ((t111_3.a > 5) AND (t111_3.a = 8) AND leakproof(t111_3.a))
!                ->  Append
!                      ->  Seq Scan on public.t12 t12_4
!                            Output: t12_4.a
!                            Filter: (t12_4.a = 8)
!                      ->  Seq Scan on public.t111 t111_4
!                            Output: t111_4.a
!                            Filter: (t111_4.a = 8)
! (61 rows)
! 
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! NOTICE:  snooped value: 8
! SELECT * FROM v1 WHERE b=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  9 | 8 | t1   | t11d
!  9 | 8 | t11  | t11d
!  9 | 8 | t12  | t11d
!  9 | 8 | t111 | t11d
! (4 rows)
! 
! DELETE FROM v1 WHERE snoop(a) AND leakproof(a); -- should not delete everything, just where a>5
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 6
! NOTICE:  snooped value: 7
! NOTICE:  snooped value: 9
! NOTICE:  snooped value: 10
! NOTICE:  snooped value: 9
! TABLE t1; -- verify all a<=5 are intact
!  a | b |  c   
! ---+---+------
!  1 | 1 | t1
!  2 | 2 | t1
!  3 | 3 | t1
!  4 | 4 | t1
!  5 | 5 | t1
!  1 | 1 | t11
!  2 | 2 | t11
!  3 | 3 | t11
!  4 | 4 | t11
!  5 | 5 | t11
!  1 | 1 | t12
!  2 | 2 | t12
!  3 | 3 | t12
!  4 | 4 | t12
!  5 | 5 | t12
!  1 | 1 | t111
!  2 | 2 | t111
!  3 | 3 | t111
!  4 | 4 | t111
!  5 | 5 | t111
! (20 rows)
! 
! DROP TABLE t1, t11, t12, t111 CASCADE;
! NOTICE:  drop cascades to view v1
! DROP FUNCTION snoop(anyelement);
! DROP FUNCTION leakproof(anyelement);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/sanity_check.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/sanity_check.out	2015-01-26 12:33:23.439031283 +0300
***************
*** 1,190 ****
! VACUUM;
! --
! -- sanity check, if we don't have indices the test will take years to
! -- complete.  But skip TOAST relations (since they will have varying
! -- names depending on the current OID counter) as well as temp tables
! -- of other backends (to avoid timing-dependent behavior).
! --
! -- temporarily disable fancy output, so catalog changes create less diff noise
! \a\t
! SELECT relname, relhasindex
!    FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
!    WHERE relkind = 'r' AND (nspname ~ '^pg_temp_') IS NOT TRUE
!    ORDER BY relname;
! a|f
! a_star|f
! abstime_tbl|f
! aggtest|f
! array_index_op_test|t
! array_op_test|f
! b|f
! b_star|f
! box_tbl|f
! bprime|f
! bt_f8_heap|t
! bt_i4_heap|t
! bt_name_heap|t
! bt_txt_heap|t
! c|f
! c_star|f
! char_tbl|f
! check2_tbl|f
! check_tbl|f
! circle_tbl|t
! city|f
! copy_tbl|f
! d|f
! d_star|f
! date_tbl|f
! default_tbl|f
! defaultexpr_tbl|f
! dept|f
! dupindexcols|t
! e_star|f
! emp|f
! equipment_r|f
! f_star|f
! fast_emp4000|t
! float4_tbl|f
! float8_tbl|f
! func_index_heap|t
! hash_f8_heap|t
! hash_i4_heap|t
! hash_name_heap|t
! hash_txt_heap|t
! hobbies_r|f
! ihighway|t
! inet_tbl|f
! inhf|f
! inhx|t
! insert_tbl|f
! int2_tbl|f
! int4_tbl|f
! int8_tbl|f
! interval_tbl|f
! iportaltest|f
! kd_point_tbl|t
! line_tbl|f
! log_table|f
! lseg_tbl|f
! main_table|f
! money_data|f
! num_data|f
! num_exp_add|t
! num_exp_div|t
! num_exp_ln|t
! num_exp_log10|t
! num_exp_mul|t
! num_exp_power_10_ln|t
! num_exp_sqrt|t
! num_exp_sub|t
! num_input_test|f
! num_result|f
! onek|t
! onek2|t
! path_tbl|f
! person|f
! pg_aggregate|t
! pg_am|t
! pg_amop|t
! pg_amproc|t
! pg_attrdef|t
! pg_attribute|t
! pg_auth_members|t
! pg_authid|t
! pg_cast|t
! pg_class|t
! pg_collation|t
! pg_constraint|t
! pg_conversion|t
! pg_database|t
! pg_db_role_setting|t
! pg_default_acl|t
! pg_depend|t
! pg_description|t
! pg_enum|t
! pg_event_trigger|t
! pg_extension|t
! pg_foreign_data_wrapper|t
! pg_foreign_server|t
! pg_foreign_table|t
! pg_index|t
! pg_inherits|t
! pg_language|t
! pg_largeobject|t
! pg_largeobject_metadata|t
! pg_namespace|t
! pg_opclass|t
! pg_operator|t
! pg_opfamily|t
! pg_pltemplate|t
! pg_proc|t
! pg_range|t
! pg_rewrite|t
! pg_rowsecurity|t
! pg_seclabel|t
! pg_shdepend|t
! pg_shdescription|t
! pg_shseclabel|t
! pg_statistic|t
! pg_tablespace|t
! pg_trigger|t
! pg_ts_config|t
! pg_ts_config_map|t
! pg_ts_dict|t
! pg_ts_parser|t
! pg_ts_template|t
! pg_type|t
! pg_user_mapping|t
! point_tbl|t
! polygon_tbl|t
! quad_point_tbl|t
! radix_text_tbl|t
! ramp|f
! real_city|f
! reltime_tbl|f
! road|t
! shighway|t
! slow_emp4000|f
! sql_features|f
! sql_implementation_info|f
! sql_languages|f
! sql_packages|f
! sql_parts|f
! sql_sizing|f
! sql_sizing_profiles|f
! stud_emp|f
! student|f
! tenk1|t
! tenk2|t
! test_range_excl|t
! test_range_gist|t
! test_range_spgist|t
! test_tsvector|f
! testjsonb|f
! text_tbl|f
! time_tbl|f
! timestamp_tbl|f
! timestamptz_tbl|f
! timetz_tbl|f
! tinterval_tbl|f
! varchar_tbl|f
! -- restore normal output mode
! \a\t
! --
! -- another sanity check: every system catalog that has OIDs should have
! -- a unique index on OID.  This ensures that the OIDs will be unique,
! -- even after the OID counter wraps around.
! -- We exclude non-system tables from the check by looking at nspname.
! --
! SELECT relname, nspname
! FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
! WHERE relhasoids
!     AND ((nspname ~ '^pg_') IS NOT FALSE)
!     AND NOT EXISTS (SELECT 1 FROM pg_index i WHERE indrelid = c.oid
!                     AND indkey[0] = -2 AND indnatts = 1
!                     AND indisunique AND indimmediate);
!  relname | nspname 
! ---------+---------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/errors.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/errors.out	2015-01-26 12:33:23.455031284 +0300
***************
*** 1,447 ****
! --
! -- ERRORS
! --
! -- bad in postquel, but ok in postsql
! select 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! --
! -- UNSUPPORTED STUFF
! -- doesn't work
! -- notify pg_class
! --
! --
! -- SELECT
! -- this used to be a syntax error, but now we allow an empty target list
! select;
! --
! (1 row)
! 
! -- no such relation
! select * from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: select * from nonesuch;
!                       ^
! -- bad name in target list
! select nonesuch from pg_database;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select nonesuch from pg_database;
!                ^
! -- empty distinct list isn't OK
! select distinct from pg_database;
! ERROR:  SELECT DISTINCT must have at least one column
! -- bad attribute name on lhs of operator
! select * from pg_database where nonesuch = pg_database.datname;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select * from pg_database where nonesuch = pg_database.datna...
!                                         ^
! -- bad attribute name on rhs of operator
! select * from pg_database where pg_database.datname = nonesuch;
! ERROR:  column "nonesuch" does not exist
! LINE 1: ...ect * from pg_database where pg_database.datname = nonesuch;
!                                                               ^
! -- bad attribute name in select distinct on
! select distinct on (foobar) * from pg_database;
! ERROR:  column "foobar" does not exist
! LINE 1: select distinct on (foobar) * from pg_database;
!                             ^
! --
! -- DELETE
! -- missing relation name (this had better not wildcard!)
! delete from;
! ERROR:  syntax error at or near ";"
! LINE 1: delete from;
!                    ^
! -- no such relation
! delete from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: delete from nonesuch;
!                     ^
! --
! -- DROP
! -- missing relation name (this had better not wildcard!)
! drop table;
! ERROR:  syntax error at or near ";"
! LINE 1: drop table;
!                   ^
! -- no such relation
! drop table nonesuch;
! ERROR:  table "nonesuch" does not exist
! --
! -- ALTER TABLE
! -- relation renaming
! -- missing relation name
! alter table rename;
! ERROR:  syntax error at or near ";"
! LINE 1: alter table rename;
!                           ^
! -- no such relation
! alter table nonesuch rename to newnonesuch;
! ERROR:  relation "nonesuch" does not exist
! -- no such relation
! alter table nonesuch rename to stud_emp;
! ERROR:  relation "nonesuch" does not exist
! -- conflict
! alter table stud_emp rename to aggtest;
! ERROR:  relation "aggtest" already exists
! -- self-conflict
! alter table stud_emp rename to stud_emp;
! ERROR:  relation "stud_emp" already exists
! -- attribute renaming
! -- no such relation
! alter table nonesuchrel rename column nonesuchatt to newnonesuchatt;
! ERROR:  relation "nonesuchrel" does not exist
! -- no such attribute
! alter table emp rename column nonesuchatt to newnonesuchatt;
! ERROR:  column "nonesuchatt" does not exist
! -- conflict
! alter table emp rename column salary to manager;
! ERROR:  column "manager" of relation "stud_emp" already exists
! -- conflict
! alter table emp rename column salary to oid;
! ERROR:  column name "oid" conflicts with a system column name
! --
! -- TRANSACTION STUFF
! -- not in a xact
! abort;
! WARNING:  there is no transaction in progress
! -- not in a xact
! end;
! WARNING:  there is no transaction in progress
! --
! -- CREATE AGGREGATE
! -- sfunc/finalfunc type disagreement
! create aggregate newavg2 (sfunc = int4pl,
! 			  basetype = int4,
! 			  stype = int4,
! 			  finalfunc = int2um,
! 			  initcond = '0');
! ERROR:  function int2um(integer) does not exist
! -- left out basetype
! create aggregate newcnt1 (sfunc = int4inc,
! 			  stype = int4,
! 			  initcond = '0');
! ERROR:  aggregate input type must be specified
! --
! -- DROP INDEX
! -- missing index name
! drop index;
! ERROR:  syntax error at or near ";"
! LINE 1: drop index;
!                   ^
! -- bad index name
! drop index 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop index 314159;
!                    ^
! -- no such index
! drop index nonesuch;
! ERROR:  index "nonesuch" does not exist
! --
! -- DROP AGGREGATE
! -- missing aggregate name
! drop aggregate;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate;
!                       ^
! -- missing aggregate type
! drop aggregate newcnt1;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate newcnt1;
!                               ^
! -- bad aggregate name
! drop aggregate 314159 (int);
! ERROR:  syntax error at or near "314159"
! LINE 1: drop aggregate 314159 (int);
!                        ^
! -- bad aggregate type
! drop aggregate newcnt (nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such aggregate
! drop aggregate nonesuch (int4);
! ERROR:  aggregate nonesuch(integer) does not exist
! -- no such aggregate for type
! drop aggregate newcnt (float4);
! ERROR:  aggregate newcnt(real) does not exist
! --
! -- DROP FUNCTION
! -- missing function name
! drop function ();
! ERROR:  syntax error at or near "("
! LINE 1: drop function ();
!                       ^
! -- bad function name
! drop function 314159();
! ERROR:  syntax error at or near "314159"
! LINE 1: drop function 314159();
!                       ^
! -- no such function
! drop function nonesuch();
! ERROR:  function nonesuch() does not exist
! --
! -- DROP TYPE
! -- missing type name
! drop type;
! ERROR:  syntax error at or near ";"
! LINE 1: drop type;
!                  ^
! -- bad type name
! drop type 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop type 314159;
!                   ^
! -- no such type
! drop type nonesuch;
! ERROR:  type "nonesuch" does not exist
! --
! -- DROP OPERATOR
! -- missing everything
! drop operator;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator;
!                      ^
! -- bad operator name
! drop operator equals;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator equals;
!                             ^
! -- missing type list
! drop operator ===;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator ===;
!                          ^
! -- missing parentheses
! drop operator int4, int4;
! ERROR:  syntax error at or near ","
! LINE 1: drop operator int4, int4;
!                           ^
! -- missing operator name
! drop operator (int4, int4);
! ERROR:  syntax error at or near "("
! LINE 1: drop operator (int4, int4);
!                       ^
! -- missing type list contents
! drop operator === ();
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator === ();
!                            ^
! -- no such operator
! drop operator === (int4);
! ERROR:  missing argument
! LINE 1: drop operator === (int4);
!                                ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such operator by that name
! drop operator === (int4, int4);
! ERROR:  operator does not exist: integer === integer
! -- no such type1
! drop operator = (nonesuch);
! ERROR:  missing argument
! LINE 1: drop operator = (nonesuch);
!                                  ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such type1
! drop operator = ( , int4);
! ERROR:  syntax error at or near ","
! LINE 1: drop operator = ( , int4);
!                           ^
! -- no such type1
! drop operator = (nonesuch, int4);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, );
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator = (int4, );
!                                ^
! --
! -- DROP RULE
! -- missing rule name
! drop rule;
! ERROR:  syntax error at or near ";"
! LINE 1: drop rule;
!                  ^
! -- bad rule name
! drop rule 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop rule 314159;
!                   ^
! -- no such rule
! drop rule nonesuch on noplace;
! ERROR:  relation "noplace" does not exist
! -- these postquel variants are no longer supported
! drop tuple rule nonesuch;
! ERROR:  syntax error at or near "tuple"
! LINE 1: drop tuple rule nonesuch;
!              ^
! drop instance rule nonesuch on noplace;
! ERROR:  syntax error at or near "instance"
! LINE 1: drop instance rule nonesuch on noplace;
!              ^
! drop rewrite rule nonesuch;
! ERROR:  syntax error at or near "rewrite"
! LINE 1: drop rewrite rule nonesuch;
!              ^
! --
! -- Check that division-by-zero is properly caught.
! --
! select 1/0;
! ERROR:  division by zero
! select 1::int8/0;
! ERROR:  division by zero
! select 1/0::int8;
! ERROR:  division by zero
! select 1::int2/0;
! ERROR:  division by zero
! select 1/0::int2;
! ERROR:  division by zero
! select 1::numeric/0;
! ERROR:  division by zero
! select 1/0::numeric;
! ERROR:  division by zero
! select 1::float8/0;
! ERROR:  division by zero
! select 1/0::float8;
! ERROR:  division by zero
! select 1::float4/0;
! ERROR:  division by zero
! select 1/0::float4;
! ERROR:  division by zero
! --
! -- Test psql's reporting of syntax error location
! --
! xxx;
! ERROR:  syntax error at or near "xxx"
! LINE 1: xxx;
!         ^
! CREATE foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: CREATE foo;
!                ^
! CREATE TABLE ;
! ERROR:  syntax error at or near ";"
! LINE 1: CREATE TABLE ;
!                      ^
! CREATE TABLE
! \g
! ERROR:  syntax error at end of input
! LINE 1: CREATE TABLE
!                     ^
! INSERT INTO foo VALUES(123) foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: INSERT INTO foo VALUES(123) foo;
!                                     ^
! INSERT INTO 123
! VALUES(123);
! ERROR:  syntax error at or near "123"
! LINE 1: INSERT INTO 123
!                     ^
! INSERT INTO foo
! VALUES(123) 123
! ;
! ERROR:  syntax error at or near "123"
! LINE 2: VALUES(123) 123
!                     ^
! -- with a tab
! CREATE TABLE foo
!   (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY,
! 	id3 INTEGER NOT NUL,
!    id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 3:  id3 INTEGER NOT NUL,
!                          ^
! -- long line to be truncated on the left
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right
! CREATE TABLE foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
! ERROR:  syntax error at or near "NUL"
! LINE 2: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- long line to be truncated on the left, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4
! UNIQUE
! NOT
! NULL,
! id5 TEXT
! UNIQUE
! NOT
! NULL)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 4: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 5: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways, many lines
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv INT4 UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 7: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- more than 10 lines...
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE
! NOT
! NULL
! ,
! idm
! INT4
! UNIQUE
! NOT
! NULL,
! idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv
! INT4
! UNIQUE
! NOT
! NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 16: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                               ^
! -- Check that stack depth detection mechanism works and
! -- max_stack_depth is not set too high
! create function infinite_recurse() returns int as
! 'select infinite_recurse()' language sql;
! \set VERBOSITY terse
! select infinite_recurse();
! ERROR:  stack depth limit exceeded
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select.out	2015-01-26 12:33:23.467031284 +0300
***************
*** 1,783 ****
! --
! -- SELECT
! --
! -- btree index
! -- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT * FROM onek
!    WHERE onek.unique1 < 10
!    ORDER BY onek.unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY stringu1 using <;
!  unique1 | stringu1 
! ---------+----------
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1d -2 +0nr -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using <, unique1 using >;
!  unique1 | string4 
! ---------+---------
!      999 | AAAAxx
!      995 | AAAAxx
!      983 | AAAAxx
!      982 | AAAAxx
!      981 | AAAAxx
!      998 | HHHHxx
!      997 | HHHHxx
!      993 | HHHHxx
!      990 | HHHHxx
!      986 | HHHHxx
!      996 | OOOOxx
!      991 | OOOOxx
!      988 | OOOOxx
!      987 | OOOOxx
!      985 | OOOOxx
!      994 | VVVVxx
!      992 | VVVVxx
!      989 | VVVVxx
!      984 | VVVVxx
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1dr -2 +0n -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using >, unique1 using <;
!  unique1 | string4 
! ---------+---------
!      984 | VVVVxx
!      989 | VVVVxx
!      992 | VVVVxx
!      994 | VVVVxx
!      985 | OOOOxx
!      987 | OOOOxx
!      988 | OOOOxx
!      991 | OOOOxx
!      996 | OOOOxx
!      986 | HHHHxx
!      990 | HHHHxx
!      993 | HHHHxx
!      997 | HHHHxx
!      998 | HHHHxx
!      981 | AAAAxx
!      982 | AAAAxx
!      983 | AAAAxx
!      995 | AAAAxx
!      999 | AAAAxx
! (19 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0nr -1 +1d -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >, string4 using <;
!  unique1 | string4 
! ---------+---------
!       19 | OOOOxx
!       18 | VVVVxx
!       17 | HHHHxx
!       16 | OOOOxx
!       15 | VVVVxx
!       14 | AAAAxx
!       13 | OOOOxx
!       12 | AAAAxx
!       11 | OOOOxx
!       10 | AAAAxx
!        9 | HHHHxx
!        8 | HHHHxx
!        7 | VVVVxx
!        6 | OOOOxx
!        5 | HHHHxx
!        4 | HHHHxx
!        3 | VVVVxx
!        2 | OOOOxx
!        1 | OOOOxx
!        0 | OOOOxx
! (20 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0n -1 +1dr -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using <, string4 using >;
!  unique1 | string4 
! ---------+---------
!        0 | OOOOxx
!        1 | OOOOxx
!        2 | OOOOxx
!        3 | VVVVxx
!        4 | HHHHxx
!        5 | HHHHxx
!        6 | OOOOxx
!        7 | VVVVxx
!        8 | HHHHxx
!        9 | HHHHxx
!       10 | AAAAxx
!       11 | OOOOxx
!       12 | AAAAxx
!       13 | OOOOxx
!       14 | AAAAxx
!       15 | VVVVxx
!       16 | OOOOxx
!       17 | HHHHxx
!       18 | VVVVxx
!       19 | OOOOxx
! (20 rows)
! 
! --
! -- test partial btree indexes
! --
! -- As of 7.2, planner probably won't pick an indexscan without stats,
! -- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
! -- followed by sort, because that could hide index ordering problems.
! --
! ANALYZE onek2;
! SET enable_seqscan TO off;
! SET enable_bitmapscan TO off;
! SET enable_sort TO off;
! --
! -- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!     WHERE onek2.unique1 < 20
!     ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!    WHERE onek2.unique1 > 980;
!  unique1 | stringu1 
! ---------+----------
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
! (19 rows)
! 
! RESET enable_seqscan;
! RESET enable_bitmapscan;
! RESET enable_sort;
! SELECT two, stringu1, ten, string4
!    INTO TABLE tmp
!    FROM onek;
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
! --
! -- SELECT name, age FROM person*; ??? check if different
! SELECT p.name, p.age FROM person* p;
!   name   | age 
! ---------+-----
!  mike    |  40
!  joe     |  20
!  sally   |  34
!  sandra  |  19
!  alex    |  30
!  sue     |  50
!  denise  |  24
!  sarah   |  88
!  teresa  |  38
!  nan     |  28
!  leah    |  68
!  wendy   |  78
!  melissa |  28
!  joan    |  18
!  mary    |   8
!  jane    |  58
!  liza    |  38
!  jean    |  28
!  jenifer |  38
!  juanita |  58
!  susan   |  78
!  zena    |  98
!  martie  |  88
!  chris   |  78
!  pat     |  18
!  zola    |  58
!  louise  |  98
!  edna    |  18
!  bertha  |  88
!  sumi    |  38
!  koko    |  88
!  gina    |  18
!  rean    |  48
!  sharon  |  78
!  paula   |  68
!  julie   |  68
!  belinda |  38
!  karen   |  48
!  carina  |  58
!  diane   |  18
!  esther  |  98
!  trudy   |  88
!  fanny   |   8
!  carmen  |  78
!  lita    |  25
!  pamela  |  48
!  sandy   |  38
!  trisha  |  88
!  uma     |  78
!  velma   |  68
!  sharon  |  25
!  sam     |  30
!  bill    |  20
!  fred    |  28
!  larry   |  60
!  jeff    |  23
!  cim     |  30
!  linda   |  19
! (58 rows)
! 
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
! -- sort +1nr -2
! --
! SELECT p.name, p.age FROM person* p ORDER BY age using >, name;
!   name   | age 
! ---------+-----
!  esther  |  98
!  louise  |  98
!  zena    |  98
!  bertha  |  88
!  koko    |  88
!  martie  |  88
!  sarah   |  88
!  trisha  |  88
!  trudy   |  88
!  carmen  |  78
!  chris   |  78
!  sharon  |  78
!  susan   |  78
!  uma     |  78
!  wendy   |  78
!  julie   |  68
!  leah    |  68
!  paula   |  68
!  velma   |  68
!  larry   |  60
!  carina  |  58
!  jane    |  58
!  juanita |  58
!  zola    |  58
!  sue     |  50
!  karen   |  48
!  pamela  |  48
!  rean    |  48
!  mike    |  40
!  belinda |  38
!  jenifer |  38
!  liza    |  38
!  sandy   |  38
!  sumi    |  38
!  teresa  |  38
!  sally   |  34
!  alex    |  30
!  cim     |  30
!  sam     |  30
!  fred    |  28
!  jean    |  28
!  melissa |  28
!  nan     |  28
!  lita    |  25
!  sharon  |  25
!  denise  |  24
!  jeff    |  23
!  bill    |  20
!  joe     |  20
!  linda   |  19
!  sandra  |  19
!  diane   |  18
!  edna    |  18
!  gina    |  18
!  joan    |  18
!  pat     |  18
!  fanny   |   8
!  mary    |   8
! (58 rows)
! 
! --
! -- Test some cases involving whole-row Var referencing a subquery
! --
! select foo from (select 1) as foo;
!  foo 
! -----
!  (1)
! (1 row)
! 
! select foo from (select null) as foo;
!  foo 
! -----
!  ()
! (1 row)
! 
! select foo from (select 'xyzzy',1,null) as foo;
!     foo     
! ------------
!  (xyzzy,1,)
! (1 row)
! 
! --
! -- Test VALUES lists
! --
! select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
!     WHERE onek.unique1 = v.i and onek.stringu1 = v.j;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
!      147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
!      931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
! (2 rows)
! 
! -- a more complex case
! -- looks like we're coding lisp :-)
! select * from onek,
!   (values ((select i from
!     (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
!     order by i asc limit 1))) bar (i)
!   where onek.unique1 = bar.i;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
! (1 row)
! 
! -- try VALUES in a subquery
! select * from onek
!     where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
!     order by unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!       20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
!       99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
! (3 rows)
! 
! -- VALUES is also legal as a standalone query or a set-operation member
! VALUES (1,2), (3,4+4), (7,77.7);
!  column1 | column2 
! ---------+---------
!        1 |       2
!        3 |       8
!        7 |    77.7
! (3 rows)
! 
! VALUES (1,2), (3,4+4), (7,77.7)
! UNION ALL
! SELECT 2+2, 57
! UNION ALL
! TABLE int8_tbl;
!      column1      |      column2      
! ------------------+-------------------
!                 1 |                 2
!                 3 |                 8
!                 7 |              77.7
!                 4 |                57
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (9 rows)
! 
! --
! -- Test ORDER BY options
! --
! CREATE TEMP TABLE foo (f1 int);
! INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 ASC;	-- same thing
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! -- check if indexscans do the right things
! CREATE INDEX fooi ON foo (f1);
! SET enable_sort = false;
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! --
! -- Test some corner cases that have been known to confuse the planner
! --
! -- ORDER BY on a constant doesn't really need any sorting
! SELECT 1 AS x ORDER BY x;
!  x 
! ---
!  1
! (1 row)
! 
! -- But ORDER BY on a set-valued expression does
! create function sillysrf(int) returns setof int as
!   'values (1),(10),(2),($1)' language sql immutable;
! select sillysrf(42);
!  sillysrf 
! ----------
!         1
!        10
!         2
!        42
! (4 rows)
! 
! select sillysrf(-1) order by 1;
!  sillysrf 
! ----------
!        -1
!         1
!         2
!        10
! (4 rows)
! 
! drop function sillysrf(int);
! -- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
! -- (see bug #5084)
! select * from (values (2),(null),(1)) v(k) where k = k order by k;
!  k 
! ---
!  1
!  2
! (2 rows)
! 
! select * from (values (2),(null),(1)) v(k) where k = k;
!  k 
! ---
!  2
!  1
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_into.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_into.out	2015-01-26 12:33:23.603031292 +0300
***************
*** 1,96 ****
! --
! -- SELECT_INTO
! --
! SELECT *
!    INTO TABLE tmp1
!    FROM onek
!    WHERE onek.unique1 < 2;
! DROP TABLE tmp1;
! SELECT *
!    INTO TABLE tmp1
!    FROM onek2
!    WHERE onek2.unique1 < 2;
! DROP TABLE tmp1;
! --
! -- SELECT INTO and INSERT permission, if owner is not allowed to insert.
! --
! CREATE SCHEMA selinto_schema;
! CREATE USER selinto_user;
! ALTER DEFAULT PRIVILEGES FOR ROLE selinto_user
! 	  REVOKE INSERT ON TABLES FROM selinto_user;
! GRANT ALL ON SCHEMA selinto_schema TO public;
! SET SESSION AUTHORIZATION selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%';	-- Error
! ERROR:  permission denied for relation tmp1
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- Error
! ERROR:  permission denied for relation tmp2
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- Error
! ERROR:  permission denied for relation tmp3
! RESET SESSION AUTHORIZATION;
! ALTER DEFAULT PRIVILEGES FOR ROLE selinto_user
! 	  GRANT INSERT ON TABLES TO selinto_user;
! SET SESSION AUTHORIZATION selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%';	-- OK
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- OK
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- OK
! RESET SESSION AUTHORIZATION;
! DROP SCHEMA selinto_schema CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table selinto_schema.tmp1
! drop cascades to table selinto_schema.tmp2
! drop cascades to table selinto_schema.tmp3
! DROP USER selinto_user;
! --
! -- CREATE TABLE AS/SELECT INTO as last command in a SQL function
! -- have been known to cause problems
! --
! CREATE FUNCTION make_table() RETURNS VOID
! AS $$
!   CREATE TABLE created_table AS SELECT * FROM int8_tbl;
! $$ LANGUAGE SQL;
! SELECT make_table();
!  make_table 
! ------------
!  
! (1 row)
! 
! SELECT * FROM created_table;
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! DROP TABLE created_table;
! --
! -- Disallowed uses of SELECT ... INTO.  All should fail
! --
! DECLARE foo CURSOR FOR SELECT 1 INTO b;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: DECLARE foo CURSOR FOR SELECT 1 INTO b;
!                                              ^
! COPY (SELECT 1 INTO frak UNION SELECT 2) TO 'blob';
! ERROR:  COPY (SELECT INTO) is not supported
! SELECT * FROM (SELECT 1 INTO f) bar;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: SELECT * FROM (SELECT 1 INTO f) bar;
!                                      ^
! CREATE VIEW foo AS SELECT 1 INTO b;
! ERROR:  views must not contain SELECT INTO
! INSERT INTO b SELECT 1 INTO f;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: INSERT INTO b SELECT 1 INTO f;
!                                     ^
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_distinct.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_distinct.out	2015-01-26 12:33:23.603031292 +0300
***************
*** 1,222 ****
! --
! -- SELECT_DISTINCT
! --
! --
! -- awk '{print $3;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT two FROM tmp ORDER BY 1;
!  two 
! -----
!    0
!    1
! (2 rows)
! 
! --
! -- awk '{print $5;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT ten FROM tmp ORDER BY 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! --
! -- awk '{print $16;}' onek.data | sort -d | uniq
! --
! SELECT DISTINCT string4 FROM tmp ORDER BY 1;
!  string4 
! ---------
!  AAAAxx
!  HHHHxx
!  OOOOxx
!  VVVVxx
! (4 rows)
! 
! --
! -- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
! -- sort +0n -1 +1d -2 +2n -3
! --
! SELECT DISTINCT two, string4, ten
!    FROM tmp
!    ORDER BY two using <, string4 using <, ten using <;
!  two | string4 | ten 
! -----+---------+-----
!    0 | AAAAxx  |   0
!    0 | AAAAxx  |   2
!    0 | AAAAxx  |   4
!    0 | AAAAxx  |   6
!    0 | AAAAxx  |   8
!    0 | HHHHxx  |   0
!    0 | HHHHxx  |   2
!    0 | HHHHxx  |   4
!    0 | HHHHxx  |   6
!    0 | HHHHxx  |   8
!    0 | OOOOxx  |   0
!    0 | OOOOxx  |   2
!    0 | OOOOxx  |   4
!    0 | OOOOxx  |   6
!    0 | OOOOxx  |   8
!    0 | VVVVxx  |   0
!    0 | VVVVxx  |   2
!    0 | VVVVxx  |   4
!    0 | VVVVxx  |   6
!    0 | VVVVxx  |   8
!    1 | AAAAxx  |   1
!    1 | AAAAxx  |   3
!    1 | AAAAxx  |   5
!    1 | AAAAxx  |   7
!    1 | AAAAxx  |   9
!    1 | HHHHxx  |   1
!    1 | HHHHxx  |   3
!    1 | HHHHxx  |   5
!    1 | HHHHxx  |   7
!    1 | HHHHxx  |   9
!    1 | OOOOxx  |   1
!    1 | OOOOxx  |   3
!    1 | OOOOxx  |   5
!    1 | OOOOxx  |   7
!    1 | OOOOxx  |   9
!    1 | VVVVxx  |   1
!    1 | VVVVxx  |   3
!    1 | VVVVxx  |   5
!    1 | VVVVxx  |   7
!    1 | VVVVxx  |   9
! (40 rows)
! 
! --
! -- awk '{print $2;}' person.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
! -- sort -n -r | uniq
! --
! SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
!  age 
! -----
!   98
!   88
!   78
!   68
!   60
!   58
!   50
!   48
!   40
!   38
!   34
!   30
!   28
!   25
!   24
!   23
!   20
!   19
!   18
!    8
! (20 rows)
! 
! --
! -- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
! -- very own regression file.
! --
! CREATE TEMP TABLE disttable (f1 integer);
! INSERT INTO DISTTABLE VALUES(1);
! INSERT INTO DISTTABLE VALUES(2);
! INSERT INTO DISTTABLE VALUES(3);
! INSERT INTO DISTTABLE VALUES(NULL);
! -- basic cases
! SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
!  f1 | not 2 
! ----+-------
!   1 | t
!   2 | f
!   3 | t
!     | t
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
!  f1 | false 
! ----+-------
!   1 | f
!   2 | f
!   3 | f
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! -- check that optimizer constant-folds it properly
! SELECT 1 IS DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT null IS DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! -- negated form
! SELECT 1 IS NOT DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT null IS NOT DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_distinct_on.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_distinct_on.out	2015-01-26 12:33:23.603031292 +0300
***************
*** 1,75 ****
! --
! -- SELECT_DISTINCT_ON
! --
! SELECT DISTINCT ON (string4) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using >, ten using <;
!  string4 | two | ten 
! ---------+-----+-----
!  AAAAxx  |   1 |   1
!  HHHHxx  |   1 |   1
!  OOOOxx  |   1 |   1
!  VVVVxx  |   1 |   1
! (4 rows)
! 
! -- this will fail due to conflict of ordering requirements
! SELECT DISTINCT ON (string4, ten) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using <, ten using <;
! ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions
! LINE 1: SELECT DISTINCT ON (string4, ten) string4, two, ten
!                                      ^
! SELECT DISTINCT ON (string4, ten) string4, ten, two
!    FROM tmp
!    ORDER BY string4 using <, ten using >, two using <;
!  string4 | ten | two 
! ---------+-----+-----
!  AAAAxx  |   9 |   1
!  AAAAxx  |   8 |   0
!  AAAAxx  |   7 |   1
!  AAAAxx  |   6 |   0
!  AAAAxx  |   5 |   1
!  AAAAxx  |   4 |   0
!  AAAAxx  |   3 |   1
!  AAAAxx  |   2 |   0
!  AAAAxx  |   1 |   1
!  AAAAxx  |   0 |   0
!  HHHHxx  |   9 |   1
!  HHHHxx  |   8 |   0
!  HHHHxx  |   7 |   1
!  HHHHxx  |   6 |   0
!  HHHHxx  |   5 |   1
!  HHHHxx  |   4 |   0
!  HHHHxx  |   3 |   1
!  HHHHxx  |   2 |   0
!  HHHHxx  |   1 |   1
!  HHHHxx  |   0 |   0
!  OOOOxx  |   9 |   1
!  OOOOxx  |   8 |   0
!  OOOOxx  |   7 |   1
!  OOOOxx  |   6 |   0
!  OOOOxx  |   5 |   1
!  OOOOxx  |   4 |   0
!  OOOOxx  |   3 |   1
!  OOOOxx  |   2 |   0
!  OOOOxx  |   1 |   1
!  OOOOxx  |   0 |   0
!  VVVVxx  |   9 |   1
!  VVVVxx  |   8 |   0
!  VVVVxx  |   7 |   1
!  VVVVxx  |   6 |   0
!  VVVVxx  |   5 |   1
!  VVVVxx  |   4 |   0
!  VVVVxx  |   3 |   1
!  VVVVxx  |   2 |   0
!  VVVVxx  |   1 |   1
!  VVVVxx  |   0 |   0
! (40 rows)
! 
! -- bug #5049: early 8.4.x chokes on volatile DISTINCT ON clauses
! select distinct on (1) floor(random()) as r, f1 from int4_tbl order by 1,2;
!  r |     f1      
! ---+-------------
!  0 | -2147483647
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_implicit.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_implicit.out	2015-01-26 12:33:23.603031292 +0300
***************
*** 1,336 ****
! --
! -- SELECT_IMPLICIT
! -- Test cases for queries with ordering terms missing from the target list.
! -- This used to be called "junkfilter.sql".
! -- The parser uses the term "resjunk" to handle these cases.
! -- - thomas 1998-07-09
! --
! -- load test data
! CREATE TABLE test_missing_target (a int, b int, c char(8), d char);
! INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');
! INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');
! INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');
! --   w/ existing GROUP BY target
! SELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!  count 
! -------
!      2
!      2
!      2
!      1
!      1
!      2
! (6 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT test_missing_target.b, count(*)
!   FROM test_missing_target GROUP BY b ORDER BY b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT c FROM test_missing_target ORDER BY a;
!     c     
! ----------
!  XXXX    
!  ABAB    
!  ABAB    
!  BBBB    
!  BBBB    
!  bbbb    
!  cccc    
!  cccc    
!  CCCC    
!  CCCC    
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b desc;
!  count 
! -------
!      4
!      3
!      2
!      1
! (4 rows)
! 
! --   group using reference number
! SELECT count(*) FROM test_missing_target ORDER BY 1 desc;
!  count 
! -------
!     10
! (1 row)
! 
! --   order using reference number
! SELECT c, count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   group using reference number out of range
! --   failure expected
! SELECT c, count(*) FROM test_missing_target GROUP BY 3;
! ERROR:  GROUP BY position 3 is not in select list
! LINE 1: SELECT c, count(*) FROM test_missing_target GROUP BY 3;
!                                                              ^
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b ORDER BY b;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b ORDER BY b;
!                              ^
! --   order w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a, a FROM test_missing_target
! 	ORDER BY a;
!  a | a 
! ---+---
!  0 | 0
!  1 | 1
!  2 | 2
!  3 | 3
!  4 | 4
!  5 | 5
!  6 | 6
!  7 | 7
!  8 | 8
!  9 | 9
! (10 rows)
! 
! --   order expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         0 |        0
!         1 |        1
!         1 |        1
!         2 |        2
!         2 |        2
!         3 |        3
!         3 |        3
!         4 |        4
!         4 |        4
! (10 rows)
! 
! --   group expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	GROUP BY a/2 ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         1 |        1
!         2 |        2
!         3 |        3
!         4 |        4
! (5 rows)
! 
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(*) INTO TABLE test_missing_target2
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
! SELECT * FROM test_missing_target2;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --  Functions and expressions
! --   w/ existing GROUP BY target
! SELECT a%2, count(b) FROM test_missing_target
! GROUP BY test_missing_target.a%2
! ORDER BY test_missing_target.a%2;
!  ?column? | count 
! ----------+-------
!         0 |     5
!         1 |     5
! (2 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(c) FROM test_missing_target
! GROUP BY lower(test_missing_target.c)
! ORDER BY lower(test_missing_target.c);
!  count 
! -------
!      2
!      3
!      4
!      1
! (4 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(b) FROM test_missing_target GROUP BY b/2 ORDER BY b/2;
!  count 
! -------
!      1
!      5
!      4
! (3 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT lower(test_missing_target.c), count(c)
!   FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
!  lower | count 
! -------+-------
!  abab  |     2
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT a FROM test_missing_target ORDER BY upper(d);
!  a 
! ---
!  0
!  1
!  2
!  3
!  4
!  5
!  6
!  7
!  8
!  9
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(b) FROM test_missing_target
! 	GROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 desc;
!  count 
! -------
!      7
!      3
! (2 rows)
! 
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(x.a) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b/2 ORDER BY b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b/2 ORDER BY b/2;
!                                ^
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
!  ?column? | count 
! ----------+-------
!         0 |     1
!         1 |     5
!         2 |     4
! (3 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   failure expected due to ambiguous b in count(b)
! SELECT count(b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 1: SELECT count(b) FROM test_missing_target x, test_missing_tar...
!                      ^
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(x.b) INTO TABLE test_missing_target3
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
! SELECT * FROM test_missing_target3;
!  count 
! -------
!      1
!      5
!      4
! (3 rows)
! 
! --   Cleanup
! DROP TABLE test_missing_target;
! DROP TABLE test_missing_target2;
! DROP TABLE test_missing_target3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_having.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_having.out	2015-01-26 12:33:23.563031289 +0300
***************
*** 1,93 ****
! --
! -- SELECT_HAVING
! --
! -- load test data
! CREATE TABLE test_having (a int, b int, c char(8), d char);
! INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');
! INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');
! INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING count(*) = 1 ORDER BY b, c;
!  b |    c     
! ---+----------
!  1 | XXXX    
!  3 | bbbb    
! (2 rows)
! 
! -- HAVING is effectively equivalent to WHERE in this case
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
!  b |    c     
! ---+----------
!  3 | BBBB    
!  3 | bbbb    
! (2 rows)
! 
! SELECT lower(c), count(c) FROM test_having
! 	GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY lower(c);
!  lower | count 
! -------+-------
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (3 rows)
! 
! SELECT c, max(a) FROM test_having
! 	GROUP BY c HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY c;
!     c     | max 
! ----------+-----
!  XXXX     |   0
!  bbbb     |   5
! (2 rows)
! 
! -- test degenerate cases involving HAVING without GROUP BY
! -- Per SQL spec, these should generate 0 or 1 row, even without aggregates
! SELECT min(a), max(a) FROM test_having HAVING min(a) = max(a);
!  min | max 
! -----+-----
! (0 rows)
! 
! SELECT min(a), max(a) FROM test_having HAVING min(a) < max(a);
!  min | max 
! -----+-----
!    0 |   9
! (1 row)
! 
! -- errors: ungrouped column references
! SELECT a FROM test_having HAVING min(a) < max(a);
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a FROM test_having HAVING min(a) < max(a);
!                ^
! SELECT 1 AS one FROM test_having HAVING a > 1;
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT 1 AS one FROM test_having HAVING a > 1;
!                                                 ^
! -- the really degenerate case: need not scan table at all
! SELECT 1 AS one FROM test_having HAVING 1 > 2;
!  one 
! -----
! (0 rows)
! 
! SELECT 1 AS one FROM test_having HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! -- and just to prove that we aren't scanning the table:
! SELECT 1 AS one FROM test_having WHERE 1/a = 1 HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! DROP TABLE test_having;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/subselect.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/subselect.out	2015-01-26 12:33:23.591031291 +0300
***************
*** 1,823 ****
! --
! -- SUBSELECT
! --
! SELECT 1 AS one WHERE 1 IN (SELECT 1);
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
!  zero 
! ------
! (0 rows)
! 
! SELECT 1 AS zero WHERE 1 IN (SELECT 2);
!  zero 
! ------
! (0 rows)
! 
! -- Check grammar's handling of extra parens in assorted contexts
! SELECT * FROM (SELECT 1 AS x) ss;
!  x 
! ---
!  1
! (1 row)
! 
! SELECT * FROM ((SELECT 1 AS x)) ss;
!  x 
! ---
!  1
! (1 row)
! 
! (SELECT 2) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! ((SELECT 2)) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT ((SELECT 2) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (((SELECT 2)) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (SELECT ARRAY[1,2,3])[1];
!  array 
! -------
!      1
! (1 row)
! 
! SELECT ((SELECT ARRAY[1,2,3]))[2];
!  array 
! -------
!      2
! (1 row)
! 
! SELECT (((SELECT ARRAY[1,2,3])))[3];
!  array 
! -------
!      3
! (1 row)
! 
! -- Set up some simple test tables
! CREATE TABLE SUBSELECT_TBL (
!   f1 integer,
!   f2 integer,
!   f3 float
! );
! INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
! INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
! INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
! INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
! INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
! INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
! INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
! INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
! SELECT '' AS eight, * FROM SUBSELECT_TBL;
!  eight | f1 | f2 | f3 
! -------+----+----+----
!        |  1 |  2 |  3
!        |  2 |  3 |  4
!        |  3 |  4 |  5
!        |  1 |  1 |  1
!        |  2 |  2 |  2
!        |  3 |  3 |  3
!        |  6 |  7 |  8
!        |  8 |  9 |   
! (8 rows)
! 
! -- Uncorrelated subselects
! SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT 1);
!  two | Constant Select 
! -----+-----------------
!      |               1
!      |               1
! (2 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL);
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  2
!      |                  3
!      |                  1
!      |                  2
!      |                  3
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
!     f2 IN (SELECT f1 FROM SUBSELECT_TBL));
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  2
!      |                  3
!      |                  1
!      |                  2
!      |                  3
! (6 rows)
! 
! SELECT '' AS three, f1, f2
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                          WHERE f3 IS NOT NULL);
!  three | f1 | f2 
! -------+----+----
!        |  1 |  2
!        |  6 |  7
!        |  8 |  9
! (3 rows)
! 
! -- Correlated subselects
! SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            2
!      |                2 |            3
!      |                3 |            4
!      |                1 |            1
!      |                2 |            2
!      |                3 |            3
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN
!     (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3);
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                2 |            4
!      |                3 |            5
!      |                1 |            1
!      |                2 |            2
!      |                3 |            3
! (5 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
!                WHERE f2 = CAST(f3 AS integer));
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            3
!      |                2 |            4
!      |                3 |            5
!      |                6 |            8
! (4 rows)
! 
! SELECT '' AS five, f1 AS "Correlated Field"
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                      WHERE f3 IS NOT NULL);
!  five | Correlated Field 
! ------+------------------
!       |                2
!       |                3
!       |                1
!       |                2
!       |                3
! (5 rows)
! 
! --
! -- Use some existing tables in the regression test
! --
! SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
!   FROM SUBSELECT_TBL ss
!   WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
!                    WHERE f1 != ss.f1 AND f1 < 2147483647);
!  eight | Correlated Field | Second Field 
! -------+------------------+--------------
!        |                2 |            4
!        |                3 |            5
!        |                2 |            2
!        |                3 |            3
!        |                6 |            8
!        |                8 |             
! (6 rows)
! 
! select q1, float8(count(*)) / (select count(*) from int8_tbl)
! from int8_tbl group by q1 order by q1;
!         q1        | ?column? 
! ------------------+----------
!               123 |      0.4
!  4567890123456789 |      0.6
! (2 rows)
! 
! --
! -- Test cases to catch unpleasant interactions between IN-join processing
! -- and subquery pullup.
! --
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Test cases to check for overenthusiastic optimization of
! -- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
! -- Luca Pireddu and Michael Fuhr.
! --
! CREATE TEMP TABLE foo (id integer);
! CREATE TEMP TABLE bar (id1 integer, id2 integer);
! INSERT INTO foo VALUES (1);
! INSERT INTO bar VALUES (1, 1);
! INSERT INTO bar VALUES (2, 2);
! INSERT INTO bar VALUES (3, 1);
! -- These cases require an extra level of distinct-ing above subquery s
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
!                       SELECT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! -- These cases do not
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar UNION
!                       SELECT id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- Test case to catch problems with multiply nested sub-SELECTs not getting
! -- recalculated properly.  Per bug report from Didier Moens.
! --
! CREATE TABLE orderstest (
!     approver_ref integer,
!     po_ref integer,
!     ordercanceled boolean
! );
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 5, false);
! INSERT INTO orderstest VALUES (66, 6, false);
! INSERT INTO orderstest VALUES (66, 7, false);
! INSERT INTO orderstest VALUES (66, 1, true);
! INSERT INTO orderstest VALUES (66, 8, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (77, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! CREATE VIEW orders_view AS
! SELECT *,
! (SELECT CASE
!    WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
!  END) AS "Approved",
! (SELECT CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (SELECT CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (SELECT CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status",
! (CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status_OK"
! FROM orderstest ord;
! SELECT * FROM orders_view;
!  approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
! --------------+--------+---------------+----------+----------+-----------
!             1 |      1 | f             | ---      | ---      | ---
!            66 |      5 | f             | Approved | PO       | PO
!            66 |      6 | f             | Approved | PO       | PO
!            66 |      7 | f             | Approved | PO       | PO
!            66 |      1 | t             | Approved | Canceled | Canceled
!            66 |      8 | f             | Approved | PO       | PO
!            66 |      1 | f             | Approved | Approved | Approved
!            77 |      1 | f             | Approved | Approved | Approved
!             1 |      1 | f             | ---      | ---      | ---
!            66 |      1 | f             | Approved | Approved | Approved
!             1 |      1 | f             | ---      | ---      | ---
! (11 rows)
! 
! DROP TABLE orderstest cascade;
! NOTICE:  drop cascades to view orders_view
! --
! -- Test cases to catch situations where rule rewriter fails to propagate
! -- hasSubLinks flag correctly.  Per example from Kyle Bateman.
! --
! create temp table parts (
!     partnum     text,
!     cost        float8
! );
! create temp table shipped (
!     ttype       char(2),
!     ordnum      int4,
!     partnum     text,
!     value       float8
! );
! create temp view shipped_view as
!     select * from shipped where ttype = 'wt';
! create rule shipped_view_insert as on insert to shipped_view do instead
!     insert into shipped values('wt', new.ordnum, new.partnum, new.value);
! insert into parts (partnum, cost) values (1, 1234.56);
! insert into shipped_view (ordnum, partnum, value)
!     values (0, 1, (select cost from parts where partnum = '1'));
! select * from shipped_view;
!  ttype | ordnum | partnum |  value  
! -------+--------+---------+---------
!  wt    |      0 | 1       | 1234.56
! (1 row)
! 
! create rule shipped_view_update as on update to shipped_view do instead
!     update shipped set partnum = new.partnum, value = new.value
!         where ttype = new.ttype and ordnum = new.ordnum;
! update shipped_view set value = 11
!     from int4_tbl a join int4_tbl b
!       on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))
!     where ordnum = a.f1;
! select * from shipped_view;
!  ttype | ordnum | partnum | value 
! -------+--------+---------+-------
!  wt    |      0 | 1       |    11
! (1 row)
! 
! select f1, ss1 as relabel from
!     (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
!      from int4_tbl a) ss;
!      f1      |  relabel   
! -------------+------------
!            0 | 2147607103
!       123456 | 2147607103
!      -123456 | 2147483647
!   2147483647 | 2147483647
!  -2147483647 |          0
! (5 rows)
! 
! --
! -- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
! -- Per bug report from David Sanchez i Gregori.
! --
! select * from (
!   select max(unique1) from tenk1 as a
!   where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
! ) ss;
!  max  
! ------
!  9997
! (1 row)
! 
! select * from (
!   select min(unique1) from tenk1 as a
!   where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
! ) ss;
!  min 
! -----
!    0
! (1 row)
! 
! --
! -- Test that an IN implemented using a UniquePath does unique-ification
! -- with the right semantics, as per bug #4113.  (Unfortunately we have
! -- no simple way to ensure that this test case actually chooses that type
! -- of plan, but it does in releases 7.4-8.3.  Note that an ordering difference
! -- here might mean that some other plan type is being used, rendering the test
! -- pointless.)
! --
! create temp table numeric_table (num_col numeric);
! insert into numeric_table values (1), (1.000000000000000000001), (2), (3);
! create temp table float_table (float_col float8);
! insert into float_table values (1), (2), (3);
! select * from float_table
!   where float_col in (select num_col from numeric_table);
!  float_col 
! -----------
!          1
!          2
!          3
! (3 rows)
! 
! select * from numeric_table
!   where num_col in (select float_col from float_table);
!          num_col         
! -------------------------
!                        1
!  1.000000000000000000001
!                        2
!                        3
! (4 rows)
! 
! --
! -- Test case for bug #4290: bogus calculation of subplan param sets
! --
! create temp table ta (id int primary key, val int);
! insert into ta values(1,1);
! insert into ta values(2,2);
! create temp table tb (id int primary key, aval int);
! insert into tb values(1,1);
! insert into tb values(2,1);
! insert into tb values(3,2);
! insert into tb values(4,2);
! create temp table tc (id int primary key, aid int);
! insert into tc values(1,1);
! insert into tc values(2,2);
! select
!   ( select min(tb.id) from tb
!     where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
! from tc;
!  min_tb_id 
! -----------
!          1
!          3
! (2 rows)
! 
! --
! -- Test case for 8.3 "failed to locate grouping columns" bug
! --
! create temp table t1 (f1 numeric(14,0), f2 varchar(30));
! select * from
!   (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs
!    from t1 up) ss
! group by f1,f2,fs;
!  f1 | f2 | fs 
! ----+----+----
! (0 rows)
! 
! --
! -- Test case for bug #5514 (mishandling of whole-row Vars in subselects)
! --
! create temp table table_a(id integer);
! insert into table_a values (42);
! create temp view view_a as select * from table_a;
! select view_a from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select view_a) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (select view_a)) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (a.*)::text) from view_a a;
!   a   
! ------
!  (42)
! (1 row)
! 
! --
! -- Check that whole-row Vars reading the result of a subselect don't include
! -- any junk columns therein
! --
! select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! with q as (select max(f1) from int4_tbl group by f1 order by f1)
!   select q from q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! --
! -- Test case for sublinks pushed down into subselects via join alias expansion
! --
! select
!   (select sq1) as qq1
! from
!   (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy
!    from int8_tbl) sq0
!   join
!   int4_tbl i4 on dummy = i4.f1;
!  qq1 
! -----
! (0 rows)
! 
! --
! -- Test case for cross-type partial matching in hashed subplan (bug #7597)
! --
! create temp table outer_7597 (f1 int4, f2 int4);
! insert into outer_7597 values (0, 0);
! insert into outer_7597 values (1, 0);
! insert into outer_7597 values (0, null);
! insert into outer_7597 values (1, null);
! create temp table inner_7597(c1 int8, c2 int8);
! insert into inner_7597 values(0, null);
! select * from outer_7597 where (f1, f2) not in (select * from inner_7597);
!  f1 | f2 
! ----+----
!   1 |  0
!   1 |   
! (2 rows)
! 
! --
! -- Test case for premature memory release during hashing of subplan output
! --
! select '1'::text in (select '1'::name union all select '1'::name);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- Test case for planner bug with nested EXISTS handling
! --
! select a.thousand from tenk1 a, tenk1 b
! where a.thousand = b.thousand
!   and exists ( select 1 from tenk1 c where b.hundred = c.hundred
!                    and not exists ( select 1 from tenk1 d
!                                     where a.thousand = d.thousand ) );
!  thousand 
! ----------
! (0 rows)
! 
! --
! -- Check that nested sub-selects are not pulled up if they contain volatiles
! --
! explain (verbose, costs off)
!   select x, x from
!     (select (select now()) as x from (values(1),(2)) v(y)) ss;
!         QUERY PLAN         
! ---------------------------
!  Values Scan on "*VALUES*"
!    Output: $0, $1
!    InitPlan 1 (returns $0)
!      ->  Result
!            Output: now()
!    InitPlan 2 (returns $1)
!      ->  Result
!            Output: now()
! (8 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random()) as x from (values(1),(2)) v(y)) ss;
!             QUERY PLAN            
! ----------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: $0
!          InitPlan 1 (returns $0)
!            ->  Result
!                  Output: random()
! (7 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Values Scan on "*VALUES*"
!    Output: (SubPlan 1), (SubPlan 2)
!    SubPlan 1
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
!    SubPlan 2
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (10 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: (SubPlan 1)
!          SubPlan 1
!            ->  Result
!                  Output: random()
!                  One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (8 rows)
! 
! --
! -- Check we behave sanely in corner case of empty SELECT list (bug #8648)
! --
! create temp table nocolumns();
! select exists(select * from nocolumns);
!  exists 
! --------
!  f
! (1 row)
! 
! --
! -- Check sane behavior with nested IN SubLinks
! --
! explain (verbose, costs off)
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!                                                                                       QUERY PLAN                                                                                       
! ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Nested Loop Semi Join
!    Output: int4_tbl.f1
!    Join Filter: (CASE WHEN (hashed SubPlan 1) THEN int4_tbl.f1 ELSE NULL::integer END = b.ten)
!    ->  Seq Scan on public.int4_tbl
!          Output: int4_tbl.f1
!    ->  Seq Scan on public.tenk1 b
!          Output: b.unique1, b.unique2, b.two, b.four, b.ten, b.twenty, b.hundred, b.thousand, b.twothousand, b.fivethous, b.tenthous, b.odd, b.even, b.stringu1, b.stringu2, b.string4
!    SubPlan 1
!      ->  Index Only Scan using tenk1_unique1 on public.tenk1 a
!            Output: a.unique1
! (10 rows)
! 
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- Check for incorrect optimization when IN subquery contains a SRF
! --
! explain (verbose, costs off)
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Hash Join
!    Output: o.f1
!    Hash Cond: (o.f1 = "ANY_subquery".f1)
!    ->  Seq Scan on public.int4_tbl o
!          Output: o.f1
!    ->  Hash
!          Output: "ANY_subquery".f1, "ANY_subquery".g
!          ->  HashAggregate
!                Output: "ANY_subquery".f1, "ANY_subquery".g
!                Group Key: "ANY_subquery".f1, "ANY_subquery".g
!                ->  Subquery Scan on "ANY_subquery"
!                      Output: "ANY_subquery".f1, "ANY_subquery".g
!                      Filter: ("ANY_subquery".f1 = "ANY_subquery".g)
!                      ->  HashAggregate
!                            Output: i.f1, (generate_series(1, 2) / 10)
!                            Group Key: i.f1
!                            ->  Seq Scan on public.int4_tbl i
!                                  Output: i.f1
! (18 rows)
! 
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- check for over-optimization of whole-row Var referencing an Append plan
! --
! select (select q from
!          (select 1,2,3 where f1 > 0
!           union all
!           select 4,5,6.0 where f1 <= 0
!          ) q )
! from int4_tbl;
!      q     
! -----------
!  (4,5,6.0)
!  (1,2,3)
!  (4,5,6.0)
!  (1,2,3)
!  (4,5,6.0)
! (5 rows)
! 
! --
! -- Check that volatile quals aren't pushed down past a DISTINCT:
! -- nextval() should not be called more than the nominal number of times
! --
! create temp sequence ts1;
! select * from
!   (select distinct ten from tenk1) ss
!   where ten < 10 + nextval('ts1')
!   order by 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! select nextval('ts1');
!  nextval 
! ---------
!       11
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/union.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/union.out	2015-01-26 12:33:23.567031290 +0300
***************
*** 1,712 ****
! --
! -- UNION (also INTERSECT, EXCEPT)
! --
! -- Simple UNION constructs
! SELECT 1 AS two UNION SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS two UNION ALL SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION ALL SELECT 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION SELECT 3;
!  three 
! -------
!      1
!      2
!      3
! (3 rows)
! 
! SELECT 1 AS two UNION SELECT 2 UNION SELECT 2;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2;
!  three 
! -------
!      1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION SELECT 2.2;
!  two 
! -----
!  1.1
!  2.2
! (2 rows)
! 
! -- Mixed types
! SELECT 1.1 AS two UNION SELECT 2;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION SELECT 2.2;
!  two 
! -----
!    1
!  2.2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1.0::float8;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1.1 AS two UNION ALL SELECT 2;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.0::float8 AS two UNION ALL SELECT 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3;
!  three 
! -------
!    1.1
!      2
!      3
! (3 rows)
! 
! SELECT 1.1::float8 AS two UNION SELECT 2 UNION SELECT 2.0::float8 ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2;
!  three 
! -------
!    1.1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2);
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! --
! -- Try testing from tables...
! --
! SELECT f1 AS five FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM FLOAT8_TBL
! ORDER BY 1;
!          five          
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
! (5 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM FLOAT8_TBL;
!           ten          
! -----------------------
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
! (10 rows)
! 
! SELECT f1 AS nine FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM INT4_TBL
! ORDER BY 1;
!          nine          
! -----------------------
!  -1.2345678901234e+200
!            -2147483647
!                -123456
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
!             2147483647
! (9 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM INT4_TBL;
!           ten          
! -----------------------
!                      0
!                 -34.84
!                -1004.3
!  -1.2345678901234e+200
!  -1.2345678901234e-200
!                      0
!                 123456
!                -123456
!             2147483647
!            -2147483647
! (10 rows)
! 
! SELECT f1 AS five FROM FLOAT8_TBL
!   WHERE f1 BETWEEN -1e6 AND 1e6
! UNION
! SELECT f1 FROM INT4_TBL
!   WHERE f1 BETWEEN 0 AND 1000000;
!          five          
! -----------------------
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
! (5 rows)
! 
! SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL
! UNION
! SELECT f1 FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a   
!  ab  
!  abcd
! (3 rows)
! 
! SELECT f1 AS three FROM VARCHAR_TBL
! UNION
! SELECT CAST(f1 AS varchar) FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a
!  ab
!  abcd
! (3 rows)
! 
! SELECT f1 AS eight FROM VARCHAR_TBL
! UNION ALL
! SELECT f1 FROM CHAR_TBL;
!  eight 
! -------
!  a
!  ab
!  abcd
!  abcd
!  a
!  ab
!  abcd
!  abcd
! (8 rows)
! 
! SELECT f1 AS five FROM TEXT_TBL
! UNION
! SELECT f1 FROM VARCHAR_TBL
! UNION
! SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL
! ORDER BY 1;
!        five        
! -------------------
!  a
!  ab
!  abcd
!  doh!
!  hi de ho neighbor
! (5 rows)
! 
! --
! -- INTERSECT and EXCEPT
! --
! SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl;
!         q2        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl;
!         q2        
! ------------------
!  4567890123456789
!  4567890123456789
!               123
! (3 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
!   4567890123456789
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl;
!  q1 
! ----
! (0 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl;
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl;
!         q1        
! ------------------
!  4567890123456789
!  4567890123456789
!               123
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
! ERROR:  FOR NO KEY UPDATE is not allowed with UNION/INTERSECT/EXCEPT
! --
! -- Mixed types
! --
! SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl;
!  f1 
! ----
!   0
! (1 row)
! 
! SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;
!           f1           
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
! (4 rows)
! 
! --
! -- Operator precedence and (((((extra))))) parentheses
! --
! SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl;
!         q1         
! -------------------
!   4567890123456789
!                123
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl)));
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! (((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl))) UNION ALL SELECT q2 FROM int8_tbl;
!         q1         
! -------------------
!   4567890123456789
!                123
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));
!         q1         
! -------------------
!                123
!                123
!   4567890123456789
!   4567890123456789
!   4567890123456789
!  -4567890123456789
!                456
! (7 rows)
! 
! (((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! --
! -- Subqueries with ORDER BY & LIMIT clauses
! --
! -- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT
! SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl
! ORDER BY q2,q1;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!               123 |               456
! (2 rows)
! 
! -- This should fail, because q2 isn't a name of an EXCEPT output column
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;
! ERROR:  column "q2" does not exist
! LINE 1: ... int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1...
!                                                              ^
! HINT:  There is a column named "q2" in table "*SELECT* 2", but it cannot be referenced from this part of the query.
! -- But this should work:
! SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1)));
!         q1        
! ------------------
!  4567890123456789
!               123
! (2 rows)
! 
! --
! -- New syntaxes (7.1) permit new tests
! --
! (((((select * from int8_tbl)))));
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! --
! -- Check handling of a case with unknown constants.  We don't guarantee
! -- an undecorated constant will work in all cases, but historically this
! -- usage has worked, so test we don't break it.
! --
! SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a
! UNION
! SELECT b.f1 FROM (SELECT f1 FROM varchar_tbl) b
! ORDER BY 1;
!   f1  
! ------
!  a
!  ab
!  abcd
!  test
! (4 rows)
! 
! -- This should fail, but it should produce an error cursor
! SELECT '3.4'::numeric UNION SELECT 'foo';
! ERROR:  invalid input syntax for type numeric: "foo"
! LINE 1: SELECT '3.4'::numeric UNION SELECT 'foo';
!                                            ^
! --
! -- Test that expression-index constraints can be pushed down through
! -- UNION or UNION ALL
! --
! CREATE TEMP TABLE t1 (a text, b text);
! CREATE INDEX t1_ab_idx on t1 ((a || b));
! CREATE TEMP TABLE t2 (ab text primary key);
! INSERT INTO t1 VALUES ('a', 'b'), ('x', 'y');
! INSERT INTO t2 VALUES ('ab'), ('xy');
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! explain (costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION ALL
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                  QUERY PLAN                  
! ---------------------------------------------
!  Append
!    ->  Index Scan using t1_ab_idx on t1
!          Index Cond: ((a || b) = 'ab'::text)
!    ->  Index Only Scan using t2_pkey on t2
!          Index Cond: (ab = 'ab'::text)
! (5 rows)
! 
! explain (costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                     QUERY PLAN                     
! ---------------------------------------------------
!  HashAggregate
!    Group Key: ((t1.a || t1.b))
!    ->  Append
!          ->  Index Scan using t1_ab_idx on t1
!                Index Cond: ((a || b) = 'ab'::text)
!          ->  Index Only Scan using t2_pkey on t2
!                Index Cond: (ab = 'ab'::text)
! (7 rows)
! 
! --
! -- Test that ORDER BY for UNION ALL can be pushed down to inheritance
! -- children.
! --
! CREATE TEMP TABLE t1c (b text, a text);
! ALTER TABLE t1c INHERIT t1;
! CREATE TEMP TABLE t2c (primary key (ab)) INHERITS (t2);
! INSERT INTO t1c VALUES ('v', 'w'), ('c', 'd'), ('m', 'n'), ('e', 'f');
! INSERT INTO t2c VALUES ('vw'), ('cd'), ('mn'), ('ef');
! CREATE INDEX t1c_ab_idx on t1c ((a || b));
! set enable_seqscan = on;
! set enable_indexonlyscan = off;
! explain (costs off)
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Limit
!    ->  Merge Append
!          Sort Key: ((t1.a || t1.b))
!          ->  Index Scan using t1_ab_idx on t1
!          ->  Index Scan using t1c_ab_idx on t1c
!          ->  Index Scan using t2_pkey on t2
!          ->  Index Scan using t2c_pkey on t2c
! (7 rows)
! 
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!  ab 
! ----
!  ab
!  ab
!  cd
!  dc
!  ef
!  fe
!  mn
!  nm
! (8 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
! -- This simpler variant of the above test has been observed to fail differently
! create table events (event_id int primary key);
! create table other_events (event_id int primary key);
! create table events_child () inherits (events);
! explain (costs off)
! select event_id
!  from (select event_id from events
!        union all
!        select event_id from other_events) ss
!  order by event_id;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Merge Append
!    Sort Key: events.event_id
!    ->  Index Scan using events_pkey on events
!    ->  Sort
!          Sort Key: events_child.event_id
!          ->  Seq Scan on events_child
!    ->  Index Scan using other_events_pkey on other_events
! (7 rows)
! 
! drop table events_child, events, other_events;
! reset enable_indexonlyscan;
! -- Test constraint exclusion of UNION ALL subqueries
! explain (costs off)
!  SELECT * FROM
!   (SELECT 1 AS t, * FROM tenk1 a
!    UNION ALL
!    SELECT 2 AS t, * FROM tenk1 b) c
!  WHERE t = 2;
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on tenk1 b
! (2 rows)
! 
! -- Test that we push quals into UNION sub-selects only when it's safe
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4;
!                  QUERY PLAN                 
! --------------------------------------------
!  Unique
!    ->  Sort
!          Sort Key: (1), (2)
!          ->  Append
!                ->  Result
!                ->  Result
!                      One-Time Filter: false
! (7 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4;
!  t | x 
! ---+---
!  1 | 2
! (1 row)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Sort
!    Sort Key: ss.x
!    ->  Subquery Scan on ss
!          Filter: (ss.x < 4)
!          ->  HashAggregate
!                Group Key: (1), (generate_series(1, 10))
!                ->  Append
!                      ->  Result
!                      ->  Result
! (9 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!  t | x 
! ---+---
!  1 | 1
!  1 | 2
!  1 | 3
! (3 rows)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on ss
!    Filter: (ss.x > 3)
!    ->  Unique
!          ->  Sort
!                Sort Key: (1), (((random() * 3::double precision))::integer)
!                ->  Append
!                      ->  Result
!                      ->  Result
! (8 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3;
!  t | x 
! ---+---
!  2 | 4
! (1 row)
! 
! -- Test proper handling of parameterized appendrel paths when the
! -- potential join qual is expensive
! create function expensivefunc(int) returns int
! language plpgsql immutable strict cost 10000
! as $$begin return $1; end$$;
! create temp table t3 as select generate_series(-1000,1000) as x;
! create index t3i on t3 (expensivefunc(x));
! analyze t3;
! explain (costs off)
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl
!    ->  Append
!          ->  Index Scan using t3i on t3 a
!                Index Cond: (expensivefunc(x) = int4_tbl.f1)
!          ->  Index Scan using t3i on t3 b
!                Index Cond: (expensivefunc(x) = int4_tbl.f1)
! (7 rows)
! 
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!  x | f1 
! ---+----
!  0 |  0
!  0 |  0
! (2 rows)
! 
! drop table t3;
! drop function expensivefunc(int);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/case.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/case.out	2015-01-26 12:33:23.571031290 +0300
***************
*** 1,303 ****
! --
! -- CASE
! -- Test the case statement
! --
! CREATE TABLE CASE_TBL (
!   i integer,
!   f double precision
! );
! CREATE TABLE CASE2_TBL (
!   i integer,
!   j integer
! );
! INSERT INTO CASE_TBL VALUES (1, 10.1);
! INSERT INTO CASE_TBL VALUES (2, 20.2);
! INSERT INTO CASE_TBL VALUES (3, -30.3);
! INSERT INTO CASE_TBL VALUES (4, NULL);
! INSERT INTO CASE2_TBL VALUES (1, -1);
! INSERT INTO CASE2_TBL VALUES (2, -2);
! INSERT INTO CASE2_TBL VALUES (3, -3);
! INSERT INTO CASE2_TBL VALUES (2, -4);
! INSERT INTO CASE2_TBL VALUES (1, NULL);
! INSERT INTO CASE2_TBL VALUES (NULL, -6);
! --
! -- Simplest examples without tables
! --
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!   END AS "Simple WHEN";
!  One | Simple WHEN 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '<NULL>' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!   END AS "Simple default";
!   One   | Simple default 
! --------+----------------
!  <NULL> |               
! (1 row)
! 
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!     ELSE 4
!   END AS "Simple ELSE";
!  One | Simple ELSE 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '4' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     ELSE 4
!   END AS "ELSE default";
!  One | ELSE default 
! -----+--------------
!  4   |            4
! (1 row)
! 
! SELECT '6' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     WHEN 4 < 5 THEN 6
!     ELSE 7
!   END AS "Two WHEN with default";
!  One | Two WHEN with default 
! -----+-----------------------
!  6   |                     6
! (1 row)
! 
! -- Constant-expression folding shouldn't evaluate unreachable subexpressions
! SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! -- However we do not currently suppress folding of potentially
! -- reachable subexpressions
! SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;
! ERROR:  division by zero
! -- Test for cases involving untyped literals in test expression
! SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;
!  case 
! ------
!     1
! (1 row)
! 
! --
! -- Examples of targets involving tables
! --
! SELECT '' AS "Five",
!   CASE
!     WHEN i >= 3 THEN i
!   END AS ">= 3 or Null"
!   FROM CASE_TBL;
!  Five | >= 3 or Null 
! ------+--------------
!       |             
!       |             
!       |            3
!       |            4
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN i >= 3 THEN (i + i)
!        ELSE i
!   END AS "Simplest Math"
!   FROM CASE_TBL;
!  Five | Simplest Math 
! ------+---------------
!       |             1
!       |             2
!       |             6
!       |             8
! (4 rows)
! 
! SELECT '' AS "Five", i AS "Value",
!   CASE WHEN (i < 0) THEN 'small'
!        WHEN (i = 0) THEN 'zero'
!        WHEN (i = 1) THEN 'one'
!        WHEN (i = 2) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL;
!  Five | Value | Category 
! ------+-------+----------
!       |     1 | one
!       |     2 | two
!       |     3 | big
!       |     4 | big
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN ((i < 0) or (i < 0)) THEN 'small'
!        WHEN ((i = 0) or (i = 0)) THEN 'zero'
!        WHEN ((i = 1) or (i = 1)) THEN 'one'
!        WHEN ((i = 2) or (i = 2)) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL;
!  Five | Category 
! ------+----------
!       | one
!       | two
!       | big
!       | big
! (4 rows)
! 
! --
! -- Examples of qualifications involving tables
! --
! --
! -- NULLIF() and COALESCE()
! -- Shorthand forms for typical CASE constructs
! --  defined in the SQL standard.
! --
! SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;
!  i | f 
! ---+---
!  4 |  
! (1 row)
! 
! SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;
!  i | f 
! ---+---
! (0 rows)
! 
! SELECT COALESCE(a.f, b.i, b.j)
!   FROM CASE_TBL a, CASE2_TBL b;
!  coalesce 
! ----------
!      10.1
!      20.2
!     -30.3
!         1
!      10.1
!      20.2
!     -30.3
!         2
!      10.1
!      20.2
!     -30.3
!         3
!      10.1
!      20.2
!     -30.3
!         2
!      10.1
!      20.2
!     -30.3
!         1
!      10.1
!      20.2
!     -30.3
!        -6
! (24 rows)
! 
! SELECT *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(a.f, b.i, b.j) = 2;
!  i | f | i | j  
! ---+---+---+----
!  4 |   | 2 | -2
!  4 |   | 2 | -4
! (2 rows)
! 
! SELECT '' AS Five, NULLIF(a.i,b.i) AS "NULLIF(a.i,b.i)",
!   NULLIF(b.i, 4) AS "NULLIF(b.i,4)"
!   FROM CASE_TBL a, CASE2_TBL b;
!  five | NULLIF(a.i,b.i) | NULLIF(b.i,4) 
! ------+-----------------+---------------
!       |                 |             1
!       |               2 |             1
!       |               3 |             1
!       |               4 |             1
!       |               1 |             2
!       |                 |             2
!       |               3 |             2
!       |               4 |             2
!       |               1 |             3
!       |               2 |             3
!       |                 |             3
!       |               4 |             3
!       |               1 |             2
!       |                 |             2
!       |               3 |             2
!       |               4 |             2
!       |                 |             1
!       |               2 |             1
!       |               3 |             1
!       |               4 |             1
!       |               1 |              
!       |               2 |              
!       |               3 |              
!       |               4 |              
! (24 rows)
! 
! SELECT '' AS "Two", *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(f,b.i) = 2;
!  Two | i | f | i | j  
! -----+---+---+---+----
!      | 4 |   | 2 | -2
!      | 4 |   | 2 | -4
! (2 rows)
! 
! --
! -- Examples of updates involving tables
! --
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 3 THEN (- i)
!                 ELSE (2 * i) END;
! SELECT * FROM CASE_TBL;
!  i  |   f   
! ----+-------
!   2 |  10.1
!   4 |  20.2
!  -3 | -30.3
!  -4 |      
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 2 THEN (2 * i)
!                 ELSE (3 * i) END;
! SELECT * FROM CASE_TBL;
!   i  |   f   
! -----+-------
!    4 |  10.1
!    8 |  20.2
!   -9 | -30.3
!  -12 |      
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN b.i >= 2 THEN (2 * j)
!                 ELSE (3 * j) END
!   FROM CASE2_TBL b
!   WHERE j = -CASE_TBL.i;
! SELECT * FROM CASE_TBL;
!   i  |   f   
! -----+-------
!    8 |  20.2
!   -9 | -30.3
!  -12 |      
!   -8 |  10.1
! (4 rows)
! 
! --
! -- Clean up
! --
! DROP TABLE CASE_TBL;
! DROP TABLE CASE2_TBL;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/join.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/join.out	2015-01-26 12:33:23.563031289 +0300
***************
*** 1,4341 ****
! --
! -- JOIN
! -- Test JOIN clauses
! --
! CREATE TABLE J1_TBL (
!   i integer,
!   j integer,
!   t text
! );
! CREATE TABLE J2_TBL (
!   i integer,
!   k integer
! );
! INSERT INTO J1_TBL VALUES (1, 4, 'one');
! INSERT INTO J1_TBL VALUES (2, 3, 'two');
! INSERT INTO J1_TBL VALUES (3, 2, 'three');
! INSERT INTO J1_TBL VALUES (4, 1, 'four');
! INSERT INTO J1_TBL VALUES (5, 0, 'five');
! INSERT INTO J1_TBL VALUES (6, 6, 'six');
! INSERT INTO J1_TBL VALUES (7, 7, 'seven');
! INSERT INTO J1_TBL VALUES (8, 8, 'eight');
! INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
! INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
! INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
! INSERT INTO J2_TBL VALUES (1, -1);
! INSERT INTO J2_TBL VALUES (2, 2);
! INSERT INTO J2_TBL VALUES (3, -3);
! INSERT INTO J2_TBL VALUES (2, 4);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (0, NULL);
! INSERT INTO J2_TBL VALUES (NULL, NULL);
! INSERT INTO J2_TBL VALUES (NULL, 0);
! --
! -- CORRELATION NAMES
! -- Make sure that table/column aliases are supported
! -- before diving into more complex join syntax.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS tx;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL tx;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS t1 (a, b, c);
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c);
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      | 0 |   | zero
!      |   |   | null
!      |   | 0 | zero
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);
!  xxx | a | b |   c   | d | e  
! -----+---+---+-------+---+----
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 1 | -1
!      | 3 | 2 | three | 1 | -1
!      | 4 | 1 | four  | 1 | -1
!      | 5 | 0 | five  | 1 | -1
!      | 6 | 6 | six   | 1 | -1
!      | 7 | 7 | seven | 1 | -1
!      | 8 | 8 | eight | 1 | -1
!      | 0 |   | zero  | 1 | -1
!      |   |   | null  | 1 | -1
!      |   | 0 | zero  | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 2 | 3 | two   | 2 |  2
!      | 3 | 2 | three | 2 |  2
!      | 4 | 1 | four  | 2 |  2
!      | 5 | 0 | five  | 2 |  2
!      | 6 | 6 | six   | 2 |  2
!      | 7 | 7 | seven | 2 |  2
!      | 8 | 8 | eight | 2 |  2
!      | 0 |   | zero  | 2 |  2
!      |   |   | null  | 2 |  2
!      |   | 0 | zero  | 2 |  2
!      | 1 | 4 | one   | 3 | -3
!      | 2 | 3 | two   | 3 | -3
!      | 3 | 2 | three | 3 | -3
!      | 4 | 1 | four  | 3 | -3
!      | 5 | 0 | five  | 3 | -3
!      | 6 | 6 | six   | 3 | -3
!      | 7 | 7 | seven | 3 | -3
!      | 8 | 8 | eight | 3 | -3
!      | 0 |   | zero  | 3 | -3
!      |   |   | null  | 3 | -3
!      |   | 0 | zero  | 3 | -3
!      | 1 | 4 | one   | 2 |  4
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 2 |  4
!      | 4 | 1 | four  | 2 |  4
!      | 5 | 0 | five  | 2 |  4
!      | 6 | 6 | six   | 2 |  4
!      | 7 | 7 | seven | 2 |  4
!      | 8 | 8 | eight | 2 |  4
!      | 0 |   | zero  | 2 |  4
!      |   |   | null  | 2 |  4
!      |   | 0 | zero  | 2 |  4
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 0 |   
!      | 2 | 3 | two   | 0 |   
!      | 3 | 2 | three | 0 |   
!      | 4 | 1 | four  | 0 |   
!      | 5 | 0 | five  | 0 |   
!      | 6 | 6 | six   | 0 |   
!      | 7 | 7 | seven | 0 |   
!      | 8 | 8 | eight | 0 |   
!      | 0 |   | zero  | 0 |   
!      |   |   | null  | 0 |   
!      |   | 0 | zero  | 0 |   
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight |   |   
!      | 0 |   | zero  |   |   
!      |   |   | null  |   |   
!      |   | 0 | zero  |   |   
!      | 1 | 4 | one   |   |  0
!      | 2 | 3 | two   |   |  0
!      | 3 | 2 | three |   |  0
!      | 4 | 1 | four  |   |  0
!      | 5 | 0 | five  |   |  0
!      | 6 | 6 | six   |   |  0
!      | 7 | 7 | seven |   |  0
!      | 8 | 8 | eight |   |  0
!      | 0 |   | zero  |   |  0
!      |   |   | null  |   |  0
!      |   | 0 | zero  |   |  0
! (99 rows)
! 
! SELECT '' AS "xxx", t1.a, t2.e
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
!   WHERE t1.a = t2.d;
!  xxx | a | e  
! -----+---+----
!      | 0 |   
!      | 1 | -1
!      | 2 |  2
!      | 2 |  4
!      | 3 | -3
!      | 5 | -5
!      | 5 | -5
! (7 rows)
! 
! --
! -- CROSS JOIN
! -- Qualifications are not allowed on cross joins,
! -- which degenerate into a standard unqualified inner join.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL;
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 1 | -1
!      | 3 | 2 | three | 1 | -1
!      | 4 | 1 | four  | 1 | -1
!      | 5 | 0 | five  | 1 | -1
!      | 6 | 6 | six   | 1 | -1
!      | 7 | 7 | seven | 1 | -1
!      | 8 | 8 | eight | 1 | -1
!      | 0 |   | zero  | 1 | -1
!      |   |   | null  | 1 | -1
!      |   | 0 | zero  | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 2 | 3 | two   | 2 |  2
!      | 3 | 2 | three | 2 |  2
!      | 4 | 1 | four  | 2 |  2
!      | 5 | 0 | five  | 2 |  2
!      | 6 | 6 | six   | 2 |  2
!      | 7 | 7 | seven | 2 |  2
!      | 8 | 8 | eight | 2 |  2
!      | 0 |   | zero  | 2 |  2
!      |   |   | null  | 2 |  2
!      |   | 0 | zero  | 2 |  2
!      | 1 | 4 | one   | 3 | -3
!      | 2 | 3 | two   | 3 | -3
!      | 3 | 2 | three | 3 | -3
!      | 4 | 1 | four  | 3 | -3
!      | 5 | 0 | five  | 3 | -3
!      | 6 | 6 | six   | 3 | -3
!      | 7 | 7 | seven | 3 | -3
!      | 8 | 8 | eight | 3 | -3
!      | 0 |   | zero  | 3 | -3
!      |   |   | null  | 3 | -3
!      |   | 0 | zero  | 3 | -3
!      | 1 | 4 | one   | 2 |  4
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 2 |  4
!      | 4 | 1 | four  | 2 |  4
!      | 5 | 0 | five  | 2 |  4
!      | 6 | 6 | six   | 2 |  4
!      | 7 | 7 | seven | 2 |  4
!      | 8 | 8 | eight | 2 |  4
!      | 0 |   | zero  | 2 |  4
!      |   |   | null  | 2 |  4
!      |   | 0 | zero  | 2 |  4
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      | 1 | 4 | one   | 0 |   
!      | 2 | 3 | two   | 0 |   
!      | 3 | 2 | three | 0 |   
!      | 4 | 1 | four  | 0 |   
!      | 5 | 0 | five  | 0 |   
!      | 6 | 6 | six   | 0 |   
!      | 7 | 7 | seven | 0 |   
!      | 8 | 8 | eight | 0 |   
!      | 0 |   | zero  | 0 |   
!      |   |   | null  | 0 |   
!      |   | 0 | zero  | 0 |   
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight |   |   
!      | 0 |   | zero  |   |   
!      |   |   | null  |   |   
!      |   | 0 | zero  |   |   
!      | 1 | 4 | one   |   |  0
!      | 2 | 3 | two   |   |  0
!      | 3 | 2 | three |   |  0
!      | 4 | 1 | four  |   |  0
!      | 5 | 0 | five  |   |  0
!      | 6 | 6 | six   |   |  0
!      | 7 | 7 | seven |   |  0
!      | 8 | 8 | eight |   |  0
!      | 0 |   | zero  |   |  0
!      |   |   | null  |   |  0
!      |   | 0 | zero  |   |  0
! (99 rows)
! 
! -- ambiguous column
! SELECT '' AS "xxx", i, k, t
!   FROM J1_TBL CROSS JOIN J2_TBL;
! ERROR:  column reference "i" is ambiguous
! LINE 1: SELECT '' AS "xxx", i, k, t
!                             ^
! -- resolve previous ambiguity by specifying the table name
! SELECT '' AS "xxx", t1.i, k, t
!   FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
!  xxx | i | k  |   t   
! -----+---+----+-------
!      | 1 | -1 | one
!      | 2 | -1 | two
!      | 3 | -1 | three
!      | 4 | -1 | four
!      | 5 | -1 | five
!      | 6 | -1 | six
!      | 7 | -1 | seven
!      | 8 | -1 | eight
!      | 0 | -1 | zero
!      |   | -1 | null
!      |   | -1 | zero
!      | 1 |  2 | one
!      | 2 |  2 | two
!      | 3 |  2 | three
!      | 4 |  2 | four
!      | 5 |  2 | five
!      | 6 |  2 | six
!      | 7 |  2 | seven
!      | 8 |  2 | eight
!      | 0 |  2 | zero
!      |   |  2 | null
!      |   |  2 | zero
!      | 1 | -3 | one
!      | 2 | -3 | two
!      | 3 | -3 | three
!      | 4 | -3 | four
!      | 5 | -3 | five
!      | 6 | -3 | six
!      | 7 | -3 | seven
!      | 8 | -3 | eight
!      | 0 | -3 | zero
!      |   | -3 | null
!      |   | -3 | zero
!      | 1 |  4 | one
!      | 2 |  4 | two
!      | 3 |  4 | three
!      | 4 |  4 | four
!      | 5 |  4 | five
!      | 6 |  4 | six
!      | 7 |  4 | seven
!      | 8 |  4 | eight
!      | 0 |  4 | zero
!      |   |  4 | null
!      |   |  4 | zero
!      | 1 | -5 | one
!      | 2 | -5 | two
!      | 3 | -5 | three
!      | 4 | -5 | four
!      | 5 | -5 | five
!      | 6 | -5 | six
!      | 7 | -5 | seven
!      | 8 | -5 | eight
!      | 0 | -5 | zero
!      |   | -5 | null
!      |   | -5 | zero
!      | 1 | -5 | one
!      | 2 | -5 | two
!      | 3 | -5 | three
!      | 4 | -5 | four
!      | 5 | -5 | five
!      | 6 | -5 | six
!      | 7 | -5 | seven
!      | 8 | -5 | eight
!      | 0 | -5 | zero
!      |   | -5 | null
!      |   | -5 | zero
!      | 1 |    | one
!      | 2 |    | two
!      | 3 |    | three
!      | 4 |    | four
!      | 5 |    | five
!      | 6 |    | six
!      | 7 |    | seven
!      | 8 |    | eight
!      | 0 |    | zero
!      |   |    | null
!      |   |    | zero
!      | 1 |    | one
!      | 2 |    | two
!      | 3 |    | three
!      | 4 |    | four
!      | 5 |    | five
!      | 6 |    | six
!      | 7 |    | seven
!      | 8 |    | eight
!      | 0 |    | zero
!      |   |    | null
!      |   |    | zero
!      | 1 |  0 | one
!      | 2 |  0 | two
!      | 3 |  0 | three
!      | 4 |  0 | four
!      | 5 |  0 | five
!      | 6 |  0 | six
!      | 7 |  0 | seven
!      | 8 |  0 | eight
!      | 0 |  0 | zero
!      |   |  0 | null
!      |   |  0 | zero
! (99 rows)
! 
! SELECT '' AS "xxx", ii, tt, kk
!   FROM (J1_TBL CROSS JOIN J2_TBL)
!     AS tx (ii, jj, tt, ii2, kk);
!  xxx | ii |  tt   | kk 
! -----+----+-------+----
!      |  1 | one   | -1
!      |  2 | two   | -1
!      |  3 | three | -1
!      |  4 | four  | -1
!      |  5 | five  | -1
!      |  6 | six   | -1
!      |  7 | seven | -1
!      |  8 | eight | -1
!      |  0 | zero  | -1
!      |    | null  | -1
!      |    | zero  | -1
!      |  1 | one   |  2
!      |  2 | two   |  2
!      |  3 | three |  2
!      |  4 | four  |  2
!      |  5 | five  |  2
!      |  6 | six   |  2
!      |  7 | seven |  2
!      |  8 | eight |  2
!      |  0 | zero  |  2
!      |    | null  |  2
!      |    | zero  |  2
!      |  1 | one   | -3
!      |  2 | two   | -3
!      |  3 | three | -3
!      |  4 | four  | -3
!      |  5 | five  | -3
!      |  6 | six   | -3
!      |  7 | seven | -3
!      |  8 | eight | -3
!      |  0 | zero  | -3
!      |    | null  | -3
!      |    | zero  | -3
!      |  1 | one   |  4
!      |  2 | two   |  4
!      |  3 | three |  4
!      |  4 | four  |  4
!      |  5 | five  |  4
!      |  6 | six   |  4
!      |  7 | seven |  4
!      |  8 | eight |  4
!      |  0 | zero  |  4
!      |    | null  |  4
!      |    | zero  |  4
!      |  1 | one   | -5
!      |  2 | two   | -5
!      |  3 | three | -5
!      |  4 | four  | -5
!      |  5 | five  | -5
!      |  6 | six   | -5
!      |  7 | seven | -5
!      |  8 | eight | -5
!      |  0 | zero  | -5
!      |    | null  | -5
!      |    | zero  | -5
!      |  1 | one   | -5
!      |  2 | two   | -5
!      |  3 | three | -5
!      |  4 | four  | -5
!      |  5 | five  | -5
!      |  6 | six   | -5
!      |  7 | seven | -5
!      |  8 | eight | -5
!      |  0 | zero  | -5
!      |    | null  | -5
!      |    | zero  | -5
!      |  1 | one   |   
!      |  2 | two   |   
!      |  3 | three |   
!      |  4 | four  |   
!      |  5 | five  |   
!      |  6 | six   |   
!      |  7 | seven |   
!      |  8 | eight |   
!      |  0 | zero  |   
!      |    | null  |   
!      |    | zero  |   
!      |  1 | one   |   
!      |  2 | two   |   
!      |  3 | three |   
!      |  4 | four  |   
!      |  5 | five  |   
!      |  6 | six   |   
!      |  7 | seven |   
!      |  8 | eight |   
!      |  0 | zero  |   
!      |    | null  |   
!      |    | zero  |   
!      |  1 | one   |  0
!      |  2 | two   |  0
!      |  3 | three |  0
!      |  4 | four  |  0
!      |  5 | five  |  0
!      |  6 | six   |  0
!      |  7 | seven |  0
!      |  8 | eight |  0
!      |  0 | zero  |  0
!      |    | null  |  0
!      |    | zero  |  0
! (99 rows)
! 
! SELECT '' AS "xxx", tx.ii, tx.jj, tx.kk
!   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
!     AS tx (ii, jj, tt, ii2, kk);
!  xxx | ii | jj | kk 
! -----+----+----+----
!      |  1 |  4 | -1
!      |  2 |  3 | -1
!      |  3 |  2 | -1
!      |  4 |  1 | -1
!      |  5 |  0 | -1
!      |  6 |  6 | -1
!      |  7 |  7 | -1
!      |  8 |  8 | -1
!      |  0 |    | -1
!      |    |    | -1
!      |    |  0 | -1
!      |  1 |  4 |  2
!      |  2 |  3 |  2
!      |  3 |  2 |  2
!      |  4 |  1 |  2
!      |  5 |  0 |  2
!      |  6 |  6 |  2
!      |  7 |  7 |  2
!      |  8 |  8 |  2
!      |  0 |    |  2
!      |    |    |  2
!      |    |  0 |  2
!      |  1 |  4 | -3
!      |  2 |  3 | -3
!      |  3 |  2 | -3
!      |  4 |  1 | -3
!      |  5 |  0 | -3
!      |  6 |  6 | -3
!      |  7 |  7 | -3
!      |  8 |  8 | -3
!      |  0 |    | -3
!      |    |    | -3
!      |    |  0 | -3
!      |  1 |  4 |  4
!      |  2 |  3 |  4
!      |  3 |  2 |  4
!      |  4 |  1 |  4
!      |  5 |  0 |  4
!      |  6 |  6 |  4
!      |  7 |  7 |  4
!      |  8 |  8 |  4
!      |  0 |    |  4
!      |    |    |  4
!      |    |  0 |  4
!      |  1 |  4 | -5
!      |  2 |  3 | -5
!      |  3 |  2 | -5
!      |  4 |  1 | -5
!      |  5 |  0 | -5
!      |  6 |  6 | -5
!      |  7 |  7 | -5
!      |  8 |  8 | -5
!      |  0 |    | -5
!      |    |    | -5
!      |    |  0 | -5
!      |  1 |  4 | -5
!      |  2 |  3 | -5
!      |  3 |  2 | -5
!      |  4 |  1 | -5
!      |  5 |  0 | -5
!      |  6 |  6 | -5
!      |  7 |  7 | -5
!      |  8 |  8 | -5
!      |  0 |    | -5
!      |    |    | -5
!      |    |  0 | -5
!      |  1 |  4 |   
!      |  2 |  3 |   
!      |  3 |  2 |   
!      |  4 |  1 |   
!      |  5 |  0 |   
!      |  6 |  6 |   
!      |  7 |  7 |   
!      |  8 |  8 |   
!      |  0 |    |   
!      |    |    |   
!      |    |  0 |   
!      |  1 |  4 |   
!      |  2 |  3 |   
!      |  3 |  2 |   
!      |  4 |  1 |   
!      |  5 |  0 |   
!      |  6 |  6 |   
!      |  7 |  7 |   
!      |  8 |  8 |   
!      |  0 |    |   
!      |    |    |   
!      |    |  0 |   
!      |  1 |  4 |  0
!      |  2 |  3 |  0
!      |  3 |  2 |  0
!      |  4 |  1 |  0
!      |  5 |  0 |  0
!      |  6 |  6 |  0
!      |  7 |  7 |  0
!      |  8 |  8 |  0
!      |  0 |    |  0
!      |    |    |  0
!      |    |  0 |  0
! (99 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
!  xxx | i | j |   t   | i | k  | i | k  
! -----+---+---+-------+---+----+---+----
!      | 1 | 4 | one   | 1 | -1 | 1 | -1
!      | 1 | 4 | one   | 1 | -1 | 2 |  2
!      | 1 | 4 | one   | 1 | -1 | 3 | -3
!      | 1 | 4 | one   | 1 | -1 | 2 |  4
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 | 0 |   
!      | 1 | 4 | one   | 1 | -1 |   |   
!      | 1 | 4 | one   | 1 | -1 |   |  0
!      | 2 | 3 | two   | 1 | -1 | 1 | -1
!      | 2 | 3 | two   | 1 | -1 | 2 |  2
!      | 2 | 3 | two   | 1 | -1 | 3 | -3
!      | 2 | 3 | two   | 1 | -1 | 2 |  4
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 | 0 |   
!      | 2 | 3 | two   | 1 | -1 |   |   
!      | 2 | 3 | two   | 1 | -1 |   |  0
!      | 3 | 2 | three | 1 | -1 | 1 | -1
!      | 3 | 2 | three | 1 | -1 | 2 |  2
!      | 3 | 2 | three | 1 | -1 | 3 | -3
!      | 3 | 2 | three | 1 | -1 | 2 |  4
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 | 0 |   
!      | 3 | 2 | three | 1 | -1 |   |   
!      | 3 | 2 | three | 1 | -1 |   |  0
!      | 4 | 1 | four  | 1 | -1 | 1 | -1
!      | 4 | 1 | four  | 1 | -1 | 2 |  2
!      | 4 | 1 | four  | 1 | -1 | 3 | -3
!      | 4 | 1 | four  | 1 | -1 | 2 |  4
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 | 0 |   
!      | 4 | 1 | four  | 1 | -1 |   |   
!      | 4 | 1 | four  | 1 | -1 |   |  0
!      | 5 | 0 | five  | 1 | -1 | 1 | -1
!      | 5 | 0 | five  | 1 | -1 | 2 |  2
!      | 5 | 0 | five  | 1 | -1 | 3 | -3
!      | 5 | 0 | five  | 1 | -1 | 2 |  4
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 | 0 |   
!      | 5 | 0 | five  | 1 | -1 |   |   
!      | 5 | 0 | five  | 1 | -1 |   |  0
!      | 6 | 6 | six   | 1 | -1 | 1 | -1
!      | 6 | 6 | six   | 1 | -1 | 2 |  2
!      | 6 | 6 | six   | 1 | -1 | 3 | -3
!      | 6 | 6 | six   | 1 | -1 | 2 |  4
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 | 0 |   
!      | 6 | 6 | six   | 1 | -1 |   |   
!      | 6 | 6 | six   | 1 | -1 |   |  0
!      | 7 | 7 | seven | 1 | -1 | 1 | -1
!      | 7 | 7 | seven | 1 | -1 | 2 |  2
!      | 7 | 7 | seven | 1 | -1 | 3 | -3
!      | 7 | 7 | seven | 1 | -1 | 2 |  4
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 | 0 |   
!      | 7 | 7 | seven | 1 | -1 |   |   
!      | 7 | 7 | seven | 1 | -1 |   |  0
!      | 8 | 8 | eight | 1 | -1 | 1 | -1
!      | 8 | 8 | eight | 1 | -1 | 2 |  2
!      | 8 | 8 | eight | 1 | -1 | 3 | -3
!      | 8 | 8 | eight | 1 | -1 | 2 |  4
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 | 0 |   
!      | 8 | 8 | eight | 1 | -1 |   |   
!      | 8 | 8 | eight | 1 | -1 |   |  0
!      | 0 |   | zero  | 1 | -1 | 1 | -1
!      | 0 |   | zero  | 1 | -1 | 2 |  2
!      | 0 |   | zero  | 1 | -1 | 3 | -3
!      | 0 |   | zero  | 1 | -1 | 2 |  4
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 | 0 |   
!      | 0 |   | zero  | 1 | -1 |   |   
!      | 0 |   | zero  | 1 | -1 |   |  0
!      |   |   | null  | 1 | -1 | 1 | -1
!      |   |   | null  | 1 | -1 | 2 |  2
!      |   |   | null  | 1 | -1 | 3 | -3
!      |   |   | null  | 1 | -1 | 2 |  4
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 | 0 |   
!      |   |   | null  | 1 | -1 |   |   
!      |   |   | null  | 1 | -1 |   |  0
!      |   | 0 | zero  | 1 | -1 | 1 | -1
!      |   | 0 | zero  | 1 | -1 | 2 |  2
!      |   | 0 | zero  | 1 | -1 | 3 | -3
!      |   | 0 | zero  | 1 | -1 | 2 |  4
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 | 0 |   
!      |   | 0 | zero  | 1 | -1 |   |   
!      |   | 0 | zero  | 1 | -1 |   |  0
!      | 1 | 4 | one   | 2 |  2 | 1 | -1
!      | 1 | 4 | one   | 2 |  2 | 2 |  2
!      | 1 | 4 | one   | 2 |  2 | 3 | -3
!      | 1 | 4 | one   | 2 |  2 | 2 |  4
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 | 0 |   
!      | 1 | 4 | one   | 2 |  2 |   |   
!      | 1 | 4 | one   | 2 |  2 |   |  0
!      | 2 | 3 | two   | 2 |  2 | 1 | -1
!      | 2 | 3 | two   | 2 |  2 | 2 |  2
!      | 2 | 3 | two   | 2 |  2 | 3 | -3
!      | 2 | 3 | two   | 2 |  2 | 2 |  4
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 | 0 |   
!      | 2 | 3 | two   | 2 |  2 |   |   
!      | 2 | 3 | two   | 2 |  2 |   |  0
!      | 3 | 2 | three | 2 |  2 | 1 | -1
!      | 3 | 2 | three | 2 |  2 | 2 |  2
!      | 3 | 2 | three | 2 |  2 | 3 | -3
!      | 3 | 2 | three | 2 |  2 | 2 |  4
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 | 0 |   
!      | 3 | 2 | three | 2 |  2 |   |   
!      | 3 | 2 | three | 2 |  2 |   |  0
!      | 4 | 1 | four  | 2 |  2 | 1 | -1
!      | 4 | 1 | four  | 2 |  2 | 2 |  2
!      | 4 | 1 | four  | 2 |  2 | 3 | -3
!      | 4 | 1 | four  | 2 |  2 | 2 |  4
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 | 0 |   
!      | 4 | 1 | four  | 2 |  2 |   |   
!      | 4 | 1 | four  | 2 |  2 |   |  0
!      | 5 | 0 | five  | 2 |  2 | 1 | -1
!      | 5 | 0 | five  | 2 |  2 | 2 |  2
!      | 5 | 0 | five  | 2 |  2 | 3 | -3
!      | 5 | 0 | five  | 2 |  2 | 2 |  4
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 | 0 |   
!      | 5 | 0 | five  | 2 |  2 |   |   
!      | 5 | 0 | five  | 2 |  2 |   |  0
!      | 6 | 6 | six   | 2 |  2 | 1 | -1
!      | 6 | 6 | six   | 2 |  2 | 2 |  2
!      | 6 | 6 | six   | 2 |  2 | 3 | -3
!      | 6 | 6 | six   | 2 |  2 | 2 |  4
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 | 0 |   
!      | 6 | 6 | six   | 2 |  2 |   |   
!      | 6 | 6 | six   | 2 |  2 |   |  0
!      | 7 | 7 | seven | 2 |  2 | 1 | -1
!      | 7 | 7 | seven | 2 |  2 | 2 |  2
!      | 7 | 7 | seven | 2 |  2 | 3 | -3
!      | 7 | 7 | seven | 2 |  2 | 2 |  4
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 | 0 |   
!      | 7 | 7 | seven | 2 |  2 |   |   
!      | 7 | 7 | seven | 2 |  2 |   |  0
!      | 8 | 8 | eight | 2 |  2 | 1 | -1
!      | 8 | 8 | eight | 2 |  2 | 2 |  2
!      | 8 | 8 | eight | 2 |  2 | 3 | -3
!      | 8 | 8 | eight | 2 |  2 | 2 |  4
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 | 0 |   
!      | 8 | 8 | eight | 2 |  2 |   |   
!      | 8 | 8 | eight | 2 |  2 |   |  0
!      | 0 |   | zero  | 2 |  2 | 1 | -1
!      | 0 |   | zero  | 2 |  2 | 2 |  2
!      | 0 |   | zero  | 2 |  2 | 3 | -3
!      | 0 |   | zero  | 2 |  2 | 2 |  4
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 | 0 |   
!      | 0 |   | zero  | 2 |  2 |   |   
!      | 0 |   | zero  | 2 |  2 |   |  0
!      |   |   | null  | 2 |  2 | 1 | -1
!      |   |   | null  | 2 |  2 | 2 |  2
!      |   |   | null  | 2 |  2 | 3 | -3
!      |   |   | null  | 2 |  2 | 2 |  4
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 | 0 |   
!      |   |   | null  | 2 |  2 |   |   
!      |   |   | null  | 2 |  2 |   |  0
!      |   | 0 | zero  | 2 |  2 | 1 | -1
!      |   | 0 | zero  | 2 |  2 | 2 |  2
!      |   | 0 | zero  | 2 |  2 | 3 | -3
!      |   | 0 | zero  | 2 |  2 | 2 |  4
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 | 0 |   
!      |   | 0 | zero  | 2 |  2 |   |   
!      |   | 0 | zero  | 2 |  2 |   |  0
!      | 1 | 4 | one   | 3 | -3 | 1 | -1
!      | 1 | 4 | one   | 3 | -3 | 2 |  2
!      | 1 | 4 | one   | 3 | -3 | 3 | -3
!      | 1 | 4 | one   | 3 | -3 | 2 |  4
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 | 0 |   
!      | 1 | 4 | one   | 3 | -3 |   |   
!      | 1 | 4 | one   | 3 | -3 |   |  0
!      | 2 | 3 | two   | 3 | -3 | 1 | -1
!      | 2 | 3 | two   | 3 | -3 | 2 |  2
!      | 2 | 3 | two   | 3 | -3 | 3 | -3
!      | 2 | 3 | two   | 3 | -3 | 2 |  4
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 | 0 |   
!      | 2 | 3 | two   | 3 | -3 |   |   
!      | 2 | 3 | two   | 3 | -3 |   |  0
!      | 3 | 2 | three | 3 | -3 | 1 | -1
!      | 3 | 2 | three | 3 | -3 | 2 |  2
!      | 3 | 2 | three | 3 | -3 | 3 | -3
!      | 3 | 2 | three | 3 | -3 | 2 |  4
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 | 0 |   
!      | 3 | 2 | three | 3 | -3 |   |   
!      | 3 | 2 | three | 3 | -3 |   |  0
!      | 4 | 1 | four  | 3 | -3 | 1 | -1
!      | 4 | 1 | four  | 3 | -3 | 2 |  2
!      | 4 | 1 | four  | 3 | -3 | 3 | -3
!      | 4 | 1 | four  | 3 | -3 | 2 |  4
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 | 0 |   
!      | 4 | 1 | four  | 3 | -3 |   |   
!      | 4 | 1 | four  | 3 | -3 |   |  0
!      | 5 | 0 | five  | 3 | -3 | 1 | -1
!      | 5 | 0 | five  | 3 | -3 | 2 |  2
!      | 5 | 0 | five  | 3 | -3 | 3 | -3
!      | 5 | 0 | five  | 3 | -3 | 2 |  4
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 | 0 |   
!      | 5 | 0 | five  | 3 | -3 |   |   
!      | 5 | 0 | five  | 3 | -3 |   |  0
!      | 6 | 6 | six   | 3 | -3 | 1 | -1
!      | 6 | 6 | six   | 3 | -3 | 2 |  2
!      | 6 | 6 | six   | 3 | -3 | 3 | -3
!      | 6 | 6 | six   | 3 | -3 | 2 |  4
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 | 0 |   
!      | 6 | 6 | six   | 3 | -3 |   |   
!      | 6 | 6 | six   | 3 | -3 |   |  0
!      | 7 | 7 | seven | 3 | -3 | 1 | -1
!      | 7 | 7 | seven | 3 | -3 | 2 |  2
!      | 7 | 7 | seven | 3 | -3 | 3 | -3
!      | 7 | 7 | seven | 3 | -3 | 2 |  4
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 | 0 |   
!      | 7 | 7 | seven | 3 | -3 |   |   
!      | 7 | 7 | seven | 3 | -3 |   |  0
!      | 8 | 8 | eight | 3 | -3 | 1 | -1
!      | 8 | 8 | eight | 3 | -3 | 2 |  2
!      | 8 | 8 | eight | 3 | -3 | 3 | -3
!      | 8 | 8 | eight | 3 | -3 | 2 |  4
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 | 0 |   
!      | 8 | 8 | eight | 3 | -3 |   |   
!      | 8 | 8 | eight | 3 | -3 |   |  0
!      | 0 |   | zero  | 3 | -3 | 1 | -1
!      | 0 |   | zero  | 3 | -3 | 2 |  2
!      | 0 |   | zero  | 3 | -3 | 3 | -3
!      | 0 |   | zero  | 3 | -3 | 2 |  4
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 | 0 |   
!      | 0 |   | zero  | 3 | -3 |   |   
!      | 0 |   | zero  | 3 | -3 |   |  0
!      |   |   | null  | 3 | -3 | 1 | -1
!      |   |   | null  | 3 | -3 | 2 |  2
!      |   |   | null  | 3 | -3 | 3 | -3
!      |   |   | null  | 3 | -3 | 2 |  4
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 | 0 |   
!      |   |   | null  | 3 | -3 |   |   
!      |   |   | null  | 3 | -3 |   |  0
!      |   | 0 | zero  | 3 | -3 | 1 | -1
!      |   | 0 | zero  | 3 | -3 | 2 |  2
!      |   | 0 | zero  | 3 | -3 | 3 | -3
!      |   | 0 | zero  | 3 | -3 | 2 |  4
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 | 0 |   
!      |   | 0 | zero  | 3 | -3 |   |   
!      |   | 0 | zero  | 3 | -3 |   |  0
!      | 1 | 4 | one   | 2 |  4 | 1 | -1
!      | 1 | 4 | one   | 2 |  4 | 2 |  2
!      | 1 | 4 | one   | 2 |  4 | 3 | -3
!      | 1 | 4 | one   | 2 |  4 | 2 |  4
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 | 0 |   
!      | 1 | 4 | one   | 2 |  4 |   |   
!      | 1 | 4 | one   | 2 |  4 |   |  0
!      | 2 | 3 | two   | 2 |  4 | 1 | -1
!      | 2 | 3 | two   | 2 |  4 | 2 |  2
!      | 2 | 3 | two   | 2 |  4 | 3 | -3
!      | 2 | 3 | two   | 2 |  4 | 2 |  4
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 | 0 |   
!      | 2 | 3 | two   | 2 |  4 |   |   
!      | 2 | 3 | two   | 2 |  4 |   |  0
!      | 3 | 2 | three | 2 |  4 | 1 | -1
!      | 3 | 2 | three | 2 |  4 | 2 |  2
!      | 3 | 2 | three | 2 |  4 | 3 | -3
!      | 3 | 2 | three | 2 |  4 | 2 |  4
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 | 0 |   
!      | 3 | 2 | three | 2 |  4 |   |   
!      | 3 | 2 | three | 2 |  4 |   |  0
!      | 4 | 1 | four  | 2 |  4 | 1 | -1
!      | 4 | 1 | four  | 2 |  4 | 2 |  2
!      | 4 | 1 | four  | 2 |  4 | 3 | -3
!      | 4 | 1 | four  | 2 |  4 | 2 |  4
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 | 0 |   
!      | 4 | 1 | four  | 2 |  4 |   |   
!      | 4 | 1 | four  | 2 |  4 |   |  0
!      | 5 | 0 | five  | 2 |  4 | 1 | -1
!      | 5 | 0 | five  | 2 |  4 | 2 |  2
!      | 5 | 0 | five  | 2 |  4 | 3 | -3
!      | 5 | 0 | five  | 2 |  4 | 2 |  4
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 | 0 |   
!      | 5 | 0 | five  | 2 |  4 |   |   
!      | 5 | 0 | five  | 2 |  4 |   |  0
!      | 6 | 6 | six   | 2 |  4 | 1 | -1
!      | 6 | 6 | six   | 2 |  4 | 2 |  2
!      | 6 | 6 | six   | 2 |  4 | 3 | -3
!      | 6 | 6 | six   | 2 |  4 | 2 |  4
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 | 0 |   
!      | 6 | 6 | six   | 2 |  4 |   |   
!      | 6 | 6 | six   | 2 |  4 |   |  0
!      | 7 | 7 | seven | 2 |  4 | 1 | -1
!      | 7 | 7 | seven | 2 |  4 | 2 |  2
!      | 7 | 7 | seven | 2 |  4 | 3 | -3
!      | 7 | 7 | seven | 2 |  4 | 2 |  4
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 | 0 |   
!      | 7 | 7 | seven | 2 |  4 |   |   
!      | 7 | 7 | seven | 2 |  4 |   |  0
!      | 8 | 8 | eight | 2 |  4 | 1 | -1
!      | 8 | 8 | eight | 2 |  4 | 2 |  2
!      | 8 | 8 | eight | 2 |  4 | 3 | -3
!      | 8 | 8 | eight | 2 |  4 | 2 |  4
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 | 0 |   
!      | 8 | 8 | eight | 2 |  4 |   |   
!      | 8 | 8 | eight | 2 |  4 |   |  0
!      | 0 |   | zero  | 2 |  4 | 1 | -1
!      | 0 |   | zero  | 2 |  4 | 2 |  2
!      | 0 |   | zero  | 2 |  4 | 3 | -3
!      | 0 |   | zero  | 2 |  4 | 2 |  4
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 | 0 |   
!      | 0 |   | zero  | 2 |  4 |   |   
!      | 0 |   | zero  | 2 |  4 |   |  0
!      |   |   | null  | 2 |  4 | 1 | -1
!      |   |   | null  | 2 |  4 | 2 |  2
!      |   |   | null  | 2 |  4 | 3 | -3
!      |   |   | null  | 2 |  4 | 2 |  4
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 | 0 |   
!      |   |   | null  | 2 |  4 |   |   
!      |   |   | null  | 2 |  4 |   |  0
!      |   | 0 | zero  | 2 |  4 | 1 | -1
!      |   | 0 | zero  | 2 |  4 | 2 |  2
!      |   | 0 | zero  | 2 |  4 | 3 | -3
!      |   | 0 | zero  | 2 |  4 | 2 |  4
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 | 0 |   
!      |   | 0 | zero  | 2 |  4 |   |   
!      |   | 0 | zero  | 2 |  4 |   |  0
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  | 5 | -5 |   |  0
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  | 5 | -5 |   |  0
!      | 1 | 4 | one   | 0 |    | 1 | -1
!      | 1 | 4 | one   | 0 |    | 2 |  2
!      | 1 | 4 | one   | 0 |    | 3 | -3
!      | 1 | 4 | one   | 0 |    | 2 |  4
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    | 0 |   
!      | 1 | 4 | one   | 0 |    |   |   
!      | 1 | 4 | one   | 0 |    |   |  0
!      | 2 | 3 | two   | 0 |    | 1 | -1
!      | 2 | 3 | two   | 0 |    | 2 |  2
!      | 2 | 3 | two   | 0 |    | 3 | -3
!      | 2 | 3 | two   | 0 |    | 2 |  4
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    | 0 |   
!      | 2 | 3 | two   | 0 |    |   |   
!      | 2 | 3 | two   | 0 |    |   |  0
!      | 3 | 2 | three | 0 |    | 1 | -1
!      | 3 | 2 | three | 0 |    | 2 |  2
!      | 3 | 2 | three | 0 |    | 3 | -3
!      | 3 | 2 | three | 0 |    | 2 |  4
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    | 0 |   
!      | 3 | 2 | three | 0 |    |   |   
!      | 3 | 2 | three | 0 |    |   |  0
!      | 4 | 1 | four  | 0 |    | 1 | -1
!      | 4 | 1 | four  | 0 |    | 2 |  2
!      | 4 | 1 | four  | 0 |    | 3 | -3
!      | 4 | 1 | four  | 0 |    | 2 |  4
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    | 0 |   
!      | 4 | 1 | four  | 0 |    |   |   
!      | 4 | 1 | four  | 0 |    |   |  0
!      | 5 | 0 | five  | 0 |    | 1 | -1
!      | 5 | 0 | five  | 0 |    | 2 |  2
!      | 5 | 0 | five  | 0 |    | 3 | -3
!      | 5 | 0 | five  | 0 |    | 2 |  4
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    | 0 |   
!      | 5 | 0 | five  | 0 |    |   |   
!      | 5 | 0 | five  | 0 |    |   |  0
!      | 6 | 6 | six   | 0 |    | 1 | -1
!      | 6 | 6 | six   | 0 |    | 2 |  2
!      | 6 | 6 | six   | 0 |    | 3 | -3
!      | 6 | 6 | six   | 0 |    | 2 |  4
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    | 0 |   
!      | 6 | 6 | six   | 0 |    |   |   
!      | 6 | 6 | six   | 0 |    |   |  0
!      | 7 | 7 | seven | 0 |    | 1 | -1
!      | 7 | 7 | seven | 0 |    | 2 |  2
!      | 7 | 7 | seven | 0 |    | 3 | -3
!      | 7 | 7 | seven | 0 |    | 2 |  4
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    | 0 |   
!      | 7 | 7 | seven | 0 |    |   |   
!      | 7 | 7 | seven | 0 |    |   |  0
!      | 8 | 8 | eight | 0 |    | 1 | -1
!      | 8 | 8 | eight | 0 |    | 2 |  2
!      | 8 | 8 | eight | 0 |    | 3 | -3
!      | 8 | 8 | eight | 0 |    | 2 |  4
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    | 0 |   
!      | 8 | 8 | eight | 0 |    |   |   
!      | 8 | 8 | eight | 0 |    |   |  0
!      | 0 |   | zero  | 0 |    | 1 | -1
!      | 0 |   | zero  | 0 |    | 2 |  2
!      | 0 |   | zero  | 0 |    | 3 | -3
!      | 0 |   | zero  | 0 |    | 2 |  4
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    | 0 |   
!      | 0 |   | zero  | 0 |    |   |   
!      | 0 |   | zero  | 0 |    |   |  0
!      |   |   | null  | 0 |    | 1 | -1
!      |   |   | null  | 0 |    | 2 |  2
!      |   |   | null  | 0 |    | 3 | -3
!      |   |   | null  | 0 |    | 2 |  4
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    | 0 |   
!      |   |   | null  | 0 |    |   |   
!      |   |   | null  | 0 |    |   |  0
!      |   | 0 | zero  | 0 |    | 1 | -1
!      |   | 0 | zero  | 0 |    | 2 |  2
!      |   | 0 | zero  | 0 |    | 3 | -3
!      |   | 0 | zero  | 0 |    | 2 |  4
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    | 0 |   
!      |   | 0 | zero  | 0 |    |   |   
!      |   | 0 | zero  | 0 |    |   |  0
!      | 1 | 4 | one   |   |    | 1 | -1
!      | 1 | 4 | one   |   |    | 2 |  2
!      | 1 | 4 | one   |   |    | 3 | -3
!      | 1 | 4 | one   |   |    | 2 |  4
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    | 0 |   
!      | 1 | 4 | one   |   |    |   |   
!      | 1 | 4 | one   |   |    |   |  0
!      | 2 | 3 | two   |   |    | 1 | -1
!      | 2 | 3 | two   |   |    | 2 |  2
!      | 2 | 3 | two   |   |    | 3 | -3
!      | 2 | 3 | two   |   |    | 2 |  4
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    | 0 |   
!      | 2 | 3 | two   |   |    |   |   
!      | 2 | 3 | two   |   |    |   |  0
!      | 3 | 2 | three |   |    | 1 | -1
!      | 3 | 2 | three |   |    | 2 |  2
!      | 3 | 2 | three |   |    | 3 | -3
!      | 3 | 2 | three |   |    | 2 |  4
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    | 0 |   
!      | 3 | 2 | three |   |    |   |   
!      | 3 | 2 | three |   |    |   |  0
!      | 4 | 1 | four  |   |    | 1 | -1
!      | 4 | 1 | four  |   |    | 2 |  2
!      | 4 | 1 | four  |   |    | 3 | -3
!      | 4 | 1 | four  |   |    | 2 |  4
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    | 0 |   
!      | 4 | 1 | four  |   |    |   |   
!      | 4 | 1 | four  |   |    |   |  0
!      | 5 | 0 | five  |   |    | 1 | -1
!      | 5 | 0 | five  |   |    | 2 |  2
!      | 5 | 0 | five  |   |    | 3 | -3
!      | 5 | 0 | five  |   |    | 2 |  4
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    | 0 |   
!      | 5 | 0 | five  |   |    |   |   
!      | 5 | 0 | five  |   |    |   |  0
!      | 6 | 6 | six   |   |    | 1 | -1
!      | 6 | 6 | six   |   |    | 2 |  2
!      | 6 | 6 | six   |   |    | 3 | -3
!      | 6 | 6 | six   |   |    | 2 |  4
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    | 0 |   
!      | 6 | 6 | six   |   |    |   |   
!      | 6 | 6 | six   |   |    |   |  0
!      | 7 | 7 | seven |   |    | 1 | -1
!      | 7 | 7 | seven |   |    | 2 |  2
!      | 7 | 7 | seven |   |    | 3 | -3
!      | 7 | 7 | seven |   |    | 2 |  4
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    | 0 |   
!      | 7 | 7 | seven |   |    |   |   
!      | 7 | 7 | seven |   |    |   |  0
!      | 8 | 8 | eight |   |    | 1 | -1
!      | 8 | 8 | eight |   |    | 2 |  2
!      | 8 | 8 | eight |   |    | 3 | -3
!      | 8 | 8 | eight |   |    | 2 |  4
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    | 0 |   
!      | 8 | 8 | eight |   |    |   |   
!      | 8 | 8 | eight |   |    |   |  0
!      | 0 |   | zero  |   |    | 1 | -1
!      | 0 |   | zero  |   |    | 2 |  2
!      | 0 |   | zero  |   |    | 3 | -3
!      | 0 |   | zero  |   |    | 2 |  4
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    | 0 |   
!      | 0 |   | zero  |   |    |   |   
!      | 0 |   | zero  |   |    |   |  0
!      |   |   | null  |   |    | 1 | -1
!      |   |   | null  |   |    | 2 |  2
!      |   |   | null  |   |    | 3 | -3
!      |   |   | null  |   |    | 2 |  4
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    | 0 |   
!      |   |   | null  |   |    |   |   
!      |   |   | null  |   |    |   |  0
!      |   | 0 | zero  |   |    | 1 | -1
!      |   | 0 | zero  |   |    | 2 |  2
!      |   | 0 | zero  |   |    | 3 | -3
!      |   | 0 | zero  |   |    | 2 |  4
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    | 0 |   
!      |   | 0 | zero  |   |    |   |   
!      |   | 0 | zero  |   |    |   |  0
!      | 1 | 4 | one   |   |  0 | 1 | -1
!      | 1 | 4 | one   |   |  0 | 2 |  2
!      | 1 | 4 | one   |   |  0 | 3 | -3
!      | 1 | 4 | one   |   |  0 | 2 |  4
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 | 0 |   
!      | 1 | 4 | one   |   |  0 |   |   
!      | 1 | 4 | one   |   |  0 |   |  0
!      | 2 | 3 | two   |   |  0 | 1 | -1
!      | 2 | 3 | two   |   |  0 | 2 |  2
!      | 2 | 3 | two   |   |  0 | 3 | -3
!      | 2 | 3 | two   |   |  0 | 2 |  4
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 | 0 |   
!      | 2 | 3 | two   |   |  0 |   |   
!      | 2 | 3 | two   |   |  0 |   |  0
!      | 3 | 2 | three |   |  0 | 1 | -1
!      | 3 | 2 | three |   |  0 | 2 |  2
!      | 3 | 2 | three |   |  0 | 3 | -3
!      | 3 | 2 | three |   |  0 | 2 |  4
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 | 0 |   
!      | 3 | 2 | three |   |  0 |   |   
!      | 3 | 2 | three |   |  0 |   |  0
!      | 4 | 1 | four  |   |  0 | 1 | -1
!      | 4 | 1 | four  |   |  0 | 2 |  2
!      | 4 | 1 | four  |   |  0 | 3 | -3
!      | 4 | 1 | four  |   |  0 | 2 |  4
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 | 0 |   
!      | 4 | 1 | four  |   |  0 |   |   
!      | 4 | 1 | four  |   |  0 |   |  0
!      | 5 | 0 | five  |   |  0 | 1 | -1
!      | 5 | 0 | five  |   |  0 | 2 |  2
!      | 5 | 0 | five  |   |  0 | 3 | -3
!      | 5 | 0 | five  |   |  0 | 2 |  4
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 | 0 |   
!      | 5 | 0 | five  |   |  0 |   |   
!      | 5 | 0 | five  |   |  0 |   |  0
!      | 6 | 6 | six   |   |  0 | 1 | -1
!      | 6 | 6 | six   |   |  0 | 2 |  2
!      | 6 | 6 | six   |   |  0 | 3 | -3
!      | 6 | 6 | six   |   |  0 | 2 |  4
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 | 0 |   
!      | 6 | 6 | six   |   |  0 |   |   
!      | 6 | 6 | six   |   |  0 |   |  0
!      | 7 | 7 | seven |   |  0 | 1 | -1
!      | 7 | 7 | seven |   |  0 | 2 |  2
!      | 7 | 7 | seven |   |  0 | 3 | -3
!      | 7 | 7 | seven |   |  0 | 2 |  4
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 | 0 |   
!      | 7 | 7 | seven |   |  0 |   |   
!      | 7 | 7 | seven |   |  0 |   |  0
!      | 8 | 8 | eight |   |  0 | 1 | -1
!      | 8 | 8 | eight |   |  0 | 2 |  2
!      | 8 | 8 | eight |   |  0 | 3 | -3
!      | 8 | 8 | eight |   |  0 | 2 |  4
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 | 0 |   
!      | 8 | 8 | eight |   |  0 |   |   
!      | 8 | 8 | eight |   |  0 |   |  0
!      | 0 |   | zero  |   |  0 | 1 | -1
!      | 0 |   | zero  |   |  0 | 2 |  2
!      | 0 |   | zero  |   |  0 | 3 | -3
!      | 0 |   | zero  |   |  0 | 2 |  4
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 | 0 |   
!      | 0 |   | zero  |   |  0 |   |   
!      | 0 |   | zero  |   |  0 |   |  0
!      |   |   | null  |   |  0 | 1 | -1
!      |   |   | null  |   |  0 | 2 |  2
!      |   |   | null  |   |  0 | 3 | -3
!      |   |   | null  |   |  0 | 2 |  4
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 | 0 |   
!      |   |   | null  |   |  0 |   |   
!      |   |   | null  |   |  0 |   |  0
!      |   | 0 | zero  |   |  0 | 1 | -1
!      |   | 0 | zero  |   |  0 | 2 |  2
!      |   | 0 | zero  |   |  0 | 3 | -3
!      |   | 0 | zero  |   |  0 | 2 |  4
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 | 0 |   
!      |   | 0 | zero  |   |  0 |   |   
!      |   | 0 | zero  |   |  0 |   |  0
! (891 rows)
! 
! --
! --
! -- Inner joins (equi-joins)
! --
! --
! --
! -- Inner joins (equi-joins) with USING clause
! -- The USING syntax changes the shape of the resulting table
! -- by including a column in the USING clause only once in the result.
! --
! -- Inner equi-join on specified column
! SELECT '' AS "xxx", *
!   FROM J1_TBL INNER JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! -- Same as above, slightly different syntax
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
!   ORDER BY a, d;
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
!   ORDER BY b, t1.a;
!  xxx | b | a |   c   | a 
! -----+---+---+-------+---
!      | 0 | 5 | five  |  
!      | 0 |   | zero  |  
!      | 2 | 3 | three | 2
!      | 4 | 1 | one   | 2
! (4 rows)
! 
! --
! -- NATURAL JOIN
! -- Inner equi-join on all columns with the same name
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL NATURAL JOIN J2_TBL;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);
!  xxx | a | b |  c   | d 
! -----+---+---+------+---
!      | 0 |   | zero |  
!      | 2 | 3 | two  | 2
!      | 4 | 1 | four | 2
! (3 rows)
! 
! -- mismatch number of columns
! -- currently, Postgres will fill in with underlying names
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
!  xxx | a | b |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! --
! -- Inner joins (equi-joins)
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 0 |   | zero  | 0 |   
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 2 |  2
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 3 | -3
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
!  xxx | i | j |  t   | i | k 
! -----+---+---+------+---+---
!      | 0 |   | zero |   | 0
!      | 2 | 3 | two  | 2 | 2
!      | 4 | 1 | four | 2 | 4
! (3 rows)
! 
! --
! -- Non-equi-joins
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
!  xxx | i | j |   t   | i | k 
! -----+---+---+-------+---+---
!      | 1 | 4 | one   | 2 | 2
!      | 2 | 3 | two   | 2 | 2
!      | 0 |   | zero  | 2 | 2
!      | 1 | 4 | one   | 2 | 4
!      | 2 | 3 | two   | 2 | 4
!      | 3 | 2 | three | 2 | 4
!      | 4 | 1 | four  | 2 | 4
!      | 0 |   | zero  | 2 | 4
!      | 0 |   | zero  |   | 0
! (9 rows)
! 
! --
! -- Outer joins
! -- Note that OUTER is a noise word
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |   
!      |   |   |       |  0
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |   
!      |   |   |       |  0
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
!  xxx | i | j | t | k 
! -----+---+---+---+---
! (0 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
!  xxx | i | j |  t  | k  
! -----+---+---+-----+----
!      | 1 | 4 | one | -1
! (1 row)
! 
! --
! -- More complicated constructs
! --
! --
! -- Multiway full join
! --
! CREATE TABLE t1 (name TEXT, n INTEGER);
! CREATE TABLE t2 (name TEXT, n INTEGER);
! CREATE TABLE t3 (name TEXT, n INTEGER);
! INSERT INTO t1 VALUES ( 'bb', 11 );
! INSERT INTO t2 VALUES ( 'bb', 12 );
! INSERT INTO t2 VALUES ( 'cc', 22 );
! INSERT INTO t2 VALUES ( 'ee', 42 );
! INSERT INTO t3 VALUES ( 'bb', 13 );
! INSERT INTO t3 VALUES ( 'cc', 23 );
! INSERT INTO t3 VALUES ( 'dd', 33 );
! SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
!  name | n  | n  | n  
! ------+----+----+----
!  bb   | 11 | 12 | 13
!  cc   |    | 22 | 23
!  dd   |    |    | 33
!  ee   |    | 42 |   
! (4 rows)
! 
! --
! -- Test interactions of join syntax and subqueries
! --
! -- Basic cases (we expect planner to pull up the subquery here)
! SELECT * FROM
! (SELECT * FROM t2) as s2
! INNER JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
! (2 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! LEFT JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  ee   | 42 |   
! (3 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! FULL JOIN
! (SELECT * FROM t3) s3
! USING (name);
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  dd   |    | 33
!  ee   | 42 |   
! (4 rows)
! 
! -- Cases with non-nullable expressions in subquery results;
! -- make sure these go to null as expected
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
! (2 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL LEFT JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  ee   |   42 |    2 |      |     
! (3 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  dd   |      |      |   33 |    3
!  ee   |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL INNER JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
! (1 row)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL FULL JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
!  cc   |      |      |   22 |    2 |   23 |    3
!  dd   |      |      |      |      |   33 |    3
!  ee   |      |      |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2;
!  name | s1_n | s2_n | s3_n 
! ------+------+------+------
!  bb   |   11 |   12 |   13
!  cc   |      |   22 |   23
!  dd   |      |      |   33
!  ee   |      |   42 |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2;
!  name | s1_n | s2_n | s2_2 | s3_n 
! ------+------+------+------+------
!  bb   |   11 |   12 |    2 |   13
!  cc   |      |   22 |    2 |   23
!  dd   |      |      |      |   33
!  ee   |      |   42 |    2 |     
! (4 rows)
! 
! -- Test for propagation of nullability constraints into sub-joins
! create temp table x (x1 int, x2 int);
! insert into x values (1,11);
! insert into x values (2,22);
! insert into x values (3,null);
! insert into x values (4,44);
! insert into x values (5,null);
! create temp table y (y1 int, y2 int);
! insert into y values (1,111);
! insert into y values (2,222);
! insert into y values (3,333);
! insert into y values (4,null);
! select * from x;
!  x1 | x2 
! ----+----
!   1 | 11
!   2 | 22
!   3 |   
!   4 | 44
!   5 |   
! (5 rows)
! 
! select * from y;
!  y1 | y2  
! ----+-----
!   1 | 111
!   2 | 222
!   3 | 333
!   4 |    
! (4 rows)
! 
! select * from x left join y on (x1 = y1 and x2 is not null);
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |    |    
!   4 | 44 |  4 |    
!   5 |    |    |    
! (5 rows)
! 
! select * from x left join y on (x1 = y1 and y2 is not null);
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |  3 | 333
!   4 | 44 |    |    
!   5 |    |    |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |   5 |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and x2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and y2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |     |    
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and xx2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! -- these should NOT give the same answers as above
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (x2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (y2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (xx2 is not null);
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! --
! -- regression test: check for bug with propagation of implied equality
! -- to outside an IN
! --
! select count(*) from tenk1 a where unique1 in
!   (select unique1 from tenk1 b join tenk1 c using (unique1)
!    where b.unique2 = 42);
!  count 
! -------
!      1
! (1 row)
! 
! --
! -- regression test: check for failure to generate a plan with multiple
! -- degenerate IN clauses
! --
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! -- try that with GEQO too
! begin;
! set geqo = on;
! set geqo_threshold = 2;
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! rollback;
! --
! -- Clean up
! --
! DROP TABLE t1;
! DROP TABLE t2;
! DROP TABLE t3;
! DROP TABLE J1_TBL;
! DROP TABLE J2_TBL;
! -- Both DELETE and UPDATE allow the specification of additional tables
! -- to "join" against to determine which rows should be modified.
! CREATE TEMP TABLE t1 (a int, b int);
! CREATE TEMP TABLE t2 (a int, b int);
! CREATE TEMP TABLE t3 (x int, y int);
! INSERT INTO t1 VALUES (5, 10);
! INSERT INTO t1 VALUES (15, 20);
! INSERT INTO t1 VALUES (100, 100);
! INSERT INTO t1 VALUES (200, 1000);
! INSERT INTO t2 VALUES (200, 2000);
! INSERT INTO t3 VALUES (5, 20);
! INSERT INTO t3 VALUES (6, 7);
! INSERT INTO t3 VALUES (7, 8);
! INSERT INTO t3 VALUES (500, 100);
! DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
! SELECT * FROM t3;
!   x  |  y  
! -----+-----
!    6 |   7
!    7 |   8
!  500 | 100
! (3 rows)
! 
! DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
! SELECT * FROM t3;
!  x | y 
! ---+---
!  6 | 7
!  7 | 8
! (2 rows)
! 
! DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
! SELECT * FROM t3;
!  x | y 
! ---+---
! (0 rows)
! 
! -- Test join against inheritance tree
! create temp table t2a () inherits (t2);
! insert into t2a values (200, 2001);
! select * from t1 left join t2 on (t1.a = t2.a);
!   a  |  b   |  a  |  b   
! -----+------+-----+------
!    5 |   10 |     |     
!   15 |   20 |     |     
!  100 |  100 |     |     
!  200 | 1000 | 200 | 2000
!  200 | 1000 | 200 | 2001
! (5 rows)
! 
! --
! -- regression test for 8.1 merge right join bug
! --
! CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
! INSERT INTO tt1 VALUES (1, 11);
! INSERT INTO tt1 VALUES (2, NULL);
! CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
! INSERT INTO tt2 VALUES (21, 11);
! INSERT INTO tt2 VALUES (22, 11);
! set enable_hashjoin to off;
! set enable_nestloop to off;
! -- these should give the same results
! select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! reset enable_hashjoin;
! reset enable_nestloop;
! --
! -- regression test for 8.2 bug with improper re-ordering of left joins
! --
! create temp table tt3(f1 int, f2 text);
! insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
! create index tt3i on tt3(f1);
! analyze tt3;
! create temp table tt4(f1 int);
! insert into tt4 values (0),(1),(9999);
! analyze tt4;
! SELECT a.f1
! FROM tt4 a
! LEFT JOIN (
!         SELECT b.f1
!         FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
!         WHERE c.f1 IS NULL
! ) AS d ON (a.f1 = d.f1)
! WHERE d.f1 IS NULL;
!   f1  
! ------
!     0
!     1
!  9999
! (3 rows)
! 
! --
! -- regression test for problems of the sort depicted in bug #3494
! --
! create temp table tt5(f1 int, f2 int);
! create temp table tt6(f1 int, f2 int);
! insert into tt5 values(1, 10);
! insert into tt5 values(1, 11);
! insert into tt6 values(1, 9);
! insert into tt6 values(1, 2);
! insert into tt6 values(2, 9);
! select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;
!  f1 | f2 | f1 | f2 
! ----+----+----+----
!   1 | 10 |  1 |  9
! (1 row)
! 
! --
! -- regression test for problems of the sort depicted in bug #3588
! --
! create temp table xx (pkxx int);
! create temp table yy (pkyy int, pkxx int);
! insert into xx values (1);
! insert into xx values (2);
! insert into xx values (3);
! insert into yy values (101, 1);
! insert into yy values (201, 2);
! insert into yy values (301, NULL);
! select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
!        xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
! from yy
!      left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
!      left join xx xxa on yya.pkxx = xxa.pkxx
!      left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
!  yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
! ---------+---------+----------+----------+----------
!      101 |       1 |      101 |        1 |        1
!      201 |       2 |          |          |        1
!      301 |         |          |          |        1
! (3 rows)
! 
! --
! -- regression test for improper pushing of constants across outer-join clauses
! -- (as seen in early 8.2.x releases)
! --
! create temp table zt1 (f1 int primary key);
! create temp table zt2 (f2 int primary key);
! create temp table zt3 (f3 int primary key);
! insert into zt1 values(53);
! insert into zt2 values(53);
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zt1 on (f3 = f1)
! where f2 = 53;
!  f2 | f3 | f1 
! ----+----+----
!  53 |    |   
! (1 row)
! 
! create temp view zv1 as select *,'dummy'::text AS junk from zt1;
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zv1 on (f3 = f1)
! where f2 = 53;
!  f2 | f3 | f1 | junk 
! ----+----+----+------
!  53 |    |    | 
! (1 row)
! 
! --
! -- regression test for improper extraction of OR indexqual conditions
! -- (as seen in early 8.3.x releases)
! --
! select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
! from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
! where a.unique1 = 42 and
!       ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
!  unique2 | ten | tenthous | unique2 | hundred 
! ---------+-----+----------+---------+---------
! (0 rows)
! 
! --
! -- test proper positioning of one-time quals in EXISTS (8.4devel bug)
! --
! prepare foo(bool) as
!   select count(*) from tenk1 a left join tenk1 b
!     on (a.unique2 = b.unique1 and exists
!         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
! execute foo(true);
!  count 
! -------
!  10000
! (1 row)
! 
! execute foo(false);
!  count 
! -------
!  10000
! (1 row)
! 
! --
! -- test for sane behavior with noncanonical merge clauses, per bug #4926
! --
! begin;
! set enable_mergejoin = 1;
! set enable_hashjoin = 0;
! set enable_nestloop = 0;
! create temp table a (i integer);
! create temp table b (x integer, y integer);
! select * from a left join b on i = x and i = y and x = i;
!  i | x | y 
! ---+---+---
! (0 rows)
! 
! rollback;
! --
! -- test NULL behavior of whole-row Vars, per bug #5025
! --
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join
!   (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
!   on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! --
! -- test incorrect failure to NULL pulled-up subexpressions
! --
! begin;
! create temp table a (
!      code char not null,
!      constraint a_pk primary key (code)
! );
! create temp table b (
!      a char not null,
!      num integer not null,
!      constraint b_pk primary key (a, num)
! );
! create temp table c (
!      name char not null,
!      a char,
!      constraint c_pk primary key (name)
! );
! insert into a (code) values ('p');
! insert into a (code) values ('q');
! insert into b (a, num) values ('p', 1);
! insert into b (a, num) values ('p', 2);
! insert into c (name, a) values ('A', 'p');
! insert into c (name, a) values ('B', 'q');
! insert into c (name, a) values ('C', null);
! select c.name, ss.code, ss.b_cnt, ss.const
! from c left join
!   (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
!    from a left join
!      (select count(1) as cnt, b.a from b group by b.a) as b_grp
!      on a.code = b_grp.a
!   ) as ss
!   on (c.a = ss.code)
! order by c.name;
!  name | code | b_cnt | const 
! ------+------+-------+-------
!  A    | p    |     2 |    -1
!  B    | q    |     0 |    -1
!  C    |      |       |      
! (3 rows)
! 
! rollback;
! --
! -- test incorrect handling of placeholders that only appear in targetlists,
! -- per bug #6154
! --
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! -- test the path using join aliases, too
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is used as a nestloop parameter
! --
! EXPLAIN (COSTS OFF)
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!                                               QUERY PLAN                                               
! -------------------------------------------------------------------------------------------------------
!  Nested Loop
!    ->  Hash Full Join
!          Hash Cond: (COALESCE(a.q1, 0::bigint) = COALESCE(b.q2, (-1)::bigint))
!          ->  Seq Scan on int8_tbl a
!          ->  Hash
!                ->  Seq Scan on int8_tbl b
!    ->  Index Scan using tenk1_unique2 on tenk1 c
!          Index Cond: (unique2 = COALESCE((COALESCE(a.q1, 0::bigint)), (COALESCE(b.q2, (-1)::bigint))))
! (8 rows)
! 
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!  qq  | unique1 
! -----+---------
!  123 |    4596
!  123 |    4596
!  456 |    7318
! (3 rows)
! 
! --
! -- nested nestloops can require nested PlaceHolderVars
! --
! create temp table nt1 (
!   id int primary key,
!   a1 boolean,
!   a2 boolean
! );
! create temp table nt2 (
!   id int primary key,
!   nt1_id int,
!   b1 boolean,
!   b2 boolean,
!   foreign key (nt1_id) references nt1(id)
! );
! create temp table nt3 (
!   id int primary key,
!   nt2_id int,
!   c1 boolean,
!   foreign key (nt2_id) references nt2(id)
! );
! insert into nt1 values (1,true,true);
! insert into nt1 values (2,true,false);
! insert into nt1 values (3,false,false);
! insert into nt2 values (1,1,true,true);
! insert into nt2 values (2,2,true,false);
! insert into nt2 values (3,3,false,false);
! insert into nt3 values (1,1,true);
! insert into nt3 values (2,2,false);
! insert into nt3 values (3,3,true);
! explain (costs off)
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Nested Loop
!          ->  Index Scan using nt3_pkey on nt3
!                Index Cond: (id = 1)
!          ->  Index Scan using nt2_pkey on nt2
!                Index Cond: (id = nt3.nt2_id)
!    ->  Index Only Scan using nt1_pkey on nt1
!          Index Cond: (id = nt2.nt1_id)
!          Filter: (nt2.b1 AND (id IS NOT NULL))
! (9 rows)
! 
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is propagated into a subquery
! --
! explain (costs off)
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Sort
!    Sort Key: t1.q1, t1.q2
!    ->  Hash Left Join
!          Hash Cond: (t1.q2 = t2.q1)
!          Filter: (1 = (SubPlan 1))
!          ->  Seq Scan on int8_tbl t1
!          ->  Hash
!                ->  Seq Scan on int8_tbl t2
!          SubPlan 1
!            ->  Limit
!                  ->  Result
!                        One-Time Filter: ((42) IS NOT NULL)
!                        ->  Seq Scan on int8_tbl t3
! (13 rows)
! 
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!         q1        |        q2        |        x         | y  
! ------------------+------------------+------------------+----
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
! (8 rows)
! 
! --
! -- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
! --
! select * from int4_tbl a full join int4_tbl b on true;
!      f1      |     f1      
! -------------+-------------
!            0 |           0
!            0 |      123456
!            0 |     -123456
!            0 |  2147483647
!            0 | -2147483647
!       123456 |           0
!       123456 |      123456
!       123456 |     -123456
!       123456 |  2147483647
!       123456 | -2147483647
!      -123456 |           0
!      -123456 |      123456
!      -123456 |     -123456
!      -123456 |  2147483647
!      -123456 | -2147483647
!   2147483647 |           0
!   2147483647 |      123456
!   2147483647 |     -123456
!   2147483647 |  2147483647
!   2147483647 | -2147483647
!  -2147483647 |           0
!  -2147483647 |      123456
!  -2147483647 |     -123456
!  -2147483647 |  2147483647
!  -2147483647 | -2147483647
! (25 rows)
! 
! select * from int4_tbl a full join int4_tbl b on false;
!      f1      |     f1      
! -------------+-------------
!              |           0
!              |      123456
!              |     -123456
!              |  2147483647
!              | -2147483647
!            0 |            
!       123456 |            
!      -123456 |            
!   2147483647 |            
!  -2147483647 |            
! (10 rows)
! 
! --
! -- test for ability to use a cartesian join when necessary
! --
! explain (costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where q1 = thousand or q2 = thousand;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Bitmap Heap Scan on tenk1
!                Recheck Cond: ((q1.q1 = thousand) OR (q2.q2 = thousand))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (q1.q1 = thousand)
!                      ->  Bitmap Index Scan on tenk1_thous_tenthous
!                            Index Cond: (q2.q2 = thousand)
!    ->  Hash
!          ->  Seq Scan on int4_tbl
! (15 rows)
! 
! explain (costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where thousand = (q1 + q2);
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Bitmap Heap Scan on tenk1
!                Recheck Cond: (thousand = (q1.q1 + q2.q2))
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: (thousand = (q1.q1 + q2.q2))
!    ->  Hash
!          ->  Seq Scan on int4_tbl
! (12 rows)
! 
! --
! -- test extraction of restriction OR clauses from join OR clause
! -- (we used to only do this for indexable clauses)
! --
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
!                                            QUERY PLAN                                            
! -------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))
!    ->  Bitmap Heap Scan on tenk1 b
!          Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on tenk1_unique1
!                      Index Cond: (unique1 = 2)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
! (17 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))
!    ->  Seq Scan on tenk1 b
!          Filter: ((unique1 = 2) OR (ten = 4))
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
! (12 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or
!   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
!                                                       QUERY PLAN                                                      
! ----------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))
!    ->  Bitmap Heap Scan on tenk1 b
!          Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on tenk1_unique1
!                      Index Cond: (unique1 = 2)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Bitmap Heap Scan on tenk1 a
!                Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 1)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 3)
!                      ->  Bitmap Index Scan on tenk1_unique2
!                            Index Cond: (unique2 = 7)
! (19 rows)
! 
! --
! -- test placement of movable quals in a parameterized join tree
! --
! explain (costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten = t3.ten
! where t1.unique1 = 1;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Nested Loop Left Join
!    ->  Index Scan using tenk1_unique1 on tenk1 t1
!          Index Cond: (unique1 = 1)
!    ->  Nested Loop
!          Join Filter: (t1.ten = t3.ten)
!          ->  Bitmap Heap Scan on tenk1 t2
!                Recheck Cond: (t1.hundred = hundred)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (t1.hundred = hundred)
!          ->  Index Scan using tenk1_unique2 on tenk1 t3
!                Index Cond: (unique2 = t2.thousand)
! (11 rows)
! 
! explain (costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
! where t1.unique1 = 1;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Nested Loop Left Join
!    ->  Index Scan using tenk1_unique1 on tenk1 t1
!          Index Cond: (unique1 = 1)
!    ->  Nested Loop
!          Join Filter: ((t1.ten + t2.ten) = t3.ten)
!          ->  Bitmap Heap Scan on tenk1 t2
!                Recheck Cond: (t1.hundred = hundred)
!                ->  Bitmap Index Scan on tenk1_hundred
!                      Index Cond: (t1.hundred = hundred)
!          ->  Index Scan using tenk1_unique2 on tenk1 t3
!                Index Cond: (unique2 = t2.thousand)
! (11 rows)
! 
! explain (costs off)
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Aggregate
!    ->  Nested Loop Left Join
!          Join Filter: (a.unique2 = b.unique1)
!          ->  Nested Loop
!                ->  Nested Loop
!                      ->  Seq Scan on int4_tbl
!                      ->  Bitmap Heap Scan on tenk1 b
!                            Recheck Cond: (thousand = int4_tbl.f1)
!                            ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                  Index Cond: (thousand = int4_tbl.f1)
!                ->  Index Scan using tenk1_unique1 on tenk1 a
!                      Index Cond: (unique1 = b.unique2)
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                Index Cond: (thousand = a.thousand)
! (14 rows)
! 
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!  count 
! -------
!     10
! (1 row)
! 
! explain (costs off)
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Sort
!    Sort Key: b.unique1
!    ->  Nested Loop Left Join
!          ->  Seq Scan on int4_tbl i2
!          ->  Nested Loop Left Join
!                Join Filter: (b.unique1 = 42)
!                ->  Nested Loop
!                      ->  Nested Loop
!                            ->  Seq Scan on int4_tbl i1
!                            ->  Index Scan using tenk1_thous_tenthous on tenk1 b
!                                  Index Cond: ((thousand = i1.f1) AND (i2.f1 = tenthous))
!                      ->  Index Scan using tenk1_unique1 on tenk1 a
!                            Index Cond: (unique1 = b.unique2)
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                      Index Cond: (thousand = a.thousand)
! (15 rows)
! 
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!  unique1 
! ---------
!        0
!         
!         
!         
!         
! (5 rows)
! 
! explain (costs off)
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: ((COALESCE(tenk1.unique1, (-1)) + int8_tbl.q1) = 122)
!    ->  Seq Scan on int8_tbl
!    ->  Index Scan using tenk1_unique2 on tenk1
!          Index Cond: (int8_tbl.q2 = unique2)
! (5 rows)
! 
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!  unique1 | q1  | fault 
! ---------+-----+-------
!          | 123 |   122
! (1 row)
! 
! --
! -- test handling of potential equivalence clauses above outer joins
! --
! explain (costs off)
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: ((COALESCE(b.thousand, 123) = a.q1) AND (a.q1 = COALESCE(b.hundred, 123)))
!    ->  Seq Scan on int8_tbl a
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (a.q1 = unique2)
! (5 rows)
! 
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!  q1 | unique2 | thousand | hundred 
! ----+---------+----------+---------
! (0 rows)
! 
! explain (costs off)
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Nested Loop Left Join
!    Filter: (CASE WHEN (b.unique2 IS NULL) THEN a.f1 ELSE 0 END = 0)
!    ->  Seq Scan on int4_tbl a
!    ->  Index Only Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = a.f1)
! (5 rows)
! 
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!  f1 | unique2 | case 
! ----+---------+------
!   0 |       0 |    0
! (1 row)
! 
! --
! -- another case with equivalence clauses above outer joins (bug #8591)
! --
! explain (costs off)
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 = 5530 and coalesce(b.twothousand, a.twothousand) = 44;
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Nested Loop Left Join
!    ->  Nested Loop Left Join
!          Filter: (COALESCE(b.twothousand, a.twothousand) = 44)
!          ->  Index Scan using tenk1_unique2 on tenk1 a
!                Index Cond: (unique2 = 5530)
!          ->  Bitmap Heap Scan on tenk1 b
!                Recheck Cond: (thousand = a.unique1)
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: (thousand = a.unique1)
!    ->  Index Scan using tenk1_unique2 on tenk1 c
!          Index Cond: ((unique2 = COALESCE(b.twothousand, a.twothousand)) AND (unique2 = 44))
! (11 rows)
! 
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 = 5530 and coalesce(b.twothousand, a.twothousand) = 44;
!  unique1 | unique1 | unique1 | coalesce 
! ---------+---------+---------+----------
! (0 rows)
! 
! --
! -- check handling of join aliases when flattening multiple levels of subquery
! --
! explain (verbose, costs off)
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Nested Loop Left Join
!    Output: "*VALUES*".column1, i1.f1, (666)
!    Join Filter: ("*VALUES*".column1 = i1.f1)
!    ->  Values Scan on "*VALUES*"
!          Output: "*VALUES*".column1
!    ->  Materialize
!          Output: i1.f1, (666)
!          ->  Nested Loop Left Join
!                Output: i1.f1, 666
!                ->  Seq Scan on public.int4_tbl i1
!                      Output: i1.f1
!                ->  Index Only Scan using tenk1_unique2 on public.tenk1 i2
!                      Output: i2.unique2
!                      Index Cond: (i2.unique2 = i1.f1)
! (14 rows)
! 
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!  foo1_id | foo3_id | bug_field 
! ---------+---------+-----------
!        0 |       0 |       666
!        1 |         |          
! (2 rows)
! 
! --
! -- test ability to push constants through outer join clauses
! --
! explain (costs off)
!   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop Left Join
!    Join Filter: (a.f1 = b.unique2)
!    ->  Seq Scan on int4_tbl a
!          Filter: (f1 = 0)
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = 0)
! (6 rows)
! 
! explain (costs off)
!   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Merge Full Join
!    Merge Cond: (a.unique2 = b.unique2)
!    ->  Index Scan using tenk1_unique2 on tenk1 a
!          Index Cond: (unique2 = 42)
!    ->  Index Scan using tenk1_unique2 on tenk1 b
!          Index Cond: (unique2 = 42)
! (6 rows)
! 
! --
! -- test join removal
! --
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
! CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
! CREATE TEMP TABLE c (id int PRIMARY KEY);
! CREATE TEMP TABLE d (a int, b int);
! INSERT INTO a VALUES (0, 0), (1, NULL);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! INSERT INTO c VALUES (0), (1);
! INSERT INTO d VALUES (1,3), (2,2), (3,1);
! -- all three cases should be optimizable into a simple seqscan
! explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on a
! (1 row)
! 
! explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on b
! (1 row)
! 
! explain (costs off)
!   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
!   ON (a.b_id = b.id);
!   QUERY PLAN   
! ---------------
!  Seq Scan on a
! (1 row)
! 
! -- check optimization of outer join within another special join
! explain (costs off)
! select id from a where id in (
! 	select b.id from b left join c on b.id = c.id
! );
!          QUERY PLAN         
! ----------------------------
!  Hash Semi Join
!    Hash Cond: (a.id = b.id)
!    ->  Seq Scan on a
!    ->  Hash
!          ->  Seq Scan on b
! (5 rows)
! 
! -- check that join removal works for a left join when joining a subquery
! -- that is guaranteed to be unique by its GROUP BY clause
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id and d.b = s.c_id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id and d.b = s.c_id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- join removal is not possible when the GROUP BY contains a column that is
! -- not in the join condition
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Merge Left Join
!    Merge Cond: (d.a = s.id)
!    ->  Sort
!          Sort Key: d.a
!          ->  Seq Scan on d
!    ->  Sort
!          Sort Key: s.id
!          ->  Subquery Scan on s
!                ->  HashAggregate
!                      Group Key: b.id, b.c_id
!                      ->  Seq Scan on b
! (11 rows)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Merge Left Join
!    Merge Cond: (d.a = s.id)
!    ->  Sort
!          Sort Key: d.a
!          ->  Seq Scan on d
!    ->  Sort
!          Sort Key: s.id
!          ->  Subquery Scan on s
!                ->  HashAggregate
!                      Group Key: b.id, b.c_id
!                      ->  Seq Scan on b
! (11 rows)
! 
! -- check join removal works when uniqueness of the join condition is enforced
! -- by a UNION
! explain (costs off)
! select d.* from d left join (select id from a union select id from b) s
!   on d.a = s.id;
!   QUERY PLAN   
! ---------------
!  Seq Scan on d
! (1 row)
! 
! -- check join removal with a cross-type comparison operator
! explain (costs off)
! select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
!   on i8.q1 = i4.f1;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on int8_tbl i8
! (1 row)
! 
! rollback;
! create temp table parent (k int primary key, pd int);
! create temp table child (k int unique, cd int);
! insert into parent values (1, 10), (2, 20), (3, 30);
! insert into child values (1, 100), (4, 400);
! -- this case is optimizable
! select p.* from parent p left join child c on (p.k = c.k);
!  k | pd 
! ---+----
!  1 | 10
!  2 | 20
!  3 | 30
! (3 rows)
! 
! explain (costs off)
!   select p.* from parent p left join child c on (p.k = c.k);
!       QUERY PLAN      
! ----------------------
!  Seq Scan on parent p
! (1 row)
! 
! -- this case is not
! select p.*, linked from parent p
!   left join (select c.*, true as linked from child c) as ss
!   on (p.k = ss.k);
!  k | pd | linked 
! ---+----+--------
!  1 | 10 | t
!  2 | 20 | 
!  3 | 30 | 
! (3 rows)
! 
! explain (costs off)
!   select p.*, linked from parent p
!     left join (select c.*, true as linked from child c) as ss
!     on (p.k = ss.k);
!            QUERY PLAN            
! ---------------------------------
!  Hash Left Join
!    Hash Cond: (p.k = c.k)
!    ->  Seq Scan on parent p
!    ->  Hash
!          ->  Seq Scan on child c
! (5 rows)
! 
! -- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (costs off)
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Result
!    One-Time Filter: false
!    ->  Index Scan using parent_pkey on parent p
!          Index Cond: (k = 1)
! (4 rows)
! 
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (costs off)
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- bug 5255: this is not optimizable by join removal
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY);
! CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
! INSERT INTO a VALUES (0), (1);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id | id 
! ----+------+----
!   1 |      |   
! (1 row)
! 
! SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id 
! ----+------
!   1 |     
! (1 row)
! 
! rollback;
! -- another join removal bug: this is not optimizable, either
! begin;
! create temp table innertab (id int8 primary key, dat1 int8);
! insert into innertab values(123, 42);
! SELECT * FROM
!     (SELECT 1 AS x) ss1
!   LEFT JOIN
!     (SELECT q1, q2, COALESCE(dat1, q1) AS y
!      FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
!   ON true;
!  x |        q1        |        q2         |        y         
! ---+------------------+-------------------+------------------
!  1 |              123 |               456 |              123
!  1 |              123 |  4567890123456789 |              123
!  1 | 4567890123456789 |               123 |               42
!  1 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  1 | 4567890123456789 | -4567890123456789 | 4567890123456789
! (5 rows)
! 
! rollback;
! -- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error
! ERROR:  column reference "f1" is ambiguous
! LINE 2: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
!                                                                     ^
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error
! ERROR:  invalid reference to FROM-clause entry for table "y"
! LINE 2: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
!                                                                   ^
! HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok
!  q1 | q2 | f1 | ff 
! ----+----+----+----
! (0 rows)
! 
! --
! -- Test LATERAL
! --
! select unique2, x.*
! from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl b
!    ->  Index Scan using tenk1_unique1 on tenk1 a
!          Index Cond: (unique1 = b.f1)
! (4 rows)
! 
! select unique2, x.*
! from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (unique1 = x.f1)
! (4 rows)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (unique1 = x.f1)
! (4 rows)
! 
! select unique2, x.*
! from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
!  unique2 |     f1      
! ---------+-------------
!     9998 |           0
!          |      123456
!          |     -123456
!          |  2147483647
!          | -2147483647
! (5 rows)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Nested Loop Left Join
!    ->  Seq Scan on int4_tbl x
!    ->  Index Scan using tenk1_unique1 on tenk1
!          Index Cond: (x.f1 = unique1)
! (4 rows)
! 
! -- check scoping of lateral versus parent references
! -- the first of these should return int8_tbl.q2, the second int8_tbl.q1
! select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |         r         
! ------------------+-------------------+-------------------
!               123 |               456 |               456
!               123 |  4567890123456789 |  4567890123456789
!  4567890123456789 |               123 |               123
!  4567890123456789 |  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789 | -4567890123456789
! (5 rows)
! 
! select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |        r         
! ------------------+-------------------+------------------
!               123 |               456 |              123
!               123 |  4567890123456789 |              123
!  4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789
! (5 rows)
! 
! -- lateral with function in FROM
! select count(*) from tenk1 a, lateral generate_series(1,two) g;
!  count 
! -------
!   5000
! (1 row)
! 
! explain (costs off)
!   select count(*) from tenk1 a, lateral generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! explain (costs off)
!   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! -- don't need the explicit LATERAL keyword for functions
! explain (costs off)
!   select count(*) from tenk1 a, generate_series(1,two) g;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (4 rows)
! 
! -- lateral with UNION ALL subselect
! explain (costs off)
!   select * from generate_series(100,200) g,
!     lateral (select * from int8_tbl a where g = q1 union all
!              select * from int8_tbl b where g = q2) ss;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop
!    ->  Function Scan on generate_series g
!    ->  Append
!          ->  Seq Scan on int8_tbl a
!                Filter: (g.g = q1)
!          ->  Seq Scan on int8_tbl b
!                Filter: (g.g = q2)
! (7 rows)
! 
! select * from generate_series(100,200) g,
!   lateral (select * from int8_tbl a where g = q1 union all
!            select * from int8_tbl b where g = q2) ss;
!   g  |        q1        |        q2        
! -----+------------------+------------------
!  123 |              123 |              456
!  123 |              123 | 4567890123456789
!  123 | 4567890123456789 |              123
! (3 rows)
! 
! -- lateral with VALUES
! explain (costs off)
!   select count(*) from tenk1 a,
!     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Aggregate
!    ->  Hash Join
!          Hash Cond: ("*VALUES*".column1 = b.unique2)
!          ->  Nested Loop
!                ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                ->  Values Scan on "*VALUES*"
!          ->  Hash
!                ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (8 rows)
! 
! select count(*) from tenk1 a,
!   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!  count 
! -------
!  10000
! (1 row)
! 
! -- lateral injecting a strange outer join condition
! explain (costs off)
!   select * from int8_tbl a,
!     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!       on x.q2 = ss.z;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop
!    ->  Seq Scan on int8_tbl a
!    ->  Hash Left Join
!          Hash Cond: (x.q2 = (a.q1))
!          ->  Seq Scan on int8_tbl x
!          ->  Hash
!                ->  Seq Scan on int4_tbl y
! (7 rows)
! 
! select * from int8_tbl a,
!   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!     on x.q2 = ss.z;
!         q1        |        q2         |        q1        |        q2         |        z         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |              123 |               456 |                 
!               123 |               456 |              123 |  4567890123456789 |                 
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |  4567890123456789 |                 
!               123 |               456 | 4567890123456789 | -4567890123456789 |                 
!               123 |  4567890123456789 |              123 |               456 |                 
!               123 |  4567890123456789 |              123 |  4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |               123 |              123 |               456 |                 
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |               123 |                 
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |  4567890123456789 |              123 |               456 |                 
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 | -4567890123456789 |              123 |               456 |                 
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789 |                 
! (57 rows)
! 
! -- lateral reference to a join alias variable
! select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (values(x)) ss2(y);
!       x      |     f1      |      y      
! -------------+-------------+-------------
!            0 |           0 |           0
!       123456 |      123456 |      123456
!      -123456 |     -123456 |     -123456
!   2147483647 |  2147483647 |  2147483647
!  -2147483647 | -2147483647 | -2147483647
! (5 rows)
! 
! select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! -- lateral references requiring pullup
! select * from (values(1)) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   1 |  1
!   1 |  2
!   1 |  3
!   1 |  4
! (4 rows)
! 
! select * from (select f1/1000000000 from int4_tbl) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   2 |  2
!   2 |  3
!   2 |  4
!  -2 | -2
!  -2 | -1
!  -2 |  0
!  -2 |  1
!  -2 |  2
!  -2 |  3
!  -2 |  4
! (25 rows)
! 
! select * from (values(1)) x(lb),
!   lateral (values(lb)) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
! (1 row)
! 
! select * from (values(1)) x(lb),
!   lateral (select lb from int4_tbl) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
! (5 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select x.* from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!               123 |  4567890123456789
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (10 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! create temp table dual();
! insert into dual default values;
! analyze dual;
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 from dual union all select x.q2,y.q2 from dual) v(vx,vy);
!         vx         |        vy         
! -------------------+-------------------
!                123 |                  
!                456 |                  
!                123 |  4567890123456789
!   4567890123456789 | -4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |  4567890123456789
!                123 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!                123 |  4567890123456789
!   4567890123456789 |               123
!                123 |               456
!   4567890123456789 |  4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |                  
!  -4567890123456789 |                  
! (20 rows)
! 
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Seq Scan on public.int8_tbl b
!          Output: b.q1, b.q2, a.q2
!          Filter: (a.q2 = b.q1)
! (7 rows)
! 
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join
!   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, b.q2, (COALESCE(a.q2, 42::bigint))
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Seq Scan on public.int8_tbl b
!          Output: b.q1, b.q2, COALESCE(a.q2, 42::bigint)
!          Filter: (a.q2 = b.q1)
! (7 rows)
! 
! select * from
!   int8_tbl a left join
!   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! -- lateral can result in join conditions appearing below their
! -- real semantic level
! explain (verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
!                 QUERY PLAN                 
! -------------------------------------------
!  Hash Left Join
!    Output: i.f1, j.f1
!    Hash Cond: (i.f1 = j.f1)
!    ->  Seq Scan on public.int4_tbl i
!          Output: i.f1
!    ->  Hash
!          Output: j.f1
!          ->  Seq Scan on public.int2_tbl j
!                Output: j.f1
! (9 rows)
! 
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
!      f1      | f1 
! -------------+----
!            0 |  0
!       123456 |   
!      -123456 |   
!   2147483647 |   
!  -2147483647 |   
! (5 rows)
! 
! explain (verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
!              QUERY PLAN              
! -------------------------------------
!  Nested Loop Left Join
!    Output: i.f1, (COALESCE(i.*))
!    ->  Seq Scan on public.int4_tbl i
!          Output: i.f1, i.*
!    ->  Seq Scan on public.int2_tbl j
!          Output: j.f1, COALESCE(i.*)
!          Filter: (i.f1 = j.f1)
! (7 rows)
! 
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
!      f1      | coalesce 
! -------------+----------
!            0 | (0)
!       123456 | 
!      -123456 | 
!   2147483647 | 
!  -2147483647 | 
! (5 rows)
! 
! explain (verbose, costs off)
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    Output: a.f1, b.f1, c.q1, c.q2
!    ->  Seq Scan on public.int4_tbl a
!          Output: a.f1
!    ->  Hash Left Join
!          Output: b.f1, c.q1, c.q2
!          Hash Cond: (b.f1 = c.q1)
!          ->  Seq Scan on public.int4_tbl b
!                Output: b.f1
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!                      Filter: (a.f1 = c.q2)
! (14 rows)
! 
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!      f1      |     f1      | q1 | q2 
! -------------+-------------+----+----
!            0 |           0 |    |   
!            0 |      123456 |    |   
!            0 |     -123456 |    |   
!            0 |  2147483647 |    |   
!            0 | -2147483647 |    |   
!       123456 |           0 |    |   
!       123456 |      123456 |    |   
!       123456 |     -123456 |    |   
!       123456 |  2147483647 |    |   
!       123456 | -2147483647 |    |   
!      -123456 |           0 |    |   
!      -123456 |      123456 |    |   
!      -123456 |     -123456 |    |   
!      -123456 |  2147483647 |    |   
!      -123456 | -2147483647 |    |   
!   2147483647 |           0 |    |   
!   2147483647 |      123456 |    |   
!   2147483647 |     -123456 |    |   
!   2147483647 |  2147483647 |    |   
!   2147483647 | -2147483647 |    |   
!  -2147483647 |           0 |    |   
!  -2147483647 |      123456 |    |   
!  -2147483647 |     -123456 |    |   
!  -2147483647 |  2147483647 |    |   
!  -2147483647 | -2147483647 |    |   
! (25 rows)
! 
! -- lateral reference in a PlaceHolderVar evaluated at join level
! explain (verbose, costs off)
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Nested Loop Left Join
!    Output: a.q1, a.q2, b.q1, c.q1, (LEAST(a.q1, b.q1, c.q1))
!    ->  Seq Scan on public.int8_tbl a
!          Output: a.q1, a.q2
!    ->  Nested Loop
!          Output: b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)
!          Join Filter: (a.q2 = b.q1)
!          ->  Seq Scan on public.int8_tbl b
!                Output: b.q1, b.q2
!          ->  Materialize
!                Output: c.q1
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1
! (13 rows)
! 
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!         q1        |        q2         |       bq1        |       cq1        |      least       
! ------------------+-------------------+------------------+------------------+------------------
!               123 |               456 |                  |                  |                 
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                  |                 
! (42 rows)
! 
! -- case requiring nested PlaceHolderVars
! explain (verbose, costs off)
! select * from
!   int8_tbl c left join (
!     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select ss2.y) ss3;
!                                                                                   QUERY PLAN                                                                                  
! ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, 42::bigint)), d.q1, (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)))
!    ->  Hash Right Join
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, 42::bigint)), (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
!          Hash Cond: (d.q1 = c.q2)
!          ->  Nested Loop
!                Output: a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, 42::bigint)), (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
!                ->  Hash Left Join
!                      Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, 42::bigint))
!                      Hash Cond: (a.q2 = b.q1)
!                      ->  Seq Scan on public.int8_tbl a
!                            Output: a.q1, a.q2
!                      ->  Hash
!                            Output: b.q1, (COALESCE(b.q2, 42::bigint))
!                            ->  Seq Scan on public.int8_tbl b
!                                  Output: b.q1, COALESCE(b.q2, 42::bigint)
!                ->  Seq Scan on public.int8_tbl d
!                      Output: d.q1, COALESCE((COALESCE(b.q2, 42::bigint)), d.q2)
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!    ->  Result
!          Output: (COALESCE((COALESCE(b.q2, 42::bigint)), d.q2))
! (24 rows)
! 
! -- case that breaks the old ph_may_need optimization
! explain (verbose, costs off)
! select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
!   int8_tbl c left join (
!     int8_tbl a left join
!       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
!        where q1 < f1) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select * from int4_tbl i where ss2.y > f1) ss3;
!                                                QUERY PLAN                                                
! ---------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
!    Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
!    ->  Hash Right Join
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!          Hash Cond: (d.q1 = c.q2)
!          ->  Nested Loop
!                Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!                ->  Hash Right Join
!                      Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
!                      Hash Cond: (b.q1 = a.q2)
!                      ->  Nested Loop
!                            Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
!                            Join Filter: (b.q1 < b2.f1)
!                            ->  Seq Scan on public.int8_tbl b
!                                  Output: b.q1, b.q2
!                            ->  Materialize
!                                  Output: b2.f1
!                                  ->  Seq Scan on public.int4_tbl b2
!                                        Output: b2.f1
!                      ->  Hash
!                            Output: a.q1, a.q2
!                            ->  Seq Scan on public.int8_tbl a
!                                  Output: a.q1, a.q2
!                ->  Seq Scan on public.int8_tbl d
!                      Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
!          ->  Hash
!                Output: c.q1, c.q2
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
!    ->  Materialize
!          Output: i.f1
!          ->  Seq Scan on public.int4_tbl i
!                Output: i.f1
! (34 rows)
! 
! -- check processing of postponed quals (bug #9041)
! explain (verbose, costs off)
! select * from
!   (select 1 as x) x cross join (select 2 as y) y
!   left join lateral (
!     select * from (select 3 as z) z where z.z = x.x
!   ) zz on zz.z = y.y;
!                   QUERY PLAN                  
! ----------------------------------------------
!  Nested Loop Left Join
!    Output: (1), (2), (3)
!    Join Filter: (((3) = (1)) AND ((3) = (2)))
!    ->  Nested Loop
!          Output: (1), (2)
!          ->  Result
!                Output: 1
!          ->  Result
!                Output: 2
!    ->  Result
!          Output: 3
! (11 rows)
! 
! -- test some error cases where LATERAL should have been used but wasn't
! select f1,g from int4_tbl a, (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a, (select f1 as g) ss;
!                                              ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a, (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a, (select a.f1 as g) ss;
!                                              ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a cross join (select f1 as g) ss;
!                                                        ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
!                                                        ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! -- SQL:2008 says the left table is in scope but illegal to access here
! select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! -- check we complain about ambiguous table references
! select * from
!   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
! ERROR:  table reference "x" is ambiguous
! LINE 2: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
!                                                              ^
! -- LATERAL can be used to put an aggregate into the FROM clause of its query
! select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
! ERROR:  aggregate functions are not allowed in FROM clause of their own query level
! LINE 1: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
!                                                ^
! -- check behavior of LATERAL in UPDATE/DELETE
! create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
! -- error, can't do this:
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- can't do it even with LATERAL:
! update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- we might in future allow something like this, but for now it's an error:
! update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  table name "xx1" specified more than once
! -- also errors:
! delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/aggregates.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/aggregates.out	2015-01-26 12:33:23.579031290 +0300
***************
*** 1,1582 ****
! --
! -- AGGREGATES
! --
! SELECT avg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
!        avg_32        
! ---------------------
!  32.6666666666666667
! (1 row)
! 
! -- In 7.1, avg(float4) is computed using float8 arithmetic.
! -- Round the result to 3 digits to avoid platform-specific results.
! SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
!  avg_107_943 
! -------------
!      107.943
! (1 row)
! 
! SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
!  avg_3_4 
! ---------
!      3.4
! (1 row)
! 
! SELECT sum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT sum(a) AS sum_198 FROM aggtest;
!  sum_198 
! ---------
!      198
! (1 row)
! 
! SELECT sum(b) AS avg_431_773 FROM aggtest;
!  avg_431_773 
! -------------
!      431.773
! (1 row)
! 
! SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
!  avg_6_8 
! ---------
!      6.8
! (1 row)
! 
! SELECT max(four) AS max_3 FROM onek;
!  max_3 
! -------
!      3
! (1 row)
! 
! SELECT max(a) AS max_100 FROM aggtest;
!  max_100 
! ---------
!      100
! (1 row)
! 
! SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
!  max_324_78 
! ------------
!      324.78
! (1 row)
! 
! SELECT max(student.gpa) AS max_3_7 FROM student;
!  max_3_7 
! ---------
!      3.7
! (1 row)
! 
! SELECT stddev_pop(b) FROM aggtest;
!    stddev_pop    
! -----------------
!  131.10703231895
! (1 row)
! 
! SELECT stddev_samp(b) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389360803998
! (1 row)
! 
! SELECT var_pop(b) FROM aggtest;
!      var_pop      
! ------------------
!  17189.0539234823
! (1 row)
! 
! SELECT var_samp(b) FROM aggtest;
!      var_samp     
! ------------------
!  22918.7385646431
! (1 row)
! 
! SELECT stddev_pop(b::numeric) FROM aggtest;
!     stddev_pop    
! ------------------
!  131.107032862199
! (1 row)
! 
! SELECT stddev_samp(b::numeric) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389361431288
! (1 row)
! 
! SELECT var_pop(b::numeric) FROM aggtest;
!       var_pop       
! --------------------
!  17189.054065929769
! (1 row)
! 
! SELECT var_samp(b::numeric) FROM aggtest;
!       var_samp      
! --------------------
!  22918.738754573025
! (1 row)
! 
! -- population variance is defined for a single tuple, sample variance
! -- is not
! SELECT var_pop(1.0), var_samp(2.0);
!  var_pop | var_samp 
! ---------+----------
!        0 |         
! (1 row)
! 
! SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
!  stddev_pop | stddev_samp 
! ------------+-------------
!           0 |            
! (1 row)
! 
! -- verify correct results for null and NaN inputs
! select sum(null::int4) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::int8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::numeric) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::float8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select avg(null::int4) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::int8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::numeric) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::float8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select sum('NaN'::numeric) from generate_series(1,3);
!  sum 
! -----
!  NaN
! (1 row)
! 
! select avg('NaN'::numeric) from generate_series(1,3);
!  avg 
! -----
!  NaN
! (1 row)
! 
! -- SQL2003 binary aggregates
! SELECT regr_count(b, a) FROM aggtest;
!  regr_count 
! ------------
!           4
! (1 row)
! 
! SELECT regr_sxx(b, a) FROM aggtest;
!  regr_sxx 
! ----------
!      5099
! (1 row)
! 
! SELECT regr_syy(b, a) FROM aggtest;
!      regr_syy     
! ------------------
!  68756.2156939293
! (1 row)
! 
! SELECT regr_sxy(b, a) FROM aggtest;
!      regr_sxy     
! ------------------
!  2614.51582155004
! (1 row)
! 
! SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
!  regr_avgx |    regr_avgy     
! -----------+------------------
!       49.5 | 107.943152273074
! (1 row)
! 
! SELECT regr_r2(b, a) FROM aggtest;
!       regr_r2       
! --------------------
!  0.0194977982031803
! (1 row)
! 
! SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
!     regr_slope     |  regr_intercept  
! -------------------+------------------
!  0.512750700441271 | 82.5619926012309
! (1 row)
! 
! SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
!     covar_pop    |    covar_samp    
! -----------------+------------------
!  653.62895538751 | 871.505273850014
! (1 row)
! 
! SELECT corr(b, a) FROM aggtest;
!        corr        
! -------------------
!  0.139634516517873
! (1 row)
! 
! SELECT count(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT count(DISTINCT four) AS cnt_4 FROM onek;
!  cnt_4 
! -------
!      4
! (1 row)
! 
! select ten, count(*), sum(four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 | 100
!    1 |   100 | 200
!    2 |   100 | 100
!    3 |   100 | 200
!    4 |   100 | 100
!    5 |   100 | 200
!    6 |   100 | 100
!    7 |   100 | 200
!    8 |   100 | 100
!    9 |   100 | 200
! (10 rows)
! 
! select ten, count(four), sum(DISTINCT four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 |   2
!    1 |   100 |   4
!    2 |   100 |   2
!    3 |   100 |   4
!    4 |   100 |   2
!    5 |   100 |   4
!    6 |   100 |   2
!    7 |   100 |   4
!    8 |   100 |   2
!    9 |   100 |   4
! (10 rows)
! 
! -- user-defined aggregates
! SELECT newavg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT newsum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT newcnt(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT newcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT oldcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT sum2(q1,q2) FROM int8_tbl;
!        sum2        
! -------------------
!  18271560493827981
! (1 row)
! 
! -- test for outer-level aggregates
! -- this should work
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four);
!  ten | sum 
! -----+-----
!    0 |   2
!    2 |   2
!    4 |   2
!    6 |   2
!    8 |   2
! (5 rows)
! 
! -- this should fail because subquery has an agg of its own in WHERE
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b
!                where sum(distinct a.four + b.four) = b.four);
! ERROR:  aggregate functions are not allowed in WHERE
! LINE 4:                where sum(distinct a.four + b.four) = b.four)...
!                              ^
! -- Test handling of sublinks within outer-level aggregates.
! -- Per bug report from Daniel Grace.
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
! from tenk1 o;
!  max  
! ------
!  9999
! (1 row)
! 
! --
! -- test for bitwise integer aggregates
! --
! CREATE TEMPORARY TABLE bitwise_test(
!   i2 INT2,
!   i4 INT4,
!   i8 INT8,
!   i INTEGER,
!   x INT2,
!   y BIT(4)
! );
! -- empty case
! SELECT
!   BIT_AND(i2) AS "?",
!   BIT_OR(i4)  AS "?"
! FROM bitwise_test;
!  ? | ? 
! ---+---
!    |  
! (1 row)
! 
! COPY bitwise_test FROM STDIN NULL 'null';
! SELECT
!   BIT_AND(i2) AS "1",
!   BIT_AND(i4) AS "1",
!   BIT_AND(i8) AS "1",
!   BIT_AND(i)  AS "?",
!   BIT_AND(x)  AS "0",
!   BIT_AND(y)  AS "0100",
!   BIT_OR(i2)  AS "7",
!   BIT_OR(i4)  AS "7",
!   BIT_OR(i8)  AS "7",
!   BIT_OR(i)   AS "?",
!   BIT_OR(x)   AS "7",
!   BIT_OR(y)   AS "1101"
! FROM bitwise_test;
!  1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 
! ---+---+---+---+---+------+---+---+---+---+---+------
!  1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101
! (1 row)
! 
! --
! -- test boolean aggregates
! --
! -- first test all possible transition and final states
! SELECT
!   -- boolean and transitions
!   -- null because strict
!   booland_statefunc(NULL, NULL)  IS NULL AS "t",
!   booland_statefunc(TRUE, NULL)  IS NULL AS "t",
!   booland_statefunc(FALSE, NULL) IS NULL AS "t",
!   booland_statefunc(NULL, TRUE)  IS NULL AS "t",
!   booland_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- and actual computations
!   booland_statefunc(TRUE, TRUE) AS "t",
!   NOT booland_statefunc(TRUE, FALSE) AS "t",
!   NOT booland_statefunc(FALSE, TRUE) AS "t",
!   NOT booland_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! SELECT
!   -- boolean or transitions
!   -- null because strict
!   boolor_statefunc(NULL, NULL)  IS NULL AS "t",
!   boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
!   boolor_statefunc(FALSE, NULL) IS NULL AS "t",
!   boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
!   boolor_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- actual computations
!   boolor_statefunc(TRUE, TRUE) AS "t",
!   boolor_statefunc(TRUE, FALSE) AS "t",
!   boolor_statefunc(FALSE, TRUE) AS "t",
!   NOT boolor_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! CREATE TEMPORARY TABLE bool_test(
!   b1 BOOL,
!   b2 BOOL,
!   b3 BOOL,
!   b4 BOOL);
! -- empty case
! SELECT
!   BOOL_AND(b1)   AS "n",
!   BOOL_OR(b3)    AS "n"
! FROM bool_test;
!  n | n 
! ---+---
!    | 
! (1 row)
! 
! COPY bool_test FROM STDIN NULL 'null';
! SELECT
!   BOOL_AND(b1)     AS "f",
!   BOOL_AND(b2)     AS "t",
!   BOOL_AND(b3)     AS "f",
!   BOOL_AND(b4)     AS "n",
!   BOOL_AND(NOT b2) AS "f",
!   BOOL_AND(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   EVERY(b1)     AS "f",
!   EVERY(b2)     AS "t",
!   EVERY(b3)     AS "f",
!   EVERY(b4)     AS "n",
!   EVERY(NOT b2) AS "f",
!   EVERY(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   BOOL_OR(b1)      AS "t",
!   BOOL_OR(b2)      AS "t",
!   BOOL_OR(b3)      AS "f",
!   BOOL_OR(b4)      AS "n",
!   BOOL_OR(NOT b2)  AS "f",
!   BOOL_OR(NOT b3)  AS "t"
! FROM bool_test;
!  t | t | f | n | f | t 
! ---+---+---+---+---+---
!  t | t | f |   | f | t
! (1 row)
! 
! --
! -- Test cases that should be optimized into indexscans instead of
! -- the generic aggregate implementation.
! --
! -- Basic cases
! explain (costs off)
!   select min(unique1) from tenk1;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan using tenk1_unique1 on tenk1
!                  Index Cond: (unique1 IS NOT NULL)
! (5 rows)
! 
! select min(unique1) from tenk1;
!  min 
! -----
!    0
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: (unique1 IS NOT NULL)
! (5 rows)
! 
! select max(unique1) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 < 42;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 < 42;
!  max 
! -----
!   41
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 > 42;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 > 42000;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                  Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
! (5 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42000;
!  max 
! -----
!     
! (1 row)
! 
! -- multi-column index (uses tenk1_thous_tenthous)
! explain (costs off)
!   select max(tenthous) from tenk1 where thousand = 33;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
!                  Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (5 rows)
! 
! select max(tenthous) from tenk1 where thousand = 33;
!  max  
! ------
!  9033
! (1 row)
! 
! explain (costs off)
!   select min(tenthous) from tenk1 where thousand = 33;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                  Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (5 rows)
! 
! select min(tenthous) from tenk1 where thousand = 33;
!  min 
! -----
!   33
! (1 row)
! 
! -- check parameter propagation into an indexscan subquery
! explain (costs off)
!   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
!     from int4_tbl;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Seq Scan on int4_tbl
!    SubPlan 2
!      ->  Result
!            InitPlan 1 (returns $1)
!              ->  Limit
!                    ->  Index Only Scan using tenk1_unique1 on tenk1
!                          Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
! (7 rows)
! 
! select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
!   from int4_tbl;
!      f1      | gt 
! -------------+----
!            0 |  1
!       123456 |   
!      -123456 |  0
!   2147483647 |   
!  -2147483647 |  0
! (5 rows)
! 
! -- check some cases that were handled incorrectly in 8.3.0
! explain (costs off)
!   select distinct max(unique2) from tenk1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  HashAggregate
!    Group Key: $0
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select distinct max(unique2) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by 1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by 1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by max(unique2);
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by max(unique2);
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2) from tenk1 order by max(unique2)+1;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: (($0 + 1))
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2) from tenk1 order by max(unique2)+1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off)
!   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Sort
!    Sort Key: (generate_series(1, 3))
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                  Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (7 rows)
! 
! select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!  max  | g 
! ------+---
!  9999 | 3
!  9999 | 2
!  9999 | 1
! (3 rows)
! 
! -- try it on an inheritance tree
! create table minmaxtest(f1 int);
! create table minmaxtest1() inherits (minmaxtest);
! create table minmaxtest2() inherits (minmaxtest);
! create table minmaxtest3() inherits (minmaxtest);
! create index minmaxtesti on minmaxtest(f1);
! create index minmaxtest1i on minmaxtest1(f1);
! create index minmaxtest2i on minmaxtest2(f1 desc);
! create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
! insert into minmaxtest values(11), (12);
! insert into minmaxtest1 values(13), (14);
! insert into minmaxtest2 values(15), (16);
! insert into minmaxtest3 values(17), (18);
! explain (costs off)
!   select min(f1), max(f1) from minmaxtest;
!                                           QUERY PLAN                                          
! ----------------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest.f1
!                  ->  Index Only Scan using minmaxtesti on minmaxtest
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest1i on minmaxtest1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest3i on minmaxtest3
!                        Index Cond: (f1 IS NOT NULL)
!    InitPlan 2 (returns $1)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest_1.f1
!                  ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
!                        Index Cond: (f1 IS NOT NULL)
! (25 rows)
! 
! select min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! -- DISTINCT doesn't do anything useful here, but it shouldn't fail
! explain (costs off)
!   select distinct min(f1), max(f1) from minmaxtest;
!                                           QUERY PLAN                                          
! ----------------------------------------------------------------------------------------------
!  HashAggregate
!    Group Key: $0, $1
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest.f1
!                  ->  Index Only Scan using minmaxtesti on minmaxtest
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest1i on minmaxtest1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest3i on minmaxtest3
!                        Index Cond: (f1 IS NOT NULL)
!    InitPlan 2 (returns $1)
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: minmaxtest_1.f1
!                  ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
!                        Index Cond: (f1 IS NOT NULL)
!                  ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
!                        Index Cond: (f1 IS NOT NULL)
!    ->  Result
! (27 rows)
! 
! select distinct min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! drop table minmaxtest cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table minmaxtest1
! drop cascades to table minmaxtest2
! drop cascades to table minmaxtest3
! -- check for correct detection of nested-aggregate errors
! select max(min(unique1)) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select max(min(unique1)) from tenk1;
!                    ^
! select (select max(min(unique1)) from int8_tbl) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
!                            ^
! --
! -- Test combinations of DISTINCT and/or ORDER BY
! --
! select array_agg(a order by b)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {3,4,2,1}
! (1 row)
! 
! select array_agg(a order by a)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! select array_agg(a order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {4,3,2,1}
! (1 row)
! 
! select array_agg(b order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {2,1,3,4}
! (1 row)
! 
! select array_agg(distinct a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a desc)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {NULL,3,2,1}
! (1 row)
! 
! select array_agg(distinct a order by a desc nulls last)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {3,2,1,NULL}
! (1 row)
! 
! -- multi-arg aggs, strict/nonstrict, distinct/order by
! select aggfstr(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! -- test specific code paths
! select aggfns(distinct a,a,c order by c using ~<~,a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by c using ~<~)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by a,c using ~<~,b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- check node I/O via view creation and usage, also deparsing logic
! create view agg_view1 as
!   select aggfns(a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c) AS aggfns                                                                            +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by b+1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY (v.b + 1)) AS aggfns                                                         +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,a,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                      aggfns                     
! ------------------------------------------------
!  {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.a, v.c ORDER BY v.b) AS aggfns                                                               +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by c using ~<~)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY v.c USING ~<~ NULLS LAST) AS aggfns                                          +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by a,c using ~<~,b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,2) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 2) i(i);
! (1 row)
! 
! drop view agg_view1;
! -- incorrect DISTINCT usage errors
! select aggfns(distinct a,b,c order by i)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by i)
!                                               ^
! select aggfns(distinct a,b,c order by a,b+1)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b+1)
!                                                 ^
! select aggfns(distinct a,b,c order by a,b,i,c)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
!                                                   ^
! select aggfns(distinct a,a,c order by a,b)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,a,c order by a,b)
!                                                 ^
! -- string_agg tests
! select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
!  string_agg 
! ------------
!  bbbbABcccc
! (1 row)
! 
! select string_agg(a,',') from (values(null),(null)) g(a);
!  string_agg 
! ------------
!  
! (1 row)
! 
! -- check some implicit casting cases, as per bug #5564
! select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
!                                                           ^
! select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
!                                                     ^
! select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! -- string_agg bytea tests
! create table bytea_test_table(v bytea);
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  
! (1 row)
! 
! insert into bytea_test_table values(decode('ff','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xff
! (1 row)
! 
! insert into bytea_test_table values(decode('aa','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, NULL) from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
!  string_agg 
! ------------
!  \xffeeaa
! (1 row)
! 
! drop table bytea_test_table;
! -- FILTER tests
! select min(unique1) filter (where unique1 > 100) from tenk1;
!  min 
! -----
!  101
! (1 row)
! 
! select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
! group by ten;
!  ten | sum 
! -----+-----
!    0 |    
!    1 |    
!    2 |    
!    3 |    
!    4 |    
!    5 |    
!    6 |    
!    7 |    
!    8 |    
!    9 |    
! (10 rows)
! 
! select ten, sum(distinct four) filter (where four > 10) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four);
!  ten | sum 
! -----+-----
!    0 |    
!    2 |    
!    4 |    
!    6 |    
!    8 |    
! (5 rows)
! 
! select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
! from (values ('a', 'b')) AS v(foo,bar);
!  max 
! -----
!  a
! (1 row)
! 
! -- outer reference in FILTER (PostgreSQL extension)
! select (select count(*)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select (select count(*) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
!  count 
! -------
!      2
! (1 row)
! 
! select (select count(inner_c) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
!      filter (where o.unique1 < 10))
! from tenk1 o;					-- outer query is aggregation query
!  max  
! ------
!  9998
! (1 row)
! 
! -- subquery in FILTER clause (PostgreSQL extension)
! select sum(unique1) FILTER (WHERE
!   unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
!  sum  
! ------
!  4950
! (1 row)
! 
! -- exercise lots of aggregate parts with FILTER
! select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!     generate_series(1,2) i;
!           aggfns           
! ---------------------------
!  {"(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- ordered-set aggregates
! select p, percentile_cont(p) within group (order by x::float8)
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
!   p   | percentile_cont 
! ------+-----------------
!     0 |               1
!   0.1 |             1.4
!  0.25 |               2
!   0.4 |             2.6
!   0.5 |               3
!   0.6 |             3.4
!  0.75 |               4
!   0.9 |             4.6
!     1 |               5
! (9 rows)
! 
! select p, percentile_cont(p order by p) within group (order by x)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
! LINE 1: select p, percentile_cont(p order by p) within group (order ...
!                                                 ^
! select p, sum() within group (order by x::float8)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
! LINE 1: select p, sum() within group (order by x::float8)  
!                   ^
! select p, percentile_cont(p,p)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
! LINE 1: select p, percentile_cont(p,p)  
!                   ^
! select percentile_cont(0.5) within group (order by b) from aggtest;
!  percentile_cont  
! ------------------
!  53.4485001564026
! (1 row)
! 
! select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
!  percentile_cont  |   sum   
! ------------------+---------
!  53.4485001564026 | 431.773
! (1 row)
! 
! select percentile_cont(0.5) within group (order by thousand) from tenk1;
!  percentile_cont 
! -----------------
!            499.5
! (1 row)
! 
! select percentile_disc(0.5) within group (order by thousand) from tenk1;
!  percentile_disc 
! -----------------
!              499
! (1 row)
! 
! select rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  rank 
! ------
!     5
! (1 row)
! 
! select cume_dist(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  cume_dist 
! -----------
!      0.875
! (1 row)
! 
! select percent_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
!  percent_rank 
! --------------
!           0.5
! (1 row)
! 
! select dense_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  dense_rank 
! ------------
!           3
! (1 row)
! 
! select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
! from tenk1;
!       percentile_disc       
! ----------------------------
!  {0,99,249,499,749,899,999}
! (1 row)
! 
! select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
! from tenk1;
!        percentile_cont       
! -----------------------------
!  {0,249.75,499.5,749.25,999}
! (1 row)
! 
! select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
! from tenk1;
!          percentile_disc         
! ---------------------------------
!  {{NULL,999,499},{749,249,NULL}}
! (1 row)
! 
! select percentile_cont(array[0,1,0.25,0.75,0.5,1]) within group (order by x)
! from generate_series(1,6) x;
!     percentile_cont    
! -----------------------
!  {1,6,2.25,4.75,3.5,6}
! (1 row)
! 
! select ten, mode() within group (order by string4) from tenk1 group by ten;
!  ten |  mode  
! -----+--------
!    0 | HHHHxx
!    1 | OOOOxx
!    2 | VVVVxx
!    3 | OOOOxx
!    4 | HHHHxx
!    5 | HHHHxx
!    6 | OOOOxx
!    7 | AAAAxx
!    8 | VVVVxx
!    9 | VVVVxx
! (10 rows)
! 
! select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
! from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
!  percentile_disc 
! -----------------
!  {fred,jill,jim}
! (1 row)
! 
! -- check collation propagates up in suitable cases:
! select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
!   from (values ('fred'),('jim')) v(x);
!  pg_collation_for 
! ------------------
!  "POSIX"
! (1 row)
! 
! -- ordered-set aggs created with CREATE AGGREGATE
! select test_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  test_rank 
! -----------
!          5
! (1 row)
! 
! select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
!  test_percentile_disc 
! ----------------------
!                   499
! (1 row)
! 
! -- ordered-set aggs can't use ungrouped vars in direct args:
! select rank(x) within group (order by x) from generate_series(1,5) x;
! ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: select rank(x) within group (order by x) from generate_serie...
!                     ^
! DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
! -- outer-level agg can't use a grouped arg of a lower level, either:
! select array(select percentile_disc(a) within group (order by x)
!                from (values (0.3),(0.7)) v(a) group by a)
!   from generate_series(1,5) g(x);
! ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
! LINE 1: select array(select percentile_disc(a) within group (order b...
!                                             ^
! -- agg in the direct args is a grouping violation, too:
! select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select rank(sum(x)) within group (order by x) from generate_...
!                     ^
! -- hypothetical-set type unification and argument-count failures:
! select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
! ERROR:  WITHIN GROUP types text and integer cannot be matched
! LINE 1: select rank(3) within group (order by x) from (values ('fred...
!                     ^
! select rank(3) within group (order by stringu1,stringu2) from tenk1;
! ERROR:  function rank(integer, name, name) does not exist
! LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
!                ^
! HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
! select rank('fred') within group (order by x) from generate_series(1,5) x;
! ERROR:  invalid input syntax for integer: "fred"
! LINE 1: select rank('fred') within group (order by x) from generate_...
!                     ^
! select rank('adam'::text collate "C") within group (order by x collate "POSIX")
!   from (values ('fred'),('jim')) v(x);
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
!                                                              ^
! -- hypothetical-set type unification successes:
! select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
!  rank 
! ------
!     1
! (1 row)
! 
! select rank('3') within group (order by x) from generate_series(1,5) x;
!  rank 
! ------
!     3
! (1 row)
! 
! -- divide by zero check
! select percent_rank(0) within group (order by x) from generate_series(1,0) x;
!  percent_rank 
! --------------
!             0
! (1 row)
! 
! -- deparse and multiple features:
! create view aggordview1 as
! select ten,
!        percentile_disc(0.5) within group (order by thousand) as p50,
!        percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
!        rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
!   from tenk1
!  group by ten order by ten;
! select pg_get_viewdef('aggordview1');
!                                                         pg_get_viewdef                                                         
! -------------------------------------------------------------------------------------------------------------------------------
!   SELECT tenk1.ten,                                                                                                           +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) AS p50,                                  +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) FILTER (WHERE (tenk1.hundred = 1)) AS px,+
!      rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY tenk1.hundred, tenk1.string4 DESC, tenk1.hundred) AS rank              +
!     FROM tenk1                                                                                                                +
!    GROUP BY tenk1.ten                                                                                                         +
!    ORDER BY tenk1.ten;
! (1 row)
! 
! select * from aggordview1 order by ten;
!  ten | p50 | px  | rank 
! -----+-----+-----+------
!    0 | 490 |     |  101
!    1 | 491 | 401 |  101
!    2 | 492 |     |  101
!    3 | 493 |     |  101
!    4 | 494 |     |  101
!    5 | 495 |     |   67
!    6 | 496 |     |    1
!    7 | 497 |     |    1
!    8 | 498 |     |    1
!    9 | 499 |     |    1
! (10 rows)
! 
! drop view aggordview1;
! -- variadic aggregates
! select least_agg(q1,q2) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
! select least_agg(variadic array[q1,q2]) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/transactions.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/transactions.out	2015-01-26 12:33:23.599031291 +0300
***************
*** 1,623 ****
! --
! -- TRANSACTIONS
! --
! BEGIN;
! SELECT *
!    INTO TABLE xacttest
!    FROM aggtest;
! INSERT INTO xacttest (a, b) VALUES (777, 777.777);
! END;
! -- should retrieve one value--
! SELECT a FROM xacttest WHERE a > 100;
!   a  
! -----
!  777
! (1 row)
! 
! BEGIN;
! CREATE TABLE disappear (a int4);
! DELETE FROM aggtest;
! -- should be empty
! SELECT * FROM aggtest;
!  a | b 
! ---+---
! (0 rows)
! 
! ABORT;
! -- should not exist
! SELECT oid FROM pg_class WHERE relname = 'disappear';
!  oid 
! -----
! (0 rows)
! 
! -- should have members again
! SELECT * FROM aggtest;
!   a  |    b    
! -----+---------
!   56 |     7.8
!  100 |  99.097
!    0 | 0.09561
!   42 |  324.78
! (4 rows)
! 
! -- Read-only tests
! CREATE TABLE writetest (a int);
! CREATE TEMPORARY TABLE temptest (a int);
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY, DEFERRABLE; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ WRITE; --fail
! ERROR:  transaction read-write mode must be set before any query
! COMMIT;
! BEGIN;
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! ROLLBACK TO SAVEPOINT x;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! SAVEPOINT y;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! RELEASE SAVEPOINT y;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! COMMIT;
! SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
! DROP TABLE writetest; -- fail
! ERROR:  cannot execute DROP TABLE in a read-only transaction
! INSERT INTO writetest VALUES (1); -- fail
! ERROR:  cannot execute INSERT in a read-only transaction
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! DELETE FROM temptest; -- ok
! UPDATE temptest SET a = 0 FROM writetest WHERE temptest.a = 1 AND writetest.a = temptest.a; -- ok
! PREPARE test AS UPDATE writetest SET a = 0; -- ok
! EXECUTE test; -- fail
! ERROR:  cannot execute UPDATE in a read-only transaction
! SELECT * FROM writetest, temptest; -- ok
!  a | a 
! ---+---
! (0 rows)
! 
! CREATE TABLE test AS SELECT * FROM writetest; -- fail
! ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
! START TRANSACTION READ WRITE;
! DROP TABLE writetest; -- ok
! COMMIT;
! -- Subtransactions, basic tests
! -- create & drop tables
! SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
! CREATE TABLE foobar (a int);
! BEGIN;
! 	CREATE TABLE foo (a int);
! 	SAVEPOINT one;
! 		DROP TABLE foo;
! 		CREATE TABLE bar (a int);
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE baz (a int);
! 	RELEASE SAVEPOINT two;
! 	drop TABLE foobar;
! 	CREATE TABLE barbaz (a int);
! COMMIT;
! -- should exist: barbaz, baz, foo
! SELECT * FROM foo;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM bar;		-- shouldn't exist
! ERROR:  relation "bar" does not exist
! LINE 1: SELECT * FROM bar;
!                       ^
! SELECT * FROM barbaz;	-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM baz;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! -- inserts
! BEGIN;
! 	INSERT INTO foo VALUES (1);
! 	SAVEPOINT one;
! 		INSERT into bar VALUES (1);
! ERROR:  relation "bar" does not exist
! LINE 1: INSERT into bar VALUES (1);
!                     ^
! 	ROLLBACK TO one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		INSERT into barbaz VALUES (1);
! 	RELEASE two;
! 	SAVEPOINT three;
! 		SAVEPOINT four;
! 			INSERT INTO foo VALUES (2);
! 		RELEASE SAVEPOINT four;
! 	ROLLBACK TO SAVEPOINT three;
! 	RELEASE SAVEPOINT three;
! 	INSERT INTO foo VALUES (3);
! COMMIT;
! SELECT * FROM foo;		-- should have 1 and 3
!  a 
! ---
!  1
!  3
! (2 rows)
! 
! SELECT * FROM barbaz;	-- should have 1
!  a 
! ---
!  1
! (1 row)
! 
! -- test whole-tree commit
! BEGIN;
! 	SAVEPOINT one;
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE savepoints (a int);
! 		SAVEPOINT three;
! 			INSERT INTO savepoints VALUES (1);
! 			SAVEPOINT four;
! 				INSERT INTO savepoints VALUES (2);
! 				SAVEPOINT five;
! 					INSERT INTO savepoints VALUES (3);
! 				ROLLBACK TO SAVEPOINT five;
! COMMIT;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree rollback
! BEGIN;
! 	SAVEPOINT one;
! 		DELETE FROM savepoints WHERE a=1;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		DELETE FROM savepoints WHERE a=1;
! 		SAVEPOINT three;
! 			DELETE FROM savepoints WHERE a=2;
! ROLLBACK;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree commit on an aborted subtransaction
! BEGIN;
! 	INSERT INTO savepoints VALUES (4);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (5);
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! COMMIT;
! SELECT * FROM savepoints;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (6);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (7);
! 	RELEASE SAVEPOINT one;
! 	INSERT INTO savepoints VALUES (8);
! COMMIT;
! -- rows 6 and 8 should have been created by the same xact
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=8;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- rows 6 and 7 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=7;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (9);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (10);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (11);
! COMMIT;
! SELECT a FROM savepoints WHERE a in (9, 10, 11);
!  a  
! ----
!   9
!  11
! (2 rows)
! 
! -- rows 9 and 11 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=9 AND b.a=11;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (12);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (13);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (14);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (15);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (16);
! 			SAVEPOINT three;
! 				INSERT INTO savepoints VALUES (17);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 12 AND 17;
!  a  
! ----
!  12
!  15
!  16
!  17
! (4 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (18);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (19);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (20);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (21);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (22);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 18 AND 22;
!  a  
! ----
!  18
!  22
! (2 rows)
! 
! DROP TABLE savepoints;
! -- only in a transaction block:
! SAVEPOINT one;
! ERROR:  SAVEPOINT can only be used in transaction blocks
! ROLLBACK TO SAVEPOINT one;
! ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
! RELEASE SAVEPOINT one;
! ERROR:  RELEASE SAVEPOINT can only be used in transaction blocks
! -- Only "rollback to" allowed in aborted state
! BEGIN;
!   SAVEPOINT one;
!   SELECT 0/0;
! ERROR:  division by zero
!   SAVEPOINT two;    -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   RELEASE SAVEPOINT one;      -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   ROLLBACK TO SAVEPOINT one;
!   SELECT 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! COMMIT;
! SELECT 1;			-- this should work
!  ?column? 
! ----------
!         1
! (1 row)
! 
! -- check non-transactional behavior of cursors
! BEGIN;
! 	DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!        0
!        1
!        2
!        3
!        4
!        5
!        6
!        7
!        8
!        9
! (10 rows)
! 
! 	ROLLBACK TO SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!       10
!       11
!       12
!       13
!       14
!       15
!       16
!       17
!       18
!       19
! (10 rows)
! 
! 	RELEASE SAVEPOINT one;
! 	FETCH 10 FROM c;
!  unique2 
! ---------
!       20
!       21
!       22
!       23
!       24
!       25
!       26
!       27
!       28
!       29
! (10 rows)
! 
! 	CLOSE c;
! 	DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT two;
! 		FETCH 10 FROM c;
! ERROR:  division by zero
! 	ROLLBACK TO SAVEPOINT two;
! 	-- c is now dead to the world ...
! 		FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! 	ROLLBACK TO SAVEPOINT two;
! 	RELEASE SAVEPOINT two;
! 	FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! COMMIT;
! --
! -- Check that "stable" functions are really stable.  They should not be
! -- able to see the partial results of the calling query.  (Ideally we would
! -- also check that they don't see commits of concurrent transactions, but
! -- that's a mite hard to do within the limitations of pg_regress.)
! --
! select * from xacttest;
!   a  |    b    
! -----+---------
!   56 |     7.8
!  100 |  99.097
!    0 | 0.09561
!   42 |  324.78
!  777 | 777.777
! (5 rows)
! 
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  787 |  99.097
!  787 |  324.78
!  787 | 777.777
! (5 rows)
! 
! rollback;
! -- But a volatile function can see the partial results of the calling query
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  797 |  99.097
!  807 |  324.78
!  817 | 777.777
! (5 rows)
! 
! rollback;
! -- Now the same test with plpgsql (since it depends on SPI which is different)
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  787 |  99.097
!  787 |  324.78
!  787 | 777.777
! (5 rows)
! 
! rollback;
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! select * from xacttest;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!  787 |     7.8
!  797 |  99.097
!  807 |  324.78
!  817 | 777.777
! (5 rows)
! 
! rollback;
! -- test case for problems with dropping an open relation during abort
! BEGIN;
! 	savepoint x;
! 		CREATE TABLE koju (a INT UNIQUE);
! 		INSERT INTO koju VALUES (1);
! 		INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! 	rollback to x;
! 	CREATE TABLE koju (a INT UNIQUE);
! 	INSERT INTO koju VALUES (1);
! 	INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! ROLLBACK;
! DROP TABLE foo;
! DROP TABLE baz;
! DROP TABLE barbaz;
! -- test case for problems with revalidating an open relation during abort
! create function inverse(int) returns float8 as
! $$
! begin
!   analyze revalidate_bug;
!   return 1::float8/$1;
! exception
!   when division_by_zero then return 0;
! end$$ language plpgsql volatile;
! create table revalidate_bug (c float8 unique);
! insert into revalidate_bug values (1);
! insert into revalidate_bug values (inverse(0));
! drop table revalidate_bug;
! drop function inverse(int);
! -- verify that cursors created during an aborted subtransaction are
! -- closed, but that we do not rollback the effect of any FETCHs
! -- performed in the aborted subtransaction
! begin;
! savepoint x;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! declare foo cursor for select * from abc;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! rollback to x;
! -- should fail
! fetch from foo;
! ERROR:  cursor "foo" does not exist
! commit;
! begin;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! insert into abc values (15);
! declare foo cursor for select * from abc;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! savepoint x;
! fetch from foo;
!  a  
! ----
!  10
! (1 row)
! 
! rollback to x;
! fetch from foo;
!  a  
! ----
!  15
! (1 row)
! 
! abort;
! -- Test for successful cleanup of an aborted transaction at session exit.
! -- THIS MUST BE THE LAST TEST IN THIS FILE.
! begin;
! select 1/0;
! ERROR:  division by zero
! rollback to X;
! ERROR:  no such savepoint
! -- DO NOT ADD ANYTHING HERE.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/random.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/random.out	2015-01-26 12:33:23.555031289 +0300
***************
*** 1,52 ****
! --
! -- RANDOM
! -- Test the random function
! --
! -- count the number of tuples originally, should be 1000
! SELECT count(*) FROM onek;
!  count 
! -------
!   1000
! (1 row)
! 
! -- pick three random rows, they shouldn't match
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1);
!  random 
! --------
! (0 rows)
! 
! -- count roughly 1/10 of the tuples
! SELECT count(*) AS random INTO RANDOM_TBL
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- now test that they are different counts
! SELECT random, count(random) FROM RANDOM_TBL
!   GROUP BY random HAVING count(random) > 3;
!  random | count 
! --------+-------
! (0 rows)
! 
! SELECT AVG(random) FROM RANDOM_TBL
!   HAVING AVG(random) NOT BETWEEN 80 AND 120;
!  avg 
! -----
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/portals.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/portals.out	2015-01-26 12:33:23.571031290 +0300
***************
*** 1,1287 ****
! --
! -- Cursor regression tests
! --
! BEGIN;
! DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;
! DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH 2 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (2 rows)
! 
! FETCH 3 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (3 rows)
! 
! FETCH 4 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH 5 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH 6 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (6 rows)
! 
! FETCH 7 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
! (7 rows)
! 
! FETCH 8 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH 9 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH 10 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (10 rows)
! 
! FETCH 11 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
! (11 rows)
! 
! FETCH 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (12 rows)
! 
! FETCH 13 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
! (13 rows)
! 
! FETCH 14 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (14 rows)
! 
! FETCH 15 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
! (15 rows)
! 
! FETCH 16 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (16 rows)
! 
! FETCH 17 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
! (17 rows)
! 
! FETCH 18 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (18 rows)
! 
! FETCH 19 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
! (19 rows)
! 
! FETCH 20 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (20 rows)
! 
! FETCH 21 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
! (21 rows)
! 
! FETCH 22 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (22 rows)
! 
! FETCH 23 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
!     8020 |      22 |   0 |    0 |   0 |      0 |      20 |       20 |          20 |      3020 |     8020 |  40 |   41 | MWAAAA   | WAAAAA   | OOOOxx
! (23 rows)
! 
! FETCH backward 1 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (1 row)
! 
! FETCH backward 2 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (2 rows)
! 
! FETCH backward 3 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (3 rows)
! 
! FETCH backward 4 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH backward 5 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (5 rows)
! 
! FETCH backward 6 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (6 rows)
! 
! FETCH backward 7 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (7 rows)
! 
! FETCH backward 8 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH backward 9 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (9 rows)
! 
! FETCH backward 10 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (10 rows)
! 
! FETCH backward 11 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (11 rows)
! 
! FETCH backward 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (11 rows)
! 
! FETCH backward 13 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (10 rows)
! 
! FETCH backward 14 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH backward 15 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (8 rows)
! 
! FETCH backward 16 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (7 rows)
! 
! FETCH backward 17 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (6 rows)
! 
! FETCH backward 18 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH backward 19 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (4 rows)
! 
! FETCH backward 20 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (3 rows)
! 
! FETCH backward 21 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (2 rows)
! 
! FETCH backward 22 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH backward 23 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
! (0 rows)
! 
! CLOSE foo1;
! CLOSE foo2;
! CLOSE foo3;
! CLOSE foo4;
! CLOSE foo5;
! CLOSE foo6;
! CLOSE foo7;
! CLOSE foo8;
! CLOSE foo9;
! CLOSE foo10;
! CLOSE foo11;
! CLOSE foo12;
! -- leave some cursors open, to test that auto-close works.
! -- record this in the system view as well (don't query the time field there
! -- however)
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name  |                               statement                               | is_holdable | is_binary | is_scrollable 
! -------+-----------------------------------------------------------------------+-------------+-----------+---------------
!  foo13 | DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo14 | DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo15 | DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo16 | DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo17 | DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo18 | DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo19 | DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo20 | DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo21 | DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo22 | DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;                  | f           | f         | t
!  foo23 | DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
! (11 rows)
! 
! END;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! --
! -- NO SCROLL disallows backward fetching
! --
! BEGIN;
! DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 FROM foo24;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH BACKWARD 1 FROM foo24; -- should fail
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! END;
! --
! -- Cursors outside transaction blocks
! --
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! BEGIN;
! DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! COMMIT;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (1 row)
! 
! FETCH BACKWARD FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! FETCH ABSOLUTE -1 FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     2968 |    9999 |   0 |    0 |   8 |      8 |      68 |      968 |         968 |      2968 |     2968 | 136 |  137 | EKAAAA   | PUOAAA   | VVVVxx
! (1 row)
! 
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name  |                           statement                            | is_holdable | is_binary | is_scrollable 
! -------+----------------------------------------------------------------+-------------+-----------+---------------
!  foo25 | DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2; | t           | f         | t
! (1 row)
! 
! CLOSE foo25;
! --
! -- ROLLBACK should close holdable cursors
! --
! BEGIN;
! DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
! ROLLBACK;
! -- should fail
! FETCH FROM foo26;
! ERROR:  cursor "foo26" does not exist
! --
! -- Parameterized DECLARE needs to insert param values into the cursor portal
! --
! BEGIN;
! CREATE FUNCTION declares_cursor(text)
!    RETURNS void
!    AS 'DECLARE c CURSOR FOR SELECT stringu1 FROM tenk1 WHERE stringu1 LIKE $1;'
!    LANGUAGE SQL;
! SELECT declares_cursor('AB%');
!  declares_cursor 
! -----------------
!  
! (1 row)
! 
! FETCH ALL FROM c;
!  stringu1 
! ----------
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
! (15 rows)
! 
! ROLLBACK;
! --
! -- Test behavior of both volatile and stable functions inside a cursor;
! -- in particular we want to see what happens during commit of a holdable
! -- cursor
! --
! create temp table tt1(f1 int);
! create function count_tt1_v() returns int8 as
! 'select count(*) from tt1' language sql volatile;
! create function count_tt1_s() returns int8 as
! 'select count(*) from tt1' language sql stable;
! begin;
! insert into tt1 values(1);
! declare c1 cursor for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! fetch all from c1;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           1
! (1 row)
! 
! rollback;
! begin;
! insert into tt1 values(1);
! declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! commit;
! delete from tt1;
! fetch all from c2;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           1
! (1 row)
! 
! drop function count_tt1_v();
! drop function count_tt1_s();
! -- Create a cursor with the BINARY option and check the pg_cursors view
! BEGIN;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  bc   | DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;                    | f           | t         | t
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (2 rows)
! 
! ROLLBACK;
! -- We should not see the portal that is created internally to
! -- implement EXECUTE in pg_cursors
! PREPARE cprep AS
!   SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
! EXECUTE cprep;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! -- test CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  c2
! (1 row)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! BEGIN;
! DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
! DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  foo1
!  foo2
! (2 rows)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! COMMIT;
! --
! -- Tests for updatable cursors
! --
! CREATE TEMP TABLE uctest(f1 int, f2 text);
! INSERT INTO uctest VALUES (1, 'one'), (2, 'two'), (3, 'three');
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check DELETE WHERE CURRENT
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! FETCH 2 FROM c1;
!  f1 | f2  
! ----+-----
!   1 | one
!   2 | two
! (2 rows)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! -- should show deletion
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   3 | three
! (2 rows)
! 
! -- cursor did not move
! FETCH ALL FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! -- cursor is insensitive
! MOVE BACKWARD ALL IN c1;
! FETCH ALL FROM c1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! COMMIT;
! -- should still see deletion
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   1 | one
!   3 | three
! (2 rows)
! 
! -- Check UPDATE WHERE CURRENT; this time use FOR UPDATE
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = 8 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! COMMIT;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! -- Check repeated-update and update-then-delete cases
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! FETCH c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  13 | three
! (2 rows)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  23 | three
! (2 rows)
! 
! -- insensitive cursor should not show effects of updates or deletes
! FETCH RELATIVE 0 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! FETCH RELATIVE 0 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! ROLLBACK;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  13 | three
! (2 rows)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   8 | one
!  23 | three
! (2 rows)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! SELECT * FROM uctest;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! --- sensitive cursors can't currently scroll back, so this is an error:
! FETCH RELATIVE 0 FROM c1;
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! ROLLBACK;
! SELECT * FROM uctest;
!  f1 |  f2   
! ----+-------
!   3 | three
!   8 | one
! (2 rows)
! 
! -- Check inheritance cases
! CREATE TEMP TABLE ucchild () inherits (uctest);
! INSERT INTO ucchild values(100, 'hundred');
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!    3 | three
!    8 | one
!  100 | hundred
! (3 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
! FETCH 1 FROM c1;
!  f1 |  f2   
! ----+-------
!   3 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1 | f2  
! ----+-----
!   8 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1  |   f2    
! -----+---------
!  100 | hundred
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! FETCH 1 FROM c1;
!  f1 | f2 
! ----+----
! (0 rows)
! 
! COMMIT;
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!   13 | three
!   18 | one
!  110 | hundred
! (3 rows)
! 
! -- Can update from a self-join, but only if FOR UPDATE says which to use
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  cursor "c1" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR UPDATE;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  cursor "c1" has multiple FOR UPDATE/SHARE references to table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR SHARE OF a;
! FETCH 1 FROM c1;
!  f1 | f2  | f1 |  f2   
! ----+-----+----+-------
!  18 | one | 13 | three
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! SELECT * FROM uctest;
!  f1  |   f2    
! -----+---------
!   13 | three
!   28 | one
!  110 | hundred
! (3 rows)
! 
! ROLLBACK;
! -- Check various error cases
! DELETE FROM uctest WHERE CURRENT OF c1;  -- fail, no such cursor
! ERROR:  cursor "c1" does not exist
! DECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF cx;  -- fail, can't use held cursor
! ERROR:  cursor "cx" is held from a previous transaction
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  cursor "c" does not have a FOR UPDATE/SHARE reference to table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
! DELETE FROM tenk1 WHERE CURRENT OF c;  -- fail, cursor is on a join
! ERROR:  cursor "c" is not a simply updatable scan of table "tenk1"
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor is on aggregation
! ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF c1; -- fail, no current row
! ERROR:  cursor "c1" is not positioned on a row
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
! ERROR:  FOR UPDATE is not allowed with aggregate functions
! ROLLBACK;
! -- WHERE CURRENT OF may someday work with views, but today is not that day.
! -- For now, just make sure it errors out cleanly.
! CREATE TEMP VIEW ucview AS SELECT * FROM uctest;
! CREATE RULE ucrule AS ON DELETE TO ucview DO INSTEAD
!   DELETE FROM uctest WHERE f1 = OLD.f1;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM ucview;
! FETCH FROM c1;
!  f1 |  f2   
! ----+-------
!  13 | three
! (1 row)
! 
! DELETE FROM ucview WHERE CURRENT OF c1; -- fail, views not supported
! ERROR:  WHERE CURRENT OF on a view is not implemented
! ROLLBACK;
! -- Make sure snapshot management works okay, per bug report in
! -- 235395b90909301035v7228ce63q392931f15aa74b31@mail.gmail.com
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! CREATE TABLE cursor (a int);
! INSERT INTO cursor VALUES (1);
! DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
! UPDATE cursor SET a = 2;
! FETCH ALL FROM c1;
!  a 
! ---
! (0 rows)
! 
! COMMIT;
! DROP TABLE cursor;
! -- Check rewinding a cursor containing a stable function in LIMIT,
! -- per bug report in 8336843.9833.1399385291498.JavaMail.root@quick
! begin;
! create function nochange(int) returns int
!   as 'select $1 limit 1' language sql stable;
! declare c cursor for select * from int8_tbl limit nochange(3);
! fetch all from c;
!         q1        |        q2        
! ------------------+------------------
!               123 |              456
!               123 | 4567890123456789
!  4567890123456789 |              123
! (3 rows)
! 
! move backward all in c;
! fetch all from c;
!         q1        |        q2        
! ------------------+------------------
!               123 |              456
!               123 | 4567890123456789
!  4567890123456789 |              123
! (3 rows)
! 
! rollback;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/arrays.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/arrays.out	2015-01-26 12:33:23.575031290 +0300
***************
*** 1,1831 ****
! --
! -- ARRAYS
! --
! CREATE TABLE arrtest (
! 	a 			int2[],
! 	b 			int4[][][],
! 	c 			name[],
! 	d			text[][],
! 	e 			float8[],
! 	f			char(5)[],
! 	g			varchar(5)[]
! );
! --
! -- only the 'e' array is 0-based, the others are 1-based.
! --
! INSERT INTO arrtest (a[1:5], b[1:1][1:2][1:2], c, d, f, g)
!    VALUES ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}', '{}', '{}');
! UPDATE arrtest SET e[0] = '1.1';
! UPDATE arrtest SET e[1] = '2.2';
! INSERT INTO arrtest (f)
!    VALUES ('{"too long"}');
! ERROR:  value too long for type character(5)
! INSERT INTO arrtest (a, b[1:2][1:2], c, d, e, f, g)
!    VALUES ('{11,12,23}', '{{3,4},{4,5}}', '{"foobar"}',
!            '{{"elt1", "elt2"}}', '{"3.4", "6.7"}',
!            '{"abc","abcde"}', '{"abc","abcde"}');
! INSERT INTO arrtest (a, b[1:2], c, d[1:2])
!    VALUES ('{}', '{3,4}', '{foo,bar}', '{bar,foo}');
! SELECT * FROM arrtest;
!       a      |        b        |     c     |       d       |        e        |        f        |      g      
! -------------+-----------------+-----------+---------------+-----------------+-----------------+-------------
!  {1,2,3,4,5} | {{{0,0},{1,2}}} | {}        | {}            | [0:1]={1.1,2.2} | {}              | {}
!  {11,12,23}  | {{3,4},{4,5}}   | {foobar}  | {{elt1,elt2}} | {3.4,6.7}       | {"abc  ",abcde} | {abc,abcde}
!  {}          | {3,4}           | {foo,bar} | {bar,foo}     |                 |                 | 
! (3 rows)
! 
! SELECT arrtest.a[1],
!           arrtest.b[1][1][1],
!           arrtest.c[1],
!           arrtest.d[1][1],
!           arrtest.e[0]
!    FROM arrtest;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1], b[1][1][1], c[1], d[1][1], e[0]
!    FROM arrtest;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][1:2]
!    FROM arrtest;
!      a      |        b        |     c     |       d       
! ------------+-----------------+-----------+---------------
!  {1,2,3}    | {{{0,0},{1,2}}} | {}        | {}
!  {11,12,23} | {}              | {foobar}  | {{elt1,elt2}}
!  {}         | {}              | {foo,bar} | {}
! (3 rows)
! 
! SELECT array_ndims(a) AS a,array_ndims(b) AS b,array_ndims(c) AS c
!    FROM arrtest;
!  a | b | c 
! ---+---+---
!  1 | 3 |  
!  1 | 2 | 1
!    | 1 | 1
! (3 rows)
! 
! SELECT array_dims(a) AS a,array_dims(b) AS b,array_dims(c) AS c
!    FROM arrtest;
!    a   |        b        |   c   
! -------+-----------------+-------
!  [1:5] | [1:1][1:2][1:2] | 
!  [1:3] | [1:2][1:2]      | [1:1]
!        | [1:2]           | [1:2]
! (3 rows)
! 
! -- returns nothing
! SELECT *
!    FROM arrtest
!    WHERE a[1] < 5 and
!          c = '{"foobar"}'::_name;
!  a | b | c | d | e | f | g 
! ---+---+---+---+---+---+---
! (0 rows)
! 
! UPDATE arrtest
!   SET a[1:2] = '{16,25}'
!   WHERE NOT a = '{}'::_int2;
! UPDATE arrtest
!   SET b[1:1][1:1][1:2] = '{113, 117}',
!       b[1:1][1:2][2:2] = '{142, 147}'
!   WHERE array_dims(b) = '[1:1][1:2][1:2]';
! UPDATE arrtest
!   SET c[2:2] = '{"new_word"}'
!   WHERE array_dims(c) is not null;
! SELECT a,b,c FROM arrtest;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {}            | {3,4}                 | {foo,new_word}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][2:2]
!    FROM arrtest;
!      a      |           b           |         c         |    d     
! ------------+-----------------------+-------------------+----------
!  {16,25,3}  | {{{113,142},{1,147}}} | {}                | {}
!  {}         | {}                    | {foo,new_word}    | {}
!  {16,25,23} | {}                    | {foobar,new_word} | {{elt2}}
! (3 rows)
! 
! INSERT INTO arrtest(a) VALUES('{1,null,3}');
! SELECT a FROM arrtest;
!        a       
! ---------------
!  {16,25,3,4,5}
!  {}
!  {16,25,23}
!  {1,NULL,3}
! (4 rows)
! 
! UPDATE arrtest SET a[4] = NULL WHERE a[2] IS NULL;
! SELECT a FROM arrtest WHERE a[2] IS NULL;
!         a        
! -----------------
!  [4:4]={NULL}
!  {1,NULL,3,NULL}
! (2 rows)
! 
! DELETE FROM arrtest WHERE a[2] IS NULL AND b IS NULL;
! SELECT a,b,c FROM arrtest;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
!  [4:4]={NULL}  | {3,4}                 | {foo,new_word}
! (3 rows)
! 
! --
! -- test array extension
! --
! CREATE TEMP TABLE arrtest1 (i int[], t text[]);
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[2] = 22, t[2] = 'twenty-two';
! select * from arrtest1;
!        i       |             t              
! ---------------+----------------------------
!  {1,22,NULL,4} | {one,twenty-two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[5] = 5, t[5] = 'five';
! select * from arrtest1;
!         i        |                t                
! -----------------+---------------------------------
!  {1,22,NULL,4,5} | {one,twenty-two,NULL,four,five}
! (1 row)
! 
! update arrtest1 set i[8] = 8, t[8] = 'eight';
! select * from arrtest1;
!               i              |                        t                        
! -----------------------------+-------------------------------------------------
!  {1,22,NULL,4,5,NULL,NULL,8} | {one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0] = 0, t[0] = 'zero';
! select * from arrtest1;
!                   i                  |                             t                              
! -------------------------------------+------------------------------------------------------------
!  [0:8]={0,1,22,NULL,4,5,NULL,NULL,8} | [0:8]={zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[-3] = -3, t[-3] = 'minus-three';
! select * from arrtest1;
!                          i                         |                                         t                                         
! ---------------------------------------------------+-----------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,0,1,22,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
! select * from arrtest1;
!                           i                          |                                        t                                        
! -----------------------------------------------------+---------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
! select * from arrtest1;
!                                i                               |                                            t                                            
! ---------------------------------------------------------------+-----------------------------------------------------------------------------------------
!  [-3:10]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20} | [-3:10]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20}
! (1 row)
! 
! update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
! select * from arrtest1;
!                                    i                                   |                                                t                                                 
! -----------------------------------------------------------------------+--------------------------------------------------------------------------------------------------
!  [-3:12]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22} | [-3:12]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22}
! (1 row)
! 
! update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
! select * from arrtest1;
!                                             i                                            |                                                          t                                                          
! -----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-3:16]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-3:16]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
! select * from arrtest1;
!                                                 i                                                 |                                                          t                                                          
! --------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-5:16]={-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-5:16]={m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
! select * from arrtest1;
!                                                      i                                                     |                                                              t                                                               
! -----------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------
!  [-7:16]={-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-7:16]={m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
! select * from arrtest1;
!                                                                  i                                                                 |                                                                          t                                                                           
! -----------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------
!  [-12:16]={-22,NULL,-20,NULL,NULL,-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-12:16]={m22,NULL,m20,NULL,NULL,m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! delete from arrtest1;
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
! select * from arrtest1;
!            i            |             t              
! ------------------------+----------------------------
!  [0:5]={0,1,2,NULL,4,5} | [0:5]={z,p1,p2,NULL,p4,p5}
! (1 row)
! 
! --
! -- array expressions and operators
! --
! -- table creation and INSERTs
! CREATE TEMP TABLE arrtest2 (i integer ARRAY[4], f float8[], n numeric[], t text[], d timestamp[]);
! INSERT INTO arrtest2 VALUES(
!   ARRAY[[[113,142],[1,147]]],
!   ARRAY[1.1,1.2,1.3]::float8[],
!   ARRAY[1.1,1.2,1.3],
!   ARRAY[[['aaa','aab'],['aba','abb'],['aca','acb']],[['baa','bab'],['bba','bbb'],['bca','bcb']]],
!   ARRAY['19620326','19931223','19970117']::timestamp[]
! );
! -- some more test data
! CREATE TEMP TABLE arrtest_f (f0 int, f1 text, f2 float8);
! insert into arrtest_f values(1,'cat1',1.21);
! insert into arrtest_f values(2,'cat1',1.24);
! insert into arrtest_f values(3,'cat1',1.18);
! insert into arrtest_f values(4,'cat1',1.26);
! insert into arrtest_f values(5,'cat1',1.15);
! insert into arrtest_f values(6,'cat2',1.15);
! insert into arrtest_f values(7,'cat2',1.26);
! insert into arrtest_f values(8,'cat2',1.32);
! insert into arrtest_f values(9,'cat2',1.30);
! CREATE TEMP TABLE arrtest_i (f0 int, f1 text, f2 int);
! insert into arrtest_i values(1,'cat1',21);
! insert into arrtest_i values(2,'cat1',24);
! insert into arrtest_i values(3,'cat1',18);
! insert into arrtest_i values(4,'cat1',26);
! insert into arrtest_i values(5,'cat1',15);
! insert into arrtest_i values(6,'cat2',15);
! insert into arrtest_i values(7,'cat2',26);
! insert into arrtest_i values(8,'cat2',32);
! insert into arrtest_i values(9,'cat2',30);
! -- expressions
! SELECT t.f[1][3][1] AS "131", t.f[2][2][1] AS "221" FROM (
!   SELECT ARRAY[[[111,112],[121,122],[131,132]],[[211,212],[221,122],[231,232]]] AS f
! ) AS t;
!  131 | 221 
! -----+-----
!  131 | 221
! (1 row)
! 
! SELECT ARRAY[[[[[['hello'],['world']]]]]];
!            array           
! ---------------------------
!  {{{{{{hello},{world}}}}}}
! (1 row)
! 
! SELECT ARRAY[ARRAY['hello'],ARRAY['world']];
!        array       
! -------------------
!  {{hello},{world}}
! (1 row)
! 
! SELECT ARRAY(select f2 from arrtest_f order by f2) AS "ARRAY";
!                      ARRAY                     
! -----------------------------------------------
!  {1.15,1.15,1.18,1.21,1.24,1.26,1.26,1.3,1.32}
! (1 row)
! 
! -- with nulls
! SELECT '{1,null,3}'::int[];
!     int4    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! SELECT ARRAY[1,NULL,3];
!    array    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! -- functions
! SELECT array_append(array[42], 6) AS "{42,6}";
!  {42,6} 
! --------
!  {42,6}
! (1 row)
! 
! SELECT array_prepend(6, array[42]) AS "{6,42}";
!  {6,42} 
! --------
!  {6,42}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[3,4]) AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
!  {{3,4},{5,6},{1,2}} 
! ---------------------
!  {{3,4},{5,6},{1,2}}
! (1 row)
! 
! -- operators
! SELECT a FROM arrtest WHERE b = ARRAY[[[113,142],[1,147]]];
!        a       
! ---------------
!  {16,25,3,4,5}
! (1 row)
! 
! SELECT NOT ARRAY[1.1,1.2,1.3] = ARRAY[1.1,1.2,1.3] AS "FALSE";
!  FALSE 
! -------
!  f
! (1 row)
! 
! SELECT ARRAY[1,2] || 3 AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] AS "{0,1,2}";
!  {0,1,2} 
! ---------
!  {0,1,2}
! (1 row)
! 
! SELECT ARRAY[1,2] || ARRAY[3,4] AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT ARRAY[[['hello','world']]] || ARRAY[[['happy','birthday']]] AS "ARRAY";
!                 ARRAY                 
! --------------------------------------
!  {{{hello,world}},{{happy,birthday}}}
! (1 row)
! 
! SELECT ARRAY[[1,2],[3,4]] || ARRAY[5,6] AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT ARRAY[0,0] || ARRAY[1,1] || ARRAY[2,2] AS "{0,0,1,1,2,2}";
!  {0,0,1,1,2,2} 
! ---------------
!  {0,0,1,1,2,2}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] || 3 AS "{0,1,2,3}";
!  {0,1,2,3} 
! -----------
!  {0,1,2,3}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (11 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
!  seqno |       i       |                                                             t                                                              
! -------+---------------+----------------------------------------------------------------------------------------------------------------------------
!     40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    101 | {}            | {}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE i = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |  i   |                                 t                                  
! -------+------+--------------------------------------------------------------------
!     79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
!  seqno |         i          |                                                     t                                                     
! -------+--------------------+-----------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
!     45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!    101 | {}                 | {}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! -- array casts
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] is of (float8[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] AS "{{a,bc},{def,hijk}}";
!  {{a,bc},{def,hijk}} 
! ---------------------
!  {{a,bc},{def,hijk}}
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] is of (varchar[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT CAST(ARRAY[[[[[['a','bb','ccc']]]]]] as text[]) as "{{{{{{a,bb,ccc}}}}}}";
!  {{{{{{a,bb,ccc}}}}}} 
! ----------------------
!  {{{{{{a,bb,ccc}}}}}}
! (1 row)
! 
! -- scalar op any/all (array)
! select 33 = any ('{1,2,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = any ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all ('{1,2,33}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 >= all ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- boundary cases
! select null::int >= all ('{1,2,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int >= all ('{}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select null::int >= any ('{}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- cross-datatype
! select 33.4 = any (array[1,2,3]);
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33.4 > all (array[1,2,3]);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- errors
! select 33 * any ('{1,2,3}');
! ERROR:  op ANY/ALL (array) requires operator to yield boolean
! LINE 1: select 33 * any ('{1,2,3}');
!                   ^
! select 33 * any (44);
! ERROR:  op ANY/ALL (array) requires array on right side
! LINE 1: select 33 * any (44);
!                   ^
! -- nulls
! select 33 = any (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = any ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = all ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = all ('{1,null,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = all ('{33,null,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- test indexes on arrays
! create temp table arr_tbl (f1 int[] unique);
! insert into arr_tbl values ('{1,2,3}');
! insert into arr_tbl values ('{1,2}');
! -- failure expected:
! insert into arr_tbl values ('{1,2,3}');
! ERROR:  duplicate key value violates unique constraint "arr_tbl_f1_key"
! DETAIL:  Key (f1)=({1,2,3}) already exists.
! insert into arr_tbl values ('{2,3,4}');
! insert into arr_tbl values ('{1,5,3}');
! insert into arr_tbl values ('{1,2,10}');
! set enable_seqscan to off;
! set enable_bitmapscan to off;
! select * from arr_tbl where f1 > '{1,2,3}' and f1 <= '{1,5,3}';
!     f1    
! ----------
!  {1,2,10}
!  {1,5,3}
! (2 rows)
! 
! select * from arr_tbl where f1 >= '{1,2,3}' and f1 < '{1,5,3}';
!     f1    
! ----------
!  {1,2,3}
!  {1,2,10}
! (2 rows)
! 
! -- note: if above selects don't produce the expected tuple order,
! -- then you didn't get an indexscan plan, and something is busted.
! reset enable_seqscan;
! reset enable_bitmapscan;
! -- test [not] (like|ilike) (any|all) (...)
! select 'foo' like any (array['%a', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like any (array['%a', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' like all (array['f%', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like all (array['f%', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' not like any (array['%a', '%b']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' not like all (array['%a', '%o']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' ilike any (array['%A', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' ilike all (array['F%', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- General array parser tests
! --
! -- none of the following should be accepted
! select '{{1,{2}},{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,{2}},{2,3}}"
! LINE 1: select '{{1,{2}},{2,3}}'::text[];
!                ^
! select '{{},{}}'::text[];
! ERROR:  malformed array literal: "{{},{}}"
! LINE 1: select '{{},{}}'::text[];
!                ^
! select E'{{1,2},\\{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,2},\{2,3}}"
! LINE 1: select E'{{1,2},\\{2,3}}'::text[];
!                ^
! select '{{"1 2" x},{3}}'::text[];
! ERROR:  malformed array literal: "{{"1 2" x},{3}}"
! LINE 1: select '{{"1 2" x},{3}}'::text[];
!                ^
! select '{}}'::text[];
! ERROR:  malformed array literal: "{}}"
! LINE 1: select '{}}'::text[];
!                ^
! select '{ }}'::text[];
! ERROR:  malformed array literal: "{ }}"
! LINE 1: select '{ }}'::text[];
!                ^
! select array[];
! ERROR:  cannot determine type of empty array
! LINE 1: select array[];
!                ^
! HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
! -- none of the above should be accepted
! -- all of the following should be accepted
! select '{}'::text[];
!  text 
! ------
!  {}
! (1 row)
! 
! select '{{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}'::text[];
!                      text                      
! -----------------------------------------------
!  {{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}
! (1 row)
! 
! select '{0 second  ,0 second}'::interval[];
!    interval    
! ---------------
!  {"@ 0","@ 0"}
! (1 row)
! 
! select '{ { "," } , { 3 } }'::text[];
!     text     
! -------------
!  {{","},{3}}
! (1 row)
! 
! select '  {   {  "  0 second  "   ,  0 second  }   }'::text[];
!              text              
! -------------------------------
!  {{"  0 second  ","0 second"}}
! (1 row)
! 
! select '{
!            0 second,
!            @ 1 hour @ 42 minutes @ 20 seconds
!          }'::interval[];
!               interval              
! ------------------------------------
!  {"@ 0","@ 1 hour 42 mins 20 secs"}
! (1 row)
! 
! select array[]::text[];
!  array 
! -------
!  {}
! (1 row)
! 
! select '[0:1]={1.1,2.2}'::float8[];
!      float8      
! -----------------
!  [0:1]={1.1,2.2}
! (1 row)
! 
! -- all of the above should be accepted
! -- tests for array aggregates
! CREATE TEMP TABLE arraggtest ( f1 INT[], f2 TEXT[][], f3 FLOAT[]);
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3,4}','{{grey,red},{blue,blue}}','{1.6, 0.0}');
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3}','{{grey,red},{grey,blue}}','{1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!     max    |   min   |           max            |           min            |   max   |  min  
! -----------+---------+--------------------------+--------------------------+---------+-------
!  {1,2,3,4} | {1,2,3} | {{grey,red},{grey,blue}} | {{grey,red},{blue,blue}} | {1.6,0} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{3,3,2,4,5,6}','{{white,yellow},{pink,orange}}','{2.1,3.3,1.8,1.7,1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |           min            |          max          |  min  
! ---------------+---------+--------------------------------+--------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{grey,red},{blue,blue}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{2}','{{black,red},{green,orange}}','{1.6,2.2,2.6,0.4}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{4,2,6,7,8,1}','{{red},{black},{purple},{blue},{blue}}',NULL);
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{}','{{pink,white,blue,red,grey,orange}}','{2.1,1.87,1.4,2.2}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      | min |              max               |             min              |          max          |  min  
! ---------------+-----+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {}  | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! -- A few simple tests for arrays of composite types
! create type comptype as (f1 int, f2 text);
! create table comptable (c1 comptype, c2 comptype[]);
! -- XXX would like to not have to specify row() construct types here ...
! insert into comptable
!   values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
! -- check that implicitly named array type _comptype isn't a problem
! create type _comptype as enum('fooey');
! select * from comptable;
!    c1    |          c2           
! ---------+-----------------------
!  (1,foo) | {"(2,bar)","(3,baz)"}
! (1 row)
! 
! select c2[2].f2 from comptable;
!  f2  
! -----
!  baz
! (1 row)
! 
! drop type _comptype;
! drop table comptable;
! drop type comptype;
! create or replace function unnest1(anyarray)
! returns setof anyelement as $$
! select $1[s] from generate_subscripts($1,1) g(s);
! $$ language sql immutable;
! create or replace function unnest2(anyarray)
! returns setof anyelement as $$
! select $1[s1][s2] from generate_subscripts($1,1) g1(s1),
!                    generate_subscripts($1,2) g2(s2);
! $$ language sql immutable;
! select * from unnest1(array[1,2,3]);
!  unnest1 
! ---------
!        1
!        2
!        3
! (3 rows)
! 
! select * from unnest2(array[[1,2,3],[4,5,6]]);
!  unnest2 
! ---------
!        1
!        2
!        3
!        4
!        5
!        6
! (6 rows)
! 
! drop function unnest1(anyarray);
! drop function unnest2(anyarray);
! select array_fill(null::integer, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::integer, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(7, array[3,3],array[2,2]);
!               array_fill              
! --------------------------------------
!  [2:4][2:4]={{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill(7, array[3,3]);
!         array_fill         
! ---------------------------
!  {{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! -- raise exception
! select array_fill(1, null, array[2,2]);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[2,2], null);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[3,3], array[1,1,1]);
! ERROR:  wrong number of array subscripts
! DETAIL:  Low bound array has different size than dimensions array.
! select array_fill(1, array[1,2,null]);
! ERROR:  dimension values cannot be null
! select string_to_array('1|2|3', '|');
!  string_to_array 
! -----------------
!  {1,2,3}
! (1 row)
! 
! select string_to_array('1|2|3|', '|');
!  string_to_array 
! -----------------
!  {1,2,3,""}
! (1 row)
! 
! select string_to_array('1||2|3||', '||');
!  string_to_array 
! -----------------
!  {1,2|3,""}
! (1 row)
! 
! select string_to_array('1|2|3', '');
!  string_to_array 
! -----------------
!  {1|2|3}
! (1 row)
! 
! select string_to_array('', '|');
!  string_to_array 
! -----------------
!  {}
! (1 row)
! 
! select string_to_array('1|2|3', NULL);
!  string_to_array 
! -----------------
!  {1,|,2,|,3}
! (1 row)
! 
! select string_to_array(NULL, '|') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select string_to_array('abc', '');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', '', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('abc', ',');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', ',', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',');
!  string_to_array 
! -----------------
!  {1,2,3,4,"",6}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',', '');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select string_to_array('1,2,3,4,*,6', ',', '*');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select array_to_string(NULL::int4[], ',') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_to_string('{}'::int4[], ',');
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',');
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
!  array_to_string 
! -----------------
!  1,2,3,4,*,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], NULL);
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(string_to_array('1|2|3', '|'), '|');
!  array_to_string 
! -----------------
!  1|2|3
! (1 row)
! 
! select array_length(array[1,2,3], 1);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 0);
!  array_length 
! --------------
!              
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 1);
!  array_length 
! --------------
!             2
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 2);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 3);
!  array_length 
! --------------
!              
! (1 row)
! 
! select cardinality(NULL::int[]);
!  cardinality 
! -------------
!             
! (1 row)
! 
! select cardinality('{}'::int[]);
!  cardinality 
! -------------
!            0
! (1 row)
! 
! select cardinality(array[1,2,3]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('[2:4]={5,6,7}'::int[]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('{{1,2}}'::int[]);
!  cardinality 
! -------------
!            2
! (1 row)
! 
! select cardinality('{{1,2},{3,4},{5,6}}'::int[]);
!  cardinality 
! -------------
!            6
! (1 row)
! 
! select cardinality('{{{1,9},{5,6}},{{2,3},{3,4}}}'::int[]);
!  cardinality 
! -------------
!            8
! (1 row)
! 
! select array_agg(unique1) from (select unique1 from tenk1 where unique1 < 15 order by unique1) ss;
!               array_agg               
! --------------------------------------
!  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14}
! (1 row)
! 
! select array_agg(ten) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!             array_agg            
! ---------------------------------
!  {0,1,2,3,4,5,6,7,8,9,0,1,2,3,4}
! (1 row)
! 
! select array_agg(nullif(ten, 4)) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!                array_agg               
! ---------------------------------------
!  {0,1,2,3,NULL,5,6,7,8,9,0,1,2,3,NULL}
! (1 row)
! 
! select array_agg(unique1) from tenk1 where unique1 < -15;
!  array_agg 
! -----------
!  
! (1 row)
! 
! select unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select * from unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select unnest(array[1,2,3,4.5]::float8[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,4.5]::numeric[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]);
!  unnest 
! --------
!       1
!       2
!       3
!        
!       4
!        
!        
!       5
!       6
! (9 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
!  unnest 
! --------
!  1
!  2
!  3
!  
!  4
!  
!  
!  5
!  6
! (9 rows)
! 
! select abs(unnest(array[1,2,null,-3]));
!  abs 
! -----
!    1
!    2
!     
!    3
! (4 rows)
! 
! select array_remove(array[1,2,2,3], 2);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array[1,2,2,3], 5);
!  array_remove 
! --------------
!  {1,2,2,3}
! (1 row)
! 
! select array_remove(array[1,NULL,NULL,3], NULL);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array['A','CC','D','C','RR'], 'RR');
!  array_remove 
! --------------
!  {A,CC,D,C}
! (1 row)
! 
! select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowed
! ERROR:  removing elements from multidimensional arrays is not supported
! select array_remove(array['X','X','X'], 'X') = '{}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,3);
!  array_replace 
! ---------------
!  {1,2,3,4}
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,NULL);
!  array_replace 
! ---------------
!  {1,2,NULL,4}
! (1 row)
! 
! select array_replace(array[1,2,NULL,4,NULL],NULL,5);
!  array_replace 
! ---------------
!  {1,2,5,4,5}
! (1 row)
! 
! select array_replace(array['A','B','DD','B'],'B','CC');
!  array_replace 
! ---------------
!  {A,CC,DD,CC}
! (1 row)
! 
! select array_replace(array[1,NULL,3],NULL,NULL);
!  array_replace 
! ---------------
!  {1,NULL,3}
! (1 row)
! 
! select array_replace(array['AB',NULL,'CDE'],NULL,'12');
!  array_replace 
! ---------------
!  {AB,12,CDE}
! (1 row)
! 
! -- Insert/update on a column that is array of composite
! create temp table t1 (f1 int8_tbl[]);
! insert into t1 (f1[5].q1) values(42);
! select * from t1;
!        f1        
! -----------------
!  [5:5]={"(42,)"}
! (1 row)
! 
! update t1 set f1[5].q2 = 43;
! select * from t1;
!         f1         
! -------------------
!  [5:5]={"(42,43)"}
! (1 row)
! 
! -- Check that arrays of composites are safely detoasted when needed
! create temp table src (f1 text);
! insert into src
!   select string_agg(random()::text,'') from generate_series(1,10000);
! create type textandtext as (c1 text, c2 text);
! create temp table dest (f1 textandtext[]);
! insert into dest select array[row(f1,f1)::textandtext] from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! delete from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! truncate table src;
! drop table src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! drop table dest;
! drop type textandtext;
! -- Tests for polymorphic-array form of width_bucket()
! -- this exercises the varwidth and float8 code paths
! SELECT
!     op,
!     width_bucket(op::numeric, ARRAY[1, 3, 5, 10.0]::numeric[]) AS wb_n1,
!     width_bucket(op::numeric, ARRAY[0, 5.5, 9.99]::numeric[]) AS wb_n2,
!     width_bucket(op::numeric, ARRAY[-6, -5, 2.0]::numeric[]) AS wb_n3,
!     width_bucket(op::float8, ARRAY[1, 3, 5, 10.0]::float8[]) AS wb_f1,
!     width_bucket(op::float8, ARRAY[0, 5.5, 9.99]::float8[]) AS wb_f2,
!     width_bucket(op::float8, ARRAY[-6, -5, 2.0]::float8[]) AS wb_f3
! FROM (VALUES
!   (-5.2),
!   (-0.0000000001),
!   (0.000000000001),
!   (1),
!   (1.99999999999999),
!   (2),
!   (2.00000000000001),
!   (3),
!   (4),
!   (4.5),
!   (5),
!   (5.5),
!   (6),
!   (7),
!   (8),
!   (9),
!   (9.99999999999999),
!   (10),
!   (10.0000000000001)
! ) v(op);
!         op        | wb_n1 | wb_n2 | wb_n3 | wb_f1 | wb_f2 | wb_f3 
! ------------------+-------+-------+-------+-------+-------+-------
!              -5.2 |     0 |     0 |     1 |     0 |     0 |     1
!     -0.0000000001 |     0 |     0 |     2 |     0 |     0 |     2
!    0.000000000001 |     0 |     1 |     2 |     0 |     1 |     2
!                 1 |     1 |     1 |     2 |     1 |     1 |     2
!  1.99999999999999 |     1 |     1 |     2 |     1 |     1 |     2
!                 2 |     1 |     1 |     3 |     1 |     1 |     3
!  2.00000000000001 |     1 |     1 |     3 |     1 |     1 |     3
!                 3 |     2 |     1 |     3 |     2 |     1 |     3
!                 4 |     2 |     1 |     3 |     2 |     1 |     3
!               4.5 |     2 |     1 |     3 |     2 |     1 |     3
!                 5 |     3 |     1 |     3 |     3 |     1 |     3
!               5.5 |     3 |     2 |     3 |     3 |     2 |     3
!                 6 |     3 |     2 |     3 |     3 |     2 |     3
!                 7 |     3 |     2 |     3 |     3 |     2 |     3
!                 8 |     3 |     2 |     3 |     3 |     2 |     3
!                 9 |     3 |     2 |     3 |     3 |     2 |     3
!  9.99999999999999 |     3 |     3 |     3 |     3 |     3 |     3
!                10 |     4 |     3 |     3 |     4 |     3 |     3
!  10.0000000000001 |     4 |     3 |     3 |     4 |     3 |     3
! (19 rows)
! 
! -- ensure float8 path handles NaN properly
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 9, 'NaN', 'NaN']::float8[]) AS wb
! FROM (VALUES
!   (-5.2::float8),
!   (4::float8),
!   (77::float8),
!   ('NaN'::float8)
! ) v(op);
!   op  | wb 
! ------+----
!  -5.2 |  0
!     4 |  2
!    77 |  3
!   NaN |  5
! (4 rows)
! 
! -- these exercise the generic fixed-width code path
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 5, 10]) AS wb_1
! FROM generate_series(0,11) as op;
!  op | wb_1 
! ----+------
!   0 |    0
!   1 |    1
!   2 |    1
!   3 |    2
!   4 |    2
!   5 |    3
!   6 |    3
!   7 |    3
!   8 |    3
!   9 |    3
!  10 |    4
!  11 |    4
! (12 rows)
! 
! SELECT width_bucket(now(),
!                     array['yesterday', 'today', 'tomorrow']::timestamptz[]);
!  width_bucket 
! --------------
!             2
! (1 row)
! 
! -- corner cases
! SELECT width_bucket(5, ARRAY[3]);
!  width_bucket 
! --------------
!             1
! (1 row)
! 
! SELECT width_bucket(5, '{}');
!  width_bucket 
! --------------
!             0
! (1 row)
! 
! -- error cases
! SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
! ERROR:  function width_bucket(text, integer[]) does not exist
! LINE 1: SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT width_bucket(5, ARRAY[3, 4, NULL]);
! ERROR:  thresholds array must not contain NULLs
! SELECT width_bucket(5, ARRAY[ARRAY[1, 2], ARRAY[3, 4]]);
! ERROR:  thresholds must be one-dimensional array
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/btree_index.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/btree_index.out	2015-01-26 12:33:23.575031290 +0300
***************
*** 1,152 ****
! --
! -- BTREE_INDEX
! -- test retrieval of min/max keys for each index
! --
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno < 1;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno >= 9999;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno = 4500;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno < '1'::name;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno >= '9999'::name;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno = '4500'::name;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno < '1'::text;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno >= '9999'::text;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno = '4500'::text;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno < '1'::float8;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno >= '9999'::float8;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno = '4500'::float8;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! --
! -- Check correct optimization of LIKE (special index operator support)
! -- for both indexscan and bitmapscan cases
! --
! set enable_seqscan to false;
! set enable_indexscan to true;
! set enable_bitmapscan to false;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! set enable_indexscan to false;
! set enable_bitmapscan to true;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! --
! -- Test B-tree page deletion. In particular, deleting a non-leaf page.
! --
! -- First create a tree that's at least four levels deep. The text inserted
! -- is long and poorly compressible. That way only a few index tuples fit on
! -- each page, allowing us to get a tall tree with fewer pages.
! create table btree_tall_tbl(id int4, t text);
! create index btree_tall_idx on btree_tall_tbl (id, t) with (fillfactor = 10);
! insert into btree_tall_tbl
!   select g, g::text || '_' ||
!           (select string_agg(md5(i::text), '_') from generate_series(1, 50) i)
! from generate_series(1, 100) g;
! -- Delete most entries, and vacuum. This causes page deletions.
! delete from btree_tall_tbl where id < 950;
! vacuum btree_tall_tbl;
! --
! -- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
! -- WAL record type). This happens when a "fast root" page is split.
! --
! -- The vacuum above should've turned the leaf page into a fast root. We just
! -- need to insert some rows to cause the fast root page to split.
! insert into btree_tall_tbl (id, t)
!   select g, repeat('x', 100) from generate_series(1, 500) g;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/hash_index.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/hash_index.out	2015-01-26 12:33:23.583031291 +0300
***************
*** 1,198 ****
! --
! -- HASH_INDEX
! -- grep 843938989 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 843938989;
!  seqno |  random   
! -------+-----------
!     15 | 843938989
! (1 row)
! 
! --
! -- hash index
! -- grep 66766766 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 66766766;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1505703298 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '1505703298'::name;
!  seqno |   random   
! -------+------------
!   9838 | 1505703298
! (1 row)
! 
! --
! -- hash index
! -- grep 7777777 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '7777777'::name;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1351610853 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '1351610853'::text;
!  seqno |   random   
! -------+------------
!   5677 | 1351610853
! (1 row)
! 
! --
! -- hash index
! -- grep 111111112222222233333333 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '111111112222222233333333'::text;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 444705537 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '444705537'::float8;
!  seqno |  random   
! -------+-----------
!   7853 | 444705537
! (1 row)
! 
! --
! -- hash index
! -- grep 88888888 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '88888888'::float8;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep '^90[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --    WHERE x = 90;
! --
! -- hash index
! -- grep '^1000[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --    WHERE x = 1000;
! --
! -- HASH
! --
! UPDATE hash_i4_heap
!    SET random = 1
!    WHERE hash_i4_heap.seqno = 1492;
! SELECT h.seqno AS i1492, h.random AS i1
!    FROM hash_i4_heap h
!    WHERE h.random = 1;
!  i1492 | i1 
! -------+----
!   1492 |  1
! (1 row)
! 
! UPDATE hash_i4_heap
!    SET seqno = 20000
!    WHERE hash_i4_heap.random = 1492795354;
! SELECT h.seqno AS i20000
!    FROM hash_i4_heap h
!    WHERE h.random = 1492795354;
!  i20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_name_heap
!    SET random = '0123456789abcdef'::name
!    WHERE hash_name_heap.seqno = 6543;
! SELECT h.seqno AS i6543, h.random AS c0_to_f
!    FROM hash_name_heap h
!    WHERE h.random = '0123456789abcdef'::name;
!  i6543 |     c0_to_f      
! -------+------------------
!   6543 | 0123456789abcdef
! (1 row)
! 
! UPDATE hash_name_heap
!    SET seqno = 20000
!    WHERE hash_name_heap.random = '76652222'::name;
! --
! -- this is the row we just replaced; index scan should return zero rows
! --
! SELECT h.seqno AS emptyset
!    FROM hash_name_heap h
!    WHERE h.random = '76652222'::name;
!  emptyset 
! ----------
! (0 rows)
! 
! UPDATE hash_txt_heap
!    SET random = '0123456789abcdefghijklmnop'::text
!    WHERE hash_txt_heap.seqno = 4002;
! SELECT h.seqno AS i4002, h.random AS c0_to_p
!    FROM hash_txt_heap h
!    WHERE h.random = '0123456789abcdefghijklmnop'::text;
!  i4002 |          c0_to_p           
! -------+----------------------------
!   4002 | 0123456789abcdefghijklmnop
! (1 row)
! 
! UPDATE hash_txt_heap
!    SET seqno = 20000
!    WHERE hash_txt_heap.random = '959363399'::text;
! SELECT h.seqno AS t20000
!    FROM hash_txt_heap h
!    WHERE h.random = '959363399'::text;
!  t20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET random = '-1234.1234'::float8
!    WHERE hash_f8_heap.seqno = 8906;
! SELECT h.seqno AS i8096, h.random AS f1234_1234
!    FROM hash_f8_heap h
!    WHERE h.random = '-1234.1234'::float8;
!  i8096 | f1234_1234 
! -------+------------
!   8906 | -1234.1234
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET seqno = 20000
!    WHERE hash_f8_heap.random = '488912369'::float8;
! SELECT h.seqno AS f20000
!    FROM hash_f8_heap h
!    WHERE h.random = '488912369'::float8;
!  f20000 
! --------
!   20000
! (1 row)
! 
! -- UPDATE hash_ovfl_heap
! --    SET x = 1000
! --   WHERE x = 90;
! -- this vacuums the index as well
! -- VACUUM hash_ovfl_heap;
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --   WHERE x = 90;
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --  WHERE x = 1000;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/update.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/update.out	2015-01-26 12:33:23.587031291 +0300
***************
*** 1,150 ****
! --
! -- UPDATE syntax tests
! --
! CREATE TABLE update_test (
!     a   INT DEFAULT 10,
!     b   INT,
!     c   TEXT
! );
! INSERT INTO update_test VALUES (5, 10, 'foo');
! INSERT INTO update_test(b, a) VALUES (15, 10);
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!   5 | 10 | foo
!  10 | 15 | 
! (2 rows)
! 
! UPDATE update_test SET a = DEFAULT, b = DEFAULT;
! SELECT * FROM update_test;
!  a  | b |  c  
! ----+---+-----
!  10 |   | foo
!  10 |   | 
! (2 rows)
! 
! -- aliases for the UPDATE target table
! UPDATE update_test AS t SET b = 10 WHERE t.a = 10;
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!  10 | 10 | foo
!  10 | 10 | 
! (2 rows)
! 
! UPDATE update_test t SET b = t.b + 10 WHERE t.a = 10;
! SELECT * FROM update_test;
!  a  | b  |  c  
! ----+----+-----
!  10 | 20 | foo
!  10 | 20 | 
! (2 rows)
! 
! --
! -- Test VALUES in FROM
! --
! UPDATE update_test SET a=v.i FROM (VALUES(100, 20)) AS v(i, j)
!   WHERE update_test.b = v.j;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
! (2 rows)
! 
! --
! -- Test multiple-set-clause syntax
! --
! INSERT INTO update_test SELECT a,b+1,c FROM update_test;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
!  100 | 21 | foo
!  100 | 21 | 
! (4 rows)
! 
! UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
! SELECT * FROM update_test;
!   a  | b  |   c   
! -----+----+-------
!  100 | 20 | 
!  100 | 21 | 
!   10 | 31 | bugle
!   10 | 32 | bugle
! (4 rows)
! 
! UPDATE update_test SET (c,b) = ('car', a+b), a = a + 1 WHERE a = 10;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | 
!  100 | 21 | 
!   11 | 41 | car
!   11 | 42 | car
! (4 rows)
! 
! -- fail, multi assignment to same column:
! UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
! ERROR:  multiple assignments to same column "b"
! -- uncorrelated sub-select:
! UPDATE update_test
!   SET (b,a) = (select a,b from update_test where b = 41 and c = 'car')
!   WHERE a = 100 AND b = 20;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 21 | 
!   11 | 41 | car
!   11 | 42 | car
!   41 | 11 | 
! (4 rows)
! 
! -- correlated sub-select:
! UPDATE update_test o
!   SET (b,a) = (select a+1,b from update_test i
!                where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
! SELECT * FROM update_test;
!  a  |  b  |  c  
! ----+-----+-----
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
!  11 |  42 | 
! (4 rows)
! 
! -- fail, multiple rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test);
! ERROR:  more than one row returned by a subquery used as an expression
! -- set to null if no rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)
!   WHERE a = 11;
! SELECT * FROM update_test;
!  a  |  b  |  c  
! ----+-----+-----
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
!     |     | 
! (4 rows)
! 
! -- if an alias for the target table is specified, don't allow references
! -- to the original table name
! UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
! ERROR:  invalid reference to FROM-clause entry for table "update_test"
! LINE 1: UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a...
!                                         ^
! HINT:  Perhaps you meant to reference the table alias "t".
! -- Make sure that we can update to a TOASTed value.
! UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
! SELECT a, b, char_length(c) FROM update_test;
!  a  |  b  | char_length 
! ----+-----+-------------
!  21 | 101 |            
!     |     |            
!  41 |  12 |       10000
!  42 |  12 |       10000
! (4 rows)
! 
! DROP TABLE update_test;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/namespace.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/namespace.out	2015-01-26 12:33:23.595031291 +0300
***************
*** 1,71 ****
! --
! -- Regression tests for schemas (namespaces)
! --
! CREATE SCHEMA test_schema_1
!        CREATE UNIQUE INDEX abc_a_idx ON abc (a)
!        CREATE VIEW abc_view AS
!               SELECT a+1 AS a, b+1 AS b FROM abc
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! -- verify that the objects were created
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      5
! (1 row)
! 
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! SELECT * FROM test_schema_1.abc;
!  a | b 
! ---+---
!  1 |  
!  2 |  
!  3 |  
! (3 rows)
! 
! SELECT * FROM test_schema_1.abc_view;
!  a | b 
! ---+---
!  2 |  
!  3 |  
!  4 |  
! (3 rows)
! 
! ALTER SCHEMA test_schema_1 RENAME TO test_schema_renamed;
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      0
! (1 row)
! 
! -- test IF NOT EXISTS cases
! CREATE SCHEMA test_schema_renamed; -- fail, already exists
! ERROR:  schema "test_schema_renamed" already exists
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed; -- ok with notice
! NOTICE:  schema "test_schema_renamed" already exists, skipping
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed -- fail, disallowed
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! ERROR:  CREATE SCHEMA IF NOT EXISTS cannot include schema elements
! LINE 2:        CREATE TABLE abc (
!                ^
! DROP SCHEMA test_schema_renamed CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table test_schema_renamed.abc
! drop cascades to view test_schema_renamed.abc_view
! -- verify that the objects were dropped
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_renamed');
!  count 
! -------
!      0
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/prepared_xacts.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/prepared_xacts.out	2015-01-26 12:33:23.567031290 +0300
***************
*** 1,254 ****
! --
! -- PREPARED TRANSACTIONS (two-phase commit)
! --
! -- We can't readily test persistence of prepared xacts within the
! -- regression script framework, unfortunately.  Note that a crash
! -- isn't really needed ... stopping and starting the postmaster would
! -- be enough, but we can't even do that here.
! -- create a simple table that we'll use in the tests
! CREATE TABLE pxtest1 (foobar VARCHAR(10));
! INSERT INTO pxtest1 VALUES ('aaa');
! -- Test PREPARE TRANSACTION
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'bbb' WHERE foobar = 'aaa';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  bbb
! (1 row)
! 
! PREPARE TRANSACTION 'foo1';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! -- Test pg_prepared_xacts system view
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo1
! (1 row)
! 
! -- Test ROLLBACK PREPARED
! ROLLBACK PREPARED 'foo1';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Test COMMIT PREPARED
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! INSERT INTO pxtest1 VALUES ('ddd');
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! PREPARE TRANSACTION 'foo2';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
! (1 row)
! 
! COMMIT PREPARED 'foo2';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- Test duplicate gids
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'eee' WHERE foobar = 'ddd';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  eee
! (2 rows)
! 
! PREPARE TRANSACTION 'foo3';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo3
! (1 row)
! 
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! INSERT INTO pxtest1 VALUES ('fff');
! -- This should fail, because the gid foo3 is already in use
! PREPARE TRANSACTION 'foo3';
! ERROR:  transaction identifier "foo3" is already in use
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! ROLLBACK PREPARED 'foo3';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- Test serialization failure (SSI)
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE pxtest1 SET foobar = 'eee' WHERE foobar = 'ddd';
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  eee
! (2 rows)
! 
! PREPARE TRANSACTION 'foo4';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo4
! (1 row)
! 
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! SELECT * FROM pxtest1;
!  foobar 
! --------
!  aaa
!  ddd
! (2 rows)
! 
! -- This should fail, because the two transactions have a write-skew anomaly
! INSERT INTO pxtest1 VALUES ('fff');
! ERROR:  could not serialize access due to read/write dependencies among transactions
! DETAIL:  Reason code: Canceled on identification as a pivot, during write.
! HINT:  The transaction might succeed if retried.
! PREPARE TRANSACTION 'foo5';
! SELECT gid FROM pg_prepared_xacts;
!  gid  
! ------
!  foo4
! (1 row)
! 
! ROLLBACK PREPARED 'foo4';
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Clean up
! DROP TABLE pxtest1;
! -- Test subtransactions
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
!   CREATE TABLE pxtest2 (a int);
!   INSERT INTO pxtest2 VALUES (1);
!   SAVEPOINT a;
!     INSERT INTO pxtest2 VALUES (2);
!   ROLLBACK TO a;
!   SAVEPOINT b;
!   INSERT INTO pxtest2 VALUES (3);
! PREPARE TRANSACTION 'regress-one';
! CREATE TABLE pxtest3(fff int);
! -- Test shared invalidation
! BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
!   DROP TABLE pxtest3;
!   CREATE TABLE pxtest4 (a int);
!   INSERT INTO pxtest4 VALUES (1);
!   INSERT INTO pxtest4 VALUES (2);
!   DECLARE foo CURSOR FOR SELECT * FROM pxtest4;
!   -- Fetch 1 tuple, keeping the cursor open
!   FETCH 1 FROM foo;
!  a 
! ---
!  1
! (1 row)
! 
! PREPARE TRANSACTION 'regress-two';
! -- No such cursor
! FETCH 1 FROM foo;
! ERROR:  cursor "foo" does not exist
! -- Table doesn't exist, the creation hasn't been committed yet
! SELECT * FROM pxtest2;
! ERROR:  relation "pxtest2" does not exist
! LINE 1: SELECT * FROM pxtest2;
!                       ^
! -- There should be two prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-one
!  regress-two
! (2 rows)
! 
! -- pxtest3 should be locked because of the pending DROP
! set statement_timeout to 2000;
! SELECT * FROM pxtest3;
! ERROR:  canceling statement due to statement timeout
! reset statement_timeout;
! -- Disconnect, we will continue testing in a different backend
! \c -
! -- There should still be two prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-one
!  regress-two
! (2 rows)
! 
! -- pxtest3 should still be locked because of the pending DROP
! set statement_timeout to 2000;
! SELECT * FROM pxtest3;
! ERROR:  canceling statement due to statement timeout
! reset statement_timeout;
! -- Commit table creation
! COMMIT PREPARED 'regress-one';
! \d pxtest2
!     Table "public.pxtest2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
! 
! SELECT * FROM pxtest2;
!  a 
! ---
!  1
!  3
! (2 rows)
! 
! -- There should be one prepared transaction
! SELECT gid FROM pg_prepared_xacts;
!      gid     
! -------------
!  regress-two
! (1 row)
! 
! -- Commit table drop
! COMMIT PREPARED 'regress-two';
! SELECT * FROM pxtest3;
! ERROR:  relation "pxtest3" does not exist
! LINE 1: SELECT * FROM pxtest3;
!                       ^
! -- There should be no prepared transactions
! SELECT gid FROM pg_prepared_xacts;
!  gid 
! -----
! (0 rows)
! 
! -- Clean up
! DROP TABLE pxtest2;
! DROP TABLE pxtest3;  -- will still be there if prepared xacts are disabled
! ERROR:  table "pxtest3" does not exist
! DROP TABLE pxtest4;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/delete.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/delete.out	2015-01-26 12:33:23.587031291 +0300
***************
*** 1,33 ****
! CREATE TABLE delete_test (
!     id SERIAL PRIMARY KEY,
!     a INT,
!     b text
! );
! INSERT INTO delete_test (a) VALUES (10);
! INSERT INTO delete_test (a, b) VALUES (50, repeat('x', 10000));
! INSERT INTO delete_test (a) VALUES (100);
! -- allow an alias to be specified for DELETE's target table
! DELETE FROM delete_test AS dt WHERE dt.a > 75;
! -- if an alias is specified, don't allow the original table name
! -- to be referenced
! DELETE FROM delete_test dt WHERE delete_test.a > 25;
! ERROR:  invalid reference to FROM-clause entry for table "delete_test"
! LINE 1: DELETE FROM delete_test dt WHERE delete_test.a > 25;
!                                          ^
! HINT:  Perhaps you meant to reference the table alias "dt".
! SELECT id, a, char_length(b) FROM delete_test;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
!   2 | 50 |       10000
! (2 rows)
! 
! -- delete a row with a TOASTed value
! DELETE FROM delete_test WHERE a > 25;
! SELECT id, a, char_length(b) FROM delete_test;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
! (1 row)
! 
! DROP TABLE delete_test;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/brin.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/brin.out	2015-01-26 12:33:24.315031329 +0300
***************
*** 1,182 ****
! CREATE TABLE brintest (byteacol bytea,
! 	charcol "char",
! 	namecol name,
! 	int8col bigint,
! 	int2col smallint,
! 	int4col integer,
! 	textcol text,
! 	oidcol oid,
! 	tidcol tid,
! 	float4col real,
! 	float8col double precision,
! 	macaddrcol macaddr,
! 	inetcol inet,
! 	bpcharcol character,
! 	datecol date,
! 	timecol time without time zone,
! 	timestampcol timestamp without time zone,
! 	timestamptzcol timestamp with time zone,
! 	intervalcol interval,
! 	timetzcol time with time zone,
! 	bitcol bit(10),
! 	varbitcol bit varying(16),
! 	numericcol numeric,
! 	uuidcol uuid,
! 	lsncol pg_lsn
! ) WITH (fillfactor=10);
! INSERT INTO brintest SELECT
! 	repeat(stringu1, 42)::bytea,
! 	substr(stringu1, 1, 1)::"char",
! 	stringu1::name, 142857 * tenthous,
! 	thousand,
! 	twothousand,
! 	repeat(stringu1, 42),
! 	unique1::oid,
! 	format('(%s,%s)', tenthous, twenty)::tid,
! 	(four + 1.0)/(hundred+1),
! 	odd::float8 / (tenthous + 1),
! 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
! 	inet '10.2.3.4' + tenthous,
! 	substr(stringu1, 1, 1)::bpchar,
! 	date '1995-08-15' + tenthous,
! 	time '01:20:30' + thousand * interval '18.5 second',
! 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
! 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
! 	justify_days(justify_hours(tenthous * interval '12 minutes')),
! 	timetz '01:30:20' + hundred * interval '15 seconds',
! 	thousand::bit(10),
! 	tenthous::bit(16)::varbit,
! 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
! 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
! 	format('%s/%s%s', odd, even, tenthous)::pg_lsn
! FROM tenk1 LIMIT 5;
! -- throw in some NULL-only tuples too
! INSERT INTO brintest SELECT NULL FROM tenk1 LIMIT 25;
! CREATE INDEX brinidx ON brintest USING brin (
! 	byteacol,
! 	charcol,
! 	namecol,
! 	int8col,
! 	int2col,
! 	int4col,
! 	textcol,
! 	oidcol,
! 	tidcol,
! 	float4col,
! 	float8col,
! 	macaddrcol,
! 	inetcol,
! 	bpcharcol,
! 	datecol,
! 	timecol,
! 	timestampcol,
! 	timestamptzcol,
! 	intervalcol,
! 	timetzcol,
! 	bitcol,
! 	varbitcol,
! 	numericcol,
! 	uuidcol,
! 	lsncol
! ) with (pages_per_range = 1);
! BEGIN;
! CREATE TABLE brinopers (colname name, op text[], value text[],
! 	check (cardinality(op) = cardinality(value)));
! INSERT INTO brinopers VALUES ('byteacol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAAA, AAAAAA, AAAAAA}');
! INSERT INTO brinopers VALUES ('charcol', '{>, >=, =, <=, <}', '{Z, Z, A, A, A}');
! INSERT INTO brinopers VALUES ('namecol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAAA, AAAAAA, AAAAAA}');
! INSERT INTO brinopers VALUES ('int8col', '{>, >=, =, <=, <}', '{1428427143, 1428427143, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('int2col', '{>, >=, =, <=, <}', '{999, 999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('int4col', '{>, >=, =, <=, <}', '{1999, 1999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('textcol', '{>, >=, =, <=, <}', '{ZZAAAA, ZZAAAA, AAAAA, AAAAA, AAAAA}');
! INSERT INTO brinopers VALUES ('oidcol', '{>, >=, =, <=, <}', '{9999, 9999, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('tidcol', '{>, >=, =, <=, <}', '{"(9999,19)", "(9999,19)", "(0,0)", "(0,0)", "(0,0)"}');
! INSERT INTO brinopers VALUES ('float4col', '{>, >=, =, <=, <}', '{1, 1, 0.0103093, 0.0103093, 0.0103093}');
! INSERT INTO brinopers VALUES ('float8col', '{>, >=, =, <=, <}', '{1.98, 1.98, 0, 0, 0}');
! INSERT INTO brinopers VALUES ('inetcol', '{>, >=, =, <=, <}', '{10.2.42.19, 10.2.42.19, 10.2.3.4, 10.2.3.4, 10.2.3.4}');
! INSERT INTO brinopers VALUES ('bpcharcol', '{>, >=, =, <=, <}', '{Z, Z, A, A, A}');
! INSERT INTO brinopers VALUES ('datecol', '{>, >=, =, <=, <}', '{2022-12-30, 2022-12-30, 1995-08-15, 1995-08-15, 1995-08-15}');
! INSERT INTO brinopers VALUES ('timecol', '{>, >=, =, <=, <}', '{06:28:31.5, 06:28:31.5, 01:20:30, 01:20:30, 01:20:30}');
! INSERT INTO brinopers VALUES ('timestampcol', '{>, >=, =, <=, <}', '{1984-01-20 22:42:21, 1984-01-20 22:42:21, 1942-07-23 03:05:09, 1942-07-23 03:05:09, 1942-07-23 03:05:09}');
! INSERT INTO brinopers VALUES ('timestamptzcol', '{>, >=, =, <=, <}', '{1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03, 1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04}');
! INSERT INTO brinopers VALUES ('intervalcol', '{>, >=, =, <=, <}', '{2 mons 23 days 07:48:00, 2 mons 23 days 07:48:00, 00:00:00, 00:00:00, 00:00:00}');
! INSERT INTO brinopers VALUES ('timetzcol', '{>, >=, =, <=, <}', '{01:55:05-03, 01:55:05-03, 01:30:20-03, 01:30:20-03, 01:30:20-03}');
! INSERT INTO brinopers VALUES ('numericcol', '{>, >=, =, <=, <}', '{99470151.9, 99470151.9, 0.00, 0.01, 0.01}');
! INSERT INTO brinopers VALUES ('macaddrcol', '{>, >=, =, <=, <}', '{ff:fe:00:00:00:00, ff:fe:00:00:00:00, 00:00:01:00:00:00, 00:00:01:00:00:00, 00:00:01:00:00:00}');
! INSERT INTO brinopers VALUES ('bitcol', '{>, >=, =, <=, <}', '{1111111000, 1111111000, 0000000010, 0000000010, 0000000010}');
! INSERT INTO brinopers VALUES ('varbitcol', '{>, >=, =, <=, <}', '{1111111111111000, 1111111111111000, 0000000000000100, 0000000000000100, 0000000000000100}');
! INSERT INTO brinopers VALUES ('uuidcol', '{>, >=, =, <=, <}', '{99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998, 00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040005}');
! INSERT INTO brinopers VALUES ('lsncol', '{>, >=, =, <=, <, IS, IS NOT}', '{198/1999799, 198/1999799, 30/312815, 0/1200, 0/1200, NULL, NULL}');
! COMMIT;
! DO $x$
! DECLARE
!         r record;
!         tabname text;
!         tabname_ss text;
! 		count int;
! 		query text;
! 		plan text;
! BEGIN
!         FOR r IN SELECT row_number() OVER (), colname, oper, value[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP
!                 tabname := format('qry_%s', r.row_number);
!                 tabname_ss := tabname || '_ss';
! 				query = format($y$INSERT INTO %s SELECT ctid FROM brintest WHERE %s %s %L $y$,
!                         tabname, r.colname, r.oper, r.value);
! 				-- run the query using the brin index
!                 SET enable_seqscan = 0;
!                 SET enable_bitmapscan = 1;
!                 EXECUTE format('create temp table %s (tid tid) ON COMMIT DROP', tabname);
!                 EXECUTE query;
! 
! 				-- run the query using a seqscan
!                 SET enable_seqscan = 1;
!                 SET enable_bitmapscan = 0;
! 				query = format($y$INSERT INTO %s SELECT ctid FROM brintest WHERE %s %s %L $y$,
!                         tabname_ss, r.colname, r.oper, r.value);
!                 EXECUTE format('create temp table %s (tid tid) ON COMMIT DROP', tabname_ss);
!                 EXECUTE query;
! 
! 				-- make sure both return the same results
!                 EXECUTE format('SELECT * from %s EXCEPT ALL SELECT * FROM %s', tabname, tabname_ss);
! 				GET DIAGNOSTICS count = ROW_COUNT;
!                 IF count <> 0 THEN RAISE EXCEPTION 'something not right in %: count %', r, count; END IF;
!                 EXECUTE format('SELECT * from %s EXCEPT ALL SELECT * FROM %s', tabname_ss, tabname);
! 				GET DIAGNOSTICS count = ROW_COUNT;
!                 IF count <> 0 THEN RAISE EXCEPTION 'something not right in %: count %', r, count; END IF;
!         end loop;
! end;
! $x$;
! INSERT INTO brintest SELECT
! 	repeat(stringu1, 42)::bytea,
! 	substr(stringu1, 1, 1)::"char",
! 	stringu1::name, 142857 * tenthous,
! 	thousand,
! 	twothousand,
! 	repeat(stringu1, 42),
! 	unique1::oid,
! 	format('(%s,%s)', tenthous, twenty)::tid,
! 	(four + 1.0)/(hundred+1),
! 	odd::float8 / (tenthous + 1),
! 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
! 	inet '10.2.3.4' + tenthous,
! 	substr(stringu1, 1, 1)::bpchar,
! 	date '1995-08-15' + tenthous,
! 	time '01:20:30' + thousand * interval '18.5 second',
! 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
! 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
! 	justify_days(justify_hours(tenthous * interval '12 minutes')),
! 	timetz '01:30:20' + hundred * interval '15 seconds',
! 	thousand::bit(10),
! 	tenthous::bit(16)::varbit,
! 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
! 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
! 	format('%s/%s%s', odd, even, tenthous)::pg_lsn
! FROM tenk1 LIMIT 5 OFFSET 5;
! SELECT brin_summarize_new_values('brinidx'::regclass);
!  brin_summarize_new_values 
! ---------------------------
!                          5
! (1 row)
! 
! UPDATE brintest SET int8col = int8col * int4col;
! UPDATE brintest SET textcol = '' WHERE textcol IS NOT NULL;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/gin.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/gin.out	2015-01-26 12:33:24.303031328 +0300
***************
*** 1,23 ****
! --
! -- Test GIN indexes.
! --
! -- There are other tests to test different GIN opclassed. This is for testing
! -- GIN itself.
! -- Create and populate a test table with a GIN index.
! create table gin_test_tbl(i int4[]);
! create index gin_test_idx on gin_test_tbl using gin (i) with (fastupdate = on);
! insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
! insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
! vacuum gin_test_tbl; -- flush the fastupdate buffers
! -- Test vacuuming
! delete from gin_test_tbl where i @> array[2];
! vacuum gin_test_tbl;
! -- Disable fastupdate, and do more insertions. With fastupdate enabled, most
! -- insertions (by flushing the list pages) cause page splits. Without
! -- fastupdate, we get more churn in the GIN data leaf pages, and exercise the
! -- recompression codepaths.
! alter index gin_test_idx set (fastupdate = off);
! insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 1000) g;
! insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
! delete from gin_test_tbl where i @> array[2];
! vacuum gin_test_tbl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/gist.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/gist.out	2015-01-26 12:33:24.307031328 +0300
***************
*** 1,19 ****
! --
! -- Test GiST indexes.
! --
! -- There are other tests to test different GiST opclasses. This is for
! -- testing GiST code itself. Vacuuming in particular.
! create table gist_point_tbl(id int4, p point);
! create index gist_pointidx on gist_point_tbl using gist(p);
! -- Insert enough data to create a tree that's a couple of levels deep.
! insert into gist_point_tbl (id, p)
! select g,        point(g*10, g*10) from generate_series(1, 10000) g;
! insert into gist_point_tbl (id, p)
! select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
! -- To test vacuum, delete some entries from all over the index.
! delete from gist_point_tbl where id % 2 = 1;
! -- And also delete some concentration of values. (GiST doesn't currently
! -- attempt to delete pages even when they become empty, but if it did, this
! -- would exercise it)
! delete from gist_point_tbl where id < 10000;
! vacuum gist_point_tbl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/spgist.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/spgist.out	2015-01-26 12:33:24.315031329 +0300
***************
*** 1,39 ****
! --
! -- Test SP-GiST indexes.
! --
! -- There are other tests to test different SP-GiST opclasses. This is for
! -- testing SP-GiST code itself.
! create table spgist_point_tbl(id int4, p point);
! create index spgist_point_idx on spgist_point_tbl using spgist(p);
! -- Test vacuum-root operation. It gets invoked when the root is also a leaf,
! -- i.e. the index is very small.
! insert into spgist_point_tbl (id, p)
! select g, point(g*10, g*10) from generate_series(1, 10) g;
! delete from spgist_point_tbl where id < 5;
! vacuum spgist_point_tbl;
! -- Insert more data, to make the index a few levels deep.
! insert into spgist_point_tbl (id, p)
! select g,      point(g*10, g*10) from generate_series(1, 10000) g;
! insert into spgist_point_tbl (id, p)
! select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
! -- To test vacuum, delete some entries from all over the index.
! delete from spgist_point_tbl where id % 2 = 1;
! -- And also delete some concentration of values. (SP-GiST doesn't currently
! -- attempt to delete pages even when they become empty, but if it did, this
! -- would exercise it)
! delete from spgist_point_tbl where id < 10000;
! vacuum spgist_point_tbl;
! -- The point opclass's choose method only uses the spgMatchNode action,
! -- so the other actions are not tested by the above. Create an index using
! -- text opclass, which uses the others actions.
! create table spgist_text_tbl(id int4, t text);
! create index spgist_text_idx on spgist_text_tbl using spgist(t);
! insert into spgist_text_tbl (id, t)
! select g, 'f' || repeat('o', 100) || g from generate_series(1, 10000) g
! union all
! select g, 'baaaaaaaaaaaaaar' || g from generate_series(1, 1000) g;
! -- Do a lot of insertions that have to split an existing node. Hopefully
! -- one of these will cause the page to run out of space, causing the inner
! -- tuple to be moved to another page.
! insert into spgist_text_tbl (id, t)
! select -g, 'f' || repeat('o', 100-g) || 'surprise' from generate_series(1, 100) g;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/privileges.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/privileges.out	2015-01-26 12:33:24.307031328 +0300
***************
*** 1,1509 ****
! --
! -- Test access privileges
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when users/groups don't exist
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS regressgroup1;
! DROP ROLE IF EXISTS regressgroup2;
! DROP ROLE IF EXISTS regressuser1;
! DROP ROLE IF EXISTS regressuser2;
! DROP ROLE IF EXISTS regressuser3;
! DROP ROLE IF EXISTS regressuser4;
! DROP ROLE IF EXISTS regressuser5;
! DROP ROLE IF EXISTS regressuser6;
! SELECT lo_unlink(oid) FROM pg_largeobject_metadata;
!  lo_unlink 
! -----------
! (0 rows)
! 
! RESET client_min_messages;
! -- test proper begins here
! CREATE USER regressuser1;
! CREATE USER regressuser2;
! CREATE USER regressuser3;
! CREATE USER regressuser4;
! CREATE USER regressuser5;
! CREATE USER regressuser5;	-- duplicate
! ERROR:  role "regressuser5" already exists
! CREATE GROUP regressgroup1;
! CREATE GROUP regressgroup2 WITH USER regressuser1, regressuser2;
! ALTER GROUP regressgroup1 ADD USER regressuser4;
! ALTER GROUP regressgroup2 ADD USER regressuser2;	-- duplicate
! NOTICE:  role "regressuser2" is already a member of role "regressgroup2"
! ALTER GROUP regressgroup2 DROP USER regressuser2;
! GRANT regressgroup2 TO regressuser4 WITH ADMIN OPTION;
! -- test owner privileges
! SET SESSION AUTHORIZATION regressuser1;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser1 | regressuser1
! (1 row)
! 
! CREATE TABLE atest1 ( a int, b text );
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! INSERT INTO atest1 VALUES (1, 'one');
! DELETE FROM atest1;
! UPDATE atest1 SET a = 1 WHERE b = 'blech';
! TRUNCATE atest1;
! BEGIN;
! LOCK atest1 IN ACCESS EXCLUSIVE MODE;
! COMMIT;
! REVOKE ALL ON atest1 FROM PUBLIC;
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! GRANT ALL ON atest1 TO regressuser2;
! GRANT SELECT ON atest1 TO regressuser3, regressuser4;
! SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
! CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
! GRANT SELECT ON atest2 TO regressuser2;
! GRANT UPDATE ON atest2 TO regressuser3;
! GRANT INSERT ON atest2 TO regressuser4;
! GRANT TRUNCATE ON atest2 TO regressuser5;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser2 | regressuser2
! (1 row)
! 
! -- try various combinations of queries on atest1 and atest2
! SELECT * FROM atest1; -- ok
!  a | b 
! ---+---
! (0 rows)
! 
! SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
! (0 rows)
! 
! INSERT INTO atest1 VALUES (2, 'two'); -- ok
! INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
! UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
! UPDATE atest2 SET col2 = NOT col2; -- fail
! ERROR:  permission denied for relation atest2
! SELECT * FROM atest1 FOR UPDATE; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest2
! DELETE FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! TRUNCATE atest2; -- fail
! ERROR:  permission denied for relation atest2
! BEGIN;
! LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
! ERROR:  permission denied for relation atest2
! COMMIT;
! COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for relation atest2
! GRANT ALL ON atest1 TO PUBLIC; -- fail
! WARNING:  no privileges were granted for "atest1"
! -- checks in subquery, both ok
! SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
!  a | b 
! ---+---
! (0 rows)
! 
! SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
!  col1 | col2 
! ------+------
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser3;
! SELECT session_user, current_user;
!  session_user | current_user 
! --------------+--------------
!  regressuser3 | regressuser3
! (1 row)
! 
! SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 VALUES (2, 'two'); -- fail
! ERROR:  permission denied for relation atest1
! INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for relation atest2
! INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
! ERROR:  permission denied for relation atest1
! UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
! ERROR:  permission denied for relation atest1
! UPDATE atest2 SET col2 = NULL; -- ok
! UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
! ERROR:  permission denied for relation atest2
! UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- ok
! SELECT * FROM atest1 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest1
! SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for relation atest2
! DELETE FROM atest2; -- fail
! ERROR:  permission denied for relation atest2
! TRUNCATE atest2; -- fail
! ERROR:  permission denied for relation atest2
! BEGIN;
! LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
! COMMIT;
! COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for relation atest2
! -- checks in subquery, both fail
! SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
! ERROR:  permission denied for relation atest2
! SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
! ERROR:  permission denied for relation atest2
! SET SESSION AUTHORIZATION regressuser4;
! COPY atest2 FROM stdin; -- ok
! SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! -- groups
! SET SESSION AUTHORIZATION regressuser3;
! CREATE TABLE atest3 (one int, two int, three int);
! GRANT DELETE ON atest3 TO GROUP regressgroup2;
! SET SESSION AUTHORIZATION regressuser1;
! SELECT * FROM atest3; -- fail
! ERROR:  permission denied for relation atest3
! DELETE FROM atest3; -- ok
! -- views
! SET SESSION AUTHORIZATION regressuser3;
! CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
! /* The next *should* fail, but it's not implemented that way yet. */
! CREATE VIEW atestv2 AS SELECT * FROM atest2;
! CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
! /* Empty view is a corner case that failed in 9.2. */
! CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
! SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for relation atest2
! GRANT SELECT ON atestv1, atestv3 TO regressuser4;
! GRANT SELECT ON atestv2 TO regressuser2;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for relation atestv2
! SELECT * FROM atestv3; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! SELECT * FROM atestv0; -- fail
! ERROR:  permission denied for relation atestv0
! -- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
! select * from
!   ((select a.q1 as x from int8_tbl a offset 0)
!    union all
!    (select b.q2 as x from int8_tbl b offset 0)) ss
! where false;
! ERROR:  permission denied for relation int8_tbl
! set constraint_exclusion = on;
! select * from
!   ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
!    union all
!    (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
! where x < 0;
! ERROR:  permission denied for relation int8_tbl
! reset constraint_exclusion;
! CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
! SELECT * FROM atestv4; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! GRANT SELECT ON atestv4 TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! -- Two complex cases:
! SELECT * FROM atestv3; -- fail
! ERROR:  permission denied for relation atestv3
! SELECT * FROM atestv4; -- ok (even though regressuser2 cannot access underlying atestv3)
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
! SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
!  bar  | t
! (1 row)
! 
! SELECT * FROM atestv2; -- fail (even though regressuser2 can access underlying atest2)
! ERROR:  permission denied for relation atest2
! -- Test column level permissions
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atest5 (one int, two int, three int);
! CREATE TABLE atest6 (one int, two int, blue int);
! GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regressuser4;
! GRANT ALL (one) ON atest5 TO regressuser3;
! INSERT INTO atest5 VALUES (1,2,3);
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! SELECT one FROM atest5; -- ok
!  one 
! -----
!    1
! (1 row)
! 
! COPY atest5 (one) TO stdout; -- ok
! 1
! SELECT two FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (two) TO stdout; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest5 FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (one,two) TO stdout; -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5; -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
! ERROR:  permission denied for relation atest5
! SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
! ERROR:  permission denied for relation atest5
! SELECT 1 FROM atest5 WHERE two = 2; -- fail
! ERROR:  permission denied for relation atest5
! SELECT * FROM atest1, atest5; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest1.* FROM atest1, atest5; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
! SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
! SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
! SELECT one, two FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT (one,two) ON atest6 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT (two) ON atest5 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
!  one | two 
! -----+-----
! (0 rows)
! 
! -- test column-level privileges for INSERT and UPDATE
! INSERT INTO atest5 (two) VALUES (3); -- ok
! COPY atest5 FROM stdin; -- fail
! ERROR:  permission denied for relation atest5
! COPY atest5 (two) FROM stdin; -- ok
! INSERT INTO atest5 (three) VALUES (4); -- fail
! ERROR:  permission denied for relation atest5
! INSERT INTO atest5 VALUES (5,5,5); -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET three = 10; -- ok
! UPDATE atest5 SET one = 8; -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET three = 5, one = 2; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! REVOKE ALL (one) ON atest5 FROM regressuser4;
! GRANT SELECT (one,two,blue) ON atest6 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT one FROM atest5; -- fail
! ERROR:  permission denied for relation atest5
! UPDATE atest5 SET one = 1; -- fail
! ERROR:  permission denied for relation atest5
! SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
! COPY atest6 TO stdout; -- ok
! -- test column-level privileges when involved with DELETE
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 ADD COLUMN three integer;
! GRANT DELETE ON atest5 TO regressuser3;
! GRANT SELECT (two) ON atest5 TO regressuser3;
! REVOKE ALL (one) ON atest5 FROM regressuser3;
! GRANT SELECT (one) ON atest5 TO regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT atest6 FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
! ERROR:  permission denied for relation atest5
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 DROP COLUMN three;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
! SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
!  one 
! -----
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser1;
! ALTER TABLE atest6 DROP COLUMN two;
! REVOKE SELECT (one,blue) ON atest6 FROM regressuser4;
! SET SESSION AUTHORIZATION regressuser4;
! SELECT * FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SELECT 1 FROM atest6; -- fail
! ERROR:  permission denied for relation atest6
! SET SESSION AUTHORIZATION regressuser3;
! DELETE FROM atest5 WHERE one = 1; -- fail
! ERROR:  permission denied for relation atest5
! DELETE FROM atest5 WHERE two = 2; -- ok
! -- check inheritance cases
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS;
! CREATE TABLE atestp2 (fx int, fy int) WITH OIDS;
! CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
! GRANT SELECT(fx,fy,oid) ON atestp2 TO regressuser2;
! GRANT SELECT(fx) ON atestc TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT fx FROM atestp2; -- ok
!  fx 
! ----
! (0 rows)
! 
! SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
! SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
! SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
! SELECT fy FROM atestc; -- fail
! ERROR:  permission denied for relation atestc
! SET SESSION AUTHORIZATION regressuser1;
! GRANT SELECT(fy,oid) ON atestc TO regressuser2;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT fx FROM atestp2; -- still ok
!  fx 
! ----
! (0 rows)
! 
! SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
! SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
! SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
! -- privileges on functions, languages
! -- switch to superuser
! \c -
! REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
! GRANT USAGE ON LANGUAGE sql TO regressuser1; -- ok
! GRANT USAGE ON LANGUAGE c TO PUBLIC; -- fail
! ERROR:  language "c" is not trusted
! HINT:  Only superusers can use untrusted languages.
! SET SESSION AUTHORIZATION regressuser1;
! GRANT USAGE ON LANGUAGE sql TO regressuser2; -- fail
! WARNING:  no privileges were granted for "sql"
! CREATE FUNCTION testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
! CREATE FUNCTION testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
! REVOKE ALL ON FUNCTION testfunc1(int), testfunc2(int) FROM PUBLIC;
! GRANT EXECUTE ON FUNCTION testfunc1(int), testfunc2(int) TO regressuser2;
! GRANT USAGE ON FUNCTION testfunc1(int) TO regressuser3; -- semantic error
! ERROR:  invalid privilege type USAGE for function
! GRANT ALL PRIVILEGES ON FUNCTION testfunc1(int) TO regressuser4;
! GRANT ALL PRIVILEGES ON FUNCTION testfunc_nosuch(int) TO regressuser4;
! ERROR:  function testfunc_nosuch(integer) does not exist
! CREATE FUNCTION testfunc4(boolean) RETURNS text
!   AS 'select col1 from atest2 where col2 = $1;'
!   LANGUAGE sql SECURITY DEFINER;
! GRANT EXECUTE ON FUNCTION testfunc4(boolean) TO regressuser3;
! SET SESSION AUTHORIZATION regressuser2;
! SELECT testfunc1(5), testfunc2(5); -- ok
!  testfunc1 | testfunc2 
! -----------+-----------
!         10 |        15
! (1 row)
! 
! CREATE FUNCTION testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
! ERROR:  permission denied for language sql
! SET SESSION AUTHORIZATION regressuser3;
! SELECT testfunc1(5); -- fail
! ERROR:  permission denied for function testfunc1
! SELECT col1 FROM atest2 WHERE col2 = true; -- fail
! ERROR:  permission denied for relation atest2
! SELECT testfunc4(true); -- ok
!  testfunc4 
! -----------
!  bar
! (1 row)
! 
! SET SESSION AUTHORIZATION regressuser4;
! SELECT testfunc1(5); -- ok
!  testfunc1 
! -----------
!         10
! (1 row)
! 
! DROP FUNCTION testfunc1(int); -- fail
! ERROR:  must be owner of function testfunc1
! \c -
! DROP FUNCTION testfunc1(int); -- ok
! -- restore to sanity
! GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
! -- privileges on types
! -- switch to superuser
! \c -
! CREATE TYPE testtype1 AS (a int, b text);
! REVOKE USAGE ON TYPE testtype1 FROM PUBLIC;
! GRANT USAGE ON TYPE testtype1 TO regressuser2;
! GRANT USAGE ON TYPE _testtype1 TO regressuser2; -- fail
! ERROR:  cannot set privileges of array types
! HINT:  Set the privileges of the element type instead.
! GRANT USAGE ON DOMAIN testtype1 TO regressuser2; -- fail
! ERROR:  "testtype1" is not a domain
! CREATE DOMAIN testdomain1 AS int;
! REVOKE USAGE on DOMAIN testdomain1 FROM PUBLIC;
! GRANT USAGE ON DOMAIN testdomain1 TO regressuser2;
! GRANT USAGE ON TYPE testdomain1 TO regressuser2; -- ok
! SET SESSION AUTHORIZATION regressuser1;
! -- commands that should fail
! CREATE AGGREGATE testagg1a(testdomain1) (sfunc = int4_sum, stype = bigint);
! ERROR:  permission denied for type testdomain1
! CREATE DOMAIN testdomain2a AS testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE DOMAIN testdomain3a AS int;
! CREATE FUNCTION castfunc(int) RETURNS testdomain3a AS $$ SELECT $1::testdomain3a $$ LANGUAGE SQL;
! CREATE CAST (testdomain1 AS testdomain3a) WITH FUNCTION castfunc(int);
! ERROR:  permission denied for type testdomain1
! DROP FUNCTION castfunc(int) CASCADE;
! DROP DOMAIN testdomain3a;
! CREATE FUNCTION testfunc5a(a testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! ERROR:  permission denied for type testdomain1
! CREATE FUNCTION testfunc6a(b int) RETURNS testdomain1 LANGUAGE SQL AS $$ SELECT $1::testdomain1 $$;
! ERROR:  permission denied for type testdomain1
! CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = testdomain1, RIGHTARG = testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test5a (a int, b testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test6a OF testtype1;
! ERROR:  permission denied for type testtype1
! CREATE TABLE test10a (a int[], b testtype1[]);
! ERROR:  permission denied for type testtype1
! CREATE TABLE test9a (a int, b int);
! ALTER TABLE test9a ADD COLUMN c testdomain1;
! ERROR:  permission denied for type testdomain1
! ALTER TABLE test9a ALTER COLUMN b TYPE testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE TYPE test7a AS (a int, b testdomain1);
! ERROR:  permission denied for type testdomain1
! CREATE TYPE test8a AS (a int, b int);
! ALTER TYPE test8a ADD ATTRIBUTE c testdomain1;
! ERROR:  permission denied for type testdomain1
! ALTER TYPE test8a ALTER ATTRIBUTE b TYPE testdomain1;
! ERROR:  permission denied for type testdomain1
! CREATE TABLE test11a AS (SELECT 1::testdomain1 AS a);
! ERROR:  permission denied for type testdomain1
! REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
! ERROR:  permission denied for type testtype1
! SET SESSION AUTHORIZATION regressuser2;
! -- commands that should succeed
! CREATE AGGREGATE testagg1b(testdomain1) (sfunc = int4_sum, stype = bigint);
! CREATE DOMAIN testdomain2b AS testdomain1;
! CREATE DOMAIN testdomain3b AS int;
! CREATE FUNCTION castfunc(int) RETURNS testdomain3b AS $$ SELECT $1::testdomain3b $$ LANGUAGE SQL;
! CREATE CAST (testdomain1 AS testdomain3b) WITH FUNCTION castfunc(int);
! WARNING:  cast will be ignored because the source data type is a domain
! CREATE FUNCTION testfunc5b(a testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! CREATE FUNCTION testfunc6b(b int) RETURNS testdomain1 LANGUAGE SQL AS $$ SELECT $1::testdomain1 $$;
! CREATE OPERATOR !! (PROCEDURE = testfunc5b, RIGHTARG = testdomain1);
! CREATE TABLE test5b (a int, b testdomain1);
! CREATE TABLE test6b OF testtype1;
! CREATE TABLE test10b (a int[], b testtype1[]);
! CREATE TABLE test9b (a int, b int);
! ALTER TABLE test9b ADD COLUMN c testdomain1;
! ALTER TABLE test9b ALTER COLUMN b TYPE testdomain1;
! CREATE TYPE test7b AS (a int, b testdomain1);
! CREATE TYPE test8b AS (a int, b int);
! ALTER TYPE test8b ADD ATTRIBUTE c testdomain1;
! ALTER TYPE test8b ALTER ATTRIBUTE b TYPE testdomain1;
! CREATE TABLE test11b AS (SELECT 1::testdomain1 AS a);
! REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
! WARNING:  no privileges could be revoked for "testtype1"
! \c -
! DROP AGGREGATE testagg1b(testdomain1);
! DROP DOMAIN testdomain2b;
! DROP OPERATOR !! (NONE, testdomain1);
! DROP FUNCTION testfunc5b(a testdomain1);
! DROP FUNCTION testfunc6b(b int);
! DROP TABLE test5b;
! DROP TABLE test6b;
! DROP TABLE test9b;
! DROP TABLE test10b;
! DROP TYPE test7b;
! DROP TYPE test8b;
! DROP CAST (testdomain1 AS testdomain3b);
! DROP FUNCTION castfunc(int) CASCADE;
! DROP DOMAIN testdomain3b;
! DROP TABLE test11b;
! DROP TYPE testtype1; -- ok
! DROP DOMAIN testdomain1; -- ok
! -- truncate
! SET SESSION AUTHORIZATION regressuser5;
! TRUNCATE atest2; -- ok
! TRUNCATE atest3; -- fail
! ERROR:  permission denied for relation atest3
! -- has_table_privilege function
! -- bad-input checks
! select has_table_privilege(NULL,'pg_authid','select');
!  has_table_privilege 
! ---------------------
!  
! (1 row)
! 
! select has_table_privilege('pg_shad','select');
! ERROR:  relation "pg_shad" does not exist
! select has_table_privilege('nosuchuser','pg_authid','select');
! ERROR:  role "nosuchuser" does not exist
! select has_table_privilege('pg_authid','sel');
! ERROR:  unrecognized privilege type: "sel"
! select has_table_privilege(-999999,'pg_authid','update');
! ERROR:  role with OID 4293967297 does not exist
! select has_table_privilege(1,'select');
!  has_table_privilege 
! ---------------------
!  
! (1 row)
! 
! -- superuser
! \c -
! select has_table_privilege(current_user,'pg_authid','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'pg_authid','insert');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_authid','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_authid','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- 'rule' privilege no longer exists, but for backwards compatibility
! -- has_table_privilege still recognizes the keyword and says FALSE
! select has_table_privilege(current_user,t1.oid,'rule')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_authid') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'pg_authid') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','update');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','delete');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege('pg_authid','truncate');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'pg_authid') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- non-superuser
! SET SESSION AUTHORIZATION regressuser3;
! select has_table_privilege(current_user,'pg_class','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'pg_class','insert');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_class','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'pg_class','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_class') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'pg_class') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','update');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','delete');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('pg_class','truncate');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'pg_class') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,'atest1','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(current_user,'atest1','insert');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'atest1','update')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,'atest1','delete')
! from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(current_user,t1.oid,'references')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'select')
! from (select oid from pg_class where relname = 'atest1') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t2.oid,t1.oid,'insert')
! from (select oid from pg_class where relname = 'atest1') as t1,
!   (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','update');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','delete');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege('atest1','truncate');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! select has_table_privilege(t1.oid,'select')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! select has_table_privilege(t1.oid,'trigger')
! from (select oid from pg_class where relname = 'atest1') as t1;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! -- Grant options
! SET SESSION AUTHORIZATION regressuser1;
! CREATE TABLE atest4 (a int);
! GRANT SELECT ON atest4 TO regressuser2 WITH GRANT OPTION;
! GRANT UPDATE ON atest4 TO regressuser2;
! GRANT SELECT ON atest4 TO GROUP regressgroup1 WITH GRANT OPTION;
! SET SESSION AUTHORIZATION regressuser2;
! GRANT SELECT ON atest4 TO regressuser3;
! GRANT UPDATE ON atest4 TO regressuser3; -- fail
! WARNING:  no privileges were granted for "atest4"
! SET SESSION AUTHORIZATION regressuser1;
! REVOKE SELECT ON atest4 FROM regressuser3; -- does nothing
! SELECT has_table_privilege('regressuser3', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! REVOKE SELECT ON atest4 FROM regressuser2; -- fail
! ERROR:  dependent privileges exist
! HINT:  Use CASCADE to revoke them too.
! REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regressuser2 CASCADE; -- ok
! SELECT has_table_privilege('regressuser2', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser3', 'atest4', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! -- Admin options
! SET SESSION AUTHORIZATION regressuser4;
! CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
! 	'GRANT regressgroup2 TO regressuser5';
! GRANT regressgroup2 TO regressuser5; -- ok: had ADMIN OPTION
! SET ROLE regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE suspended privilege
! ERROR:  must have admin option on role "regressgroup2"
! SET SESSION AUTHORIZATION regressuser1;
! GRANT regressgroup2 TO regressuser5; -- fails: no ADMIN OPTION
! ERROR:  must have admin option on role "regressgroup2"
! SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
! NOTICE:  role "regressuser5" is already a member of role "regressgroup2"
! CONTEXT:  SQL function "dogrant_ok" statement 1
!  dogrant_ok 
! ------------
!  
! (1 row)
! 
! SET ROLE regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE did not help
! ERROR:  must have admin option on role "regressgroup2"
! SET SESSION AUTHORIZATION regressgroup2;
! GRANT regressgroup2 TO regressuser5; -- ok: a role can self-admin
! NOTICE:  role "regressuser5" is already a member of role "regressgroup2"
! CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
! 	'GRANT regressgroup2 TO regressuser5';
! SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
! ERROR:  must have admin option on role "regressgroup2"
! CONTEXT:  SQL function "dogrant_fails" statement 1
! DROP FUNCTION dogrant_fails();
! SET SESSION AUTHORIZATION regressuser4;
! DROP FUNCTION dogrant_ok();
! REVOKE regressgroup2 FROM regressuser5;
! -- has_sequence_privilege tests
! \c -
! CREATE SEQUENCE x_seq;
! GRANT USAGE on x_seq to regressuser2;
! SELECT has_sequence_privilege('regressuser1', 'atest1', 'SELECT');
! ERROR:  "atest1" is not a sequence
! SELECT has_sequence_privilege('regressuser1', 'x_seq', 'INSERT');
! ERROR:  unrecognized privilege type: "INSERT"
! SELECT has_sequence_privilege('regressuser1', 'x_seq', 'SELECT');
!  has_sequence_privilege 
! ------------------------
!  f
! (1 row)
! 
! SET SESSION AUTHORIZATION regressuser2;
! SELECT has_sequence_privilege('x_seq', 'USAGE');
!  has_sequence_privilege 
! ------------------------
!  t
! (1 row)
! 
! -- largeobject privilege tests
! \c -
! SET SESSION AUTHORIZATION regressuser1;
! SELECT lo_create(1001);
!  lo_create 
! -----------
!       1001
! (1 row)
! 
! SELECT lo_create(1002);
!  lo_create 
! -----------
!       1002
! (1 row)
! 
! SELECT lo_create(1003);
!  lo_create 
! -----------
!       1003
! (1 row)
! 
! SELECT lo_create(1004);
!  lo_create 
! -----------
!       1004
! (1 row)
! 
! SELECT lo_create(1005);
!  lo_create 
! -----------
!       1005
! (1 row)
! 
! GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
! GRANT SELECT ON LARGE OBJECT 1003 TO regressuser2;
! GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regressuser2;
! GRANT ALL ON LARGE OBJECT 1005 TO regressuser2;
! GRANT SELECT ON LARGE OBJECT 1005 TO regressuser2 WITH GRANT OPTION;
! GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;	-- to be failed
! ERROR:  invalid privilege type INSERT for large object
! GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;	-- to be failed
! ERROR:  role "nosuchuser" does not exist
! GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;	-- to be failed
! ERROR:  large object 999 does not exist
! \c -
! SET SESSION AUTHORIZATION regressuser2;
! SELECT lo_create(2001);
!  lo_create 
! -----------
!       2001
! (1 row)
! 
! SELECT lo_create(2002);
!  lo_create 
! -----------
!       2002
! (1 row)
! 
! SELECT loread(lo_open(1001, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT loread(lo_open(1003, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT loread(lo_open(1004, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1003
! SELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! GRANT SELECT ON LARGE OBJECT 1005 TO regressuser3;
! GRANT UPDATE ON LARGE OBJECT 1006 TO regressuser3;	-- to be denied
! ERROR:  large object 1006 does not exist
! REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
! GRANT ALL ON LARGE OBJECT 2001 TO regressuser3;
! SELECT lo_unlink(1001);		-- to be denied
! ERROR:  must be owner of large object 1001
! SELECT lo_unlink(2002);
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! \c -
! -- confirm ACL setting
! SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata;
!  oid  |  ownername   |                                          lomacl                                          
! ------+--------------+------------------------------------------------------------------------------------------
!  1002 | regressuser1 | 
!  1001 | regressuser1 | {regressuser1=rw/regressuser1,=rw/regressuser1}
!  1003 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=r/regressuser1}
!  1004 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=rw/regressuser1}
!  1005 | regressuser1 | {regressuser1=rw/regressuser1,regressuser2=r*w/regressuser1,regressuser3=r/regressuser2}
!  2001 | regressuser2 | {regressuser2=rw/regressuser2,regressuser3=rw/regressuser2}
! (6 rows)
! 
! SET SESSION AUTHORIZATION regressuser3;
! SELECT loread(lo_open(1001, x'40000'::int), 32);
!    loread   
! ------------
!  \x61626364
! (1 row)
! 
! SELECT loread(lo_open(1003, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1003
! SELECT loread(lo_open(1005, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);	-- to be denied
! ERROR:  permission denied for large object 1005
! SELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! -- compatibility mode in largeobject permission
! \c -
! SET lo_compat_privileges = false;	-- default setting
! SET SESSION AUTHORIZATION regressuser4;
! SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);	-- to be denied
! ERROR:  permission denied for large object 1002
! SELECT lo_unlink(1002);					-- to be denied
! ERROR:  must be owner of large object 1002
! SELECT lo_export(1001, '/dev/null');			-- to be denied
! ERROR:  must be superuser to use server-side lo_export()
! HINT:  Anyone can use the client-side lo_export() provided by libpq.
! \c -
! SET lo_compat_privileges = true;	-- compatibility mode
! SET SESSION AUTHORIZATION regressuser4;
! SELECT loread(lo_open(1002, x'40000'::int), 32);
!  loread 
! --------
!  \x
! (1 row)
! 
! SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
!  lowrite 
! ---------
!        4
! (1 row)
! 
! SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! SELECT lo_unlink(1002);
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! SELECT lo_export(1001, '/dev/null');			-- to be denied
! ERROR:  must be superuser to use server-side lo_export()
! HINT:  Anyone can use the client-side lo_export() provided by libpq.
! -- don't allow unpriv users to access pg_largeobject contents
! \c -
! SELECT * FROM pg_largeobject LIMIT 0;
!  loid | pageno | data 
! ------+--------+------
! (0 rows)
! 
! SET SESSION AUTHORIZATION regressuser1;
! SELECT * FROM pg_largeobject LIMIT 0;			-- to be denied
! ERROR:  permission denied for relation pg_largeobject
! -- test default ACLs
! \c -
! CREATE SCHEMA testns;
! GRANT ALL ON SCHEMA testns TO regressuser1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT SELECT ON TABLES TO public;
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regressuser1;
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regressuser1;
! DROP TABLE testns.acltest1;
! CREATE TABLE testns.acltest1 (x int);
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'SELECT'); -- yes
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.acltest1', 'INSERT'); -- no
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES FOR ROLE regressuser1 REVOKE EXECUTE ON FUNCTIONS FROM public;
! SET ROLE regressuser1;
! CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
! SELECT has_function_privilege('regressuser2', 'testns.foo()', 'EXECUTE'); -- no
!  has_function_privilege 
! ------------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON FUNCTIONS to public;
! DROP FUNCTION testns.foo();
! CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
! SELECT has_function_privilege('regressuser2', 'testns.foo()', 'EXECUTE'); -- yes
!  has_function_privilege 
! ------------------------
!  t
! (1 row)
! 
! DROP FUNCTION testns.foo();
! ALTER DEFAULT PRIVILEGES FOR ROLE regressuser1 REVOKE USAGE ON TYPES FROM public;
! CREATE DOMAIN testns.testdomain1 AS int;
! SELECT has_type_privilege('regressuser2', 'testns.testdomain1', 'USAGE'); -- no
!  has_type_privilege 
! --------------------
!  f
! (1 row)
! 
! ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
! DROP DOMAIN testns.testdomain1;
! CREATE DOMAIN testns.testdomain1 AS int;
! SELECT has_type_privilege('regressuser2', 'testns.testdomain1', 'USAGE'); -- yes
!  has_type_privilege 
! --------------------
!  t
! (1 row)
! 
! DROP DOMAIN testns.testdomain1;
! RESET ROLE;
! SELECT count(*)
!   FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
!   WHERE nspname = 'testns';
!  count 
! -------
!      3
! (1 row)
! 
! DROP SCHEMA testns CASCADE;
! NOTICE:  drop cascades to table testns.acltest1
! SELECT d.*     -- check that entries went away
!   FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
!   WHERE nspname IS NULL AND defaclnamespace != 0;
!  defaclrole | defaclnamespace | defaclobjtype | defaclacl 
! ------------+-----------------+---------------+-----------
! (0 rows)
! 
! -- Grant on all objects of given type in a schema
! \c -
! CREATE SCHEMA testns;
! CREATE TABLE testns.t1 (f1 int);
! CREATE TABLE testns.t2 (f1 int);
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! GRANT ALL ON ALL TABLES IN SCHEMA testns TO regressuser1;
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.t2', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
! REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regressuser1;
! SELECT has_table_privilege('regressuser1', 'testns.t1', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! SELECT has_table_privilege('regressuser1', 'testns.t2', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
! CREATE FUNCTION testns.testfunc(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
! SELECT has_function_privilege('regressuser1', 'testns.testfunc(int)', 'EXECUTE'); -- true by default
!  has_function_privilege 
! ------------------------
!  t
! (1 row)
! 
! REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
! SELECT has_function_privilege('regressuser1', 'testns.testfunc(int)', 'EXECUTE'); -- false
!  has_function_privilege 
! ------------------------
!  f
! (1 row)
! 
! SET client_min_messages TO 'warning';
! DROP SCHEMA testns CASCADE;
! RESET client_min_messages;
! -- Change owner of the schema & and rename of new schema owner
! \c -
! CREATE ROLE schemauser1 superuser login;
! CREATE ROLE schemauser2 superuser login;
! SET SESSION ROLE schemauser1;
! CREATE SCHEMA testns;
! SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
!  nspname |   rolname   
! ---------+-------------
!  testns  | schemauser1
! (1 row)
! 
! ALTER SCHEMA testns OWNER TO schemauser2;
! ALTER ROLE schemauser2 RENAME TO schemauser_renamed;
! SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
!  nspname |      rolname       
! ---------+--------------------
!  testns  | schemauser_renamed
! (1 row)
! 
! set session role schemauser_renamed;
! SET client_min_messages TO 'warning';
! DROP SCHEMA testns CASCADE;
! RESET client_min_messages;
! -- clean up
! \c -
! DROP ROLE schemauser1;
! DROP ROLE schemauser_renamed;
! -- test that dependent privileges are revoked (or not) properly
! \c -
! set session role regressuser1;
! create table dep_priv_test (a int);
! grant select on dep_priv_test to regressuser2 with grant option;
! grant select on dep_priv_test to regressuser3 with grant option;
! set session role regressuser2;
! grant select on dep_priv_test to regressuser4 with grant option;
! set session role regressuser3;
! grant select on dep_priv_test to regressuser4 with grant option;
! set session role regressuser4;
! grant select on dep_priv_test to regressuser5;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1     +|                   | 
!         |               |       | regressuser4=r*/regressuser2     +|                   | 
!         |               |       | regressuser4=r*/regressuser3     +|                   | 
!         |               |       | regressuser5=r/regressuser4       |                   | 
! (1 row)
! 
! set session role regressuser2;
! revoke select on dep_priv_test from regressuser4 cascade;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1     +|                   | 
!         |               |       | regressuser4=r*/regressuser3     +|                   | 
!         |               |       | regressuser5=r/regressuser4       |                   | 
! (1 row)
! 
! set session role regressuser3;
! revoke select on dep_priv_test from regressuser4 cascade;
! \dp dep_priv_test
!                                          Access privileges
!  Schema |     Name      | Type  |         Access privileges         | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------+-------------------+----------
!  public | dep_priv_test | table | regressuser1=arwdDxt/regressuser1+|                   | 
!         |               |       | regressuser2=r*/regressuser1     +|                   | 
!         |               |       | regressuser3=r*/regressuser1      |                   | 
! (1 row)
! 
! set session role regressuser1;
! drop table dep_priv_test;
! -- clean up
! \c
! drop sequence x_seq;
! DROP FUNCTION testfunc2(int);
! DROP FUNCTION testfunc4(boolean);
! DROP VIEW atestv0;
! DROP VIEW atestv1;
! DROP VIEW atestv2;
! -- this should cascade to drop atestv4
! DROP VIEW atestv3 CASCADE;
! NOTICE:  drop cascades to view atestv4
! -- this should complain "does not exist"
! DROP VIEW atestv4;
! ERROR:  view "atestv4" does not exist
! DROP TABLE atest1;
! DROP TABLE atest2;
! DROP TABLE atest3;
! DROP TABLE atest4;
! DROP TABLE atest5;
! DROP TABLE atest6;
! DROP TABLE atestc;
! DROP TABLE atestp1;
! DROP TABLE atestp2;
! SELECT lo_unlink(oid) FROM pg_largeobject_metadata;
!  lo_unlink 
! -----------
!          1
!          1
!          1
!          1
!          1
! (5 rows)
! 
! DROP GROUP regressgroup1;
! DROP GROUP regressgroup2;
! -- these are needed to clean up permissions
! REVOKE USAGE ON LANGUAGE sql FROM regressuser1;
! DROP OWNED BY regressuser1;
! DROP USER regressuser1;
! DROP USER regressuser2;
! DROP USER regressuser3;
! DROP USER regressuser4;
! DROP USER regressuser5;
! DROP USER regressuser6;
! ERROR:  role "regressuser6" does not exist
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/security_label.out	2015-01-26 12:33:13.755030777 +0300
--- /home/orion/postgres/src/test/regress/results/security_label.out	2015-01-26 12:33:24.311031329 +0300
***************
*** 1,123 ****
! --
! -- Test for facilities of security label
! --
! -- initial setups
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS seclabel_user1;
! DROP ROLE IF EXISTS seclabel_user2;
! DROP TABLE IF EXISTS seclabel_tbl1;
! DROP TABLE IF EXISTS seclabel_tbl2;
! DROP TABLE IF EXISTS seclabel_tbl3;
! CREATE USER seclabel_user1 WITH CREATEROLE;
! CREATE USER seclabel_user2;
! CREATE TABLE seclabel_tbl1 (a int, b text);
! CREATE TABLE seclabel_tbl2 (x int, y text);
! CREATE VIEW seclabel_view1 AS SELECT * FROM seclabel_tbl2;
! CREATE FUNCTION seclabel_four() RETURNS integer AS $$SELECT 4$$ language sql;
! CREATE DOMAIN seclabel_domain AS text;
! ALTER TABLE seclabel_tbl1 OWNER TO seclabel_user1;
! ALTER TABLE seclabel_tbl2 OWNER TO seclabel_user2;
! RESET client_min_messages;
! --
! -- Test of SECURITY LABEL statement without a plugin
! --
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';		-- fail
! ERROR:  security label provider "dummy" is not loaded
! SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';		-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS 'classified';			-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL FOR 'dummy' ON ROLE seclabel_user1 IS 'classified';		-- fail
! ERROR:  security label provider "dummy" is not loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS '...invalid label...';		-- fail
! ERROR:  no security label providers have been loaded
! SECURITY LABEL ON ROLE seclabel_user3 IS 'unclassified';			-- fail
! ERROR:  no security label providers have been loaded
! -- Load dummy external security provider
! LOAD '/home/orion/postgres/src/test/regress/dummy_seclabel.so';
! --
! -- Test of SECURITY LABEL statement with a plugin
! --
! SET SESSION AUTHORIZATION seclabel_user1;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- OK
! SECURITY LABEL ON COLUMN seclabel_tbl1.a IS 'unclassified';		-- OK
! SECURITY LABEL ON COLUMN seclabel_tbl1 IS 'unclassified';	-- fail
! ERROR:  column name must be qualified
! SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';	-- fail
! ERROR:  '...invalid label...' is not a valid security label
! SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'unclassified';	-- OK
! SECURITY LABEL FOR 'unknown_seclabel' ON TABLE seclabel_tbl1 IS 'classified';	-- fail
! ERROR:  security label provider "unknown_seclabel" is not loaded
! SECURITY LABEL ON TABLE seclabel_tbl2 IS 'unclassified';	-- fail (not owner)
! ERROR:  must be owner of relation seclabel_tbl2
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'secret';		-- fail (not superuser)
! ERROR:  only superuser can set 'secret' label
! SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';	-- fail (not found)
! ERROR:  relation "seclabel_tbl3" does not exist
! SET SESSION AUTHORIZATION seclabel_user2;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'unclassified';		-- fail
! ERROR:  must be owner of relation seclabel_tbl1
! SECURITY LABEL ON TABLE seclabel_tbl2 IS 'classified';			-- OK
! --
! -- Test for shared database object
! --
! SET SESSION AUTHORIZATION seclabel_user1;
! SECURITY LABEL ON ROLE seclabel_user1 IS 'classified';			-- OK
! SECURITY LABEL ON ROLE seclabel_user1 IS '...invalid label...';	-- fail
! ERROR:  '...invalid label...' is not a valid security label
! SECURITY LABEL FOR 'dummy' ON ROLE seclabel_user2 IS 'unclassified';	-- OK
! SECURITY LABEL FOR 'unknown_seclabel' ON ROLE seclabel_user1 IS 'unclassified';	-- fail
! ERROR:  security label provider "unknown_seclabel" is not loaded
! SECURITY LABEL ON ROLE seclabel_user1 IS 'secret';	-- fail (not superuser)
! ERROR:  only superuser can set 'secret' label
! SECURITY LABEL ON ROLE seclabel_user3 IS 'unclassified';	-- fail (not found)
! ERROR:  role "seclabel_user3" does not exist
! SET SESSION AUTHORIZATION seclabel_user2;
! SECURITY LABEL ON ROLE seclabel_user2 IS 'unclassified';	-- fail (not privileged)
! ERROR:  must have CREATEROLE privilege
! RESET SESSION AUTHORIZATION;
! --
! -- Test for various types of object
! --
! RESET SESSION AUTHORIZATION;
! SECURITY LABEL ON TABLE seclabel_tbl1 IS 'top secret';			-- OK
! SECURITY LABEL ON VIEW seclabel_view1 IS 'classified';			-- OK
! SECURITY LABEL ON FUNCTION seclabel_four() IS 'classified';		-- OK
! SECURITY LABEL ON DOMAIN seclabel_domain IS 'classified';		-- OK
! CREATE SCHEMA seclabel_test;
! SECURITY LABEL ON SCHEMA seclabel_test IS 'unclassified';		-- OK
! SELECT objtype, objname, provider, label FROM pg_seclabels
! 	ORDER BY objtype, objname;
!  objtype  |     objname     | provider |    label     
! ----------+-----------------+----------+--------------
!  column   | seclabel_tbl1.a | dummy    | unclassified
!  domain   | seclabel_domain | dummy    | classified
!  function | seclabel_four() | dummy    | classified
!  role     | seclabel_user1  | dummy    | classified
!  role     | seclabel_user2  | dummy    | unclassified
!  schema   | seclabel_test   | dummy    | unclassified
!  table    | seclabel_tbl1   | dummy    | top secret
!  table    | seclabel_tbl2   | dummy    | classified
!  view     | seclabel_view1  | dummy    | classified
! (9 rows)
! 
! -- clean up objects
! DROP FUNCTION seclabel_four();
! DROP DOMAIN seclabel_domain;
! DROP VIEW seclabel_view1;
! DROP TABLE seclabel_tbl1;
! DROP TABLE seclabel_tbl2;
! DROP USER seclabel_user1;
! DROP USER seclabel_user2;
! DROP SCHEMA seclabel_test;
! -- make sure we don't have any leftovers
! SELECT objtype, objname, provider, label FROM pg_seclabels
! 	ORDER BY objtype, objname;
!  objtype | objname | provider | label 
! ---------+---------+----------+-------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/collate.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/collate.out	2015-01-26 12:33:24.315031329 +0300
***************
*** 1,650 ****
! /*
!  * This test is intended to pass on all platforms supported by Postgres.
!  * We can therefore only assume that the default, C, and POSIX collations
!  * are available --- and since the regression tests are often run in a
!  * C-locale database, these may well all have the same behavior.  But
!  * fortunately, the system doesn't know that and will treat them as
!  * incompatible collations.  It is therefore at least possible to test
!  * parser behaviors such as collation conflict resolution.  This test will,
!  * however, be more revealing when run in a database with non-C locale,
!  * since any departure from C sorting behavior will show as a failure.
!  */
! CREATE SCHEMA collate_tests;
! SET search_path = collate_tests;
! CREATE TABLE collate_test1 (
!     a int,
!     b text COLLATE "C" NOT NULL
! );
! \d collate_test1
!   Table "collate_tests.collate_test1"
!  Column |  Type   |     Modifiers      
! --------+---------+--------------------
!  a      | integer | 
!  b      | text    | collate C not null
! 
! CREATE TABLE collate_test_fail (
!     a int COLLATE "C",
!     b text
! );
! ERROR:  collations are not supported by type integer
! LINE 2:     a int COLLATE "C",
!                   ^
! CREATE TABLE collate_test_like (
!     LIKE collate_test1
! );
! \d collate_test_like
! Table "collate_tests.collate_test_like"
!  Column |  Type   |     Modifiers      
! --------+---------+--------------------
!  a      | integer | 
!  b      | text    | collate C not null
! 
! CREATE TABLE collate_test2 (
!     a int,
!     b text COLLATE "POSIX"
! );
! INSERT INTO collate_test1 VALUES (1, 'abc'), (2, 'Abc'), (3, 'bbc'), (4, 'ABD');
! INSERT INTO collate_test2 SELECT * FROM collate_test1;
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc';
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b >= 'abc' COLLATE "C";
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc' COLLATE "C";
!  a |  b  
! ---+-----
!  1 | abc
!  3 | bbc
! (2 rows)
! 
! SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "POSIX"; -- fail
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: ...* FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "P...
!                                                              ^
! CREATE DOMAIN testdomain_p AS text COLLATE "POSIX";
! CREATE DOMAIN testdomain_i AS int COLLATE "POSIX"; -- fail
! ERROR:  collations are not supported by type integer
! CREATE TABLE collate_test4 (
!     a int,
!     b testdomain_p
! );
! INSERT INTO collate_test4 SELECT * FROM collate_test1;
! SELECT a, b FROM collate_test4 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! CREATE TABLE collate_test5 (
!     a int,
!     b testdomain_p COLLATE "C"
! );
! INSERT INTO collate_test5 SELECT * FROM collate_test1;
! SELECT a, b FROM collate_test5 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test2 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- star expansion
! SELECT * FROM collate_test1 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT * FROM collate_test2 ORDER BY b;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- constant expression folding
! SELECT 'bbc' COLLATE "C" > 'Abc' COLLATE "C" AS "true";
!  true 
! ------
!  t
! (1 row)
! 
! SELECT 'bbc' COLLATE "POSIX" < 'Abc' COLLATE "POSIX" AS "false";
!  false 
! -------
!  f
! (1 row)
! 
! -- upper/lower
! CREATE TABLE collate_test10 (
!     a int,
!     x text COLLATE "C",
!     y text COLLATE "POSIX"
! );
! INSERT INTO collate_test10 VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
! SELECT a, lower(x), lower(y), upper(x), upper(y), initcap(x), initcap(y) FROM collate_test10;
!  a | lower | lower | upper | upper | initcap | initcap 
! ---+-------+-------+-------+-------+---------+---------
!  1 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
!  2 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
! (2 rows)
! 
! SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
!  a |  x  |  y  
! ---+-----+-----
!  1 | hij | hij
!  2 | HIJ | HIJ
! (2 rows)
! 
! -- backwards parsing
! CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
! CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
! CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "POSIX") FROM collate_test10;
! SELECT table_name, view_definition FROM information_schema.views
!   WHERE table_name LIKE 'collview%' ORDER BY 1;
!  table_name |                               view_definition                                
! ------------+------------------------------------------------------------------------------
!  collview1  |  SELECT collate_test1.a,                                                    +
!             |     collate_test1.b                                                         +
!             |    FROM collate_test1                                                       +
!             |   WHERE ((collate_test1.b COLLATE "C") >= 'bbc'::text);
!  collview2  |  SELECT collate_test1.a,                                                    +
!             |     collate_test1.b                                                         +
!             |    FROM collate_test1                                                       +
!             |   ORDER BY (collate_test1.b COLLATE "C");
!  collview3  |  SELECT collate_test10.a,                                                   +
!             |     lower(((collate_test10.x || collate_test10.x) COLLATE "POSIX")) AS lower+
!             |    FROM collate_test10;
! (3 rows)
! 
! -- collation propagation in various expression types
! SELECT a, coalesce(b, 'foo') FROM collate_test1 ORDER BY 2;
!  a | coalesce 
! ---+----------
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, coalesce(b, 'foo') FROM collate_test2 ORDER BY 2;
!  a | coalesce 
! ---+----------
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, lower(coalesce(x, 'foo')), lower(coalesce(y, 'foo')) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, b, greatest(b, 'CCC') FROM collate_test1 ORDER BY 3;
!  a |  b  | greatest 
! ---+-----+----------
!  2 | Abc | CCC
!  4 | ABD | CCC
!  1 | abc | abc
!  3 | bbc | bbc
! (4 rows)
! 
! SELECT a, b, greatest(b, 'CCC') FROM collate_test2 ORDER BY 3;
!  a |  b  | greatest 
! ---+-----+----------
!  2 | Abc | CCC
!  4 | ABD | CCC
!  1 | abc | abc
!  3 | bbc | bbc
! (4 rows)
! 
! SELECT a, x, y, lower(greatest(x, 'foo')), lower(greatest(y, 'foo')) FROM collate_test10;
!  a |  x  |  y  | lower | lower 
! ---+-----+-----+-------+-------
!  1 | hij | hij | hij   | hij
!  2 | HIJ | HIJ | foo   | foo
! (2 rows)
! 
! SELECT a, nullif(b, 'abc') FROM collate_test1 ORDER BY 2;
!  a | nullif 
! ---+--------
!  4 | ABD
!  2 | Abc
!  3 | bbc
!  1 | 
! (4 rows)
! 
! SELECT a, nullif(b, 'abc') FROM collate_test2 ORDER BY 2;
!  a | nullif 
! ---+--------
!  4 | ABD
!  2 | Abc
!  3 | bbc
!  1 | 
! (4 rows)
! 
! SELECT a, lower(nullif(x, 'foo')), lower(nullif(y, 'foo')) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test1 ORDER BY 2;
!  a |  b   
! ---+------
!  4 | ABD
!  2 | Abc
!  1 | abcd
!  3 | bbc
! (4 rows)
! 
! SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test2 ORDER BY 2;
!  a |  b   
! ---+------
!  4 | ABD
!  2 | Abc
!  1 | abcd
!  3 | bbc
! (4 rows)
! 
! CREATE DOMAIN testdomain AS text;
! SELECT a, b::testdomain FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b::testdomain FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b::testdomain_p FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, lower(x::testdomain), lower(y::testdomain) FROM collate_test10;
!  a | lower | lower 
! ---+-------+-------
!  1 | hij   | hij
!  2 | hij   | hij
! (2 rows)
! 
! SELECT min(b), max(b) FROM collate_test1;
!  min | max 
! -----+-----
!  ABD | bbc
! (1 row)
! 
! SELECT min(b), max(b) FROM collate_test2;
!  min | max 
! -----+-----
!  ABD | bbc
! (1 row)
! 
! SELECT array_agg(b ORDER BY b) FROM collate_test1;
!      array_agg     
! -------------------
!  {ABD,Abc,abc,bbc}
! (1 row)
! 
! SELECT array_agg(b ORDER BY b) FROM collate_test2;
!      array_agg     
! -------------------
!  {ABD,Abc,abc,bbc}
! (1 row)
! 
! -- In aggregates, ORDER BY expressions don't affect aggregate's collation
! SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;  -- fail
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM col...
!                                            ^
! SELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
!  array_agg 
! -----------
!  {HIJ,hij}
! (1 row)
! 
! SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
!  array_agg 
! -----------
!  {2,1}
! (1 row)
! 
! SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT array_agg(a ORDER BY x||y) FROM collate_test10;
!                                        ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  4 | ABD
!  2 | Abc
!  2 | Abc
!  1 | abc
!  1 | abc
!  3 | bbc
!  3 | bbc
! (8 rows)
! 
! SELECT a, b FROM collate_test2 UNION SELECT a, b FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test2 WHERE a < 4 INTERSECT SELECT a, b FROM collate_test2 WHERE a > 1 ORDER BY 2;
!  a |  b  
! ---+-----
!  2 | Abc
!  3 | bbc
! (2 rows)
! 
! SELECT a, b FROM collate_test2 EXCEPT SELECT a, b FROM collate_test2 WHERE a < 2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  3 | bbc
! (3 rows)
! 
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  could not determine which collation to use for string comparison
! HINT:  Use the COLLATE clause to set the collation explicitly.
! SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- ok
!  a |  b  
! ---+-----
!  1 | abc
!  2 | Abc
!  3 | bbc
!  4 | ABD
!  1 | abc
!  2 | Abc
!  3 | bbc
!  4 | ABD
! (8 rows)
! 
! SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collat...
!                                                        ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- ok
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: ...ELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM col...
!                                                              ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM colla...
!                                                         ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- fail
! ERROR:  no collation was derived for column "b" with collatable type text
! HINT:  Use the COLLATE clause to set the collation explicitly.
! -- ideally this would be a parse-time error, but for now it must be run-time:
! select x < y from collate_test10; -- fail
! ERROR:  could not determine which collation to use for string comparison
! HINT:  Use the COLLATE clause to set the collation explicitly.
! select x || y from collate_test10; -- ok, because || is not collation aware
!  ?column? 
! ----------
!  hijhij
!  HIJHIJ
! (2 rows)
! 
! select x, y from collate_test10 order by x || y; -- not so ok
! ERROR:  collation mismatch between implicit collations "C" and "POSIX"
! LINE 1: select x, y from collate_test10 order by x || y;
!                                                       ^
! HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
! -- collation mismatch between recursive and non-recursive term
! WITH RECURSIVE foo(x) AS
!    (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
!    UNION ALL
!    SELECT (x || 'c') COLLATE "POSIX" FROM foo WHERE length(x) < 10)
! SELECT * FROM foo;
! ERROR:  recursive query "foo" column 1 has collation "C" in non-recursive term but collation "POSIX" overall
! LINE 2:    (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
!                    ^
! HINT:  Use the COLLATE clause to set the collation of the non-recursive term.
! SELECT a, b, a < b as lt FROM
!   (VALUES ('a', 'B'), ('A', 'b' COLLATE "C")) v(a,b);
!  a | b | lt 
! ---+---+----
!  a | B | f
!  A | b | t
! (2 rows)
! 
! -- casting
! SELECT CAST('42' AS text COLLATE "C");
! ERROR:  syntax error at or near "COLLATE"
! LINE 1: SELECT CAST('42' AS text COLLATE "C");
!                                  ^
! SELECT a, CAST(b AS varchar) FROM collate_test1 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, CAST(b AS varchar) FROM collate_test2 ORDER BY 2;
!  a |  b  
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- polymorphism
! SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
!  unnest 
! --------
!  ABD
!  Abc
!  abc
!  bbc
! (4 rows)
! 
! SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
!  unnest 
! --------
!  ABD
!  Abc
!  abc
!  bbc
! (4 rows)
! 
! CREATE FUNCTION dup (anyelement) RETURNS anyelement
!     AS 'select $1' LANGUAGE sql;
! SELECT a, dup(b) FROM collate_test1 ORDER BY 2;
!  a | dup 
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! SELECT a, dup(b) FROM collate_test2 ORDER BY 2;
!  a | dup 
! ---+-----
!  4 | ABD
!  2 | Abc
!  1 | abc
!  3 | bbc
! (4 rows)
! 
! -- indexes
! CREATE INDEX collate_test1_idx1 ON collate_test1 (b);
! CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "POSIX");
! CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "POSIX")); -- this is different grammatically
! CREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
! CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "POSIX"); -- fail
! ERROR:  collations are not supported by type integer
! CREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "POSIX")); -- fail
! ERROR:  collations are not supported by type integer
! LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "P...
!                                                              ^
! SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
!       relname       |                                           pg_get_indexdef                                           
! --------------------+-----------------------------------------------------------------------------------------------------
!  collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
!  collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "POSIX")
!  collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "POSIX")
!  collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
! (4 rows)
! 
! -- foreign keys
! -- force indexes and mergejoins to be used for FK checking queries,
! -- else they might not exercise collation-dependent operators
! SET enable_seqscan TO 0;
! SET enable_hashjoin TO 0;
! SET enable_nestloop TO 0;
! CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
! INSERT INTO collate_test20 VALUES ('foo'), ('bar');
! CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
! INSERT INTO collate_test21 VALUES ('foo'), ('bar');
! INSERT INTO collate_test21 VALUES ('baz'); -- fail
! ERROR:  insert or update on table "collate_test21" violates foreign key constraint "collate_test21_f2_fkey"
! DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
! CREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
! INSERT INTO collate_test22 VALUES ('foo'), ('bar'), ('baz');
! ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- fail
! ERROR:  insert or update on table "collate_test22" violates foreign key constraint "collate_test22_f2_fkey"
! DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
! DELETE FROM collate_test22 WHERE f2 = 'baz';
! ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20;
! RESET enable_seqscan;
! RESET enable_hashjoin;
! RESET enable_nestloop;
! -- 9.1 bug with useless COLLATE in an expression subject to length coercion
! CREATE TEMP TABLE vctable (f1 varchar(25));
! INSERT INTO vctable VALUES ('foo' COLLATE "C");
! SELECT collation for ('foo'); -- unknown type - null
!  pg_collation_for 
! ------------------
!  
! (1 row)
! 
! SELECT collation for ('foo'::text);
!  pg_collation_for 
! ------------------
!  "default"
! (1 row)
! 
! SELECT collation for ((SELECT a FROM collate_test1 LIMIT 1)); -- non-collatable type - error
! ERROR:  collations are not supported by type integer
! SELECT collation for ((SELECT b FROM collate_test1 LIMIT 1));
!  pg_collation_for 
! ------------------
!  "C"
! (1 row)
! 
! --
! -- Clean up.  Many of these table names will be re-used if the user is
! -- trying to run any platform-specific collation tests later, so we
! -- must get rid of them.
! --
! DROP SCHEMA collate_tests CASCADE;
! NOTICE:  drop cascades to 15 other objects
! DETAIL:  drop cascades to table collate_test1
! drop cascades to table collate_test_like
! drop cascades to table collate_test2
! drop cascades to type testdomain_p
! drop cascades to table collate_test4
! drop cascades to table collate_test5
! drop cascades to table collate_test10
! drop cascades to view collview1
! drop cascades to view collview2
! drop cascades to view collview3
! drop cascades to type testdomain
! drop cascades to function dup(anyelement)
! drop cascades to table collate_test20
! drop cascades to table collate_test21
! drop cascades to table collate_test22
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/matview.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/matview.out	2015-01-26 12:33:24.299031328 +0300
***************
*** 1,516 ****
! -- create a table to use as a basis for views and materialized views in various combinations
! CREATE TABLE t (id int NOT NULL PRIMARY KEY, type text NOT NULL, amt numeric NOT NULL);
! INSERT INTO t VALUES
!   (1, 'x', 2),
!   (2, 'x', 3),
!   (3, 'y', 5),
!   (4, 'y', 7),
!   (5, 'z', 11);
! -- we want a view based on the table, too, since views present additional challenges
! CREATE VIEW tv AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type;
! SELECT * FROM tv ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! -- create a materialized view with no data, and confirm correct behavior
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tm AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type WITH NO DATA;
!      QUERY PLAN      
! ---------------------
!  HashAggregate
!    Group Key: type
!    ->  Seq Scan on t
! (3 rows)
! 
! CREATE MATERIALIZED VIEW tm AS SELECT type, sum(amt) AS totamt FROM t GROUP BY type WITH NO DATA;
! SELECT relispopulated FROM pg_class WHERE oid = 'tm'::regclass;
!  relispopulated 
! ----------------
!  f
! (1 row)
! 
! SELECT * FROM tm;
! ERROR:  materialized view "tm" has not been populated
! HINT:  Use the REFRESH MATERIALIZED VIEW command.
! REFRESH MATERIALIZED VIEW tm;
! SELECT relispopulated FROM pg_class WHERE oid = 'tm'::regclass;
!  relispopulated 
! ----------------
!  t
! (1 row)
! 
! CREATE UNIQUE INDEX tm_type ON tm (type);
! SELECT * FROM tm;
!  type | totamt 
! ------+--------
!  y    |     12
!  z    |     11
!  x    |      5
! (3 rows)
! 
! -- create various views
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tvm AS SELECT * FROM tv ORDER BY type;
!         QUERY PLAN         
! ---------------------------
!  Sort
!    Sort Key: t.type
!    ->  HashAggregate
!          Group Key: t.type
!          ->  Seq Scan on t
! (5 rows)
! 
! CREATE MATERIALIZED VIEW tvm AS SELECT * FROM tv ORDER BY type;
! SELECT * FROM tvm;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! CREATE MATERIALIZED VIEW tmm AS SELECT sum(totamt) AS grandtot FROM tm;
! CREATE MATERIALIZED VIEW tvmm AS SELECT sum(totamt) AS grandtot FROM tvm;
! CREATE UNIQUE INDEX tvmm_expr ON tvmm ((grandtot > 0));
! CREATE UNIQUE INDEX tvmm_pred ON tvmm (grandtot) WHERE grandtot < 0;
! CREATE VIEW tvv AS SELECT sum(totamt) AS grandtot FROM tv;
! EXPLAIN (costs off)
!   CREATE MATERIALIZED VIEW tvvm AS SELECT * FROM tvv;
!         QUERY PLAN         
! ---------------------------
!  Aggregate
!    ->  HashAggregate
!          Group Key: t.type
!          ->  Seq Scan on t
! (4 rows)
! 
! CREATE MATERIALIZED VIEW tvvm AS SELECT * FROM tvv;
! CREATE VIEW tvvmv AS SELECT * FROM tvvm;
! CREATE MATERIALIZED VIEW bb AS SELECT * FROM tvvmv;
! CREATE INDEX aa ON bb (grandtot);
! -- check that plans seem reasonable
! \d+ tvm
!                     Materialized view "public.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! \d+ tvm
!                     Materialized view "public.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! \d+ tvvm
!                     Materialized view "public.tvvm"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! View definition:
!  SELECT tvv.grandtot
!    FROM tvv;
! 
! \d+ bb
!                      Materialized view "public.bb"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! Indexes:
!     "aa" btree (grandtot)
! View definition:
!  SELECT tvvmv.grandtot
!    FROM tvvmv;
! 
! -- test schema behavior
! CREATE SCHEMA mvschema;
! ALTER MATERIALIZED VIEW tvm SET SCHEMA mvschema;
! \d+ tvm
! \d+ tvmm
!                     Materialized view "public.tvmm"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  grandtot | numeric |           | main    |              | 
! Indexes:
!     "tvmm_expr" UNIQUE, btree ((grandtot > 0::numeric))
!     "tvmm_pred" UNIQUE, btree (grandtot) WHERE grandtot < 0::numeric
! View definition:
!  SELECT sum(tvm.totamt) AS grandtot
!    FROM mvschema.tvm;
! 
! SET search_path = mvschema, public;
! \d+ tvm
!                    Materialized view "mvschema.tvm"
!  Column |  Type   | Modifiers | Storage  | Stats target | Description 
! --------+---------+-----------+----------+--------------+-------------
!  type   | text    |           | extended |              | 
!  totamt | numeric |           | main     |              | 
! View definition:
!  SELECT tv.type,
!     tv.totamt
!    FROM tv
!   ORDER BY tv.type;
! 
! -- modify the underlying table data
! INSERT INTO t VALUES (6, 'z', 13);
! -- confirm pre- and post-refresh contents of fairly simple materialized views
! SELECT * FROM tm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! SELECT * FROM tvm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     11
! (3 rows)
! 
! REFRESH MATERIALIZED VIEW CONCURRENTLY tm;
! REFRESH MATERIALIZED VIEW tvm;
! SELECT * FROM tm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     24
! (3 rows)
! 
! SELECT * FROM tvm ORDER BY type;
!  type | totamt 
! ------+--------
!  x    |      5
!  y    |     12
!  z    |     24
! (3 rows)
! 
! RESET search_path;
! -- confirm pre- and post-refresh contents of nested materialized views
! EXPLAIN (costs off)
!   SELECT * FROM tmm;
!    QUERY PLAN    
! -----------------
!  Seq Scan on tmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvmm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvvm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvvm
! (1 row)
! 
! SELECT * FROM tmm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! SELECT * FROM tvmm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! SELECT * FROM tvvm;
!  grandtot 
! ----------
!        28
! (1 row)
! 
! REFRESH MATERIALIZED VIEW tmm;
! REFRESH MATERIALIZED VIEW CONCURRENTLY tvmm;
! ERROR:  cannot refresh materialized view "public.tvmm" concurrently
! HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
! REFRESH MATERIALIZED VIEW tvmm;
! REFRESH MATERIALIZED VIEW tvvm;
! EXPLAIN (costs off)
!   SELECT * FROM tmm;
!    QUERY PLAN    
! -----------------
!  Seq Scan on tmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvmm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvmm
! (1 row)
! 
! EXPLAIN (costs off)
!   SELECT * FROM tvvm;
!     QUERY PLAN    
! ------------------
!  Seq Scan on tvvm
! (1 row)
! 
! SELECT * FROM tmm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! SELECT * FROM tvmm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! SELECT * FROM tvvm;
!  grandtot 
! ----------
!        41
! (1 row)
! 
! -- test diemv when the mv does not exist
! DROP MATERIALIZED VIEW IF EXISTS no_such_mv;
! NOTICE:  materialized view "no_such_mv" does not exist, skipping
! -- make sure invalid comination of options is prohibited
! REFRESH MATERIALIZED VIEW CONCURRENTLY tvmm WITH NO DATA;
! ERROR:  CONCURRENTLY and WITH NO DATA options cannot be used together
! -- no tuple locks on materialized views
! SELECT * FROM tvvm FOR SHARE;
! ERROR:  cannot lock rows in materialized view "tvvm"
! -- test join of mv and view
! SELECT type, m.totamt AS mtot, v.totamt AS vtot FROM tm m LEFT JOIN tv v USING (type) ORDER BY type;
!  type | mtot | vtot 
! ------+------+------
!  x    |    5 |    5
!  y    |   12 |   12
!  z    |   24 |   24
! (3 rows)
! 
! -- make sure that dependencies are reported properly when they block the drop
! DROP TABLE t;
! ERROR:  cannot drop table t because other objects depend on it
! DETAIL:  view tv depends on table t
! view tvv depends on view tv
! materialized view tvvm depends on view tvv
! view tvvmv depends on materialized view tvvm
! materialized view bb depends on view tvvmv
! materialized view mvschema.tvm depends on view tv
! materialized view tvmm depends on materialized view mvschema.tvm
! materialized view tm depends on table t
! materialized view tmm depends on materialized view tm
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- make sure dependencies are dropped and reported
! -- and make sure that transactional behavior is correct on rollback
! -- incidentally leaving some interesting materialized views for pg_dump testing
! BEGIN;
! DROP TABLE t CASCADE;
! NOTICE:  drop cascades to 9 other objects
! DETAIL:  drop cascades to view tv
! drop cascades to view tvv
! drop cascades to materialized view tvvm
! drop cascades to view tvvmv
! drop cascades to materialized view bb
! drop cascades to materialized view mvschema.tvm
! drop cascades to materialized view tvmm
! drop cascades to materialized view tm
! drop cascades to materialized view tmm
! ROLLBACK;
! -- some additional tests not using base tables
! CREATE VIEW v_test1 AS SELECT 1 moo;
! CREATE VIEW v_test2 AS SELECT moo, 2*moo FROM v_test1 UNION ALL SELECT moo, 3*moo FROM v_test1;
! \d+ v_test2
!                  View "public.v_test2"
!   Column  |  Type   | Modifiers | Storage | Description 
! ----------+---------+-----------+---------+-------------
!  moo      | integer |           | plain   | 
!  ?column? | integer |           | plain   | 
! View definition:
!  SELECT v_test1.moo,
!     2 * v_test1.moo
!    FROM v_test1
! UNION ALL
!  SELECT v_test1.moo,
!     3 * v_test1.moo
!    FROM v_test1;
! 
! CREATE MATERIALIZED VIEW mv_test2 AS SELECT moo, 2*moo FROM v_test2 UNION ALL SELECT moo, 3*moo FROM v_test2;
! \d+ mv_test2
!                   Materialized view "public.mv_test2"
!   Column  |  Type   | Modifiers | Storage | Stats target | Description 
! ----------+---------+-----------+---------+--------------+-------------
!  moo      | integer |           | plain   |              | 
!  ?column? | integer |           | plain   |              | 
! View definition:
!  SELECT v_test2.moo,
!     2 * v_test2.moo
!    FROM v_test2
! UNION ALL
!  SELECT v_test2.moo,
!     3 * v_test2.moo
!    FROM v_test2;
! 
! CREATE MATERIALIZED VIEW mv_test3 AS SELECT * FROM mv_test2 WHERE moo = 12345;
! SELECT relispopulated FROM pg_class WHERE oid = 'mv_test3'::regclass;
!  relispopulated 
! ----------------
!  t
! (1 row)
! 
! DROP VIEW v_test1 CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view v_test2
! drop cascades to materialized view mv_test2
! drop cascades to materialized view mv_test3
! -- test that vacuum does not make empty matview look unpopulated
! CREATE TABLE hoge (i int);
! INSERT INTO hoge VALUES (generate_series(1,100000));
! CREATE MATERIALIZED VIEW hogeview AS SELECT * FROM hoge WHERE i % 2 = 0;
! CREATE INDEX hogeviewidx ON hogeview (i);
! DELETE FROM hoge;
! REFRESH MATERIALIZED VIEW hogeview;
! SELECT * FROM hogeview WHERE i < 10;
!  i 
! ---
! (0 rows)
! 
! VACUUM ANALYZE hogeview;
! SELECT * FROM hogeview WHERE i < 10;
!  i 
! ---
! (0 rows)
! 
! DROP TABLE hoge CASCADE;
! NOTICE:  drop cascades to materialized view hogeview
! -- test that duplicate values on unique index prevent refresh
! CREATE TABLE foo(a, b) AS VALUES(1, 10);
! CREATE MATERIALIZED VIEW mv AS SELECT * FROM foo;
! CREATE UNIQUE INDEX ON mv(a);
! INSERT INTO foo SELECT * FROM foo;
! REFRESH MATERIALIZED VIEW mv;
! ERROR:  could not create unique index "mv_a_idx"
! DETAIL:  Key (a)=(1) is duplicated.
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv;
! ERROR:  new data for "mv" contains duplicate rows without any null columns
! DETAIL:  Row: (1,10)
! DROP TABLE foo CASCADE;
! NOTICE:  drop cascades to materialized view mv
! -- make sure that all columns covered by unique indexes works
! CREATE TABLE foo(a, b, c) AS VALUES(1, 2, 3);
! CREATE MATERIALIZED VIEW mv AS SELECT * FROM foo;
! CREATE UNIQUE INDEX ON mv (a);
! CREATE UNIQUE INDEX ON mv (b);
! CREATE UNIQUE INDEX on mv (c);
! INSERT INTO foo VALUES(2, 3, 4);
! INSERT INTO foo VALUES(3, 4, 5);
! REFRESH MATERIALIZED VIEW mv;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv;
! DROP TABLE foo CASCADE;
! NOTICE:  drop cascades to materialized view mv
! -- allow subquery to reference unpopulated matview if WITH NO DATA is specified
! CREATE MATERIALIZED VIEW mv1 AS SELECT 1 AS col1 WITH NO DATA;
! CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1
!   WHERE col1 = (SELECT LEAST(col1) FROM mv1) WITH NO DATA;
! DROP MATERIALIZED VIEW mv1 CASCADE;
! NOTICE:  drop cascades to materialized view mv2
! -- make sure that types with unusual equality tests work
! CREATE TABLE boxes (id serial primary key, b box);
! INSERT INTO boxes (b) VALUES
!   ('(32,32),(31,31)'),
!   ('(2.0000004,2.0000004),(1,1)'),
!   ('(1.9999996,1.9999996),(1,1)');
! CREATE MATERIALIZED VIEW boxmv AS SELECT * FROM boxes;
! CREATE UNIQUE INDEX boxmv_id ON boxmv (id);
! UPDATE boxes SET b = '(2,2),(1,1)' WHERE id = 2;
! REFRESH MATERIALIZED VIEW CONCURRENTLY boxmv;
! SELECT * FROM boxmv ORDER BY id;
!  id |              b              
! ----+-----------------------------
!   1 | (32,32),(31,31)
!   2 | (2,2),(1,1)
!   3 | (1.9999996,1.9999996),(1,1)
! (3 rows)
! 
! DROP TABLE boxes CASCADE;
! NOTICE:  drop cascades to materialized view boxmv
! -- make sure that column names are handled correctly
! CREATE TABLE v (i int, j int);
! CREATE MATERIALIZED VIEW mv_v (ii) AS SELECT i, j AS jj FROM v;
! ALTER TABLE v RENAME COLUMN i TO x;
! INSERT INTO v values (1, 2);
! CREATE UNIQUE INDEX mv_v_ii ON mv_v (ii);
! REFRESH MATERIALIZED VIEW mv_v;
! UPDATE v SET j = 3 WHERE x = 1;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv_v;
! SELECT * FROM v;
!  x | j 
! ---+---
!  1 | 3
! (1 row)
! 
! SELECT * FROM mv_v;
!  ii | jj 
! ----+----
!   1 |  3
! (1 row)
! 
! DROP TABLE v CASCADE;
! NOTICE:  drop cascades to materialized view mv_v
! -- make sure that matview rows can be referenced as source rows (bug #9398)
! CREATE TABLE v AS SELECT generate_series(1,10) AS a;
! CREATE MATERIALIZED VIEW mv_v AS SELECT a FROM v WHERE a <= 5;
! DELETE FROM v WHERE EXISTS ( SELECT * FROM mv_v WHERE mv_v.a = v.a );
! SELECT * FROM v;
!  a  
! ----
!   6
!   7
!   8
!   9
!  10
! (5 rows)
! 
! SELECT * FROM mv_v;
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
! DROP TABLE v CASCADE;
! NOTICE:  drop cascades to materialized view mv_v
! -- make sure running as superuser works when MV owned by another role (bug #11208)
! CREATE ROLE user_dw;
! SET ROLE user_dw;
! CREATE TABLE foo_data AS SELECT i, md5(random()::text)
!   FROM generate_series(1, 10) i;
! CREATE MATERIALIZED VIEW mv_foo AS SELECT * FROM foo_data;
! CREATE UNIQUE INDEX ON mv_foo (i);
! RESET ROLE;
! REFRESH MATERIALIZED VIEW mv_foo;
! REFRESH MATERIALIZED VIEW CONCURRENTLY mv_foo;
! DROP OWNED BY user_dw CASCADE;
! DROP ROLE user_dw;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/lock.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/lock.out	2015-01-26 12:33:24.299031328 +0300
***************
*** 1,70 ****
! --
! -- Test the LOCK statement
! --
! -- Setup
! CREATE SCHEMA lock_schema1;
! SET search_path = lock_schema1;
! CREATE TABLE lock_tbl1 (a BIGINT);
! CREATE VIEW lock_view1 AS SELECT 1;
! CREATE ROLE regress_rol_lock1;
! ALTER ROLE regress_rol_lock1 SET search_path = lock_schema1;
! GRANT USAGE ON SCHEMA lock_schema1 TO regress_rol_lock1;
! -- Try all valid lock options; also try omitting the optional TABLE keyword.
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE;
! LOCK lock_tbl1 IN ROW SHARE MODE;
! LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN SHARE MODE;
! LOCK lock_tbl1 IN SHARE ROW EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE;
! LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE;
! ROLLBACK;
! -- Try using NOWAIT along with valid options.
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ROW SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN SHARE ROW EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE NOWAIT;
! LOCK TABLE lock_view1 IN EXCLUSIVE MODE;   -- Will fail; can't lock a non-table
! ERROR:  "lock_view1" is not a table
! ROLLBACK;
! -- Verify that we can lock a table with inheritance children.
! CREATE TABLE lock_tbl2 (b BIGINT) INHERITS (lock_tbl1);
! CREATE TABLE lock_tbl3 () INHERITS (lock_tbl2);
! BEGIN TRANSACTION;
! LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
! ROLLBACK;
! -- Verify that we can't lock a child table just because we have permission
! -- on the parent, but that we can lock the parent only.
! GRANT UPDATE ON TABLE lock_tbl1 TO regress_rol_lock1;
! SET ROLE regress_rol_lock1;
! BEGIN;
! LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
! ERROR:  permission denied for relation lock_tbl2
! ROLLBACK;
! BEGIN;
! LOCK TABLE ONLY lock_tbl1;
! ROLLBACK;
! RESET ROLE;
! --
! -- Clean up
! --
! DROP VIEW lock_view1;
! DROP TABLE lock_tbl3;
! DROP TABLE lock_tbl2;
! DROP TABLE lock_tbl1;
! DROP SCHEMA lock_schema1 CASCADE;
! DROP ROLE regress_rol_lock1;
! -- atomic ops tests
! RESET search_path;
! SELECT test_atomic_ops();
!  test_atomic_ops 
! -----------------
!  t
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/replica_identity.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/replica_identity.out	2015-01-26 12:33:24.315031329 +0300
***************
*** 1,184 ****
! CREATE TABLE test_replica_identity (
!        id serial primary key,
!        keya text not null,
!        keyb text not null,
!        nonkey text,
!        CONSTRAINT test_replica_identity_unique_defer UNIQUE (keya, keyb) DEFERRABLE,
!        CONSTRAINT test_replica_identity_unique_nondefer UNIQUE (keya, keyb)
! );
! CREATE TABLE test_replica_identity_othertable (id serial primary key);
! CREATE INDEX test_replica_identity_keyab ON test_replica_identity (keya, keyb);
! CREATE UNIQUE INDEX test_replica_identity_keyab_key ON test_replica_identity (keya, keyb);
! CREATE UNIQUE INDEX test_replica_identity_nonkey ON test_replica_identity (keya, nonkey);
! CREATE INDEX test_replica_identity_hash ON test_replica_identity USING hash (nonkey);
! WARNING:  hash indexes are not WAL-logged and their use is discouraged
! CREATE UNIQUE INDEX test_replica_identity_expr ON test_replica_identity (keya, keyb, (3));
! CREATE UNIQUE INDEX test_replica_identity_partial ON test_replica_identity (keya, keyb) WHERE keyb != '3';
! -- default is 'd'/DEFAULT for user created tables
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! -- but 'none' for system tables
! SELECT relreplident FROM pg_class WHERE oid = 'pg_class'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! SELECT relreplident FROM pg_class WHERE oid = 'pg_constraint'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! ----
! -- Make sure we detect ineligible indexes
! ----
! -- fail, not unique
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab;
! ERROR:  cannot use non-unique index "test_replica_identity_keyab" as replica identity
! -- fail, not a candidate key, nullable column
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_nonkey;
! ERROR:  index "test_replica_identity_nonkey" cannot be used as replica identity because column "nonkey" is nullable
! -- fail, hash indexes cannot do uniqueness
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_hash;
! ERROR:  cannot use non-unique index "test_replica_identity_hash" as replica identity
! -- fail, expression index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_expr;
! ERROR:  cannot use expression index "test_replica_identity_expr" as replica identity
! -- fail, partial index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_partial;
! ERROR:  cannot use partial index "test_replica_identity_partial" as replica identity
! -- fail, not our index
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey;
! ERROR:  "test_replica_identity_othertable_pkey" is not an index for table "test_replica_identity"
! -- fail, deferrable
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer;
! ERROR:  cannot use non-immediate index "test_replica_identity_unique_defer" as replica identity
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! ----
! -- Make sure index cases succeeed
! ----
! -- succeed, primary key
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_pkey;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  i
! (1 row)
! 
! \d test_replica_identity
!                          Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              
! --------+---------+--------------------------------------------------------------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass)
!  keya   | text    | not null
!  keyb   | text    | not null
!  nonkey | text    | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id) REPLICA IDENTITY
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! 
! -- succeed, nondeferrable unique constraint over nonullable cols
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_nondefer;
! -- succeed unique index over nonnullable cols
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
! ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  i
! (1 row)
! 
! \d test_replica_identity
!                          Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              
! --------+---------+--------------------------------------------------------------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass)
!  keya   | text    | not null
!  keyb   | text    | not null
!  nonkey | text    | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id)
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb) REPLICA IDENTITY
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! 
! SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
!  count 
! -------
!      1
! (1 row)
! 
! ----
! -- Make sure non index cases work
! ----
! ALTER TABLE test_replica_identity REPLICA IDENTITY DEFAULT;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  d
! (1 row)
! 
! SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
!  count 
! -------
!      0
! (1 row)
! 
! ALTER TABLE test_replica_identity REPLICA IDENTITY FULL;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  f
! (1 row)
! 
! \d+ test_replica_identity
!                                              Table "public.test_replica_identity"
!  Column |  Type   |                             Modifiers                              | Storage  | Stats target | Description 
! --------+---------+--------------------------------------------------------------------+----------+--------------+-------------
!  id     | integer | not null default nextval('test_replica_identity_id_seq'::regclass) | plain    |              | 
!  keya   | text    | not null                                                           | extended |              | 
!  keyb   | text    | not null                                                           | extended |              | 
!  nonkey | text    |                                                                    | extended |              | 
! Indexes:
!     "test_replica_identity_pkey" PRIMARY KEY, btree (id)
!     "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
!     "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
!     "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
!     "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
!     "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
!     "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
!     "test_replica_identity_hash" hash (nonkey)
!     "test_replica_identity_keyab" btree (keya, keyb)
! Replica Identity: FULL
! 
! ALTER TABLE test_replica_identity REPLICA IDENTITY NOTHING;
! SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
!  relreplident 
! --------------
!  n
! (1 row)
! 
! DROP TABLE test_replica_identity;
! DROP TABLE test_replica_identity_othertable;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rowsecurity.out	2014-11-21 01:48:04.351429000 +0300
--- /home/orion/postgres/src/test/regress/results/rowsecurity.out	2015-01-26 12:33:24.307031328 +0300
***************
*** 1,2236 ****
! --
! -- Test of Row-level security feature
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when users/groups don't exist
! SET client_min_messages TO 'warning';
! DROP USER IF EXISTS rls_regress_user0;
! DROP USER IF EXISTS rls_regress_user1;
! DROP USER IF EXISTS rls_regress_user2;
! DROP USER IF EXISTS rls_regress_exempt_user;
! DROP ROLE IF EXISTS rls_regress_group1;
! DROP ROLE IF EXISTS rls_regress_group2;
! DROP SCHEMA IF EXISTS rls_regress_schema CASCADE;
! RESET client_min_messages;
! -- initial setup
! CREATE USER rls_regress_user0;
! CREATE USER rls_regress_user1;
! CREATE USER rls_regress_user2;
! CREATE USER rls_regress_exempt_user BYPASSRLS;
! CREATE ROLE rls_regress_group1 NOLOGIN;
! CREATE ROLE rls_regress_group2 NOLOGIN;
! GRANT rls_regress_group1 TO rls_regress_user1;
! GRANT rls_regress_group2 TO rls_regress_user2;
! CREATE SCHEMA rls_regress_schema;
! GRANT ALL ON SCHEMA rls_regress_schema to public;
! SET search_path = rls_regress_schema;
! -- setup of malicious function
! CREATE OR REPLACE FUNCTION f_leak(text) RETURNS bool
!     COST 0.0000001 LANGUAGE plpgsql
!     AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END';
! GRANT EXECUTE ON FUNCTION f_leak(text) TO public;
! -- BASIC Row-Level Security Scenario
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE uaccount (
!     pguser      name primary key,
!     seclv       int
! );
! GRANT SELECT ON uaccount TO public;
! INSERT INTO uaccount VALUES
!     ('rls_regress_user0', 99),
!     ('rls_regress_user1', 1),
!     ('rls_regress_user2', 2),
!     ('rls_regress_user3', 3);
! CREATE TABLE category (
!     cid        int primary key,
!     cname      text
! );
! GRANT ALL ON category TO public;
! INSERT INTO category VALUES
!     (11, 'novel'),
!     (22, 'science fiction'),
!     (33, 'technology'),
!     (44, 'manga');
! CREATE TABLE document (
!     did         int primary key,
!     cid         int references category(cid),
!     dlevel      int not null,
!     dauthor     name,
!     dtitle      text
! );
! GRANT ALL ON document TO public;
! INSERT INTO document VALUES
!     ( 1, 11, 1, 'rls_regress_user1', 'my first novel'),
!     ( 2, 11, 2, 'rls_regress_user1', 'my second novel'),
!     ( 3, 22, 2, 'rls_regress_user1', 'my science fiction'),
!     ( 4, 44, 1, 'rls_regress_user1', 'my first manga'),
!     ( 5, 44, 2, 'rls_regress_user1', 'my second manga'),
!     ( 6, 22, 1, 'rls_regress_user2', 'great science fiction'),
!     ( 7, 33, 2, 'rls_regress_user2', 'great technology book'),
!     ( 8, 44, 1, 'rls_regress_user2', 'great manga');
! ALTER TABLE document ENABLE ROW LEVEL SECURITY;
! -- user's security level must be higher than or equal to document's
! CREATE POLICY p1 ON document
!     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
! -- viewpoint from rls_regress_user1
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (4 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel        | novel
!   44 |   4 |      1 | rls_regress_user1 | my first manga        | manga
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (4 rows)
! 
! -- viewpoint from rls_regress_user2
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (8 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel        | novel
!   11 |   2 |      2 | rls_regress_user1 | my second novel       | novel
!   22 |   3 |      2 | rls_regress_user1 | my science fiction    | science fiction
!   44 |   4 |      1 | rls_regress_user1 | my first manga        | manga
!   44 |   5 |      2 | rls_regress_user1 | my second manga       | manga
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   33 |   7 |      2 | rls_regress_user2 | great technology book | technology
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (8 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on document
!    Filter: f_leak(document.dtitle)
!    ->  Seq Scan on document document_1
!          Filter: (dlevel <= $0)
!          InitPlan 1 (returns $0)
!            ->  Index Scan using uaccount_pkey on uaccount
!                  Index Cond: (pguser = "current_user"())
! (7 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (category.cid = document.cid)
!    ->  Seq Scan on category
!    ->  Hash
!          ->  Subquery Scan on document
!                Filter: f_leak(document.dtitle)
!                ->  Seq Scan on document document_1
!                      Filter: (dlevel <= $0)
!                      InitPlan 1 (returns $0)
!                        ->  Index Scan using uaccount_pkey on uaccount
!                              Index Cond: (pguser = "current_user"())
! (11 rows)
! 
! -- only owner can change row-level security
! ALTER POLICY p1 ON document USING (true);    --fail
! ERROR:  must be owner of relation document
! DROP POLICY p1 ON document;                  --fail
! ERROR:  must be owner of relation document
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p1 ON document USING (dauthor = current_user);
! -- viewpoint from rls_regress_user1 again
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
!  did | cid | dlevel |      dauthor      |       dtitle       
! -----+-----+--------+-------------------+--------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
! (5 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! NOTICE:  f_leak => my first novel
! NOTICE:  f_leak => my second novel
! NOTICE:  f_leak => my science fiction
! NOTICE:  f_leak => my first manga
! NOTICE:  f_leak => my second manga
!  cid | did | dlevel |      dauthor      |       dtitle       |      cname      
! -----+-----+--------+-------------------+--------------------+-----------------
!   11 |   1 |      1 | rls_regress_user1 | my first novel     | novel
!   11 |   2 |      2 | rls_regress_user1 | my second novel    | novel
!   22 |   3 |      2 | rls_regress_user1 | my science fiction | science fiction
!   44 |   4 |      1 | rls_regress_user1 | my first manga     | manga
!   44 |   5 |      2 | rls_regress_user1 | my second manga    | manga
! (5 rows)
! 
! -- viewpoint from rls_regres_user2 again
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
! (3 rows)
! 
! SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! NOTICE:  f_leak => great science fiction
! NOTICE:  f_leak => great technology book
! NOTICE:  f_leak => great manga
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   22 |   6 |      1 | rls_regress_user2 | great science fiction | science fiction
!   33 |   7 |      2 | rls_regress_user2 | great technology book | technology
!   44 |   8 |      1 | rls_regress_user2 | great manga           | manga
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                   QUERY PLAN                  
! ----------------------------------------------
!  Subquery Scan on document
!    Filter: f_leak(document.dtitle)
!    ->  Seq Scan on document document_1
!          Filter: (dauthor = "current_user"())
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Nested Loop
!    ->  Subquery Scan on document
!          Filter: f_leak(document.dtitle)
!          ->  Seq Scan on document document_1
!                Filter: (dauthor = "current_user"())
!    ->  Index Scan using category_pkey on category
!          Index Cond: (cid = document.cid)
! (7 rows)
! 
! -- interaction of FK/PK constraints
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY p2 ON category
!     USING (CASE WHEN current_user = 'rls_regress_user1' THEN cid IN (11, 33)
!            WHEN current_user = 'rls_regress_user2' THEN cid IN (22, 44)
!            ELSE false END);
! ALTER TABLE category ENABLE ROW LEVEL SECURITY;
! -- cannot delete PK referenced by invisible FK
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid;
!  did | cid | dlevel |      dauthor      |       dtitle       | cid |   cname    
! -----+-----+--------+-------------------+--------------------+-----+------------
!    2 |  11 |      2 | rls_regress_user1 | my second novel    |  11 | novel
!    1 |  11 |      1 | rls_regress_user1 | my first novel     |  11 | novel
!      |     |        |                   |                    |  33 | technology
!    5 |  44 |      2 | rls_regress_user1 | my second manga    |     | 
!    4 |  44 |      1 | rls_regress_user1 | my first manga     |     | 
!    3 |  22 |      2 | rls_regress_user1 | my science fiction |     | 
! (6 rows)
! 
! DELETE FROM category WHERE cid = 33;    -- fails with FK violation
! ERROR:  update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
! DETAIL:  Key (cid)=(33) is still referenced from table "document".
! -- can insert FK referencing invisible PK
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid;
!  did | cid | dlevel |      dauthor      |        dtitle         | cid |      cname      
! -----+-----+--------+-------------------+-----------------------+-----+-----------------
!    6 |  22 |      1 | rls_regress_user2 | great science fiction |  22 | science fiction
!    8 |  44 |      1 | rls_regress_user2 | great manga           |  44 | manga
!    7 |  33 |      2 | rls_regress_user2 | great technology book |     | 
! (3 rows)
! 
! INSERT INTO document VALUES (10, 33, 1, current_user, 'hoge');
! -- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
! SET SESSION AUTHORIZATION rls_regress_user1;
! INSERT INTO document VALUES (8, 44, 1, 'rls_regress_user1', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't see
! ERROR:  duplicate key value violates unique constraint "document_pkey"
! DETAIL:  Key (did)=(8) already exists.
! SELECT * FROM document WHERE did = 8; -- and confirm we can't see it
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! -- database superuser does bypass RLS policy when enabled
! RESET SESSION AUTHORIZATION;
! SET row_security TO ON;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- database superuser does not bypass RLS policy when FORCE enabled.
! RESET SESSION AUTHORIZATION;
! SET row_security TO FORCE;
! SELECT * FROM document;
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! SELECT * FROM category;
!  cid | cname 
! -----+-------
! (0 rows)
! 
! -- database superuser does bypass RLS policy when disabled
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- database non-superuser with bypass privilege can bypass RLS policy when disabled
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- RLS policy applies to table owner when FORCE enabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO FORCE;
! SELECT * FROM document;
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
! SELECT * FROM category;
!  cid | cname 
! -----+-------
! (0 rows)
! 
! -- RLS policy does not apply to table owner when RLS enabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! -- RLS policy does not apply to table owner when RLS disabled.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO OFF;
! SELECT * FROM document;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    1 |  11 |      1 | rls_regress_user1 | my first novel
!    2 |  11 |      2 | rls_regress_user1 | my second novel
!    3 |  22 |      2 | rls_regress_user1 | my science fiction
!    4 |  44 |      1 | rls_regress_user1 | my first manga
!    5 |  44 |      2 | rls_regress_user1 | my second manga
!    6 |  22 |      1 | rls_regress_user2 | great science fiction
!    7 |  33 |      2 | rls_regress_user2 | great technology book
!    8 |  44 |      1 | rls_regress_user2 | great manga
!   10 |  33 |      1 | rls_regress_user2 | hoge
! (9 rows)
! 
! SELECT * FROM category;
!  cid |      cname      
! -----+-----------------
!   11 | novel
!   22 | science fiction
!   33 | technology
!   44 | manga
! (4 rows)
! 
! --
! -- Table inheritance and RLS policy
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! CREATE TABLE t1 (a int, junk1 text, b text) WITH OIDS;
! ALTER TABLE t1 DROP COLUMN junk1;    -- just a disturbing factor
! GRANT ALL ON t1 TO public;
! COPY t1 FROM stdin WITH (oids);
! CREATE TABLE t2 (c float) INHERITS (t1);
! COPY t2 FROM stdin WITH (oids);
! CREATE TABLE t3 (c text, b text, a int) WITH OIDS;
! ALTER TABLE t3 INHERIT t1;
! COPY t3(a,b,c) FROM stdin WITH (oids);
! CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0); -- be even number
! CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1); -- be odd number
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM t1;
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Subquery Scan on t1
!    Filter: f_leak(t1.b)
!    ->  Append
!          ->  Seq Scan on t1 t1_1
!                Filter: ((a % 2) = 0)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (9 rows)
! 
! -- reference to system column
! SELECT oid, * FROM t1;
!  oid | a |  b  
! -----+---+-----
!  102 | 2 | bbb
!  104 | 4 | ddd
!  202 | 2 | bcd
!  204 | 4 | def
!  302 | 2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! -- reference to whole-row reference
! SELECT *, t1 FROM t1;
!  a |  b  |   t1    
! ---+-----+---------
!  2 | bbb | (2,bbb)
!  4 | ddd | (4,ddd)
!  2 | bcd | (2,bcd)
!  4 | def | (4,def)
!  2 | yyy | (2,yyy)
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
!           QUERY PLAN           
! -------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t2
!          Filter: ((a % 2) = 0)
!    ->  Seq Scan on t3
!          Filter: ((a % 2) = 0)
! (7 rows)
! 
! -- for share/update lock
! SELECT * FROM t1 FOR SHARE;
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  LockRows
!    ->  Subquery Scan on t1
!          ->  LockRows
!                ->  Result
!                      ->  Append
!                            ->  Seq Scan on t1 t1_1
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t2
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t3
!                                  Filter: ((a % 2) = 0)
! (11 rows)
! 
! SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
!  2 | bcd
!  4 | def
!  2 | yyy
! (5 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  LockRows
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  LockRows
!                ->  Result
!                      ->  Append
!                            ->  Seq Scan on t1 t1_1
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t2
!                                  Filter: ((a % 2) = 0)
!                            ->  Seq Scan on t3
!                                  Filter: ((a % 2) = 0)
! (12 rows)
! 
! -- superuser is allowed to bypass RLS checks
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! -- non-superuser with bypass privilege can bypass RLS policy when disabled
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! ----- Dependencies -----
! SET SESSION AUTHORIZATION rls_regress_user0;
! SET row_security TO ON;
! CREATE TABLE dependee (x integer, y integer);
! CREATE TABLE dependent (x integer, y integer);
! CREATE POLICY d1 ON dependent FOR ALL
!     TO PUBLIC
!     USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
! DROP TABLE dependee; -- Should fail without CASCADE due to dependency on row-security qual?
! ERROR:  cannot drop table dependee because other objects depend on it
! DETAIL:  policy d1 on table dependent depends on table dependee
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TABLE dependee CASCADE;
! NOTICE:  drop cascades to policy d1 on table dependent
! EXPLAIN (COSTS OFF) SELECT * FROM dependent; -- After drop, should be unqualified
!       QUERY PLAN       
! -----------------------
!  Seq Scan on dependent
! (1 row)
! 
! -----   RECURSION    ----
! --
! -- Simple recursion
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE rec1 (x integer, y integer);
! CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
! ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1; -- fail, direct recursion
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE rec2 (a integer, b integer);
! ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
! CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
! ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion via views
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rec1v AS SELECT * FROM rec1;
! CREATE VIEW rec2v AS SELECT * FROM rec2;
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
! ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion via views
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- Mutual recursion via .s.b views
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! DROP VIEW rec1v, rec2v CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to policy r1 on table rec1
! drop cascades to policy r2 on table rec2
! CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1;
! CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2;
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
! CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rec1;    -- fail, mutual recursion via s.b. views
! ERROR:  infinite recursion detected in row-security policy for relation "rec1"
! --
! -- recursive RLS and VIEWs in policy
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE s1 (a int, b text);
! INSERT INTO s1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
! CREATE TABLE s2 (x int, y text);
! INSERT INTO s2 (SELECT x, md5(x::text) FROM generate_series(-6,6) x);
! GRANT SELECT ON s1, s2 TO rls_regress_user1;
! CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
! CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
! CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
! ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW v2 AS SELECT * FROM s2 WHERE y like '%af%';
! SELECT * FROM s1 WHERE f_leak(b); -- fail (infinite recursion)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! INSERT INTO s1 VALUES (1, 'foo'); -- fail (infinite recursion)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! SET SESSION AUTHORIZATION rls_regress_user0;
! DROP POLICY p3 on s1;
! ALTER POLICY p2 ON s2 USING (x % 2 = 0);
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- OK
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
!  a |                b                 
! ---+----------------------------------
!  2 | c81e728d9d4c2f636f067f89cc14862c
!  4 | a87ff679a2f3e71d9181a67b7542122c
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on s1
!    Filter: f_leak(s1.b)
!    ->  Hash Join
!          Hash Cond: (s1_1.a = s2.x)
!          ->  Seq Scan on s1 s1_1
!          ->  Hash
!                ->  HashAggregate
!                      Group Key: s2.x
!                      ->  Subquery Scan on s2
!                            Filter: (s2.y ~~ '%2f%'::text)
!                            ->  Seq Scan on s2 s2_1
!                                  Filter: ((x % 2) = 0)
! (12 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p1 ON s1 USING (a in (select x from v2)); -- using VIEW in RLS policy
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- OK
! NOTICE:  f_leak => 0267aaf632e87a63288a08331f22c7c3
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
!  a  |                b                 
! ----+----------------------------------
!  -4 | 0267aaf632e87a63288a08331f22c7c3
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on s1
!    Filter: f_leak(s1.b)
!    ->  Hash Join
!          Hash Cond: (s1_1.a = s2.x)
!          ->  Seq Scan on s1 s1_1
!          ->  Hash
!                ->  HashAggregate
!                      Group Key: s2.x
!                      ->  Subquery Scan on s2
!                            Filter: (s2.y ~~ '%af%'::text)
!                            ->  Seq Scan on s2 s2_1
!                                  Filter: ((x % 2) = 0)
! (12 rows)
! 
! SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
!  xx | x  |                y                 
! ----+----+----------------------------------
!  -6 | -6 | 596a3d04481816330f07e4f97510c28f
!  -4 | -4 | 0267aaf632e87a63288a08331f22c7c3
!   2 |  2 | c81e728d9d4c2f636f067f89cc14862c
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Subquery Scan on s2
!    Filter: (s2.y ~~ '%28%'::text)
!    ->  Seq Scan on s2 s2_1
!          Filter: ((x % 2) = 0)
!    SubPlan 1
!      ->  Limit
!            ->  Subquery Scan on s1
!                  ->  Nested Loop Semi Join
!                        Join Filter: (s1_1.a = s2_2.x)
!                        ->  Seq Scan on s1 s1_1
!                        ->  Materialize
!                              ->  Subquery Scan on s2_2
!                                    Filter: (s2_2.y ~~ '%af%'::text)
!                                    ->  Seq Scan on s2 s2_3
!                                          Filter: ((x % 2) = 0)
! (15 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM s1 WHERE f_leak(b);	-- fail (infinite recursion via view)
! ERROR:  infinite recursion detected in row-security policy for relation "s1"
! -- prepared statement with rls_regress_user0 privilege
! PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
! EXECUTE p1(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p1(2);
!                   QUERY PLAN                  
! ----------------------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a <= 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t2
!          Filter: ((a <= 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t3
!          Filter: ((a <= 2) AND ((a % 2) = 0))
! (7 rows)
! 
! -- superuser is allowed to bypass RLS checks
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => def
! NOTICE:  f_leak => xxx
! NOTICE:  f_leak => yyy
! NOTICE:  f_leak => zzz
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
!  1 | abc
!  2 | bcd
!  3 | cde
!  4 | def
!  1 | xxx
!  2 | yyy
!  3 | zzz
! (11 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
!         QUERY PLAN         
! ---------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: f_leak(b)
!    ->  Seq Scan on t2
!          Filter: f_leak(b)
!    ->  Seq Scan on t3
!          Filter: f_leak(b)
! (7 rows)
! 
! -- plan cache should be invalidated
! EXECUTE p1(2);
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  1 | abc
!  2 | bcd
!  1 | xxx
!  2 | yyy
! (6 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p1(2);
!         QUERY PLAN        
! --------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: (a <= 2)
!    ->  Seq Scan on t2
!          Filter: (a <= 2)
!    ->  Seq Scan on t3
!          Filter: (a <= 2)
! (7 rows)
! 
! PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
! EXECUTE p2(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p2(2);
!        QUERY PLAN        
! -------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: (a = 2)
!    ->  Seq Scan on t2
!          Filter: (a = 2)
!    ->  Seq Scan on t3
!          Filter: (a = 2)
! (7 rows)
! 
! -- also, case when privilege switch from superuser
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! EXECUTE p2(2);
!  a |  b  
! ---+-----
!  2 | bbb
!  2 | bcd
!  2 | yyy
! (3 rows)
! 
! EXPLAIN (COSTS OFF) EXECUTE p2(2);
!                  QUERY PLAN                  
! ---------------------------------------------
!  Append
!    ->  Seq Scan on t1
!          Filter: ((a = 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t2
!          Filter: ((a = 2) AND ((a % 2) = 0))
!    ->  Seq Scan on t3
!          Filter: ((a = 2) AND ((a % 2) = 0))
! (7 rows)
! 
! --
! -- UPDATE / DELETE and Row-level security
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Update on t1 t1_3
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_4
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_1
!          Filter: f_leak(t1_1.b)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_2
!          Filter: f_leak(t1_2.b)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (13 rows)
! 
! UPDATE t1 SET b = b || b WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => yyy
! EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Update on t1 t1_1
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_2
!                Filter: ((a % 2) = 0)
! (5 rows)
! 
! UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
! NOTICE:  f_leak => bbbbbb
! NOTICE:  f_leak => dddddd
! -- returning clause with system column
! UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
! (2 rows)
! 
! UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  a |      b      
! ---+-------------
!  2 | bbbbbb_updt
!  4 | dddddd_updt
!  2 | bcdbcd
!  4 | defdef
!  2 | yyyyyy
! (5 rows)
! 
! UPDATE t1 SET b = b WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
!  202 | 2 | bcdbcd      | (2,bcdbcd)
!  204 | 4 | defdef      | (4,defdef)
!  302 | 2 | yyyyyy      | (2,yyyyyy)
! (5 rows)
! 
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! SELECT * FROM t1;
!  a |      b      
! ---+-------------
!  1 | aaa
!  3 | ccc
!  2 | bbbbbb_updt
!  4 | dddddd_updt
!  1 | abc
!  3 | cde
!  2 | bcdbcd
!  4 | defdef
!  1 | xxx
!  3 | zzz
!  2 | yyyyyy
! (11 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Delete on t1 t1_1
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_2
!                Filter: ((a % 2) = 0)
! (5 rows)
! 
! EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
!              QUERY PLAN              
! -------------------------------------
!  Delete on t1 t1_3
!    ->  Subquery Scan on t1
!          Filter: f_leak(t1.b)
!          ->  Seq Scan on t1 t1_4
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_1
!          Filter: f_leak(t1_1.b)
!          ->  Seq Scan on t2
!                Filter: ((a % 2) = 0)
!    ->  Subquery Scan on t1_2
!          Filter: f_leak(t1_2.b)
!          ->  Seq Scan on t3
!                Filter: ((a % 2) = 0)
! (13 rows)
! 
! DELETE FROM only t1 WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bbbbbb_updt
! NOTICE:  f_leak => dddddd_updt
!  oid | a |      b      |       t1        
! -----+---+-------------+-----------------
!  102 | 2 | bbbbbb_updt | (2,bbbbbb_updt)
!  104 | 4 | dddddd_updt | (4,dddddd_updt)
! (2 rows)
! 
! DELETE FROM t1 WHERE f_leak(b) RETURNING oid, *, t1;
! NOTICE:  f_leak => bcdbcd
! NOTICE:  f_leak => defdef
! NOTICE:  f_leak => yyyyyy
!  oid | a |   b    |     t1     
! -----+---+--------+------------
!  202 | 2 | bcdbcd | (2,bcdbcd)
!  204 | 4 | defdef | (4,defdef)
!  302 | 2 | yyyyyy | (2,yyyyyy)
! (3 rows)
! 
! --
! -- ROLE/GROUP
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE z1 (a int, b text);
! GRANT SELECT ON z1 TO rls_regress_group1, rls_regress_group2,
!     rls_regress_user1, rls_regress_user2;
! INSERT INTO z1 VALUES
!     (1, 'aaa'),
!     (2, 'bbb'),
!     (3, 'ccc'),
!     (4, 'ddd');
! CREATE POLICY p1 ON z1 TO rls_regress_group1 USING (a % 2 = 0);
! CREATE POLICY p2 ON z1 TO rls_regress_group2 USING (a % 2 = 1);
! ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET ROLE rls_regress_group1;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => ccc
!  a |  b  
! ---+-----
!  1 | aaa
!  3 | ccc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 1)
! (4 rows)
! 
! SET ROLE rls_regress_group2;
! SELECT * FROM z1 WHERE f_leak(b);
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => ccc
!  a |  b  
! ---+-----
!  1 | aaa
!  3 | ccc
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 1)
! (4 rows)
! 
! --
! -- Views should follow policy for view owner.
! --
! -- View and Table owner are the same.
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
! GRANT SELECT ON rls_view TO rls_regress_user1;
! -- Query as role that is not owner of view or table.  Should return all records.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!      QUERY PLAN      
! ---------------------
!  Seq Scan on z1
!    Filter: f_leak(b)
! (2 rows)
! 
! -- Query as view/table owner.  Should return all records.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => aaa
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ccc
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  1 | aaa
!  2 | bbb
!  3 | ccc
!  4 | ddd
! (4 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!      QUERY PLAN      
! ---------------------
!  Seq Scan on z1
!    Filter: f_leak(b)
! (2 rows)
! 
! DROP VIEW rls_view;
! -- View and Table owners are different.
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
! GRANT SELECT ON rls_view TO rls_regress_user0;
! -- Query as role that is not owner of view but is owner of table.
! -- Should return records based on view owner policies.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! -- Query as role that is not owner of table but is owner of view.
! -- Should return records based on view owner policies.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! -- Query as role that is not the owner of the table or view without permissions.
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM rls_view; --fail - permission denied.
! ERROR:  permission denied for relation rls_view
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view; --fail - permission denied.
! ERROR:  permission denied for relation rls_view
! -- Query as role that is not the owner of the table or view with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! GRANT SELECT ON rls_view TO rls_regress_user2;
! SELECT * FROM rls_view;
! NOTICE:  f_leak => bbb
! NOTICE:  f_leak => ddd
!  a |  b  
! ---+-----
!  2 | bbb
!  4 | ddd
! (2 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
!           QUERY PLAN           
! -------------------------------
!  Subquery Scan on z1
!    Filter: f_leak(z1.b)
!    ->  Seq Scan on z1 z1_1
!          Filter: ((a % 2) = 0)
! (4 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! DROP VIEW rls_view;
! --
! -- Command specific
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE x1 (a int, b text, c text);
! GRANT ALL ON x1 TO PUBLIC;
! INSERT INTO x1 VALUES
!     (1, 'abc', 'rls_regress_user1'),
!     (2, 'bcd', 'rls_regress_user1'),
!     (3, 'cde', 'rls_regress_user2'),
!     (4, 'def', 'rls_regress_user2'),
!     (5, 'efg', 'rls_regress_user1'),
!     (6, 'fgh', 'rls_regress_user1'),
!     (7, 'fgh', 'rls_regress_user2'),
!     (8, 'fgh', 'rls_regress_user2');
! CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
! CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
! CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
! CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
! CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
! ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => efg
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => fgh
!  a |  b  |         c         
! ---+-----+-------------------
!  1 | abc | rls_regress_user1
!  2 | bcd | rls_regress_user1
!  4 | def | rls_regress_user2
!  5 | efg | rls_regress_user1
!  6 | fgh | rls_regress_user1
!  8 | fgh | rls_regress_user2
! (6 rows)
! 
! UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => abc
! NOTICE:  f_leak => bcd
! NOTICE:  f_leak => def
! NOTICE:  f_leak => efg
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => fgh
!  a |    b     |         c         
! ---+----------+-------------------
!  1 | abc_updt | rls_regress_user1
!  2 | bcd_updt | rls_regress_user1
!  4 | def_updt | rls_regress_user2
!  5 | efg_updt | rls_regress_user1
!  6 | fgh_updt | rls_regress_user1
!  8 | fgh_updt | rls_regress_user2
! (6 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user2;
! SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => bcd_updt
! NOTICE:  f_leak => def_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => fgh_updt
!  a |    b     |         c         
! ---+----------+-------------------
!  2 | bcd_updt | rls_regress_user1
!  3 | cde      | rls_regress_user2
!  4 | def_updt | rls_regress_user2
!  6 | fgh_updt | rls_regress_user1
!  7 | fgh      | rls_regress_user2
!  8 | fgh_updt | rls_regress_user2
! (6 rows)
! 
! UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => cde
! NOTICE:  f_leak => fgh
! NOTICE:  f_leak => bcd_updt
! NOTICE:  f_leak => def_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => fgh_updt
!  a |       b       |         c         
! ---+---------------+-------------------
!  3 | cde_updt      | rls_regress_user2
!  7 | fgh_updt      | rls_regress_user2
!  2 | bcd_updt_updt | rls_regress_user1
!  4 | def_updt_updt | rls_regress_user2
!  6 | fgh_updt_updt | rls_regress_user1
!  8 | fgh_updt_updt | rls_regress_user2
! (6 rows)
! 
! DELETE FROM x1 WHERE f_leak(b) RETURNING *;
! NOTICE:  f_leak => abc_updt
! NOTICE:  f_leak => efg_updt
! NOTICE:  f_leak => cde_updt
! NOTICE:  f_leak => fgh_updt
! NOTICE:  f_leak => bcd_updt_updt
! NOTICE:  f_leak => def_updt_updt
! NOTICE:  f_leak => fgh_updt_updt
! NOTICE:  f_leak => fgh_updt_updt
!  a |       b       |         c         
! ---+---------------+-------------------
!  1 | abc_updt      | rls_regress_user1
!  5 | efg_updt      | rls_regress_user1
!  3 | cde_updt      | rls_regress_user2
!  7 | fgh_updt      | rls_regress_user2
!  2 | bcd_updt_updt | rls_regress_user1
!  4 | def_updt_updt | rls_regress_user2
!  6 | fgh_updt_updt | rls_regress_user1
!  8 | fgh_updt_updt | rls_regress_user2
! (8 rows)
! 
! --
! -- Duplicate Policy Names
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE y1 (a int, b text);
! CREATE TABLE y2 (a int, b text);
! GRANT ALL ON y1, y2 TO rls_regress_user1;
! CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
! CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
! CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);  --fail
! ERROR:  policy "p1" for relation "y1" already exists
! CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);  --OK
! ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
! ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
! --
! -- Expression structure with SBV
! --
! -- Create view as table owner.  RLS should NOT be applied.
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE VIEW rls_sbv WITH (security_barrier) AS
!     SELECT * FROM y1 WHERE f_leak(b);
! EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
!             QUERY PLAN             
! -----------------------------------
!  Seq Scan on y1
!    Filter: (f_leak(b) AND (a = 1))
! (2 rows)
! 
! DROP VIEW rls_sbv;
! -- Create view as role that does not own table.  RLS should be applied.
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE VIEW rls_sbv WITH (security_barrier) AS
!     SELECT * FROM y1 WHERE f_leak(b);
! EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on y1
!    Filter: f_leak(y1.b)
!    ->  Seq Scan on y1 y1_1
!          Filter: ((a = 1) AND ((a > 2) OR ((a % 2) = 0)))
! (4 rows)
! 
! DROP VIEW rls_sbv;
! --
! -- Expression structure
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! INSERT INTO y2 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
! CREATE POLICY p2 ON y2 USING (a % 3 = 0);
! CREATE POLICY p3 ON y2 USING (a % 4 = 0);
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM y2 WHERE f_leak(b);
! NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => eccbc87e4b5ce2fe28308fd9f2a7baf3
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
! NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
! NOTICE:  f_leak => 45c48cce2e2d7fbdea1afc51c7c6ad26
! NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
! NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
! NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
! NOTICE:  f_leak => 9bf31c7ff062936a96d3c8bd1f8f2ff3
! NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
! NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
! NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (14 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Subquery Scan on y2
!    Filter: f_leak(y2.b)
!    ->  Seq Scan on y2 y2_1
!          Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))
! (4 rows)
! 
! --
! -- Plancache invalidate on user change.
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE t1 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table t2
! drop cascades to table t3
! CREATE TABLE t1 (a integer);
! GRANT SELECT ON t1 TO rls_regress_user1, rls_regress_user2;
! CREATE POLICY p1 ON t1 TO rls_regress_user1 USING ((a % 2) = 0);
! CREATE POLICY p2 ON t1 TO rls_regress_user2 USING ((a % 4) = 0);
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! SET ROLE rls_regress_user1;
! PREPARE role_inval AS SELECT * FROM t1;
! EXPLAIN (COSTS OFF) EXECUTE role_inval;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on t1
!    Filter: ((a % 2) = 0)
! (2 rows)
! 
! SET ROLE rls_regress_user2;
! EXPLAIN (COSTS OFF) EXECUTE role_inval;
!        QUERY PLAN        
! -------------------------
!  Seq Scan on t1
!    Filter: ((a % 4) = 0)
! (2 rows)
! 
! --
! -- CTE and RLS
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE t1 CASCADE;
! CREATE TABLE t1 (a integer, b text);
! CREATE POLICY p1 ON t1 USING (a % 2 = 0);
! ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
! GRANT ALL ON t1 TO rls_regress_user1;
! INSERT INTO t1 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
! SET SESSION AUTHORIZATION rls_regress_user1;
! WITH cte1 AS (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
! NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
! NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
! NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
! NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
! NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
! NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
! NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
! NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
! NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
! NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
! NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (11 rows)
! 
! EXPLAIN (COSTS OFF) WITH cte1 AS (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
!               QUERY PLAN               
! ---------------------------------------
!  CTE Scan on cte1
!    CTE cte1
!      ->  Subquery Scan on t1
!            Filter: f_leak(t1.b)
!            ->  Seq Scan on t1 t1_1
!                  Filter: ((a % 2) = 0)
! (6 rows)
! 
! WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1; --fail
! ERROR:  new row violates WITH CHECK OPTION for "t1"
! DETAIL:  Failing row contains (1, cfcd208495d565ef66e7dff9f98764da).
! WITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1; --ok
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
! (11 rows)
! 
! WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1; --fail
! ERROR:  new row violates WITH CHECK OPTION for "t1"
! DETAIL:  Failing row contains (21, Fail).
! WITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1; --ok
!  a  |    b    
! ----+---------
!  20 | Success
! (1 row)
! 
! --
! -- Rename Policy
! --
! RESET SESSION AUTHORIZATION;
! ALTER POLICY p1 ON t1 RENAME TO p1; --fail
! ERROR:  row-policy "p1" for table "t1" already exists
! SELECT rsecpolname, relname
!     FROM pg_rowsecurity rs
!     JOIN pg_class pc ON (pc.oid = rs.rsecrelid)
!     WHERE relname = 't1';
!  rsecpolname | relname 
! -------------+---------
!  p1          | t1
! (1 row)
! 
! ALTER POLICY p1 ON t1 RENAME TO p2; --ok
! SELECT rsecpolname, relname
!     FROM pg_rowsecurity rs
!     JOIN pg_class pc ON (pc.oid = rs.rsecrelid)
!     WHERE relname = 't1';
!  rsecpolname | relname 
! -------------+---------
!  p2          | t1
! (1 row)
! 
! --
! -- Check INSERT SELECT
! --
! SET SESSION AUTHORIZATION rls_regress_user1;
! CREATE TABLE t2 (a integer, b text);
! INSERT INTO t2 (SELECT * FROM t1);
! EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
!           QUERY PLAN           
! -------------------------------
!  Insert on t2
!    ->  Seq Scan on t1
!          Filter: ((a % 2) = 0)
! (3 rows)
! 
! SELECT * FROM t2;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t2;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t2
! (1 row)
! 
! CREATE TABLE t3 AS SELECT * FROM t1;
! SELECT * FROM t3;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! SELECT * INTO t4 FROM t1;
! SELECT * FROM t4;
!  a  |                b                 
! ----+----------------------------------
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (12 rows)
! 
! --
! -- RLS with JOIN
! --
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE TABLE blog (id integer, author text, post text);
! CREATE TABLE comment (blog_id integer, message text);
! GRANT ALL ON blog, comment TO rls_regress_user1;
! CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
! ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
! INSERT INTO blog VALUES
!     (1, 'alice', 'blog #1'),
!     (2, 'bob', 'blog #1'),
!     (3, 'alice', 'blog #2'),
!     (4, 'alice', 'blog #3'),
!     (5, 'john', 'blog #1');
! INSERT INTO comment VALUES
!     (1, 'cool blog'),
!     (1, 'fun blog'),
!     (3, 'crazy blog'),
!     (5, 'what?'),
!     (4, 'insane!'),
!     (2, 'who did it?');
! SET SESSION AUTHORIZATION rls_regress_user1;
! -- Check RLS JOIN with Non-RLS.
! SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   4 | alice  | insane!
!   2 | bob    | who did it?
! (2 rows)
! 
! -- Check Non-RLS JOIN with RLS.
! SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   4 | alice  | insane!
!   2 | bob    | who did it?
! (2 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! CREATE POLICY comment_1 ON comment USING (blog_id < 4);
! ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
! SET SESSION AUTHORIZATION rls_regress_user1;
! -- Check RLS JOIN RLS
! SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   2 | bob    | who did it?
! (1 row)
! 
! SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
!  id | author |   message   
! ----+--------+-------------
!   2 | bob    | who did it?
! (1 row)
! 
! SET SESSION AUTHORIZATION rls_regress_user0;
! DROP TABLE blog, comment;
! --
! -- Default Deny Policy
! --
! RESET SESSION AUTHORIZATION;
! DROP POLICY p2 ON t1;
! ALTER TABLE t1 OWNER TO rls_regress_user0;
! -- Check that default deny does not apply to superuser.
! RESET SESSION AUTHORIZATION;
! SELECT * FROM t1;
!  a  |                b                 
! ----+----------------------------------
!   1 | c4ca4238a0b923820dcc509a6f75849b
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   5 | e4da3b7fbbce2345d7772b0674a318d5
!   7 | 8f14e45fceea167a5a36dedd4bea2543
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  11 | 6512bd43d9caa6e02c990b0a82652dca
!  13 | c51ce410c124a10e0db5e4b97fc2af39
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  17 | 70efdf2ec9b086079795c442636b55fb
!  19 | 1f0e3dad99908345f7439f8ffabdffc4
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (22 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t1
! (1 row)
! 
! -- Check that default deny does not apply to table owner.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM t1;
!  a  |                b                 
! ----+----------------------------------
!   1 | c4ca4238a0b923820dcc509a6f75849b
!   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
!   5 | e4da3b7fbbce2345d7772b0674a318d5
!   7 | 8f14e45fceea167a5a36dedd4bea2543
!   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
!  11 | 6512bd43d9caa6e02c990b0a82652dca
!  13 | c51ce410c124a10e0db5e4b97fc2af39
!  15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
!  17 | 70efdf2ec9b086079795c442636b55fb
!  19 | 1f0e3dad99908345f7439f8ffabdffc4
!   0 | cfcd208495d565ef66e7dff9f98764da
!   2 | c81e728d9d4c2f636f067f89cc14862c
!   4 | a87ff679a2f3e71d9181a67b7542122c
!   6 | 1679091c5a880faf6fb5e6087eb1b2dc
!   8 | c9f0f895fb98ab9159f51fd0297e236d
!  10 | d3d9446802a44259755d38e6d163e820
!  12 | c20ad4d76fe97759aa27a0c99bff6710
!  14 | aab3238922bcc25a6f606eb525ffdc56
!  16 | c74d97b01eae257e44aa9d5bade97baf
!  18 | 6f4922f45568161a8cdf4ad2299f6d23
!  20 | 98f13708210194c475687be6106a3b84
!  20 | Success
! (22 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!    QUERY PLAN   
! ----------------
!  Seq Scan on t1
! (1 row)
! 
! -- Check that default deny does apply to superuser when RLS force.
! SET row_security TO FORCE;
! RESET SESSION AUTHORIZATION;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- Check that default deny does apply to table owner when RLS force.
! SET SESSION AUTHORIZATION rls_regress_user0;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! -- Check that default deny applies to non-owner/non-superuser when RLS on.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO ON;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! SET SESSION AUTHORIZATION rls_regress_user1;
! SELECT * FROM t1;
!  a | b 
! ---+---
! (0 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM t1;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! --
! -- Event Triggers
! --
! RESET SESSION AUTHORIZATION;
! CREATE TABLE event_trigger_test (a integer, b text);
! CREATE OR REPLACE FUNCTION start_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - ddl_command_start', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE OR REPLACE FUNCTION end_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - ddl_command_end', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE OR REPLACE FUNCTION drop_sql_command()
! RETURNS event_trigger AS $$
! BEGIN
! RAISE NOTICE '% - sql_drop', tg_tag;
! END;
! $$ LANGUAGE plpgsql;
! CREATE EVENT TRIGGER start_rls_command ON ddl_command_start
!     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE start_command();
! CREATE EVENT TRIGGER end_rls_command ON ddl_command_end
!     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE end_command();
! CREATE EVENT TRIGGER sql_drop_command ON sql_drop
!     WHEN TAG IN ('DROP POLICY') EXECUTE PROCEDURE drop_sql_command();
! CREATE POLICY p1 ON event_trigger_test USING (FALSE);
! NOTICE:  CREATE POLICY - ddl_command_start
! NOTICE:  CREATE POLICY - ddl_command_end
! ALTER POLICY p1 ON event_trigger_test USING (TRUE);
! NOTICE:  ALTER POLICY - ddl_command_start
! NOTICE:  ALTER POLICY - ddl_command_end
! ALTER POLICY p1 ON event_trigger_test RENAME TO p2;
! NOTICE:  ALTER POLICY - ddl_command_start
! NOTICE:  ALTER POLICY - ddl_command_end
! DROP POLICY p2 ON event_trigger_test;
! NOTICE:  DROP POLICY - ddl_command_start
! NOTICE:  DROP POLICY - sql_drop
! NOTICE:  DROP POLICY - ddl_command_end
! DROP EVENT TRIGGER start_rls_command;
! DROP EVENT TRIGGER end_rls_command;
! DROP EVENT TRIGGER sql_drop_command;
! --
! -- COPY TO/FROM
! --
! RESET SESSION AUTHORIZATION;
! DROP TABLE copy_t CASCADE;
! ERROR:  table "copy_t" does not exist
! CREATE TABLE copy_t (a integer, b text);
! CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
! ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
! GRANT ALL ON copy_t TO rls_regress_user1, rls_regress_exempt_user;
! INSERT INTO copy_t (SELECT x, md5(x::text) FROM generate_series(0,10) x);
! -- Check COPY TO as Superuser/owner.
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - insufficient to bypass rls
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user with permissions and BYPASSRLS
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 1,c4ca4238a0b923820dcc509a6f75849b
! 2,c81e728d9d4c2f636f067f89cc14862c
! 3,eccbc87e4b5ce2fe28308fd9f2a7baf3
! 4,a87ff679a2f3e71d9181a67b7542122c
! 5,e4da3b7fbbce2345d7772b0674a318d5
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 7,8f14e45fceea167a5a36dedd4bea2543
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 9,45c48cce2e2d7fbdea1afc51c7c6ad26
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
! 0,cfcd208495d565ef66e7dff9f98764da
! 2,c81e728d9d4c2f636f067f89cc14862c
! 4,a87ff679a2f3e71d9181a67b7542122c
! 6,1679091c5a880faf6fb5e6087eb1b2dc
! 8,c9f0f895fb98ab9159f51fd0297e236d
! 10,d3d9446802a44259755d38e6d163e820
! -- Check COPY TO as user without permissions.SET row_security TO OFF;
! SET SESSION AUTHORIZATION rls_regress_user2;
! SET row_security TO OFF;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - insufficient to bypass rls
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission denied
! ERROR:  permission denied for relation copy_t
! SET row_security TO FORCE;
! COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission denied
! ERROR:  permission denied for relation copy_t
! -- Check COPY FROM as Superuser/owner.
! RESET SESSION AUTHORIZATION;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY FROM as user with permissions.
! SET SESSION AUTHORIZATION rls_regress_user1;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --fail - insufficient privilege to bypass rls.
! ERROR:  insufficient privilege to bypass row security.
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY TO as user with permissions and BYPASSRLS
! SET SESSION AUTHORIZATION rls_regress_exempt_user;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --ok
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
! ERROR:  COPY FROM not supported with row security.
! HINT:  Use direct INSERT statements instead.
! -- Check COPY FROM as user without permissions.
! SET SESSION AUTHORIZATION rls_regress_user2;
! SET row_security TO OFF;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! SET row_security TO ON;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! SET row_security TO FORCE;
! COPY copy_t FROM STDIN; --fail - permission denied.
! ERROR:  permission denied for relation copy_t
! RESET SESSION AUTHORIZATION;
! DROP TABLE copy_t;
! --
! -- Clean up objects
! --
! RESET SESSION AUTHORIZATION;
! DROP SCHEMA rls_regress_schema CASCADE;
! NOTICE:  drop cascades to 24 other objects
! DETAIL:  drop cascades to function f_leak(text)
! drop cascades to table uaccount
! drop cascades to table category
! drop cascades to table document
! drop cascades to table dependent
! drop cascades to table rec1
! drop cascades to table rec2
! drop cascades to view rec1v
! drop cascades to view rec2v
! drop cascades to table s1
! drop cascades to table s2
! drop cascades to view v2
! drop cascades to table z1
! drop cascades to table x1
! drop cascades to table y1
! drop cascades to table y2
! drop cascades to table t1
! drop cascades to table t2
! drop cascades to table t3
! drop cascades to table t4
! drop cascades to table event_trigger_test
! drop cascades to function start_command()
! drop cascades to function end_command()
! drop cascades to function drop_sql_command()
! DROP USER rls_regress_user0;
! DROP USER rls_regress_user1;
! DROP USER rls_regress_user2;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/alter_generic.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/alter_generic.out	2015-01-26 12:33:25.791031406 +0300
***************
*** 1,681 ****
! --
! -- Test for ALTER some_object {RENAME TO, OWNER TO, SET SCHEMA}
! --
! -- Clean up in case a prior regression run failed
! SET client_min_messages TO 'warning';
! DROP ROLE IF EXISTS regtest_alter_user1;
! DROP ROLE IF EXISTS regtest_alter_user2;
! DROP ROLE IF EXISTS regtest_alter_user3;
! RESET client_min_messages;
! CREATE USER regtest_alter_user3;
! CREATE USER regtest_alter_user2;
! CREATE USER regtest_alter_user1 IN ROLE regtest_alter_user3;
! CREATE SCHEMA alt_nsp1;
! CREATE SCHEMA alt_nsp2;
! GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;
! SET search_path = alt_nsp1, public;
! --
! -- Function and Aggregate
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 + 1';
! CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 - 1';
! CREATE AGGREGATE alt_agg1 (
!   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0
! );
! CREATE AGGREGATE alt_agg2 (
!   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0
! );
! ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER AGGREGATE alt_func1(int) OWNER TO regtest_alter_user3;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;  -- failed (name conflict)
! ERROR:  function alt_func2(integer) already exists in schema "alt_nsp1"
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;  -- OK
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user3;  -- OK
! ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OK
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict)
! ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp1"
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OK
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user3;  -- OK
! ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 + 2';
! CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
!   AS 'SELECT $1 - 2';
! CREATE AGGREGATE alt_agg1 (
!   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100
! );
! CREATE AGGREGATE alt_agg2 (
!   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100
! );
! ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;	-- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func1(int) RENAME TO alt_func4;	-- OK
! ALTER FUNCTION alt_func3(int) OWNER TO regtest_alter_user2;	-- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user3;	-- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;      -- failed (not owner)
! ERROR:  must be owner of function alt_func3
! ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;	-- failed (name conflicts)
! ERROR:  function alt_func2(integer) already exists in schema "alt_nsp2"
! ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;   -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;   -- OK
! ALTER AGGREGATE alt_agg3(int) OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg2(int) OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
! ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, proname, prorettype::regtype, proisagg, a.rolname
!   FROM pg_proc p, pg_namespace n, pg_authid a
!   WHERE p.pronamespace = n.oid AND p.proowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, proname;
!  nspname  |  proname  | prorettype | proisagg |       rolname       
! ----------+-----------+------------+----------+---------------------
!  alt_nsp1 | alt_agg2  | integer    | t        | regtest_alter_user2
!  alt_nsp1 | alt_agg3  | integer    | t        | regtest_alter_user1
!  alt_nsp1 | alt_agg4  | integer    | t        | regtest_alter_user2
!  alt_nsp1 | alt_func2 | integer    | f        | regtest_alter_user2
!  alt_nsp1 | alt_func3 | integer    | f        | regtest_alter_user1
!  alt_nsp1 | alt_func4 | integer    | f        | regtest_alter_user2
!  alt_nsp2 | alt_agg2  | integer    | t        | regtest_alter_user3
!  alt_nsp2 | alt_func2 | integer    | f        | regtest_alter_user3
! (8 rows)
! 
! --
! -- We would test collations here, but it's not possible because the error
! -- messages tend to be nonportable.
! --
! --
! -- Conversion
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;  -- failed (name conflict)
! ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp1"
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;  -- OK
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user3;  -- OK
! ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;  -- OK
! ALTER CONVERSION alt_conv3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
! ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, c.conname, a.rolname
!   FROM pg_conversion c, pg_namespace n, pg_authid a
!   WHERE c.connamespace = n.oid AND c.conowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, conname;
!  nspname  |  conname  |       rolname       
! ----------+-----------+---------------------
!  alt_nsp1 | alt_conv2 | regtest_alter_user2
!  alt_nsp1 | alt_conv3 | regtest_alter_user1
!  alt_nsp1 | alt_conv4 | regtest_alter_user2
!  alt_nsp2 | alt_conv2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Foreign Data Wrapper and Foreign Server
! --
! CREATE FOREIGN DATA WRAPPER alt_fdw1;
! CREATE FOREIGN DATA WRAPPER alt_fdw2;
! CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
! CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
! ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict)
! ERROR:  foreign-data wrapper "alt_fdw2" already exists
! ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OK
! ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict)
! ERROR:  server "alt_fserv2" already exists
! ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OK
! SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
!  fdwname  
! ----------
!  alt_fdw2
!  alt_fdw3
! (2 rows)
! 
! SELECT srvname FROM pg_foreign_server WHERE srvname like 'alt_fserv%';
!   srvname   
! ------------
!  alt_fserv2
!  alt_fserv3
! (2 rows)
! 
! --
! -- Procedural Language
! --
! CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
! CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler;
! ALTER LANGUAGE alt_lang1 OWNER TO regtest_alter_user1;  -- OK
! ALTER LANGUAGE alt_lang2 OWNER TO regtest_alter_user2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user1;
! ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;   -- failed (name conflict)
! ERROR:  language "alt_lang2" already exists
! ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;   -- failed (not owner)
! ERROR:  must be owner of language alt_lang2
! ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;   -- OK
! ALTER LANGUAGE alt_lang2 OWNER TO regtest_alter_user3;  -- failed (not owner)
! ERROR:  must be owner of language alt_lang2
! ALTER LANGUAGE alt_lang3 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER LANGUAGE alt_lang3 OWNER TO regtest_alter_user3;  -- OK
! RESET SESSION AUTHORIZATION;
! SELECT lanname, a.rolname
!   FROM pg_language l, pg_authid a
!   WHERE l.lanowner = a.oid AND l.lanname like 'alt_lang%'
!   ORDER BY lanname;
!   lanname  |       rolname       
! -----------+---------------------
!  alt_lang2 | regtest_alter_user2
!  alt_lang3 | regtest_alter_user3
! (2 rows)
! 
! --
! -- Operator
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
! CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;           -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
! ALTER OPERATOR @+@(int4, int4) OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator @+@
! ALTER OPERATOR @-@(int4, int4) OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (not owner)
! ERROR:  must be owner of operator @+@
! -- can't test this: the error message includes the raw oid of namespace
! -- ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (name conflict)
! RESET SESSION AUTHORIZATION;
! SELECT n.nspname, oprname, a.rolname,
!     oprleft::regtype, oprright::regtype, oprcode::regproc
!   FROM pg_operator o, pg_namespace n, pg_authid a
!   WHERE o.oprnamespace = n.oid AND o.oprowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, oprname;
!  nspname  | oprname |       rolname       | oprleft | oprright | oprcode 
! ----------+---------+---------------------+---------+----------+---------
!  alt_nsp1 | @+@     | regtest_alter_user3 | integer | integer  | int4pl
!  alt_nsp1 | @-@     | regtest_alter_user2 | integer | integer  | int4mi
!  alt_nsp2 | @-@     | regtest_alter_user1 | integer | integer  | int4mi
! (3 rows)
! 
! --
! -- OpFamily and OpClass
! --
! CREATE OPERATOR FAMILY alt_opf1 USING hash;
! CREATE OPERATOR FAMILY alt_opf2 USING hash;
! ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regtest_alter_user1;
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user1;
! CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
! CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
! ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regtest_alter_user1;
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user1;
! SET SESSION AUTHORIZATION regtest_alter_user1;
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict)
! ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OK
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OK
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict)
! ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OK
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user3;  -- OK
! ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- OK
! RESET SESSION AUTHORIZATION;
! CREATE OPERATOR FAMILY alt_opf1 USING hash;
! CREATE OPERATOR FAMILY alt_opf2 USING hash;
! ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regtest_alter_user2;
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user2;
! CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
! CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
! ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regtest_alter_user2;
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user2;
! SET SESSION AUTHORIZATION regtest_alter_user2;
! ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OK
! ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
! ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"
! ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OK
! ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
! ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, opfname, amname, rolname
!   FROM pg_opfamily o, pg_am m, pg_namespace n, pg_authid a
!   WHERE o.opfmethod = m.oid AND o.opfnamespace = n.oid AND o.opfowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
! 	AND NOT opfname LIKE 'alt_opc%'
!   ORDER BY nspname, opfname;
!  nspname  | opfname  | amname |       rolname       
! ----------+----------+--------+---------------------
!  alt_nsp1 | alt_opf2 | hash   | regtest_alter_user2
!  alt_nsp1 | alt_opf3 | hash   | regtest_alter_user1
!  alt_nsp1 | alt_opf4 | hash   | regtest_alter_user2
!  alt_nsp2 | alt_opf2 | hash   | regtest_alter_user3
! (4 rows)
! 
! SELECT nspname, opcname, amname, rolname
!   FROM pg_opclass o, pg_am m, pg_namespace n, pg_authid a
!   WHERE o.opcmethod = m.oid AND o.opcnamespace = n.oid AND o.opcowner = a.oid
!     AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, opcname;
!  nspname  | opcname  | amname |       rolname       
! ----------+----------+--------+---------------------
!  alt_nsp1 | alt_opc2 | hash   | regtest_alter_user2
!  alt_nsp1 | alt_opc3 | hash   | regtest_alter_user1
!  alt_nsp1 | alt_opc4 | hash   | regtest_alter_user2
!  alt_nsp2 | alt_opc2 | hash   | regtest_alter_user3
! (4 rows)
! 
! -- ALTER OPERATOR FAMILY ... ADD/DROP
! -- Should work. Textbook case of CREATE / ALTER ADD / ALTER DROP / DROP
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf4 USING btree;
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD
!   -- int4 vs int2
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);
! ALTER OPERATOR FAMILY alt_opf4 USING btree DROP
!   -- int4 vs int2
!   OPERATOR 1 (int4, int2) ,
!   OPERATOR 2 (int4, int2) ,
!   OPERATOR 3 (int4, int2) ,
!   OPERATOR 4 (int4, int2) ,
!   OPERATOR 5 (int4, int2) ,
!   FUNCTION 1 (int4, int2) ;
! DROP OPERATOR FAMILY alt_opf4 USING btree;
! ROLLBACK;
! -- Should fail. Invalid values for ALTER OPERATOR FAMILY .. ADD / DROP
! CREATE OPERATOR FAMILY alt_opf4 USING btree;
! ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2); -- invalid indexing_method
! ERROR:  access method "invalid_index_method" does not exist
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2); -- operator number should be between 1 and 5
! ERROR:  invalid operator number 6, must be between 1 and 5
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2); -- operator number should be between 1 and 5
! ERROR:  invalid operator number 0, must be between 1 and 5
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ; -- operator without argument types
! ERROR:  operator argument types must be specified in ALTER OPERATOR FAMILY
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2); -- function number should be between 1 and 5
! ERROR:  invalid procedure number 0, must be between 1 and 2
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2); -- function number should be between 1 and 5
! ERROR:  invalid procedure number 6, must be between 1 and 2
! ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage; -- Ensure STORAGE is not a part of ALTER OPERATOR FAMILY
! ERROR:  STORAGE cannot be specified in ALTER OPERATOR FAMILY
! DROP OPERATOR FAMILY alt_opf4 USING btree;
! -- Should fail. Need to be SUPERUSER to do ALTER OPERATOR FAMILY .. ADD / DROP
! BEGIN TRANSACTION;
! CREATE ROLE regtest_alter_user5 NOSUPERUSER;
! CREATE OPERATOR FAMILY alt_opf5 USING btree;
! SET ROLE regtest_alter_user5;
! ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
! ERROR:  must be superuser to alter an operator family
! RESET ROLE;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DROP OPERATOR FAMILY alt_opf5 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. Need rights to namespace for ALTER OPERATOR FAMILY .. ADD / DROP
! BEGIN TRANSACTION;
! CREATE ROLE regtest_alter_user6;
! CREATE SCHEMA alt_nsp6;
! REVOKE ALL ON SCHEMA alt_nsp6 FROM regtest_alter_user6;
! CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
! SET ROLE regtest_alter_user6;
! ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
! ERROR:  permission denied for schema alt_nsp6
! ROLLBACK;
! -- Should fail. Only two arguments required for ALTER OPERATOR FAMILY ... DROP OPERATOR
! CREATE OPERATOR FAMILY alt_opf7 USING btree;
! ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
! ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
! ERROR:  one or two argument types must be specified
! DROP OPERATOR FAMILY alt_opf7 USING btree;
! -- Should work. During ALTER OPERATOR FAMILY ... DROP OPERATOR
! -- when left type is the same as right type, a DROP with only one argument type should work
! CREATE OPERATOR FAMILY alt_opf8 USING btree;
! ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
! DROP OPERATOR FAMILY alt_opf8 USING btree;
! -- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf9 USING gist;
! ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! DROP OPERATOR FAMILY alt_opf9 USING gist;
! -- Should fail. Ensure correct ordering methods in ALTER OPERATOR FAMILY ... ADD OPERATOR .. FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf10 USING btree;
! ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! ERROR:  access method "btree" does not support ordering operators
! DROP OPERATOR FAMILY alt_opf10 USING btree;
! -- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
! CREATE OPERATOR FAMILY alt_opf11 USING gist;
! ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
! ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
! DROP OPERATOR FAMILY alt_opf11 USING gist;
! -- Should fail. btree comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf12 USING btree;
! CREATE FUNCTION fn_opf12  (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
! ERROR:  btree comparison procedures must return integer
! DROP OPERATOR FAMILY alt_opf12 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. hash comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf13 USING hash;
! CREATE FUNCTION fn_opf13  (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
! ERROR:  hash procedures must return integer
! DROP OPERATOR FAMILY alt_opf13 USING hash;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. btree comparison functions should have two arguments in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf14 USING btree;
! CREATE FUNCTION fn_opf14 (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
! ERROR:  btree comparison procedures must have two arguments
! DROP OPERATOR FAMILY alt_opf14 USING btree;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. hash comparison functions should have one argument in ALTER OPERATOR FAMILY ... ADD FUNCTION
! BEGIN TRANSACTION;
! CREATE OPERATOR FAMILY alt_opf15 USING hash;
! CREATE FUNCTION fn_opf15 (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
! ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
! ERROR:  hash procedures must have one argument
! DROP OPERATOR FAMILY alt_opf15 USING hash;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Should fail. In gist throw an error when giving different data types for function argument
! -- without defining left / right type in ALTER OPERATOR FAMILY ... ADD FUNCTION
! CREATE OPERATOR FAMILY alt_opf16 USING gist;
! ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
! ERROR:  associated data types must be specified for index support procedure
! DROP OPERATOR FAMILY alt_opf16 USING gist;
! -- Should fail. duplicate operator number / function number in ALTER OPERATOR FAMILY ... ADD FUNCTION
! CREATE OPERATOR FAMILY alt_opf17 USING btree;
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4); -- operator # appears twice in same statment
! ERROR:  operator number 1 for (integer,integer) appears more than once
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested first-time
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested again in separate statement
! ERROR:  operator 1(integer,integer) already exists in operator family "alt_opf17"
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears twice in same statement
! ERROR:  procedure number 1 for (integer,smallint) appears more than once
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears first time
! ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 requested again in separate statement
! ERROR:  operator 1(integer,smallint) already exists in operator family "alt_opf17"
! DROP OPERATOR FAMILY alt_opf17 USING btree;
! -- Should fail. Ensure that DROP requests for missing OPERATOR / FUNCTIONS
! -- return appropriate message in ALTER OPERATOR FAMILY ... DROP OPERATOR / FUNCTION
! CREATE OPERATOR FAMILY alt_opf18 USING btree;
! ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
! ERROR:  operator 1(integer,integer) does not exist in operator family "alt_opf18"
! ALTER OPERATOR FAMILY alt_opf18 USING btree ADD
!   OPERATOR 1 < (int4, int2) ,
!   OPERATOR 2 <= (int4, int2) ,
!   OPERATOR 3 = (int4, int2) ,
!   OPERATOR 4 >= (int4, int2) ,
!   OPERATOR 5 > (int4, int2) ,
!   FUNCTION 1 btint42cmp(int4, int2);
! ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
! ERROR:  function 2(integer,integer) does not exist in operator family "alt_opf18"
! DROP OPERATOR FAMILY alt_opf18 USING btree;
! --
! -- Text Search Dictionary
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;  -- failed (name conflict)
! ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user3;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
! CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;  -- OK
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
! ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, dictname, rolname
!   FROM pg_ts_dict t, pg_namespace n, pg_authid a
!   WHERE t.dictnamespace = n.oid AND t.dictowner = a.oid
!     AND n.nspname in ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, dictname;
!  nspname  |   dictname   |       rolname       
! ----------+--------------+---------------------
!  alt_nsp1 | alt_ts_dict2 | regtest_alter_user2
!  alt_nsp1 | alt_ts_dict3 | regtest_alter_user1
!  alt_nsp1 | alt_ts_dict4 | regtest_alter_user2
!  alt_nsp2 | alt_ts_dict2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Text Search Configuration
! --
! SET SESSION AUTHORIZATION regtest_alter_user1;
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict)
! ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user2;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user2"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user3;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- OK
! SET SESSION AUTHORIZATION regtest_alter_user2;
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
! CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OK
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regtest_alter_user2;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regtest_alter_user3;  -- failed (no role membership)
! ERROR:  must be member of role "regtest_alter_user3"
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
! ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- failed (name conflict)
! ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp2"
! RESET SESSION AUTHORIZATION;
! SELECT nspname, cfgname, rolname
!   FROM pg_ts_config t, pg_namespace n, pg_authid a
!   WHERE t.cfgnamespace = n.oid AND t.cfgowner = a.oid
!     AND n.nspname in ('alt_nsp1', 'alt_nsp2')
!   ORDER BY nspname, cfgname;
!  nspname  |   cfgname    |       rolname       
! ----------+--------------+---------------------
!  alt_nsp1 | alt_ts_conf2 | regtest_alter_user2
!  alt_nsp1 | alt_ts_conf3 | regtest_alter_user1
!  alt_nsp1 | alt_ts_conf4 | regtest_alter_user2
!  alt_nsp2 | alt_ts_conf2 | regtest_alter_user3
! (4 rows)
! 
! --
! -- Text Search Template
! --
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2; -- failed (name conflict)
! ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3; -- OK
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- OK
! CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
! ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- failed (name conflict)
! ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp2"
! SELECT nspname, tmplname
!   FROM pg_ts_template t, pg_namespace n
!   WHERE t.tmplnamespace = n.oid AND nspname like 'alt_nsp%'
!   ORDER BY nspname, tmplname;
!  nspname  |   tmplname   
! ----------+--------------
!  alt_nsp1 | alt_ts_temp2
!  alt_nsp1 | alt_ts_temp3
!  alt_nsp2 | alt_ts_temp2
! (3 rows)
! 
! --
! -- Text Search Parser
! --
! CREATE TEXT SEARCH PARSER alt_ts_prs1
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! CREATE TEXT SEARCH PARSER alt_ts_prs2
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2; -- failed (name conflict)
! ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"
! ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3; -- OK
! ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- OK
! CREATE TEXT SEARCH PARSER alt_ts_prs2
!     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- failed (name conflict)
! ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp2"
! SELECT nspname, prsname
!   FROM pg_ts_parser t, pg_namespace n
!   WHERE t.prsnamespace = n.oid AND nspname like 'alt_nsp%'
!   ORDER BY nspname, prsname;
!  nspname  |   prsname   
! ----------+-------------
!  alt_nsp1 | alt_ts_prs2
!  alt_nsp1 | alt_ts_prs3
!  alt_nsp2 | alt_ts_prs2
! (3 rows)
! 
! ---
! --- Cleanup resources
! ---
! DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
! NOTICE:  drop cascades to server alt_fserv2
! DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
! NOTICE:  drop cascades to server alt_fserv3
! DROP LANGUAGE alt_lang2 CASCADE;
! DROP LANGUAGE alt_lang3 CASCADE;
! DROP LANGUAGE alt_lang4 CASCADE;
! ERROR:  language "alt_lang4" does not exist
! DROP SCHEMA alt_nsp1 CASCADE;
! NOTICE:  drop cascades to 26 other objects
! DETAIL:  drop cascades to function alt_func3(integer)
! drop cascades to function alt_agg3(integer)
! drop cascades to function alt_func4(integer)
! drop cascades to function alt_func2(integer)
! drop cascades to function alt_agg4(integer)
! drop cascades to function alt_agg2(integer)
! drop cascades to conversion alt_conv3
! drop cascades to conversion alt_conv4
! drop cascades to conversion alt_conv2
! drop cascades to operator @+@(integer,integer)
! drop cascades to operator @-@(integer,integer)
! drop cascades to operator family alt_opf3 for access method hash
! drop cascades to operator family alt_opc1 for access method hash
! drop cascades to operator family alt_opc2 for access method hash
! drop cascades to operator family alt_opf4 for access method hash
! drop cascades to operator family alt_opf2 for access method hash
! drop cascades to text search dictionary alt_ts_dict3
! drop cascades to text search dictionary alt_ts_dict4
! drop cascades to text search dictionary alt_ts_dict2
! drop cascades to text search configuration alt_ts_conf3
! drop cascades to text search configuration alt_ts_conf4
! drop cascades to text search configuration alt_ts_conf2
! drop cascades to text search template alt_ts_temp3
! drop cascades to text search template alt_ts_temp2
! drop cascades to text search parser alt_ts_prs3
! drop cascades to text search parser alt_ts_prs2
! DROP SCHEMA alt_nsp2 CASCADE;
! NOTICE:  drop cascades to 9 other objects
! DETAIL:  drop cascades to function alt_nsp2.alt_func2(integer)
! drop cascades to function alt_nsp2.alt_agg2(integer)
! drop cascades to conversion alt_conv2
! drop cascades to operator alt_nsp2.@-@(integer,integer)
! drop cascades to operator family alt_nsp2.alt_opf2 for access method hash
! drop cascades to text search dictionary alt_ts_dict2
! drop cascades to text search configuration alt_ts_conf2
! drop cascades to text search template alt_ts_temp2
! drop cascades to text search parser alt_ts_prs2
! DROP USER regtest_alter_user1;
! DROP USER regtest_alter_user2;
! DROP USER regtest_alter_user3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/misc.out	2015-01-26 12:33:13.755030777 +0300
--- /home/orion/postgres/src/test/regress/results/misc.out	2015-01-26 12:33:25.787031406 +0300
***************
*** 1,843 ****
! --
! -- MISC
! --
! --
! -- BTREE
! --
! UPDATE onek
!    SET unique1 = onek.unique1 + 1;
! UPDATE onek
!    SET unique1 = onek.unique1 - 1;
! --
! -- BTREE partial
! --
! -- UPDATE onek2
! --   SET unique1 = onek2.unique1 + 1;
! --UPDATE onek2
! --   SET unique1 = onek2.unique1 - 1;
! --
! -- BTREE shutting out non-functional updates
! --
! -- the following two tests seem to take a long time on some
! -- systems.    This non-func update stuff needs to be examined
! -- more closely.  			- jolly (2/22/96)
! --
! UPDATE tmp
!    SET stringu1 = reverse_name(onek.stringu1)
!    FROM onek
!    WHERE onek.stringu1 = 'JBAAAA' and
! 	  onek.stringu1 = tmp.stringu1;
! UPDATE tmp
!    SET stringu1 = reverse_name(onek2.stringu1)
!    FROM onek2
!    WHERE onek2.stringu1 = 'JCAAAA' and
! 	  onek2.stringu1 = tmp.stringu1;
! DROP TABLE tmp;
! --UPDATE person*
! --   SET age = age + 1;
! --UPDATE person*
! --   SET age = age + 3
! --   WHERE name = 'linda';
! --
! -- copy
! --
! COPY onek TO '/home/orion/postgres/src/test/regress/results/onek.data';
! DELETE FROM onek;
! COPY onek FROM '/home/orion/postgres/src/test/regress/results/onek.data';
! SELECT unique1 FROM onek WHERE unique1 < 2 ORDER BY unique1;
!  unique1 
! ---------
!        0
!        1
! (2 rows)
! 
! DELETE FROM onek2;
! COPY onek2 FROM '/home/orion/postgres/src/test/regress/results/onek.data';
! SELECT unique1 FROM onek2 WHERE unique1 < 2 ORDER BY unique1;
!  unique1 
! ---------
!        0
!        1
! (2 rows)
! 
! COPY BINARY stud_emp TO '/home/orion/postgres/src/test/regress/results/stud_emp.data';
! DELETE FROM stud_emp;
! COPY BINARY stud_emp FROM '/home/orion/postgres/src/test/regress/results/stud_emp.data';
! SELECT * FROM stud_emp;
!  name  | age |  location  | salary | manager | gpa | percent 
! -------+-----+------------+--------+---------+-----+---------
!  jeff  |  23 | (8,7.7)    |    600 | sharon  | 3.5 |        
!  cim   |  30 | (10.5,4.7) |    400 |         | 3.4 |        
!  linda |  19 | (0.9,6.1)  |    100 |         | 2.9 |        
! (3 rows)
! 
! -- COPY aggtest FROM stdin;
! -- 56	7.8
! -- 100	99.097
! -- 0	0.09561
! -- 42	324.78
! -- .
! -- COPY aggtest TO stdout;
! --
! -- inheritance stress test
! --
! SELECT * FROM a_star*;
!  class | a  
! -------+----
!  a     |  1
!  a     |  2
!  a     |   
!  b     |  3
!  b     |  4
!  b     |   
!  b     |   
!  c     |  5
!  c     |  6
!  c     |   
!  c     |   
!  d     |  7
!  d     |  8
!  d     |  9
!  d     | 10
!  d     |   
!  d     | 11
!  d     | 12
!  d     | 13
!  d     |   
!  d     |   
!  d     |   
!  d     | 14
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  e     | 15
!  e     | 16
!  e     | 17
!  e     |   
!  e     | 18
!  e     |   
!  e     |   
!  f     | 19
!  f     | 20
!  f     | 21
!  f     | 22
!  f     |   
!  f     | 24
!  f     | 25
!  f     | 26
!  f     |   
!  f     |   
!  f     |   
!  f     | 27
!  f     |   
!  f     |   
!  f     |   
!  f     |   
! (50 rows)
! 
! SELECT *
!    FROM b_star* x
!    WHERE x.b = text 'bumble' or x.a < 3;
!  class | a |   b    
! -------+---+--------
!  b     |   | bumble
! (1 row)
! 
! SELECT class, a
!    FROM c_star* x
!    WHERE x.c ~ text 'hi';
!  class | a  
! -------+----
!  c     |  5
!  c     |   
!  d     |  7
!  d     |  8
!  d     | 10
!  d     |   
!  d     | 12
!  d     |   
!  d     |   
!  d     |   
!  e     | 15
!  e     | 16
!  e     |   
!  e     |   
!  f     | 19
!  f     | 20
!  f     | 21
!  f     |   
!  f     | 24
!  f     |   
!  f     |   
!  f     |   
! (22 rows)
! 
! SELECT class, b, c
!    FROM d_star* x
!    WHERE x.a < 100;
!  class |    b    |     c      
! -------+---------+------------
!  d     | grumble | hi sunita
!  d     | stumble | hi koko
!  d     | rumble  | 
!  d     |         | hi kristin
!  d     | fumble  | 
!  d     |         | hi avi
!  d     |         | 
!  d     |         | 
! (8 rows)
! 
! SELECT class, c FROM e_star* x WHERE x.c NOTNULL;
!  class |      c      
! -------+-------------
!  e     | hi carol
!  e     | hi bob
!  e     | hi michelle
!  e     | hi elisa
!  f     | hi claire
!  f     | hi mike
!  f     | hi marcel
!  f     | hi keith
!  f     | hi marc
!  f     | hi allison
!  f     | hi jeff
!  f     | hi carl
! (12 rows)
! 
! SELECT * FROM f_star* x WHERE x.c ISNULL;
!  class | a  | c |  e  |                     f                     
! -------+----+---+-----+-------------------------------------------
!  f     | 22 |   |  -7 | ((111,555),(222,666),(333,777),(444,888))
!  f     | 25 |   |  -9 | 
!  f     | 26 |   |     | ((11111,33333),(22222,44444))
!  f     |    |   | -11 | ((1111111,3333333),(2222222,4444444))
!  f     | 27 |   |     | 
!  f     |    |   | -12 | 
!  f     |    |   |     | ((11111111,33333333),(22222222,44444444))
!  f     |    |   |     | 
! (8 rows)
! 
! -- grouping and aggregation on inherited sets have been busted in the past...
! SELECT sum(a) FROM a_star*;
!  sum 
! -----
!  355
! (1 row)
! 
! SELECT class, sum(a) FROM a_star* GROUP BY class ORDER BY class;
!  class | sum 
! -------+-----
!  a     |   3
!  b     |   7
!  c     |  11
!  d     |  84
!  e     |  66
!  f     | 184
! (6 rows)
! 
! ALTER TABLE f_star RENAME COLUMN f TO ff;
! ALTER TABLE e_star* RENAME COLUMN e TO ee;
! ALTER TABLE d_star* RENAME COLUMN d TO dd;
! ALTER TABLE c_star* RENAME COLUMN c TO cc;
! ALTER TABLE b_star* RENAME COLUMN b TO bb;
! ALTER TABLE a_star* RENAME COLUMN a TO aa;
! SELECT class, aa
!    FROM a_star* x
!    WHERE aa ISNULL;
!  class | aa 
! -------+----
!  a     |   
!  b     |   
!  b     |   
!  c     |   
!  c     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  d     |   
!  e     |   
!  e     |   
!  e     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
!  f     |   
! (24 rows)
! 
! -- As of Postgres 7.1, ALTER implicitly recurses,
! -- so this should be same as ALTER a_star*
! ALTER TABLE a_star RENAME COLUMN aa TO foo;
! SELECT class, foo
!    FROM a_star* x
!    WHERE x.foo >= 2;
!  class | foo 
! -------+-----
!  a     |   2
!  b     |   3
!  b     |   4
!  c     |   5
!  c     |   6
!  d     |   7
!  d     |   8
!  d     |   9
!  d     |  10
!  d     |  11
!  d     |  12
!  d     |  13
!  d     |  14
!  e     |  15
!  e     |  16
!  e     |  17
!  e     |  18
!  f     |  19
!  f     |  20
!  f     |  21
!  f     |  22
!  f     |  24
!  f     |  25
!  f     |  26
!  f     |  27
! (25 rows)
! 
! ALTER TABLE a_star RENAME COLUMN foo TO aa;
! SELECT *
!    from a_star*
!    WHERE aa < 1000;
!  class | aa 
! -------+----
!  a     |  1
!  a     |  2
!  b     |  3
!  b     |  4
!  c     |  5
!  c     |  6
!  d     |  7
!  d     |  8
!  d     |  9
!  d     | 10
!  d     | 11
!  d     | 12
!  d     | 13
!  d     | 14
!  e     | 15
!  e     | 16
!  e     | 17
!  e     | 18
!  f     | 19
!  f     | 20
!  f     | 21
!  f     | 22
!  f     | 24
!  f     | 25
!  f     | 26
!  f     | 27
! (26 rows)
! 
! ALTER TABLE f_star ADD COLUMN f int4;
! UPDATE f_star SET f = 10;
! ALTER TABLE e_star* ADD COLUMN e int4;
! --UPDATE e_star* SET e = 42;
! SELECT * FROM e_star*;
!  class | aa |     cc      | ee  | e 
! -------+----+-------------+-----+---
!  e     | 15 | hi carol    |  -1 |  
!  e     | 16 | hi bob      |     |  
!  e     | 17 |             |  -2 |  
!  e     |    | hi michelle |  -3 |  
!  e     | 18 |             |     |  
!  e     |    | hi elisa    |     |  
!  e     |    |             |  -4 |  
!  f     | 19 | hi claire   |  -5 |  
!  f     | 20 | hi mike     |  -6 |  
!  f     | 21 | hi marcel   |     |  
!  f     | 22 |             |  -7 |  
!  f     |    | hi keith    |  -8 |  
!  f     | 24 | hi marc     |     |  
!  f     | 25 |             |  -9 |  
!  f     | 26 |             |     |  
!  f     |    | hi allison  | -10 |  
!  f     |    | hi jeff     |     |  
!  f     |    |             | -11 |  
!  f     | 27 |             |     |  
!  f     |    | hi carl     |     |  
!  f     |    |             | -12 |  
!  f     |    |             |     |  
!  f     |    |             |     |  
! (23 rows)
! 
! ALTER TABLE a_star* ADD COLUMN a text;
! NOTICE:  merging definition of column "a" for child "d_star"
! -- That ALTER TABLE should have added TOAST tables.
! SELECT relname, reltoastrelid <> 0 AS has_toast_table
!    FROM pg_class
!    WHERE oid::regclass IN ('a_star', 'c_star')
!    ORDER BY 1;
!  relname | has_toast_table 
! ---------+-----------------
!  a_star  | t
!  c_star  | t
! (2 rows)
! 
! --UPDATE b_star*
! --   SET a = text 'gazpacho'
! --   WHERE aa > 4;
! SELECT class, aa, a FROM a_star*;
!  class | aa | a 
! -------+----+---
!  a     |  1 | 
!  a     |  2 | 
!  a     |    | 
!  b     |  3 | 
!  b     |  4 | 
!  b     |    | 
!  b     |    | 
!  c     |  5 | 
!  c     |  6 | 
!  c     |    | 
!  c     |    | 
!  d     |  7 | 
!  d     |  8 | 
!  d     |  9 | 
!  d     | 10 | 
!  d     |    | 
!  d     | 11 | 
!  d     | 12 | 
!  d     | 13 | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  d     | 14 | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  d     |    | 
!  e     | 15 | 
!  e     | 16 | 
!  e     | 17 | 
!  e     |    | 
!  e     | 18 | 
!  e     |    | 
!  e     |    | 
!  f     | 19 | 
!  f     | 20 | 
!  f     | 21 | 
!  f     | 22 | 
!  f     |    | 
!  f     | 24 | 
!  f     | 25 | 
!  f     | 26 | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
!  f     | 27 | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
!  f     |    | 
! (50 rows)
! 
! --
! -- versions
! --
! --
! -- postquel functions
! --
! --
! -- mike does post_hacking,
! -- joe and sally play basketball, and
! -- everyone else does nothing.
! --
! SELECT p.name, name(p.hobbies) FROM ONLY person p;
!  name  |    name     
! -------+-------------
!  mike  | posthacking
!  joe   | basketball
!  sally | basketball
! (3 rows)
! 
! --
! -- as above, but jeff also does post_hacking.
! --
! SELECT p.name, name(p.hobbies) FROM person* p;
!  name  |    name     
! -------+-------------
!  mike  | posthacking
!  joe   | basketball
!  sally | basketball
!  jeff  | posthacking
! (4 rows)
! 
! --
! -- the next two queries demonstrate how functions generate bogus duplicates.
! -- this is a "feature" ..
! --
! SELECT DISTINCT hobbies_r.name, name(hobbies_r.equipment) FROM hobbies_r
!   ORDER BY 1,2;
!     name     |     name      
! -------------+---------------
!  basketball  | hightops
!  posthacking | advil
!  posthacking | peet's coffee
!  skywalking  | guts
! (4 rows)
! 
! SELECT hobbies_r.name, (hobbies_r.equipment).name FROM hobbies_r;
!     name     |     name      
! -------------+---------------
!  posthacking | advil
!  posthacking | peet's coffee
!  posthacking | advil
!  posthacking | peet's coffee
!  basketball  | hightops
!  basketball  | hightops
!  skywalking  | guts
! (7 rows)
! 
! --
! -- mike needs advil and peet's coffee,
! -- joe and sally need hightops, and
! -- everyone else is fine.
! --
! SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM ONLY person p;
!  name  |    name     |     name      
! -------+-------------+---------------
!  mike  | posthacking | advil
!  mike  | posthacking | peet's coffee
!  joe   | basketball  | hightops
!  sally | basketball  | hightops
! (4 rows)
! 
! --
! -- as above, but jeff needs advil and peet's coffee as well.
! --
! SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM person* p;
!  name  |    name     |     name      
! -------+-------------+---------------
!  mike  | posthacking | advil
!  mike  | posthacking | peet's coffee
!  joe   | basketball  | hightops
!  sally | basketball  | hightops
!  jeff  | posthacking | advil
!  jeff  | posthacking | peet's coffee
! (6 rows)
! 
! --
! -- just like the last two, but make sure that the target list fixup and
! -- unflattening is being done correctly.
! --
! SELECT name(equipment(p.hobbies)), p.name, name(p.hobbies) FROM ONLY person p;
!      name      | name  |    name     
! ---------------+-------+-------------
!  advil         | mike  | posthacking
!  peet's coffee | mike  | posthacking
!  hightops      | joe   | basketball
!  hightops      | sally | basketball
! (4 rows)
! 
! SELECT (p.hobbies).equipment.name, p.name, name(p.hobbies) FROM person* p;
!      name      | name  |    name     
! ---------------+-------+-------------
!  advil         | mike  | posthacking
!  peet's coffee | mike  | posthacking
!  hightops      | joe   | basketball
!  hightops      | sally | basketball
!  advil         | jeff  | posthacking
!  peet's coffee | jeff  | posthacking
! (6 rows)
! 
! SELECT (p.hobbies).equipment.name, name(p.hobbies), p.name FROM ONLY person p;
!      name      |    name     | name  
! ---------------+-------------+-------
!  advil         | posthacking | mike
!  peet's coffee | posthacking | mike
!  hightops      | basketball  | joe
!  hightops      | basketball  | sally
! (4 rows)
! 
! SELECT name(equipment(p.hobbies)), name(p.hobbies), p.name FROM person* p;
!      name      |    name     | name  
! ---------------+-------------+-------
!  advil         | posthacking | mike
!  peet's coffee | posthacking | mike
!  hightops      | basketball  | joe
!  hightops      | basketball  | sally
!  advil         | posthacking | jeff
!  peet's coffee | posthacking | jeff
! (6 rows)
! 
! SELECT user_relns() AS user_relns
!    ORDER BY user_relns;
!      user_relns      
! ---------------------
!  a
!  a_star
!  abstime_tbl
!  aggtest
!  aggtype
!  array_index_op_test
!  array_op_test
!  arrtest
!  b
!  b_star
!  bb
!  box_tbl
!  bprime
!  brinopers
!  brintest
!  bt_f8_heap
!  bt_i4_heap
!  bt_name_heap
!  bt_txt_heap
!  btree_tall_tbl
!  c
!  c_star
!  char_tbl
!  check2_tbl
!  check_seq
!  check_tbl
!  circle_tbl
!  city
!  copy_tbl
!  d
!  d_star
!  date_tbl
!  default_seq
!  default_tbl
!  defaultexpr_tbl
!  dept
!  dupindexcols
!  e_star
!  emp
!  equipment_r
!  f_star
!  fast_emp4000
!  float4_tbl
!  float8_tbl
!  func_index_heap
!  gin_test_tbl
!  gist_point_tbl
!  hash_f8_heap
!  hash_i4_heap
!  hash_name_heap
!  hash_txt_heap
!  hobbies_r
!  iexit
!  ihighway
!  inet_tbl
!  inhf
!  inhx
!  insert_seq
!  insert_tbl
!  int2_tbl
!  int4_tbl
!  int8_tbl
!  interval_tbl
!  iportaltest
!  kd_point_tbl
!  line_tbl
!  log_table
!  lseg_tbl
!  main_table
!  money_data
!  num_data
!  num_exp_add
!  num_exp_div
!  num_exp_ln
!  num_exp_log10
!  num_exp_mul
!  num_exp_power_10_ln
!  num_exp_sqrt
!  num_exp_sub
!  num_input_test
!  num_result
!  onek
!  onek2
!  path_tbl
!  person
!  point_tbl
!  polygon_tbl
!  quad_point_tbl
!  radix_text_tbl
!  ramp
!  random_tbl
!  real_city
!  reltime_tbl
!  road
!  shighway
!  slow_emp4000
!  spgist_point_tbl
!  spgist_text_tbl
!  street
!  stud_emp
!  student
!  subselect_tbl
!  t
!  tenk1
!  tenk2
!  test_range_excl
!  test_range_gist
!  test_range_spgist
!  test_tsvector
!  testjsonb
!  text_tbl
!  time_tbl
!  timestamp_tbl
!  timestamptz_tbl
!  timetz_tbl
!  tinterval_tbl
!  tm
!  tmm
!  toyemp
!  tv
!  tvm
!  tvmm
!  tvv
!  tvvm
!  tvvmv
!  varchar_tbl
!  xacttest
! (127 rows)
! 
! SELECT name(equipment(hobby_construct(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1a(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1b(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_1c(hobby_construct_named(text 'skywalking', text 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_2a(text 'skywalking'));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT name(equipment_named_ambiguous_2b(text 'skywalking'));
!      name      
! ---------------
!  advil
!  peet's coffee
!  hightops
!  guts
! (4 rows)
! 
! SELECT hobbies_by_name('basketball');
!  hobbies_by_name 
! -----------------
!  joe
! (1 row)
! 
! SELECT name, overpaid(emp.*) FROM emp;
!   name  | overpaid 
! --------+----------
!  sharon | t
!  sam    | t
!  bill   | t
!  jeff   | f
!  cim    | f
!  linda  | f
! (6 rows)
! 
! --
! -- Try a few cases with SQL-spec row constructor expressions
! --
! SELECT * FROM equipment(ROW('skywalking', 'mer'));
!  name |   hobby    
! ------+------------
!  guts | skywalking
! (1 row)
! 
! SELECT name(equipment(ROW('skywalking', 'mer')));
!  name 
! ------
!  guts
! (1 row)
! 
! SELECT *, name(equipment(h.*)) FROM hobbies_r h;
!     name     | person |     name      
! -------------+--------+---------------
!  posthacking | mike   | advil
!  posthacking | mike   | peet's coffee
!  posthacking | jeff   | advil
!  posthacking | jeff   | peet's coffee
!  basketball  | joe    | hightops
!  basketball  | sally  | hightops
!  skywalking  |        | guts
! (7 rows)
! 
! SELECT *, (equipment(CAST((h.*) AS hobbies_r))).name FROM hobbies_r h;
!     name     | person |     name      
! -------------+--------+---------------
!  posthacking | mike   | advil
!  posthacking | mike   | peet's coffee
!  posthacking | jeff   | advil
!  posthacking | jeff   | peet's coffee
!  basketball  | joe    | hightops
!  basketball  | sally  | hightops
!  skywalking  |        | guts
! (7 rows)
! 
! --
! -- check that old-style C functions work properly with TOASTed values
! --
! create table oldstyle_test(i int4, t text);
! insert into oldstyle_test values(null,null);
! insert into oldstyle_test values(0,'12');
! insert into oldstyle_test values(1000,'12');
! insert into oldstyle_test values(0, repeat('x', 50000));
! select i, length(t), octet_length(t), oldstyle_length(i,t) from oldstyle_test;
!   i   | length | octet_length | oldstyle_length 
! ------+--------+--------------+-----------------
!       |        |              |                
!     0 |      2 |            2 |               2
!  1000 |      2 |            2 |            1002
!     0 |  50000 |        50000 |           50000
! (4 rows)
! 
! drop table oldstyle_test;
! --
! -- functional joins
! --
! --
! -- instance rules
! --
! --
! -- rewrite rules
! --
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/psql.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/psql.out	2015-01-26 12:33:25.787031406 +0300
***************
*** 1,2127 ****
! --
! -- Tests for psql features that aren't closely connected to any
! -- specific server features
! --
! -- \gset
! select 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_
! \echo :pref01_test01 :pref01_test02 :pref01_test03
! 10 20 Hello
! -- should fail: bad variable name
! select 10 as "bad name"
! \gset
! could not set variable "bad name"
! -- multiple backslash commands in one line
! select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
! 1
! select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
! 3
! 4
! select 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_y
!  x | y 
! ---+---
!  5 | 6
! (1 row)
! 
! 5 6
! select 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y
!  x | y 
! ---+---
!  7 | 8
! (1 row)
! 
! 7 8
! -- NULL should unset the variable
! \set var2 xyz
! select 1 as var1, NULL as var2, 3 as var3 \gset
! \echo :var1 :var2 :var3
! 1 :var2 3
! -- \gset requires just one tuple
! select 10 as test01, 20 as test02 from generate_series(1,3) \gset
! more than one row returned for \gset
! select 10 as test01, 20 as test02 from generate_series(1,0) \gset
! no rows returned for \gset
! -- \gset should work in FETCH_COUNT mode too
! \set FETCH_COUNT 1
! select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
! 1
! select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
! 3
! 4
! select 10 as test01, 20 as test02 from generate_series(1,3) \gset
! more than one row returned for \gset
! select 10 as test01, 20 as test02 from generate_series(1,0) \gset
! no rows returned for \gset
! \unset FETCH_COUNT
! -- show all pset options
! \pset
! border                   1
! columns                  0
! expanded                 off
! fieldsep                 '|'
! fieldsep_zero            off
! footer                   on
! format                   aligned
! linestyle                ascii
! null                     ''
! numericlocale            off
! pager                    1
! recordsep                '\n'
! recordsep_zero           off
! tableattr                
! title                    
! tuples_only              off
! unicode_border_linestyle single
! unicode_column_linestyle single
! unicode_header_linestyle single
! -- test multi-line headers, wrapping, and newline indicators
! prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab
! 
! c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
! bc" from generate_series(1,10) as n(n) group by n>1 ;
! \pset linestyle ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!          ab         +        a         +
!                     +        bc         
!          c                              
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                +yyyyyyyyyyyyyyyy  +
! xxxxxx              +yyyyyyyyyyyyyy    +
! xxxxxxxx            +yyyyyyyyyyyy      +
! xxxxxxxxxx          +yyyyyyyyyy        +
! xxxxxxxxxxxx        +yyyyyyyy          +
! xxxxxxxxxxxxxx      +yyyyyy            +
! xxxxxxxxxxxxxxxx    +yyyy              +
! xxxxxxxxxxxxxxxxxx  +yy                +
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!          ab         +        a         +
!                     +        bc         
!          c                              
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                +yyyyyyyyyyyyyyyy  +
! xxxxxx              +yyyyyyyyyyyyyy    +
! xxxxxxxx            +yyyyyyyyyyyy      +
! xxxxxxxxxx          +yyyyyyyyyy        +
! xxxxxxxxxxxx        +yyyyyyyy          +
! xxxxxxxxxxxxxx      +yyyyyy            +
! xxxxxxxxxxxxxxxx    +yyyy              +
! xxxxxxxxxxxxxxxxxx  +yy                +
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!           ab         +|         a         +
!                      +|         bc         
!           c           |                    
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                +| yyyyyyyyyyyyyyyy  +
!  xxxxxx              +| yyyyyyyyyyyyyy    +
!  xxxxxxxx            +| yyyyyyyyyyyy      +
!  xxxxxxxxxx          +| yyyyyyyyyy        +
!  xxxxxxxxxxxx        +| yyyyyyyy          +
!  xxxxxxxxxxxxxx      +| yyyyyy            +
!  xxxxxxxxxxxxxxxx    +| yyyy              +
!  xxxxxxxxxxxxxxxxxx  +| yy                +
!  xxxxxxxxxxxxxxxxxxxx | 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!         ab        +|         a         +
!                   +|         bc         
!          c         |                    
! -------------------+--------------------
!  xx                | yyyyyyyyyyyyyyyyyy
!  xxxx             +| yyyyyyyyyyyyyyyy  +
!  xxxxxx           +| yyyyyyyyyyyyyy    +
!  xxxxxxxx         +| yyyyyyyyyyyy      +
!  xxxxxxxxxx       +| yyyyyyyyyy        +
!  xxxxxxxxxxxx     +| yyyyyyyy          +
!  xxxxxxxxxxxxxx   +| yyyyyy            +
!  xxxxxxxxxxxxxxxx +| yyyy              +
!  xxxxxxxxxxxxxxxxx.| yy                +
! .x                +| 
!  xxxxxxxxxxxxxxxxx.| 
! .xxx               | 
! (2 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |          ab         +|         a         +|
! |                     +|         bc         |
! |          c           |                    |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                +| yyyyyyyyyyyyyyyy  +|
! | xxxxxx              +| yyyyyyyyyyyyyy    +|
! | xxxxxxxx            +| yyyyyyyyyyyy      +|
! | xxxxxxxxxx          +| yyyyyyyyyy        +|
! | xxxxxxxxxxxx        +| yyyyyyyy          +|
! | xxxxxxxxxxxxxx      +| yyyyyy            +|
! | xxxxxxxxxxxxxxxx    +| yyyy              +|
! | xxxxxxxxxxxxxxxxxx  +| yy                +|
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (2 rows)
! 
! \pset format wrapped
! execute q;
! +-----------------+--------------------+
! |       ab       +|         a         +|
! |                +|         bc         |
! |        c        |                    |
! +-----------------+--------------------+
! | xx              | yyyyyyyyyyyyyyyyyy |
! | xxxx           +| yyyyyyyyyyyyyyyy  +|
! | xxxxxx         +| yyyyyyyyyyyyyy    +|
! | xxxxxxxx       +| yyyyyyyyyyyy      +|
! | xxxxxxxxxx     +| yyyyyyyyyy        +|
! | xxxxxxxxxxxx   +| yyyyyyyy          +|
! | xxxxxxxxxxxxxx +| yyyyyy            +|
! | xxxxxxxxxxxxxxx.| yyyy              +|
! |.x              +| yy                +|
! | xxxxxxxxxxxxxxx.|                    |
! |.xxx            +|                    |
! | xxxxxxxxxxxxxxx.|                    |
! |.xxxxx           |                    |
! +-----------------+--------------------+
! (2 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! * Record 1            
! ab+ xx
!   +
! c  
! a + yyyyyyyyyyyyyyyyyy
! bc 
! * Record 2            
! ab+ xxxx                +
!   + xxxxxx              +
! c   xxxxxxxx            +
!     xxxxxxxxxx          +
!     xxxxxxxxxxxx        +
!     xxxxxxxxxxxxxx      +
!     xxxxxxxxxxxxxxxx    +
!     xxxxxxxxxxxxxxxxxx  +
!     xxxxxxxxxxxxxxxxxxxx
! a + yyyyyyyyyyyyyyyy    +
! bc  yyyyyyyyyyyyyy      +
!     yyyyyyyyyyyy        +
!     yyyyyyyyyy          +
!     yyyyyyyy            +
!     yyyyyy              +
!     yyyy                +
!     yy                  +
!     
! 
! \pset format wrapped
! execute q;
! * Record 1       
! ab+ xx
!   +
! c  
! a + yyyyyyyyyyyyyyy.
! bc .yyy
! * Record 2       
! ab+ xxxx           +
!   + xxxxxx         +
! c   xxxxxxxx       +
!     xxxxxxxxxx     +
!     xxxxxxxxxxxx   +
!     xxxxxxxxxxxxxx +
!     xxxxxxxxxxxxxxx.
!    .x              +
!     xxxxxxxxxxxxxxx.
!    .xxx            +
!     xxxxxxxxxxxxxxx.
!    .xxxxx
! a + yyyyyyyyyyyyyyy.
! bc .y              +
!     yyyyyyyyyyyyyy +
!     yyyyyyyyyyyy   +
!     yyyyyyyyyy     +
!     yyyyyyyy       +
!     yyyyyy         +
!     yyyy           +
!     yy             +
!     
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! -[ RECORD 1 ]------------
! ab+| xx
!   +|
! c  |
! a +| yyyyyyyyyyyyyyyyyy
! bc |
! -[ RECORD 2 ]------------
! ab+| xxxx                +
!   +| xxxxxx              +
! c  | xxxxxxxx            +
!    | xxxxxxxxxx          +
!    | xxxxxxxxxxxx        +
!    | xxxxxxxxxxxxxx      +
!    | xxxxxxxxxxxxxxxx    +
!    | xxxxxxxxxxxxxxxxxx  +
!    | xxxxxxxxxxxxxxxxxxxx
! a +| yyyyyyyyyyyyyyyy    +
! bc | yyyyyyyyyyyyyy      +
!    | yyyyyyyyyyyy        +
!    | yyyyyyyyyy          +
!    | yyyyyyyy            +
!    | yyyyyy              +
!    | yyyy                +
!    | yy                  +
!    | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]------
! ab+| xx
!   +|
! c  |
! a +| yyyyyyyyyyyyyy.
! bc |.yyyy
! -[ RECORD 2 ]------
! ab+| xxxx          +
!   +| xxxxxx        +
! c  | xxxxxxxx      +
!    | xxxxxxxxxx    +
!    | xxxxxxxxxxxx  +
!    | xxxxxxxxxxxxxx+
!    | xxxxxxxxxxxxxx.
!    |.xx            +
!    | xxxxxxxxxxxxxx.
!    |.xxxx          +
!    | xxxxxxxxxxxxxx.
!    |.xxxxxx
! a +| yyyyyyyyyyyyyy.
! bc |.yy            +
!    | yyyyyyyyyyyyyy+
!    | yyyyyyyyyyyy  +
!    | yyyyyyyyyy    +
!    | yyyyyyyy      +
!    | yyyyyy        +
!    | yyyy          +
!    | yy            +
!    | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]--------------+
! | ab+| xx                   |
! |   +|                      |
! | c  |                      |
! | a +| yyyyyyyyyyyyyyyyyy   |
! | bc |                      |
! +-[ RECORD 2 ]--------------+
! | ab+| xxxx                +|
! |   +| xxxxxx              +|
! | c  | xxxxxxxx            +|
! |    | xxxxxxxxxx          +|
! |    | xxxxxxxxxxxx        +|
! |    | xxxxxxxxxxxxxx      +|
! |    | xxxxxxxxxxxxxxxx    +|
! |    | xxxxxxxxxxxxxxxxxx  +|
! |    | xxxxxxxxxxxxxxxxxxxx |
! | a +| yyyyyyyyyyyyyyyy    +|
! | bc | yyyyyyyyyyyyyy      +|
! |    | yyyyyyyyyyyy        +|
! |    | yyyyyyyyyy          +|
! |    | yyyyyyyy            +|
! |    | yyyyyy              +|
! |    | yyyy                +|
! |    | yy                  +|
! |    |                      |
! +----+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+
! | ab+| xx          |
! |   +|             |
! | c  |             |
! | a +| yyyyyyyyyyy.|
! | bc |.yyyyyyy     |
! +-[ RECORD 2 ]-----+
! | ab+| xxxx       +|
! |   +| xxxxxx     +|
! | c  | xxxxxxxx   +|
! |    | xxxxxxxxxx +|
! |    | xxxxxxxxxxx.|
! |    |.x          +|
! |    | xxxxxxxxxxx.|
! |    |.xxx        +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxx      +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxxxx    +|
! |    | xxxxxxxxxxx.|
! |    |.xxxxxxxxx   |
! | a +| yyyyyyyyyyy.|
! | bc |.yyyyy      +|
! |    | yyyyyyyyyyy.|
! |    |.yyy        +|
! |    | yyyyyyyyyyy.|
! |    |.y          +|
! |    | yyyyyyyyyy +|
! |    | yyyyyyyy   +|
! |    | yyyyyy     +|
! |    | yyyy       +|
! |    | yy         +|
! |    |             |
! +----+-------------+
! 
! \pset linestyle old-ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!          ab                  a         
!                     +        bc        
!          c          +                  
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy   
! xxxxxx               yyyyyyyyyyyyyy     
! xxxxxxxx             yyyyyyyyyyyy       
! xxxxxxxxxx           yyyyyyyyyy         
! xxxxxxxxxxxx         yyyyyyyy           
! xxxxxxxxxxxxxx       yyyyyy             
! xxxxxxxxxxxxxxxx     yyyy               
! xxxxxxxxxxxxxxxxxx   yy                 
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!          ab                  a         
!                     +        bc        
!          c          +                  
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy   
! xxxxxx               yyyyyyyyyyyyyy     
! xxxxxxxx             yyyyyyyyyyyy       
! xxxxxxxxxx           yyyyyyyyyy         
! xxxxxxxxxxxx         yyyyyyyy           
! xxxxxxxxxxxxxx       yyyyyy             
! xxxxxxxxxxxxxxxx     yyyy               
! xxxxxxxxxxxxxxxxxx   yy                 
! xxxxxxxxxxxxxxxxxxxx 
! (2 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
!           ab          |         a          
! +                     |+        bc         
! +         c           |+                   
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy   
!  xxxxxx               : yyyyyyyyyyyyyy     
!  xxxxxxxx             : yyyyyyyyyyyy       
!  xxxxxxxxxx           : yyyyyyyyyy         
!  xxxxxxxxxxxx         : yyyyyyyy           
!  xxxxxxxxxxxxxx       : yyyyyy             
!  xxxxxxxxxxxxxxxx     : yyyy               
!  xxxxxxxxxxxxxxxxxx   : yy                 
!  xxxxxxxxxxxxxxxxxxxx : 
! (2 rows)
! 
! \pset format wrapped
! execute q;
!         ab         |         a          
! +                  |+        bc         
! +        c         |+                   
! -------------------+--------------------
!  xx                | yyyyyyyyyyyyyyyyyy
!  xxxx              | yyyyyyyyyyyyyyyy   
!  xxxxxx            : yyyyyyyyyyyyyy     
!  xxxxxxxx          : yyyyyyyyyyyy       
!  xxxxxxxxxx        : yyyyyyyyyy         
!  xxxxxxxxxxxx      : yyyyyyyy           
!  xxxxxxxxxxxxxx    : yyyyyy             
!  xxxxxxxxxxxxxxxx  : yyyy               
!  xxxxxxxxxxxxxxxxx : yy                 
!  x                 : 
!  xxxxxxxxxxxxxxxxx   
!  xxx                 
! (2 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|a
! bc
! xx|yyyyyyyyyyyyyyyyyy
! xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! (2 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |          ab          |         a          |
! |+                     |+        bc         |
! |+         c           |+                   |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               : yyyyyyyyyyyyyy     |
! | xxxxxxxx             : yyyyyyyyyyyy       |
! | xxxxxxxxxx           : yyyyyyyyyy         |
! | xxxxxxxxxxxx         : yyyyyyyy           |
! | xxxxxxxxxxxxxx       : yyyyyy             |
! | xxxxxxxxxxxxxxxx     : yyyy               |
! | xxxxxxxxxxxxxxxxxx   : yy                 |
! | xxxxxxxxxxxxxxxxxxxx :                    |
! +----------------------+--------------------+
! (2 rows)
! 
! \pset format wrapped
! execute q;
! +-----------------+--------------------+
! |       ab        |         a          |
! |+                |+        bc         |
! |+       c        |+                   |
! +-----------------+--------------------+
! | xx              | yyyyyyyyyyyyyyyyyy |
! | xxxx            | yyyyyyyyyyyyyyyy   |
! | xxxxxx          : yyyyyyyyyyyyyy     |
! | xxxxxxxx        : yyyyyyyyyyyy       |
! | xxxxxxxxxx      : yyyyyyyyyy         |
! | xxxxxxxxxxxx    : yyyyyyyy           |
! | xxxxxxxxxxxxxx  : yyyyyy             |
! | xxxxxxxxxxxxxxx : yyyy               |
! | x               : yy                 |
! | xxxxxxxxxxxxxxx :                    |
! | xxx                                  |
! | xxxxxxxxxxxxxxx                      |
! | xxxxx                                |
! +-----------------+--------------------+
! (2 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! * Record 1             
!  ab xx
! +  
! +c 
!  a  yyyyyyyyyyyyyyyyyy
! +bc
! * Record 2             
!  ab xxxx
! +   xxxxxx
! +c  xxxxxxxx
!     xxxxxxxxxx
!     xxxxxxxxxxxx
!     xxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxxxxxx
!  a  yyyyyyyyyyyyyyyy
! +bc yyyyyyyyyyyyyy
!     yyyyyyyyyyyy
!     yyyyyyyyyy
!     yyyyyyyy
!     yyyyyy
!     yyyy
!     yy
!     
! 
! \pset format wrapped
! execute q;
! * Record 1         
!  ab xx
! +  
! +c 
!  a  yyyyyyyyyyyyyyyy
! +bc yy
! * Record 2         
!  ab xxxx
! +   xxxxxx
! +c  xxxxxxxx
!     xxxxxxxxxx
!     xxxxxxxxxxxx
!     xxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xxxxxxxxxxxxxxxx
!     xx
!     xxxxxxxxxxxxxxxx
!     xxxx
!  a  yyyyyyyyyyyyyyyy
! +bc yyyyyyyyyyyyyy
!     yyyyyyyyyyyy
!     yyyyyyyyyy
!     yyyyyyyy
!     yyyyyy
!     yyyy
!     yy
!     
! 
! \pset border 1
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! -[ RECORD 1 ]-------------
!  ab | xx
! +   ;
! +c  ;
!  a  | yyyyyyyyyyyyyyyyyy
! +bc ;
! -[ RECORD 2 ]-------------
!  ab | xxxx
! +   : xxxxxx
! +c  : xxxxxxxx
!     : xxxxxxxxxx
!     : xxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxxxxxxxx
!  a  | yyyyyyyyyyyyyyyy
! +bc : yyyyyyyyyyyyyy
!     : yyyyyyyyyyyy
!     : yyyyyyyyyy
!     : yyyyyyyy
!     : yyyyyy
!     : yyyy
!     : yy
!     : 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]-------
!  ab | xx
! +   ;
! +c  ;
!  a  | yyyyyyyyyyyyyy
! +bc ; yyyy
! -[ RECORD 2 ]-------
!  ab | xxxx
! +   : xxxxxx
! +c  : xxxxxxxx
!     : xxxxxxxxxx
!     : xxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     : xxxxxxxxxxxxxx
!     ; xx
!     : xxxxxxxxxxxxxx
!     ; xxxx
!     : xxxxxxxxxxxxxx
!     ; xxxxxx
!  a  | yyyyyyyyyyyyyy
! +bc ; yy
!     : yyyyyyyyyyyyyy
!     : yyyyyyyyyyyy
!     : yyyyyyyyyy
!     : yyyyyyyy
!     : yyyyyy
!     : yyyy
!     : yy
!     : 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! ab
! 
! c|xx
! a
! bc|yyyyyyyyyyyyyyyyyy
! 
! ab
! 
! c|xxxx
! xxxxxx
! xxxxxxxx
! xxxxxxxxxx
! xxxxxxxxxxxx
! xxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxx
! xxxxxxxxxxxxxxxxxxxx
! a
! bc|yyyyyyyyyyyyyyyy
! yyyyyyyyyyyyyy
! yyyyyyyyyyyy
! yyyyyyyyyy
! yyyyyyyy
! yyyyyy
! yyyy
! yy
! 
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]--------------+
! | ab | xx                   |
! |+   ;                      |
! |+c  ;                      |
! | a  | yyyyyyyyyyyyyyyyyy   |
! |+bc ;                      |
! +-[ RECORD 2 ]--------------+
! | ab | xxxx                 |
! |+   : xxxxxx               |
! |+c  : xxxxxxxx             |
! |    : xxxxxxxxxx           |
! |    : xxxxxxxxxxxx         |
! |    : xxxxxxxxxxxxxx       |
! |    : xxxxxxxxxxxxxxxx     |
! |    : xxxxxxxxxxxxxxxxxx   |
! |    : xxxxxxxxxxxxxxxxxxxx |
! | a  | yyyyyyyyyyyyyyyy     |
! |+bc : yyyyyyyyyyyyyy       |
! |    : yyyyyyyyyyyy         |
! |    : yyyyyyyyyy           |
! |    : yyyyyyyy             |
! |    : yyyyyy               |
! |    : yyyy                 |
! |    : yy                   |
! |    :                      |
! +----+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+
! | ab | xx          |
! |+   ;             |
! |+c  ;             |
! | a  | yyyyyyyyyyy |
! |+bc ; yyyyyyy     |
! +-[ RECORD 2 ]-----+
! | ab | xxxx        |
! |+   : xxxxxx      |
! |+c  : xxxxxxxx    |
! |    : xxxxxxxxxx  |
! |    : xxxxxxxxxxx |
! |    ; x           |
! |    : xxxxxxxxxxx |
! |    ; xxx         |
! |    : xxxxxxxxxxx |
! |    ; xxxxx       |
! |    : xxxxxxxxxxx |
! |    ; xxxxxxx     |
! |    : xxxxxxxxxxx |
! |    ; xxxxxxxxx   |
! | a  | yyyyyyyyyyy |
! |+bc ; yyyyy       |
! |    : yyyyyyyyyyy |
! |    ; yyy         |
! |    : yyyyyyyyyyy |
! |    ; y           |
! |    : yyyyyyyyyy  |
! |    : yyyyyyyy    |
! |    : yyyyyy      |
! |    : yyyy        |
! |    : yy          |
! |    :             |
! +----+-------------+
! 
! deallocate q;
! -- test single-line header and data
! prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
! \pset linestyle ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!   0123456789abcdef       0123456789     
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef       0123456789     
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!    0123456789abcdef   |     0123456789     
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy
!  xxxxxx               | yyyyyyyyyyyyyy
!  xxxxxxxx             | yyyyyyyyyyyy
!  xxxxxxxxxx           | yyyyyyyyyy
!  xxxxxxxxxxxx         | yyyyyyyy
!  xxxxxxxxxxxxxx       | yyyyyy
!  xxxxxxxxxxxxxxxx     | yyyy
!  xxxxxxxxxxxxxxxxxx   | yy
!  xxxxxxxxxxxxxxxxxxxx | 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef   |    0123456789    
! ---------------------+------------------
!  xx                  | yyyyyyyyyyyyyyyy.
!                      |.yy
!  xxxx                | yyyyyyyyyyyyyyyy
!  xxxxxx              | yyyyyyyyyyyyyy
!  xxxxxxxx            | yyyyyyyyyyyy
!  xxxxxxxxxx          | yyyyyyyyyy
!  xxxxxxxxxxxx        | yyyyyyyy
!  xxxxxxxxxxxxxx      | yyyyyy
!  xxxxxxxxxxxxxxxx    | yyyy
!  xxxxxxxxxxxxxxxxxx  | yy
!  xxxxxxxxxxxxxxxxxxx.| 
! .x                   | 
! (10 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |   0123456789abcdef   |     0123456789     |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               | yyyyyyyyyyyyyy     |
! | xxxxxxxx             | yyyyyyyyyyyy       |
! | xxxxxxxxxx           | yyyyyyyyyy         |
! | xxxxxxxxxxxx         | yyyyyyyy           |
! | xxxxxxxxxxxxxx       | yyyyyy             |
! | xxxxxxxxxxxxxxxx     | yyyy               |
! | xxxxxxxxxxxxxxxxxx   | yy                 |
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (10 rows)
! 
! \pset format wrapped
! execute q;
! +--------------------+-----------------+
! |  0123456789abcdef  |   0123456789    |
! +--------------------+-----------------+
! | xx                 | yyyyyyyyyyyyyyy.|
! |                    |.yyy             |
! | xxxx               | yyyyyyyyyyyyyyy.|
! |                    |.y               |
! | xxxxxx             | yyyyyyyyyyyyyy  |
! | xxxxxxxx           | yyyyyyyyyyyy    |
! | xxxxxxxxxx         | yyyyyyyyyy      |
! | xxxxxxxxxxxx       | yyyyyyyy        |
! | xxxxxxxxxxxxxx     | yyyyyy          |
! | xxxxxxxxxxxxxxxx   | yyyy            |
! | xxxxxxxxxxxxxxxxxx | yy              |
! | xxxxxxxxxxxxxxxxxx.|                 |
! |.xx                 |                 |
! +--------------------+-----------------+
! (10 rows)
! 
! \pset expanded on
! \pset columns 20
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! * Record 1                          
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                          
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                          
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                          
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                          
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                          
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                          
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                          
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                          
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                         
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset format wrapped
! execute q;
! * Record 1        
! 0123456789abcdef xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 2        
! 0123456789abcdef xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 3        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 4        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 5        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 6        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy.
!                 .yy
! * Record 7        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy.
!                 .yy
! * Record 8        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy.
!                 .yy
! * Record 9        
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       yy
! * Record 10       
! 0123456789abcdef xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx.
!                 .xx
! 0123456789       
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! -[ RECORD 1 ]----+---------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+---------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+---------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+---------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]----+----
! 0123456789abcdef | xx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy
! -[ RECORD 2 ]----+----
! 0123456789abcdef | xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.y
! -[ RECORD 3 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yy
! -[ RECORD 4 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.yyy
! -[ RECORD 5 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yyy.
!                  |.y
! -[ RECORD 6 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx
! 0123456789       | yyy.
!                  |.yyy.
!                  |.yy
! -[ RECORD 7 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | yyy.
!                  |.yyy
! -[ RECORD 8 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.x
! 0123456789       | yyy.
!                  |.y
! -[ RECORD 9 ]----+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx
! 0123456789       | yy
! -[ RECORD 10 ]---+----
! 0123456789abcdef | xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xxx.
!                  |.xx
! 0123456789       | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]-----+----------------------+
! | 0123456789abcdef | xx                   |
! | 0123456789       | yyyyyyyyyyyyyyyyyy   |
! +-[ RECORD 2 ]-----+----------------------+
! | 0123456789abcdef | xxxx                 |
! | 0123456789       | yyyyyyyyyyyyyyyy     |
! +-[ RECORD 3 ]-----+----------------------+
! | 0123456789abcdef | xxxxxx               |
! | 0123456789       | yyyyyyyyyyyyyy       |
! +-[ RECORD 4 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxx             |
! | 0123456789       | yyyyyyyyyyyy         |
! +-[ RECORD 5 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxx           |
! | 0123456789       | yyyyyyyyyy           |
! +-[ RECORD 6 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxx         |
! | 0123456789       | yyyyyyyy             |
! +-[ RECORD 7 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx       |
! | 0123456789       | yyyyyy               |
! +-[ RECORD 8 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx     |
! | 0123456789       | yyyy                 |
! +-[ RECORD 9 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
! | 0123456789       | yy                   |
! +-[ RECORD 10 ]----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
! | 0123456789       |                      |
! +------------------+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+-----+
! | 0123456789abcdef | xx  |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy |
! +-[ RECORD 2 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.y   |
! +-[ RECORD 3 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yy  |
! +-[ RECORD 4 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.yyy |
! +-[ RECORD 5 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yyy.|
! |                  |.y   |
! +-[ RECORD 6 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx |
! | 0123456789       | yyy.|
! |                  |.yyy.|
! |                  |.yy  |
! +-[ RECORD 7 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       | yyy.|
! |                  |.yyy |
! +-[ RECORD 8 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.x   |
! | 0123456789       | yyy.|
! |                  |.y   |
! +-[ RECORD 9 ]-----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx |
! | 0123456789       | yy  |
! +-[ RECORD 10 ]----+-----+
! | 0123456789abcdef | xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xxx.|
! |                  |.xx  |
! | 0123456789       |     |
! +------------------+-----+
! 
! \pset linestyle old-ascii
! \pset expanded off
! \pset columns 40
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!   0123456789abcdef       0123456789    
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef       0123456789    
! -------------------- ------------------
! xx                   yyyyyyyyyyyyyyyyyy
! xxxx                 yyyyyyyyyyyyyyyy
! xxxxxx               yyyyyyyyyyyyyy
! xxxxxxxx             yyyyyyyyyyyy
! xxxxxxxxxx           yyyyyyyyyy
! xxxxxxxxxxxx         yyyyyyyy
! xxxxxxxxxxxxxx       yyyyyy
! xxxxxxxxxxxxxxxx     yyyy
! xxxxxxxxxxxxxxxxxx   yy
! xxxxxxxxxxxxxxxxxxxx 
! (10 rows)
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
!    0123456789abcdef   |     0123456789     
! ----------------------+--------------------
!  xx                   | yyyyyyyyyyyyyyyyyy
!  xxxx                 | yyyyyyyyyyyyyyyy
!  xxxxxx               | yyyyyyyyyyyyyy
!  xxxxxxxx             | yyyyyyyyyyyy
!  xxxxxxxxxx           | yyyyyyyyyy
!  xxxxxxxxxxxx         | yyyyyyyy
!  xxxxxxxxxxxxxx       | yyyyyy
!  xxxxxxxxxxxxxxxx     | yyyy
!  xxxxxxxxxxxxxxxxxx   | yy
!  xxxxxxxxxxxxxxxxxxxx | 
! (10 rows)
! 
! \pset format wrapped
! execute q;
!   0123456789abcdef   |    0123456789    
! ---------------------+------------------
!  xx                  | yyyyyyyyyyyyyyyy 
!                      ; yy
!  xxxx                | yyyyyyyyyyyyyyyy
!  xxxxxx              | yyyyyyyyyyyyyy
!  xxxxxxxx            | yyyyyyyyyyyy
!  xxxxxxxxxx          | yyyyyyyyyy
!  xxxxxxxxxxxx        | yyyyyyyy
!  xxxxxxxxxxxxxx      | yyyyyy
!  xxxxxxxxxxxxxxxx    | yyyy
!  xxxxxxxxxxxxxxxxxx  | yy
!  xxxxxxxxxxxxxxxxxxx | 
!  x                     
! (10 rows)
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|0123456789
! xx|yyyyyyyyyyyyyyyyyy
! xxxx|yyyyyyyyyyyyyyyy
! xxxxxx|yyyyyyyyyyyyyy
! xxxxxxxx|yyyyyyyyyyyy
! xxxxxxxxxx|yyyyyyyyyy
! xxxxxxxxxxxx|yyyyyyyy
! xxxxxxxxxxxxxx|yyyyyy
! xxxxxxxxxxxxxxxx|yyyy
! xxxxxxxxxxxxxxxxxx|yy
! xxxxxxxxxxxxxxxxxxxx|
! (10 rows)
! \pset format aligned
! execute q;
! +----------------------+--------------------+
! |   0123456789abcdef   |     0123456789     |
! +----------------------+--------------------+
! | xx                   | yyyyyyyyyyyyyyyyyy |
! | xxxx                 | yyyyyyyyyyyyyyyy   |
! | xxxxxx               | yyyyyyyyyyyyyy     |
! | xxxxxxxx             | yyyyyyyyyyyy       |
! | xxxxxxxxxx           | yyyyyyyyyy         |
! | xxxxxxxxxxxx         | yyyyyyyy           |
! | xxxxxxxxxxxxxx       | yyyyyy             |
! | xxxxxxxxxxxxxxxx     | yyyy               |
! | xxxxxxxxxxxxxxxxxx   | yy                 |
! | xxxxxxxxxxxxxxxxxxxx |                    |
! +----------------------+--------------------+
! (10 rows)
! 
! \pset format wrapped
! execute q;
! +--------------------+-----------------+
! |  0123456789abcdef  |   0123456789    |
! +--------------------+-----------------+
! | xx                 | yyyyyyyyyyyyyyy |
! |                    ; yyy             |
! | xxxx               | yyyyyyyyyyyyyyy |
! |                    ; y               |
! | xxxxxx             | yyyyyyyyyyyyyy  |
! | xxxxxxxx           | yyyyyyyyyyyy    |
! | xxxxxxxxxx         | yyyyyyyyyy      |
! | xxxxxxxxxxxx       | yyyyyyyy        |
! | xxxxxxxxxxxxxx     | yyyyyy          |
! | xxxxxxxxxxxxxxxx   | yyyy            |
! | xxxxxxxxxxxxxxxxxx | yy              |
! | xxxxxxxxxxxxxxxxxx |                 |
! | xx                                   |
! +--------------------+-----------------+
! (10 rows)
! 
! \pset expanded on
! \pset border 0
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! * Record 1                          
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                          
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                          
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                          
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                          
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                          
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                          
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                          
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                          
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                         
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset format wrapped
! execute q;
! * Record 1                             
! 0123456789abcdef xx
! 0123456789       yyyyyyyyyyyyyyyyyy
! * Record 2                             
! 0123456789abcdef xxxx
! 0123456789       yyyyyyyyyyyyyyyy
! * Record 3                             
! 0123456789abcdef xxxxxx
! 0123456789       yyyyyyyyyyyyyy
! * Record 4                             
! 0123456789abcdef xxxxxxxx
! 0123456789       yyyyyyyyyyyy
! * Record 5                             
! 0123456789abcdef xxxxxxxxxx
! 0123456789       yyyyyyyyyy
! * Record 6                             
! 0123456789abcdef xxxxxxxxxxxx
! 0123456789       yyyyyyyy
! * Record 7                             
! 0123456789abcdef xxxxxxxxxxxxxx
! 0123456789       yyyyyy
! * Record 8                             
! 0123456789abcdef xxxxxxxxxxxxxxxx
! 0123456789       yyyy
! * Record 9                             
! 0123456789abcdef xxxxxxxxxxxxxxxxxx
! 0123456789       yy
! * Record 10                            
! 0123456789abcdef xxxxxxxxxxxxxxxxxxxx
! 0123456789       
! 
! \pset border 1
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! -[ RECORD 1 ]----+---------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+---------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+---------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+---------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+---------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset format wrapped
! execute q;
! -[ RECORD 1 ]----+----------------------
! 0123456789abcdef | xx
! 0123456789       | yyyyyyyyyyyyyyyyyy
! -[ RECORD 2 ]----+----------------------
! 0123456789abcdef | xxxx
! 0123456789       | yyyyyyyyyyyyyyyy
! -[ RECORD 3 ]----+----------------------
! 0123456789abcdef | xxxxxx
! 0123456789       | yyyyyyyyyyyyyy
! -[ RECORD 4 ]----+----------------------
! 0123456789abcdef | xxxxxxxx
! 0123456789       | yyyyyyyyyyyy
! -[ RECORD 5 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxx
! 0123456789       | yyyyyyyyyy
! -[ RECORD 6 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxx
! 0123456789       | yyyyyyyy
! -[ RECORD 7 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxx
! 0123456789       | yyyyyy
! -[ RECORD 8 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxx
! 0123456789       | yyyy
! -[ RECORD 9 ]----+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxx
! 0123456789       | yy
! -[ RECORD 10 ]---+----------------------
! 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
! 0123456789       | 
! 
! \pset border 2
! \pset format unaligned
! execute q;
! 0123456789abcdef|xx
! 0123456789|yyyyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxx
! 0123456789|yyyyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxx
! 0123456789|yyyyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxx
! 0123456789|yyyyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxx
! 0123456789|yyyyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxx
! 0123456789|yyyyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxx
! 0123456789|yyyyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxx
! 0123456789|yyyy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxx
! 0123456789|yy
! 
! 0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
! 0123456789|
! \pset format aligned
! execute q;
! +-[ RECORD 1 ]-----+----------------------+
! | 0123456789abcdef | xx                   |
! | 0123456789       | yyyyyyyyyyyyyyyyyy   |
! +-[ RECORD 2 ]-----+----------------------+
! | 0123456789abcdef | xxxx                 |
! | 0123456789       | yyyyyyyyyyyyyyyy     |
! +-[ RECORD 3 ]-----+----------------------+
! | 0123456789abcdef | xxxxxx               |
! | 0123456789       | yyyyyyyyyyyyyy       |
! +-[ RECORD 4 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxx             |
! | 0123456789       | yyyyyyyyyyyy         |
! +-[ RECORD 5 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxx           |
! | 0123456789       | yyyyyyyyyy           |
! +-[ RECORD 6 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxx         |
! | 0123456789       | yyyyyyyy             |
! +-[ RECORD 7 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx       |
! | 0123456789       | yyyyyy               |
! +-[ RECORD 8 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx     |
! | 0123456789       | yyyy                 |
! +-[ RECORD 9 ]-----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
! | 0123456789       | yy                   |
! +-[ RECORD 10 ]----+----------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
! | 0123456789       |                      |
! +------------------+----------------------+
! 
! \pset format wrapped
! execute q;
! +-[ RECORD 1 ]-----+-------------------+
! | 0123456789abcdef | xx                |
! | 0123456789       | yyyyyyyyyyyyyyyyy |
! |                  ; y                 |
! +-[ RECORD 2 ]-----+-------------------+
! | 0123456789abcdef | xxxx              |
! | 0123456789       | yyyyyyyyyyyyyyyy  |
! +-[ RECORD 3 ]-----+-------------------+
! | 0123456789abcdef | xxxxxx            |
! | 0123456789       | yyyyyyyyyyyyyy    |
! +-[ RECORD 4 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxx          |
! | 0123456789       | yyyyyyyyyyyy      |
! +-[ RECORD 5 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxx        |
! | 0123456789       | yyyyyyyyyy        |
! +-[ RECORD 6 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxx      |
! | 0123456789       | yyyyyyyy          |
! +-[ RECORD 7 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxx    |
! | 0123456789       | yyyyyy            |
! +-[ RECORD 8 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxx  |
! | 0123456789       | yyyy              |
! +-[ RECORD 9 ]-----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxx |
! |                  ; x                 |
! | 0123456789       | yy                |
! +-[ RECORD 10 ]----+-------------------+
! | 0123456789abcdef | xxxxxxxxxxxxxxxxx |
! |                  ; xxx               |
! | 0123456789       |                   |
! +------------------+-------------------+
! 
! deallocate q;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/async.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/async.out	2015-01-26 12:33:25.787031406 +0300
***************
*** 1,34 ****
! --
! -- ASYNC
! --
! --Should work. Send a valid message via a valid channel name
! SELECT pg_notify('notify_async1','sample message1');
!  pg_notify 
! -----------
!  
! (1 row)
! 
! SELECT pg_notify('notify_async1','');
!  pg_notify 
! -----------
!  
! (1 row)
! 
! SELECT pg_notify('notify_async1',NULL);
!  pg_notify 
! -----------
!  
! (1 row)
! 
! -- Should fail. Send a valid message via an invalid channel name
! SELECT pg_notify('','sample message1');
! ERROR:  channel name cannot be empty
! SELECT pg_notify(NULL,'sample message1');
! ERROR:  channel name cannot be empty
! SELECT pg_notify('notify_async_channel_name_too_long______________________________','sample_message1');
! ERROR:  channel name too long
! --Should work. Valid NOTIFY/LISTEN/UNLISTEN commands
! NOTIFY notify_async2;
! LISTEN notify_async2;
! UNLISTEN notify_async2;
! UNLISTEN *;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rules.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/rules.out	2015-01-26 12:33:25.839031409 +0300
***************
*** 1,2681 ****
! --
! -- RULES
! -- From Jan's original setup_ruletest.sql and run_ruletest.sql
! -- - thomas 1998-09-13
! --
! --
! -- Tables and rules for the view test
! --
! create table rtest_t1 (a int4, b int4);
! create table rtest_t2 (a int4, b int4);
! create table rtest_t3 (a int4, b int4);
! create view rtest_v1 as select * from rtest_t1;
! create rule rtest_v1_ins as on insert to rtest_v1 do instead
! 	insert into rtest_t1 values (new.a, new.b);
! create rule rtest_v1_upd as on update to rtest_v1 do instead
! 	update rtest_t1 set a = new.a, b = new.b
! 	where a = old.a;
! create rule rtest_v1_del as on delete to rtest_v1 do instead
! 	delete from rtest_t1 where a = old.a;
! -- Test comments
! COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
! ERROR:  rule "rtest_v1_bad" for relation "rtest_v1" does not exist
! COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
! COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
! --
! -- Tables and rules for the constraint update/delete test
! --
! -- Note:
! -- 	Now that we have multiple action rule support, we check
! -- 	both possible syntaxes to define them (The last action
! --  can but must not have a semicolon at the end).
! --
! create table rtest_system (sysname text, sysdesc text);
! create table rtest_interface (sysname text, ifname text);
! create table rtest_person (pname text, pdesc text);
! create table rtest_admin (pname text, sysname text);
! create rule rtest_sys_upd as on update to rtest_system do also (
! 	update rtest_interface set sysname = new.sysname
! 		where sysname = old.sysname;
! 	update rtest_admin set sysname = new.sysname
! 		where sysname = old.sysname
! 	);
! create rule rtest_sys_del as on delete to rtest_system do also (
! 	delete from rtest_interface where sysname = old.sysname;
! 	delete from rtest_admin where sysname = old.sysname;
! 	);
! create rule rtest_pers_upd as on update to rtest_person do also
! 	update rtest_admin set pname = new.pname where pname = old.pname;
! create rule rtest_pers_del as on delete to rtest_person do also
! 	delete from rtest_admin where pname = old.pname;
! --
! -- Tables and rules for the logging test
! --
! create table rtest_emp (ename char(20), salary money);
! create table rtest_emplog (ename char(20), who name, action char(10), newsal money, oldsal money);
! create table rtest_empmass (ename char(20), salary money);
! create rule rtest_emp_ins as on insert to rtest_emp do
! 	insert into rtest_emplog values (new.ename, current_user,
! 			'hired', new.salary, '0.00');
! create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
! 	insert into rtest_emplog values (new.ename, current_user,
! 			'honored', new.salary, old.salary);
! create rule rtest_emp_del as on delete to rtest_emp do
! 	insert into rtest_emplog values (old.ename, current_user,
! 			'fired', '0.00', old.salary);
! --
! -- Tables and rules for the multiple cascaded qualified instead
! -- rule test
! --
! create table rtest_t4 (a int4, b text);
! create table rtest_t5 (a int4, b text);
! create table rtest_t6 (a int4, b text);
! create table rtest_t7 (a int4, b text);
! create table rtest_t8 (a int4, b text);
! create table rtest_t9 (a int4, b text);
! create rule rtest_t4_ins1 as on insert to rtest_t4
! 		where new.a >= 10 and new.a < 20 do instead
! 	insert into rtest_t5 values (new.a, new.b);
! create rule rtest_t4_ins2 as on insert to rtest_t4
! 		where new.a >= 20 and new.a < 30 do
! 	insert into rtest_t6 values (new.a, new.b);
! create rule rtest_t5_ins as on insert to rtest_t5
! 		where new.a > 15 do
! 	insert into rtest_t7 values (new.a, new.b);
! create rule rtest_t6_ins as on insert to rtest_t6
! 		where new.a > 25 do instead
! 	insert into rtest_t8 values (new.a, new.b);
! --
! -- Tables and rules for the rule fire order test
! --
! -- As of PG 7.3, the rules should fire in order by name, regardless
! -- of INSTEAD attributes or creation order.
! --
! create table rtest_order1 (a int4);
! create table rtest_order2 (a int4, b int4, c text);
! create sequence rtest_seq;
! create rule rtest_order_r3 as on insert to rtest_order1 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 3 - this should run 3rd');
! create rule rtest_order_r4 as on insert to rtest_order1
! 		where a < 100 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 4 - this should run 4th');
! create rule rtest_order_r2 as on insert to rtest_order1 do
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 2 - this should run 2nd');
! create rule rtest_order_r1 as on insert to rtest_order1 do instead
! 	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
! 		'rule 1 - this should run 1st');
! --
! -- Tables and rules for the instead nothing test
! --
! create table rtest_nothn1 (a int4, b text);
! create table rtest_nothn2 (a int4, b text);
! create table rtest_nothn3 (a int4, b text);
! create table rtest_nothn4 (a int4, b text);
! create rule rtest_nothn_r1 as on insert to rtest_nothn1
! 	where new.a >= 10 and new.a < 20 do instead nothing;
! create rule rtest_nothn_r2 as on insert to rtest_nothn1
! 	where new.a >= 30 and new.a < 40 do instead nothing;
! create rule rtest_nothn_r3 as on insert to rtest_nothn2
! 	where new.a >= 100 do instead
! 	insert into rtest_nothn3 values (new.a, new.b);
! create rule rtest_nothn_r4 as on insert to rtest_nothn2
! 	do instead nothing;
! --
! -- Tests on a view that is select * of a table
! -- and has insert/update/delete instead rules to
! -- behave close like the real table.
! --
! --
! -- We need test date later
! --
! insert into rtest_t2 values (1, 21);
! insert into rtest_t2 values (2, 22);
! insert into rtest_t2 values (3, 23);
! insert into rtest_t3 values (1, 31);
! insert into rtest_t3 values (2, 32);
! insert into rtest_t3 values (3, 33);
! insert into rtest_t3 values (4, 34);
! insert into rtest_t3 values (5, 35);
! -- insert values
! insert into rtest_v1 values (1, 11);
! insert into rtest_v1 values (2, 12);
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
!  2 | 12
! (2 rows)
! 
! -- delete with constant expression
! delete from rtest_v1 where a = 1;
! select * from rtest_v1;
!  a | b  
! ---+----
!  2 | 12
! (1 row)
! 
! insert into rtest_v1 values (1, 11);
! delete from rtest_v1 where b = 12;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
! (1 row)
! 
! insert into rtest_v1 values (2, 12);
! insert into rtest_v1 values (2, 13);
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
!  2 | 12
!  2 | 13
! (3 rows)
! 
! ** Remember the delete rule on rtest_v1: It says
! ** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
! ** So this time both rows with a = 2 must get deleted
! \p
! ** Remember the delete rule on rtest_v1: It says
! ** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
! ** So this time both rows with a = 2 must get deleted
! \r
! delete from rtest_v1 where b = 12;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 11
! (1 row)
! 
! delete from rtest_v1;
! -- insert select
! insert into rtest_v1 select * from rtest_t2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! delete from rtest_v1;
! -- same with swapped targetlist
! insert into rtest_v1 (b, a) select b, a from rtest_t2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! -- now with only one target attribute
! insert into rtest_v1 (a) select a from rtest_t3;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
!  1 |   
!  2 |   
!  3 |   
!  4 |   
!  5 |   
! (8 rows)
! 
! select * from rtest_v1 where b isnull;
!  a | b 
! ---+---
!  1 |  
!  2 |  
!  3 |  
!  4 |  
!  5 |  
! (5 rows)
! 
! -- let attribute a differ (must be done on rtest_t1 - see above)
! update rtest_t1 set a = a + 10 where b isnull;
! delete from rtest_v1 where b isnull;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! -- now updates with constant expression
! update rtest_v1 set b = 42 where a = 2;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  3 | 23
!  2 | 42
! (3 rows)
! 
! update rtest_v1 set b = 99 where b = 42;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  3 | 23
!  2 | 99
! (3 rows)
! 
! update rtest_v1 set b = 88 where b < 50;
! select * from rtest_v1;
!  a | b  
! ---+----
!  2 | 99
!  1 | 88
!  3 | 88
! (3 rows)
! 
! delete from rtest_v1;
! insert into rtest_v1 select rtest_t2.a, rtest_t3.b
!     from rtest_t2, rtest_t3
!     where rtest_t2.a = rtest_t3.a;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 31
!  2 | 32
!  3 | 33
! (3 rows)
! 
! -- updates in a mergejoin
! update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
! (3 rows)
! 
! insert into rtest_v1 select * from rtest_t3;
! select * from rtest_v1;
!  a | b  
! ---+----
!  1 | 21
!  2 | 22
!  3 | 23
!  1 | 31
!  2 | 32
!  3 | 33
!  4 | 34
!  5 | 35
! (8 rows)
! 
! update rtest_t1 set a = a + 10 where b > 30;
! select * from rtest_v1;
!  a  | b  
! ----+----
!   1 | 21
!   2 | 22
!   3 | 23
!  11 | 31
!  12 | 32
!  13 | 33
!  14 | 34
!  15 | 35
! (8 rows)
! 
! update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
! select * from rtest_v1;
!  a  | b  
! ----+----
!   1 | 21
!   2 | 22
!   3 | 23
!  21 | 31
!  22 | 32
!  23 | 33
!  24 | 34
!  25 | 35
! (8 rows)
! 
! --
! -- Test for constraint updates/deletes
! --
! insert into rtest_system values ('orion', 'Linux Jan Wieck');
! insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
! insert into rtest_system values ('neptun', 'Fileserver');
! insert into rtest_interface values ('orion', 'eth0');
! insert into rtest_interface values ('orion', 'eth1');
! insert into rtest_interface values ('notjw', 'eth0');
! insert into rtest_interface values ('neptun', 'eth0');
! insert into rtest_person values ('jw', 'Jan Wieck');
! insert into rtest_person values ('bm', 'Bruce Momjian');
! insert into rtest_admin values ('jw', 'orion');
! insert into rtest_admin values ('jw', 'notjw');
! insert into rtest_admin values ('bm', 'neptun');
! update rtest_system set sysname = 'pluto' where sysname = 'neptun';
! select * from rtest_interface;
!  sysname | ifname 
! ---------+--------
!  orion   | eth0
!  orion   | eth1
!  notjw   | eth0
!  pluto   | eth0
! (4 rows)
! 
! select * from rtest_admin;
!  pname | sysname 
! -------+---------
!  jw    | orion
!  jw    | notjw
!  bm    | pluto
! (3 rows)
! 
! update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
! -- Note: use ORDER BY here to ensure consistent output across all systems.
! -- The above UPDATE affects two rows with equal keys, so they could be
! -- updated in either order depending on the whim of the local qsort().
! select * from rtest_admin order by pname, sysname;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
!  jwieck | orion
! (3 rows)
! 
! delete from rtest_system where sysname = 'orion';
! select * from rtest_interface;
!  sysname | ifname 
! ---------+--------
!  notjw   | eth0
!  pluto   | eth0
! (2 rows)
! 
! select * from rtest_admin;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
! (2 rows)
! 
! --
! -- Rule qualification test
! --
! insert into rtest_emp values ('wiecc', '5000.00');
! insert into rtest_emp values ('gates', '80000.00');
! update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
! update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
! update rtest_emp set salary = '7000.00' where ename = 'wieck';
! delete from rtest_emp where ename = 'gates';
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (5 rows)
! 
! insert into rtest_empmass values ('meyer', '4000.00');
! insert into rtest_empmass values ('maier', '5000.00');
! insert into rtest_empmass values ('mayr', '6000.00');
! insert into rtest_emp select * from rtest_empmass;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (8 rows)
! 
! update rtest_empmass set salary = salary + '1000.00';
! update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (11 rows)
! 
! delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
! select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | fired      |      $0.00 |  $6,000.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | fired      |      $0.00 |  $7,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | fired      |      $0.00 |  $5,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (14 rows)
! 
! --
! -- Multiple cascaded qualified instead rule test
! --
! insert into rtest_t4 values (1, 'Record should go to rtest_t4');
! insert into rtest_t4 values (2, 'Record should go to rtest_t4');
! insert into rtest_t4 values (10, 'Record should go to rtest_t5');
! insert into rtest_t4 values (15, 'Record should go to rtest_t5');
! insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
! insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
! insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
! insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
! insert into rtest_t4 values (30, 'Record should go to rtest_t4');
! insert into rtest_t4 values (40, 'Record should go to rtest_t4');
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  20 | Record should go to rtest_t4 and t6
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
!  30 | Record should go to rtest_t4
!  40 | Record should go to rtest_t4
! (7 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a  |                  b                  
! ----+-------------------------------------
!  20 | Record should go to rtest_t4 and t6
! (1 row)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! delete from rtest_t4;
! delete from rtest_t5;
! delete from rtest_t6;
! delete from rtest_t7;
! delete from rtest_t8;
! insert into rtest_t9 values (1, 'Record should go to rtest_t4');
! insert into rtest_t9 values (2, 'Record should go to rtest_t4');
! insert into rtest_t9 values (10, 'Record should go to rtest_t5');
! insert into rtest_t9 values (15, 'Record should go to rtest_t5');
! insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
! insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
! insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
! insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
! insert into rtest_t9 values (30, 'Record should go to rtest_t4');
! insert into rtest_t9 values (40, 'Record should go to rtest_t4');
! insert into rtest_t4 select * from rtest_t9 where a < 20;
! select * from rtest_t4;
!  a |              b               
! ---+------------------------------
!  1 | Record should go to rtest_t4
!  2 | Record should go to rtest_t4
! (2 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a | b 
! ---+---
! (0 rows)
! 
! insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (4 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
! select * from rtest_t4;
!  a  |                  b                  
! ----+-------------------------------------
!   1 | Record should go to rtest_t4
!   2 | Record should go to rtest_t4
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
!  21 | Record should go to rtest_t4 and t6
!  31 | Record should go to rtest_t4
!  41 | Record should go to rtest_t4
! (7 rows)
! 
! select * from rtest_t5;
!  a  |                  b                  
! ----+-------------------------------------
!  10 | Record should go to rtest_t5
!  15 | Record should go to rtest_t5
!  19 | Record should go to rtest_t5 and t7
! (3 rows)
! 
! select * from rtest_t6;
!  a  |                  b                  
! ----+-------------------------------------
!  21 | Record should go to rtest_t4 and t6
! (1 row)
! 
! select * from rtest_t7;
!  a  |                  b                  
! ----+-------------------------------------
!  19 | Record should go to rtest_t5 and t7
! (1 row)
! 
! select * from rtest_t8;
!  a  |                  b                  
! ----+-------------------------------------
!  26 | Record should go to rtest_t4 and t8
!  28 | Record should go to rtest_t4 and t8
! (2 rows)
! 
! --
! -- Check that the ordering of rules fired is correct
! --
! insert into rtest_order1 values (1);
! select * from rtest_order2;
!  a | b |              c               
! ---+---+------------------------------
!  1 | 1 | rule 1 - this should run 1st
!  1 | 2 | rule 2 - this should run 2nd
!  1 | 3 | rule 3 - this should run 3rd
!  1 | 4 | rule 4 - this should run 4th
! (4 rows)
! 
! --
! -- Check if instead nothing w/without qualification works
! --
! insert into rtest_nothn1 values (1, 'want this');
! insert into rtest_nothn1 values (2, 'want this');
! insert into rtest_nothn1 values (10, 'don''t want this');
! insert into rtest_nothn1 values (19, 'don''t want this');
! insert into rtest_nothn1 values (20, 'want this');
! insert into rtest_nothn1 values (29, 'want this');
! insert into rtest_nothn1 values (30, 'don''t want this');
! insert into rtest_nothn1 values (39, 'don''t want this');
! insert into rtest_nothn1 values (40, 'want this');
! insert into rtest_nothn1 values (50, 'want this');
! insert into rtest_nothn1 values (60, 'want this');
! select * from rtest_nothn1;
!  a  |     b     
! ----+-----------
!   1 | want this
!   2 | want this
!  20 | want this
!  29 | want this
!  40 | want this
!  50 | want this
!  60 | want this
! (7 rows)
! 
! insert into rtest_nothn2 values (10, 'too small');
! insert into rtest_nothn2 values (50, 'too small');
! insert into rtest_nothn2 values (100, 'OK');
! insert into rtest_nothn2 values (200, 'OK');
! select * from rtest_nothn2;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_nothn3;
!   a  | b  
! -----+----
!  100 | OK
!  200 | OK
! (2 rows)
! 
! delete from rtest_nothn1;
! delete from rtest_nothn2;
! delete from rtest_nothn3;
! insert into rtest_nothn4 values (1, 'want this');
! insert into rtest_nothn4 values (2, 'want this');
! insert into rtest_nothn4 values (10, 'don''t want this');
! insert into rtest_nothn4 values (19, 'don''t want this');
! insert into rtest_nothn4 values (20, 'want this');
! insert into rtest_nothn4 values (29, 'want this');
! insert into rtest_nothn4 values (30, 'don''t want this');
! insert into rtest_nothn4 values (39, 'don''t want this');
! insert into rtest_nothn4 values (40, 'want this');
! insert into rtest_nothn4 values (50, 'want this');
! insert into rtest_nothn4 values (60, 'want this');
! insert into rtest_nothn1 select * from rtest_nothn4;
! select * from rtest_nothn1;
!  a  |     b     
! ----+-----------
!   1 | want this
!   2 | want this
!  20 | want this
!  29 | want this
!  40 | want this
!  50 | want this
!  60 | want this
! (7 rows)
! 
! delete from rtest_nothn4;
! insert into rtest_nothn4 values (10, 'too small');
! insert into rtest_nothn4 values (50, 'too small');
! insert into rtest_nothn4 values (100, 'OK');
! insert into rtest_nothn4 values (200, 'OK');
! insert into rtest_nothn2 select * from rtest_nothn4;
! select * from rtest_nothn2;
!  a | b 
! ---+---
! (0 rows)
! 
! select * from rtest_nothn3;
!   a  | b  
! -----+----
!  100 | OK
!  200 | OK
! (2 rows)
! 
! create table rtest_view1 (a int4, b text, v bool);
! create table rtest_view2 (a int4);
! create table rtest_view3 (a int4, b text);
! create table rtest_view4 (a int4, b text, c int4);
! create view rtest_vview1 as select a, b from rtest_view1 X
! 	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
! create view rtest_vview2 as select a, b from rtest_view1 where v;
! create view rtest_vview3 as select a, b from rtest_vview2 X
! 	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
! create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
! 	from rtest_view1 X, rtest_view2 Y
! 	where X.a = Y.a
! 	group by X.a, X.b;
! create function rtest_viewfunc1(int4) returns int4 as
! 	'select count(*)::int4 from rtest_view2 where a = $1'
! 	language sql;
! create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
! 	from rtest_view1;
! insert into rtest_view1 values (1, 'item 1', 't');
! insert into rtest_view1 values (2, 'item 2', 't');
! insert into rtest_view1 values (3, 'item 3', 't');
! insert into rtest_view1 values (4, 'item 4', 'f');
! insert into rtest_view1 values (5, 'item 5', 't');
! insert into rtest_view1 values (6, 'item 6', 'f');
! insert into rtest_view1 values (7, 'item 7', 't');
! insert into rtest_view1 values (8, 'item 8', 't');
! insert into rtest_view2 values (2);
! insert into rtest_view2 values (2);
! insert into rtest_view2 values (4);
! insert into rtest_view2 values (5);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! insert into rtest_view2 values (7);
! select * from rtest_vview1;
!  a |   b    
! ---+--------
!  2 | item 2
!  4 | item 4
!  5 | item 5
!  7 | item 7
! (4 rows)
! 
! select * from rtest_vview2;
!  a |   b    
! ---+--------
!  1 | item 1
!  2 | item 2
!  3 | item 3
!  5 | item 5
!  7 | item 7
!  8 | item 8
! (6 rows)
! 
! select * from rtest_vview3;
!  a |   b    
! ---+--------
!  2 | item 2
!  5 | item 5
!  7 | item 7
! (3 rows)
! 
! select * from rtest_vview4 order by a, b;
!  a |   b    | refcount 
! ---+--------+----------
!  2 | item 2 |        2
!  4 | item 4 |        1
!  5 | item 5 |        1
!  7 | item 7 |        4
! (4 rows)
! 
! select * from rtest_vview5;
!  a |   b    | refcount 
! ---+--------+----------
!  1 | item 1 |        0
!  2 | item 2 |        2
!  3 | item 3 |        0
!  4 | item 4 |        1
!  5 | item 5 |        1
!  6 | item 6 |        0
!  7 | item 7 |        4
!  8 | item 8 |        0
! (8 rows)
! 
! insert into rtest_view3 select * from rtest_vview1 where a < 7;
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  2 | item 2
!  4 | item 4
!  5 | item 5
! (3 rows)
! 
! delete from rtest_view3;
! insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  1 | item 1
!  3 | item 3
!  7 | item 7
!  8 | item 8
! (4 rows)
! 
! delete from rtest_view3;
! insert into rtest_view3 select * from rtest_vview3;
! select * from rtest_view3;
!  a |   b    
! ---+--------
!  2 | item 2
!  5 | item 5
!  7 | item 7
! (3 rows)
! 
! delete from rtest_view3;
! insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
! select * from rtest_view4 order by a, b;
!  a |   b    | c 
! ---+--------+---
!  2 | item 2 | 2
!  4 | item 4 | 1
!  5 | item 5 | 1
! (3 rows)
! 
! delete from rtest_view4;
! insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
! select * from rtest_view4;
!  a |   b    | c 
! ---+--------+---
!  3 | item 3 | 0
!  6 | item 6 | 0
!  8 | item 8 | 0
! (3 rows)
! 
! delete from rtest_view4;
! --
! -- Test for computations in views
! --
! create table rtest_comp (
! 	part	text,
! 	unit	char(4),
! 	size	float
! );
! create table rtest_unitfact (
! 	unit	char(4),
! 	factor	float
! );
! create view rtest_vcomp as
! 	select X.part, (X.size * Y.factor) as size_in_cm
! 			from rtest_comp X, rtest_unitfact Y
! 			where X.unit = Y.unit;
! insert into rtest_unitfact values ('m', 100.0);
! insert into rtest_unitfact values ('cm', 1.0);
! insert into rtest_unitfact values ('inch', 2.54);
! insert into rtest_comp values ('p1', 'm', 5.0);
! insert into rtest_comp values ('p2', 'm', 3.0);
! insert into rtest_comp values ('p3', 'cm', 5.0);
! insert into rtest_comp values ('p4', 'cm', 15.0);
! insert into rtest_comp values ('p5', 'inch', 7.0);
! insert into rtest_comp values ('p6', 'inch', 4.4);
! select * from rtest_vcomp order by part;
!  part | size_in_cm 
! ------+------------
!  p1   |        500
!  p2   |        300
!  p3   |          5
!  p4   |         15
!  p5   |      17.78
!  p6   |     11.176
! (6 rows)
! 
! select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
!  part | size_in_cm 
! ------+------------
!  p1   |        500
!  p2   |        300
!  p5   |      17.78
!  p4   |         15
!  p6   |     11.176
! (5 rows)
! 
! --
! -- In addition run the (slightly modified) queries from the
! -- programmers manual section on the rule system.
! --
! CREATE TABLE shoe_data (
! 	shoename   char(10),      -- primary key
! 	sh_avail   integer,       -- available # of pairs
! 	slcolor    char(10),      -- preferred shoelace color
! 	slminlen   float,         -- miminum shoelace length
! 	slmaxlen   float,         -- maximum shoelace length
! 	slunit     char(8)        -- length unit
! );
! CREATE TABLE shoelace_data (
! 	sl_name    char(10),      -- primary key
! 	sl_avail   integer,       -- available # of pairs
! 	sl_color   char(10),      -- shoelace color
! 	sl_len     float,         -- shoelace length
! 	sl_unit    char(8)        -- length unit
! );
! CREATE TABLE unit (
! 	un_name    char(8),       -- the primary key
! 	un_fact    float          -- factor to transform to cm
! );
! CREATE VIEW shoe AS
! 	SELECT sh.shoename,
! 		   sh.sh_avail,
! 		   sh.slcolor,
! 		   sh.slminlen,
! 		   sh.slminlen * un.un_fact AS slminlen_cm,
! 		   sh.slmaxlen,
! 		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
! 		   sh.slunit
! 	  FROM shoe_data sh, unit un
! 	 WHERE sh.slunit = un.un_name;
! CREATE VIEW shoelace AS
! 	SELECT s.sl_name,
! 		   s.sl_avail,
! 		   s.sl_color,
! 		   s.sl_len,
! 		   s.sl_unit,
! 		   s.sl_len * u.un_fact AS sl_len_cm
! 	  FROM shoelace_data s, unit u
! 	 WHERE s.sl_unit = u.un_name;
! CREATE VIEW shoe_ready AS
! 	SELECT rsh.shoename,
! 		   rsh.sh_avail,
! 		   rsl.sl_name,
! 		   rsl.sl_avail,
! 		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
! 	  FROM shoe rsh, shoelace rsl
! 	 WHERE rsl.sl_color = rsh.slcolor
! 	   AND rsl.sl_len_cm >= rsh.slminlen_cm
! 	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
! INSERT INTO unit VALUES ('cm', 1.0);
! INSERT INTO unit VALUES ('m', 100.0);
! INSERT INTO unit VALUES ('inch', 2.54);
! INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
! INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
! INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
! INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
! INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
! INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
! INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
! INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
! INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
! INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
! INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
! INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
! -- SELECTs in doc
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        7 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
!   shoename  | sh_avail |  sl_name   | sl_avail | total_avail 
! ------------+----------+------------+----------+-------------
!  sh1        |        2 | sl1        |        5 |           2
!  sh3        |        4 | sl7        |        7 |           4
! (2 rows)
! 
!     CREATE TABLE shoelace_log (
!         sl_name    char(10),      -- shoelace changed
!         sl_avail   integer,       -- new available value
!         log_who    name,          -- who did it
!         log_when   timestamp      -- when
!     );
! -- Want "log_who" to be CURRENT_USER,
! -- but that is non-portable for the regression test
! -- - thomas 1999-02-21
!     CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
!         WHERE NEW.sl_avail != OLD.sl_avail
!         DO INSERT INTO shoelace_log VALUES (
!                                         NEW.sl_name,
!                                         NEW.sl_avail,
!                                         'Al Bundy',
!                                         'epoch'
!                                     );
! UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
! SELECT * FROM shoelace_log;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
! (1 row)
! 
!     CREATE RULE shoelace_ins AS ON INSERT TO shoelace
!         DO INSTEAD
!         INSERT INTO shoelace_data VALUES (
!                NEW.sl_name,
!                NEW.sl_avail,
!                NEW.sl_color,
!                NEW.sl_len,
!                NEW.sl_unit);
!     CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
!         DO INSTEAD
!         UPDATE shoelace_data SET
!                sl_name = NEW.sl_name,
!                sl_avail = NEW.sl_avail,
!                sl_color = NEW.sl_color,
!                sl_len = NEW.sl_len,
!                sl_unit = NEW.sl_unit
!          WHERE sl_name = OLD.sl_name;
!     CREATE RULE shoelace_del AS ON DELETE TO shoelace
!         DO INSTEAD
!         DELETE FROM shoelace_data
!          WHERE sl_name = OLD.sl_name;
!     CREATE TABLE shoelace_arrive (
!         arr_name    char(10),
!         arr_quant   integer
!     );
!     CREATE TABLE shoelace_ok (
!         ok_name     char(10),
!         ok_quant    integer
!     );
!     CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
!         DO INSTEAD
!         UPDATE shoelace SET
!                sl_avail = sl_avail + NEW.ok_quant
!          WHERE sl_name = NEW.ok_name;
! INSERT INTO shoelace_arrive VALUES ('sl3', 10);
! INSERT INTO shoelace_arrive VALUES ('sl6', 20);
! INSERT INTO shoelace_arrive VALUES ('sl8', 20);
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! insert into shoelace_ok select * from shoelace_arrive;
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
! SELECT * FROM shoelace_log ORDER BY sl_name;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl3        |       10 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl6        |       20 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl8        |       21 | Al Bundy | Thu Jan 01 00:00:00 1970
! (4 rows)
! 
!     CREATE VIEW shoelace_obsolete AS
! 	SELECT * FROM shoelace WHERE NOT EXISTS
! 	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
!     CREATE VIEW shoelace_candelete AS
! 	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
! insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
! insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
! SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
! (2 rows)
! 
! SELECT * FROM shoelace_candelete;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
! (1 row)
! 
! DELETE FROM shoelace WHERE EXISTS
!     (SELECT * FROM shoelace_candelete
!              WHERE sl_name = shoelace.sl_name);
! SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (9 rows)
! 
! SELECT * FROM shoe ORDER BY shoename;
!   shoename  | sh_avail |  slcolor   | slminlen | slminlen_cm | slmaxlen | slmaxlen_cm |  slunit  
! ------------+----------+------------+----------+-------------+----------+-------------+----------
!  sh1        |        2 | black      |       70 |          70 |       90 |          90 | cm      
!  sh2        |        0 | black      |       30 |        76.2 |       40 |       101.6 | inch    
!  sh3        |        4 | brown      |       50 |          50 |       65 |          65 | cm      
!  sh4        |        3 | brown      |       40 |       101.6 |       50 |         127 | inch    
! (4 rows)
! 
! SELECT count(*) FROM shoe;
!  count 
! -------
!      4
! (1 row)
! 
! --
! -- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
! --
! create table foo (f1 int);
! create table foo2 (f1 int);
! create rule foorule as on insert to foo where f1 < 100
! do instead nothing;
! insert into foo values(1);
! insert into foo values(1001);
! select * from foo;
!   f1  
! ------
!  1001
! (1 row)
! 
! drop rule foorule on foo;
! -- this should fail because f1 is not exposed for unqualified reference:
! create rule foorule as on insert to foo where f1 < 100
! do instead insert into foo2 values (f1);
! ERROR:  column "f1" does not exist
! LINE 2: do instead insert into foo2 values (f1);
!                                             ^
! HINT:  There is a column named "f1" in table "old", but it cannot be referenced from this part of the query.
! -- this is the correct way:
! create rule foorule as on insert to foo where f1 < 100
! do instead insert into foo2 values (new.f1);
! insert into foo values(2);
! insert into foo values(100);
! select * from foo;
!   f1  
! ------
!  1001
!   100
! (2 rows)
! 
! select * from foo2;
!  f1 
! ----
!   2
! (1 row)
! 
! drop rule foorule on foo;
! drop table foo;
! drop table foo2;
! --
! -- Test rules containing INSERT ... SELECT, which is a very ugly special
! -- case as of 7.1.  Example is based on bug report from Joel Burton.
! --
! create table pparent (pid int, txt text);
! insert into pparent values (1,'parent1');
! insert into pparent values (2,'parent2');
! create table cchild (pid int, descrip text);
! insert into cchild values (1,'descrip1');
! create view vview as
!   select pparent.pid, txt, descrip from
!     pparent left join cchild using (pid);
! create rule rrule as
!   on update to vview do instead
! (
!   insert into cchild (pid, descrip)
!     select old.pid, new.descrip where old.descrip isnull;
!   update cchild set descrip = new.descrip where cchild.pid = old.pid;
! );
! select * from vview;
!  pid |   txt   | descrip  
! -----+---------+----------
!    1 | parent1 | descrip1
!    2 | parent2 | 
! (2 rows)
! 
! update vview set descrip='test1' where pid=1;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | 
! (2 rows)
! 
! update vview set descrip='test2' where pid=2;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | test2
! (2 rows)
! 
! update vview set descrip='test3' where pid=3;
! select * from vview;
!  pid |   txt   | descrip 
! -----+---------+---------
!    1 | parent1 | test1
!    2 | parent2 | test2
! (2 rows)
! 
! select * from cchild;
!  pid | descrip 
! -----+---------
!    1 | test1
!    2 | test2
! (2 rows)
! 
! drop rule rrule on vview;
! drop view vview;
! drop table pparent;
! drop table cchild;
! --
! -- Check that ruleutils are working
! --
! -- temporarily disable fancy output, so view changes create less diff noise
! \a\t
! SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
! iexit| SELECT ih.name,
!     ih.thepath,
!     interpt_pp(ih.thepath, r.thepath) AS exit
!    FROM ihighway ih,
!     ramp r
!   WHERE (ih.thepath ## r.thepath);
! pg_available_extension_versions| SELECT e.name,
!     e.version,
!     (x.extname IS NOT NULL) AS installed,
!     e.superuser,
!     e.relocatable,
!     e.schema,
!     e.requires,
!     e.comment
!    FROM (pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment)
!      LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));
! pg_available_extensions| SELECT e.name,
!     e.default_version,
!     x.extversion AS installed_version,
!     e.comment
!    FROM (pg_available_extensions() e(name, default_version, comment)
!      LEFT JOIN pg_extension x ON ((e.name = x.extname)));
! pg_cursors| SELECT c.name,
!     c.statement,
!     c.is_holdable,
!     c.is_binary,
!     c.is_scrollable,
!     c.creation_time
!    FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);
! pg_group| SELECT pg_authid.rolname AS groname,
!     pg_authid.oid AS grosysid,
!     ARRAY( SELECT pg_auth_members.member
!            FROM pg_auth_members
!           WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist
!    FROM pg_authid
!   WHERE (NOT pg_authid.rolcanlogin);
! pg_indexes| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     i.relname AS indexname,
!     t.spcname AS tablespace,
!     pg_get_indexdef(i.oid) AS indexdef
!    FROM ((((pg_index x
!      JOIN pg_class c ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))
!   WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'm'::"char"])) AND (i.relkind = 'i'::"char"));
! pg_locks| SELECT l.locktype,
!     l.database,
!     l.relation,
!     l.page,
!     l.tuple,
!     l.virtualxid,
!     l.transactionid,
!     l.classid,
!     l.objid,
!     l.objsubid,
!     l.virtualtransaction,
!     l.pid,
!     l.mode,
!     l.granted,
!     l.fastpath
!    FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath);
! pg_matviews| SELECT n.nspname AS schemaname,
!     c.relname AS matviewname,
!     pg_get_userbyid(c.relowner) AS matviewowner,
!     t.spcname AS tablespace,
!     c.relhasindex AS hasindexes,
!     c.relispopulated AS ispopulated,
!     pg_get_viewdef(c.oid) AS definition
!    FROM ((pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
!   WHERE (c.relkind = 'm'::"char");
! pg_policies| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     rs.rsecpolname AS policyname,
!         CASE
!             WHEN (rs.rsecroles = '{0}'::oid[]) THEN (string_to_array('public'::text, ''::text))::name[]
!             ELSE ARRAY( SELECT pg_authid.rolname
!                FROM pg_authid
!               WHERE (pg_authid.oid = ANY (rs.rsecroles))
!               ORDER BY pg_authid.rolname)
!         END AS roles,
!         CASE
!             WHEN (rs.rseccmd IS NULL) THEN 'ALL'::text
!             ELSE
!             CASE rs.rseccmd
!                 WHEN 'r'::"char" THEN 'SELECT'::text
!                 WHEN 'a'::"char" THEN 'INSERT'::text
!                 WHEN 'u'::"char" THEN 'UPDATE'::text
!                 WHEN 'd'::"char" THEN 'DELETE'::text
!                 ELSE NULL::text
!             END
!         END AS cmd,
!     pg_get_expr(rs.rsecqual, rs.rsecrelid) AS qual,
!     pg_get_expr(rs.rsecwithcheck, rs.rsecrelid) AS with_check
!    FROM ((pg_rowsecurity rs
!      JOIN pg_class c ON ((c.oid = rs.rsecrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));
! pg_prepared_statements| SELECT p.name,
!     p.statement,
!     p.prepare_time,
!     p.parameter_types,
!     p.from_sql
!    FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT p.transaction,
!     p.gid,
!     p.prepared,
!     u.rolname AS owner,
!     d.datname AS database
!    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
!      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
!      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
! pg_replication_slots| SELECT l.slot_name,
!     l.plugin,
!     l.slot_type,
!     l.datoid,
!     d.datname AS database,
!     l.active,
!     l.xmin,
!     l.catalog_xmin,
!     l.restart_lsn
!    FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, active, xmin, catalog_xmin, restart_lsn)
!      LEFT JOIN pg_database d ON ((l.datoid = d.oid)));
! pg_roles| SELECT pg_authid.rolname,
!     pg_authid.rolsuper,
!     pg_authid.rolinherit,
!     pg_authid.rolcreaterole,
!     pg_authid.rolcreatedb,
!     pg_authid.rolcatupdate,
!     pg_authid.rolcanlogin,
!     pg_authid.rolreplication,
!     pg_authid.rolconnlimit,
!     '********'::text AS rolpassword,
!     pg_authid.rolvaliduntil,
!     pg_authid.rolbypassrls,
!     s.setconfig AS rolconfig,
!     pg_authid.oid
!    FROM (pg_authid
!      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));
! pg_rules| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     r.rulename,
!     pg_get_ruledef(r.oid) AS definition
!    FROM ((pg_rewrite r
!      JOIN pg_class c ON ((c.oid = r.ev_class)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (r.rulename <> '_RETURN'::name);
! pg_seclabels| SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (rel.relkind = 'r'::"char") THEN 'table'::text
!             WHEN (rel.relkind = 'v'::"char") THEN 'view'::text
!             WHEN (rel.relkind = 'm'::"char") THEN 'materialized view'::text
!             WHEN (rel.relkind = 'S'::"char") THEN 'sequence'::text
!             WHEN (rel.relkind = 'f'::"char") THEN 'foreign table'::text
!             ELSE NULL::text
!         END AS objtype,
!     rel.relnamespace AS objnamespace,
!         CASE
!             WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
!         END AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
!      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'column'::text AS objtype,
!     rel.relnamespace AS objnamespace,
!     ((
!         CASE
!             WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
!         END || '.'::text) || (att.attname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (((pg_seclabel l
!      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
!      JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))
!      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
!   WHERE (l.objsubid <> 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (pro.proisagg = true) THEN 'aggregate'::text
!             WHEN (pro.proisagg = false) THEN 'function'::text
!             ELSE NULL::text
!         END AS objtype,
!     pro.pronamespace AS objnamespace,
!     (((
!         CASE
!             WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((pro.proname)::text))
!         END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text) AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))
!      JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!         CASE
!             WHEN (typ.typtype = 'd'::"char") THEN 'domain'::text
!             ELSE 'type'::text
!         END AS objtype,
!     typ.typnamespace AS objnamespace,
!         CASE
!             WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text)
!             ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((typ.typname)::text))
!         END AS objname,
!     l.provider,
!     l.label
!    FROM ((pg_seclabel l
!      JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))
!      JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'large object'::text AS objtype,
!     NULL::oid AS objnamespace,
!     (l.objoid)::text AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))
!   WHERE ((l.classoid = ('pg_largeobject'::regclass)::oid) AND (l.objsubid = 0))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'language'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((lan.lanname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'schema'::text AS objtype,
!     nsp.oid AS objnamespace,
!     quote_ident((nsp.nspname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     l.objsubid,
!     'event trigger'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((evt.evtname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_seclabel l
!      JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))
!   WHERE (l.objsubid = 0)
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'database'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((dat.datname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'tablespace'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((spc.spcname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))
! UNION ALL
!  SELECT l.objoid,
!     l.classoid,
!     0 AS objsubid,
!     'role'::text AS objtype,
!     NULL::oid AS objnamespace,
!     quote_ident((rol.rolname)::text) AS objname,
!     l.provider,
!     l.label
!    FROM (pg_shseclabel l
!      JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));
! pg_settings| SELECT a.name,
!     a.setting,
!     a.unit,
!     a.category,
!     a.short_desc,
!     a.extra_desc,
!     a.context,
!     a.vartype,
!     a.source,
!     a.min_val,
!     a.max_val,
!     a.enumvals,
!     a.boot_val,
!     a.reset_val,
!     a.sourcefile,
!     a.sourceline
!    FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline);
! pg_shadow| SELECT pg_authid.rolname AS usename,
!     pg_authid.oid AS usesysid,
!     pg_authid.rolcreatedb AS usecreatedb,
!     pg_authid.rolsuper AS usesuper,
!     pg_authid.rolcatupdate AS usecatupd,
!     pg_authid.rolreplication AS userepl,
!     pg_authid.rolpassword AS passwd,
!     (pg_authid.rolvaliduntil)::abstime AS valuntil,
!     s.setconfig AS useconfig
!    FROM (pg_authid
!      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))))
!   WHERE pg_authid.rolcanlogin;
! pg_stat_activity| SELECT s.datid,
!     d.datname,
!     s.pid,
!     s.usesysid,
!     u.rolname AS usename,
!     s.application_name,
!     s.client_addr,
!     s.client_hostname,
!     s.client_port,
!     s.backend_start,
!     s.xact_start,
!     s.query_start,
!     s.state_change,
!     s.waiting,
!     s.state,
!     s.backend_xid,
!     s.backend_xmin,
!     s.query
!    FROM pg_database d,
!     pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin),
!     pg_authid u
!   WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));
! pg_stat_all_indexes| SELECT c.oid AS relid,
!     i.oid AS indexrelid,
!     n.nspname AS schemaname,
!     c.relname,
!     i.relname AS indexrelname,
!     pg_stat_get_numscans(i.oid) AS idx_scan,
!     pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
!     pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch
!    FROM (((pg_class c
!      JOIN pg_index x ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));
! pg_stat_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     pg_stat_get_numscans(c.oid) AS seq_scan,
!     pg_stat_get_tuples_returned(c.oid) AS seq_tup_read,
!     (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan,
!     ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch,
!     pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins,
!     pg_stat_get_tuples_updated(c.oid) AS n_tup_upd,
!     pg_stat_get_tuples_deleted(c.oid) AS n_tup_del,
!     pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd,
!     pg_stat_get_live_tuples(c.oid) AS n_live_tup,
!     pg_stat_get_dead_tuples(c.oid) AS n_dead_tup,
!     pg_stat_get_mod_since_analyze(c.oid) AS n_mod_since_analyze,
!     pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum,
!     pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum,
!     pg_stat_get_last_analyze_time(c.oid) AS last_analyze,
!     pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze,
!     pg_stat_get_vacuum_count(c.oid) AS vacuum_count,
!     pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count,
!     pg_stat_get_analyze_count(c.oid) AS analyze_count,
!     pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count
!    FROM ((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname;
! pg_stat_archiver| SELECT s.archived_count,
!     s.last_archived_wal,
!     s.last_archived_time,
!     s.failed_count,
!     s.last_failed_wal,
!     s.last_failed_time,
!     s.stats_reset
!    FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);
! pg_stat_bgwriter| SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed,
!     pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req,
!     pg_stat_get_checkpoint_write_time() AS checkpoint_write_time,
!     pg_stat_get_checkpoint_sync_time() AS checkpoint_sync_time,
!     pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
!     pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean,
!     pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean,
!     pg_stat_get_buf_written_backend() AS buffers_backend,
!     pg_stat_get_buf_fsync_backend() AS buffers_backend_fsync,
!     pg_stat_get_buf_alloc() AS buffers_alloc,
!     pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;
! pg_stat_database| SELECT d.oid AS datid,
!     d.datname,
!     pg_stat_get_db_numbackends(d.oid) AS numbackends,
!     pg_stat_get_db_xact_commit(d.oid) AS xact_commit,
!     pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback,
!     (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read,
!     pg_stat_get_db_blocks_hit(d.oid) AS blks_hit,
!     pg_stat_get_db_tuples_returned(d.oid) AS tup_returned,
!     pg_stat_get_db_tuples_fetched(d.oid) AS tup_fetched,
!     pg_stat_get_db_tuples_inserted(d.oid) AS tup_inserted,
!     pg_stat_get_db_tuples_updated(d.oid) AS tup_updated,
!     pg_stat_get_db_tuples_deleted(d.oid) AS tup_deleted,
!     pg_stat_get_db_conflict_all(d.oid) AS conflicts,
!     pg_stat_get_db_temp_files(d.oid) AS temp_files,
!     pg_stat_get_db_temp_bytes(d.oid) AS temp_bytes,
!     pg_stat_get_db_deadlocks(d.oid) AS deadlocks,
!     pg_stat_get_db_blk_read_time(d.oid) AS blk_read_time,
!     pg_stat_get_db_blk_write_time(d.oid) AS blk_write_time,
!     pg_stat_get_db_stat_reset_time(d.oid) AS stats_reset
!    FROM pg_database d;
! pg_stat_database_conflicts| SELECT d.oid AS datid,
!     d.datname,
!     pg_stat_get_db_conflict_tablespace(d.oid) AS confl_tablespace,
!     pg_stat_get_db_conflict_lock(d.oid) AS confl_lock,
!     pg_stat_get_db_conflict_snapshot(d.oid) AS confl_snapshot,
!     pg_stat_get_db_conflict_bufferpin(d.oid) AS confl_bufferpin,
!     pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
!    FROM pg_database d;
! pg_stat_replication| SELECT s.pid,
!     s.usesysid,
!     u.rolname AS usename,
!     s.application_name,
!     s.client_addr,
!     s.client_hostname,
!     s.client_port,
!     s.backend_start,
!     s.backend_xmin,
!     w.state,
!     w.sent_location,
!     w.write_location,
!     w.flush_location,
!     w.replay_location,
!     w.sync_priority,
!     w.sync_state
!    FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin),
!     pg_authid u,
!     pg_stat_get_wal_senders() w(pid, state, sent_location, write_location, flush_location, replay_location, sync_priority, sync_state)
!   WHERE ((s.usesysid = u.oid) AND (s.pid = w.pid));
! pg_stat_sys_indexes| SELECT pg_stat_all_indexes.relid,
!     pg_stat_all_indexes.indexrelid,
!     pg_stat_all_indexes.schemaname,
!     pg_stat_all_indexes.relname,
!     pg_stat_all_indexes.indexrelname,
!     pg_stat_all_indexes.idx_scan,
!     pg_stat_all_indexes.idx_tup_read,
!     pg_stat_all_indexes.idx_tup_fetch
!    FROM pg_stat_all_indexes
!   WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_indexes.schemaname ~ '^pg_toast'::text));
! pg_stat_sys_tables| SELECT pg_stat_all_tables.relid,
!     pg_stat_all_tables.schemaname,
!     pg_stat_all_tables.relname,
!     pg_stat_all_tables.seq_scan,
!     pg_stat_all_tables.seq_tup_read,
!     pg_stat_all_tables.idx_scan,
!     pg_stat_all_tables.idx_tup_fetch,
!     pg_stat_all_tables.n_tup_ins,
!     pg_stat_all_tables.n_tup_upd,
!     pg_stat_all_tables.n_tup_del,
!     pg_stat_all_tables.n_tup_hot_upd,
!     pg_stat_all_tables.n_live_tup,
!     pg_stat_all_tables.n_dead_tup,
!     pg_stat_all_tables.n_mod_since_analyze,
!     pg_stat_all_tables.last_vacuum,
!     pg_stat_all_tables.last_autovacuum,
!     pg_stat_all_tables.last_analyze,
!     pg_stat_all_tables.last_autoanalyze,
!     pg_stat_all_tables.vacuum_count,
!     pg_stat_all_tables.autovacuum_count,
!     pg_stat_all_tables.analyze_count,
!     pg_stat_all_tables.autoanalyze_count
!    FROM pg_stat_all_tables
!   WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_tables.schemaname ~ '^pg_toast'::text));
! pg_stat_user_functions| SELECT p.oid AS funcid,
!     n.nspname AS schemaname,
!     p.proname AS funcname,
!     pg_stat_get_function_calls(p.oid) AS calls,
!     pg_stat_get_function_total_time(p.oid) AS total_time,
!     pg_stat_get_function_self_time(p.oid) AS self_time
!    FROM (pg_proc p
!      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
!   WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));
! pg_stat_user_indexes| SELECT pg_stat_all_indexes.relid,
!     pg_stat_all_indexes.indexrelid,
!     pg_stat_all_indexes.schemaname,
!     pg_stat_all_indexes.relname,
!     pg_stat_all_indexes.indexrelname,
!     pg_stat_all_indexes.idx_scan,
!     pg_stat_all_indexes.idx_tup_read,
!     pg_stat_all_indexes.idx_tup_fetch
!    FROM pg_stat_all_indexes
!   WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_indexes.schemaname !~ '^pg_toast'::text));
! pg_stat_user_tables| SELECT pg_stat_all_tables.relid,
!     pg_stat_all_tables.schemaname,
!     pg_stat_all_tables.relname,
!     pg_stat_all_tables.seq_scan,
!     pg_stat_all_tables.seq_tup_read,
!     pg_stat_all_tables.idx_scan,
!     pg_stat_all_tables.idx_tup_fetch,
!     pg_stat_all_tables.n_tup_ins,
!     pg_stat_all_tables.n_tup_upd,
!     pg_stat_all_tables.n_tup_del,
!     pg_stat_all_tables.n_tup_hot_upd,
!     pg_stat_all_tables.n_live_tup,
!     pg_stat_all_tables.n_dead_tup,
!     pg_stat_all_tables.n_mod_since_analyze,
!     pg_stat_all_tables.last_vacuum,
!     pg_stat_all_tables.last_autovacuum,
!     pg_stat_all_tables.last_analyze,
!     pg_stat_all_tables.last_autoanalyze,
!     pg_stat_all_tables.vacuum_count,
!     pg_stat_all_tables.autovacuum_count,
!     pg_stat_all_tables.analyze_count,
!     pg_stat_all_tables.autoanalyze_count
!    FROM pg_stat_all_tables
!   WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_tables.schemaname !~ '^pg_toast'::text));
! pg_stat_xact_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     pg_stat_get_xact_numscans(c.oid) AS seq_scan,
!     pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read,
!     (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan,
!     ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_xact_tuples_fetched(c.oid)) AS idx_tup_fetch,
!     pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins,
!     pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd,
!     pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del,
!     pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd
!    FROM ((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname;
! pg_stat_xact_sys_tables| SELECT pg_stat_xact_all_tables.relid,
!     pg_stat_xact_all_tables.schemaname,
!     pg_stat_xact_all_tables.relname,
!     pg_stat_xact_all_tables.seq_scan,
!     pg_stat_xact_all_tables.seq_tup_read,
!     pg_stat_xact_all_tables.idx_scan,
!     pg_stat_xact_all_tables.idx_tup_fetch,
!     pg_stat_xact_all_tables.n_tup_ins,
!     pg_stat_xact_all_tables.n_tup_upd,
!     pg_stat_xact_all_tables.n_tup_del,
!     pg_stat_xact_all_tables.n_tup_hot_upd
!    FROM pg_stat_xact_all_tables
!   WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text));
! pg_stat_xact_user_functions| SELECT p.oid AS funcid,
!     n.nspname AS schemaname,
!     p.proname AS funcname,
!     pg_stat_get_xact_function_calls(p.oid) AS calls,
!     pg_stat_get_xact_function_total_time(p.oid) AS total_time,
!     pg_stat_get_xact_function_self_time(p.oid) AS self_time
!    FROM (pg_proc p
!      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
!   WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));
! pg_stat_xact_user_tables| SELECT pg_stat_xact_all_tables.relid,
!     pg_stat_xact_all_tables.schemaname,
!     pg_stat_xact_all_tables.relname,
!     pg_stat_xact_all_tables.seq_scan,
!     pg_stat_xact_all_tables.seq_tup_read,
!     pg_stat_xact_all_tables.idx_scan,
!     pg_stat_xact_all_tables.idx_tup_fetch,
!     pg_stat_xact_all_tables.n_tup_ins,
!     pg_stat_xact_all_tables.n_tup_upd,
!     pg_stat_xact_all_tables.n_tup_del,
!     pg_stat_xact_all_tables.n_tup_hot_upd
!    FROM pg_stat_xact_all_tables
!   WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text));
! pg_statio_all_indexes| SELECT c.oid AS relid,
!     i.oid AS indexrelid,
!     n.nspname AS schemaname,
!     c.relname,
!     i.relname AS indexrelname,
!     (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,
!     pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit
!    FROM (((pg_class c
!      JOIN pg_index x ON ((c.oid = x.indrelid)))
!      JOIN pg_class i ON ((i.oid = x.indexrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));
! pg_statio_all_sequences| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,
!     pg_stat_get_blocks_hit(c.oid) AS blks_hit
!    FROM (pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = 'S'::"char");
! pg_statio_all_tables| SELECT c.oid AS relid,
!     n.nspname AS schemaname,
!     c.relname,
!     (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,
!     pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit,
!     (sum((pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))))::bigint AS idx_blks_read,
!     (sum(pg_stat_get_blocks_hit(i.indexrelid)))::bigint AS idx_blks_hit,
!     (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,
!     pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit,
!     (sum((pg_stat_get_blocks_fetched(x.indexrelid) - pg_stat_get_blocks_hit(x.indexrelid))))::bigint AS tidx_blks_read,
!     (sum(pg_stat_get_blocks_hit(x.indexrelid)))::bigint AS tidx_blks_hit
!    FROM ((((pg_class c
!      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
!      LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))
!      LEFT JOIN pg_index x ON ((t.oid = x.indrelid)))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
!   GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;
! pg_statio_sys_indexes| SELECT pg_statio_all_indexes.relid,
!     pg_statio_all_indexes.indexrelid,
!     pg_statio_all_indexes.schemaname,
!     pg_statio_all_indexes.relname,
!     pg_statio_all_indexes.indexrelname,
!     pg_statio_all_indexes.idx_blks_read,
!     pg_statio_all_indexes.idx_blks_hit
!    FROM pg_statio_all_indexes
!   WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_indexes.schemaname ~ '^pg_toast'::text));
! pg_statio_sys_sequences| SELECT pg_statio_all_sequences.relid,
!     pg_statio_all_sequences.schemaname,
!     pg_statio_all_sequences.relname,
!     pg_statio_all_sequences.blks_read,
!     pg_statio_all_sequences.blks_hit
!    FROM pg_statio_all_sequences
!   WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_sequences.schemaname ~ '^pg_toast'::text));
! pg_statio_sys_tables| SELECT pg_statio_all_tables.relid,
!     pg_statio_all_tables.schemaname,
!     pg_statio_all_tables.relname,
!     pg_statio_all_tables.heap_blks_read,
!     pg_statio_all_tables.heap_blks_hit,
!     pg_statio_all_tables.idx_blks_read,
!     pg_statio_all_tables.idx_blks_hit,
!     pg_statio_all_tables.toast_blks_read,
!     pg_statio_all_tables.toast_blks_hit,
!     pg_statio_all_tables.tidx_blks_read,
!     pg_statio_all_tables.tidx_blks_hit
!    FROM pg_statio_all_tables
!   WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_tables.schemaname ~ '^pg_toast'::text));
! pg_statio_user_indexes| SELECT pg_statio_all_indexes.relid,
!     pg_statio_all_indexes.indexrelid,
!     pg_statio_all_indexes.schemaname,
!     pg_statio_all_indexes.relname,
!     pg_statio_all_indexes.indexrelname,
!     pg_statio_all_indexes.idx_blks_read,
!     pg_statio_all_indexes.idx_blks_hit
!    FROM pg_statio_all_indexes
!   WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_indexes.schemaname !~ '^pg_toast'::text));
! pg_statio_user_sequences| SELECT pg_statio_all_sequences.relid,
!     pg_statio_all_sequences.schemaname,
!     pg_statio_all_sequences.relname,
!     pg_statio_all_sequences.blks_read,
!     pg_statio_all_sequences.blks_hit
!    FROM pg_statio_all_sequences
!   WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_sequences.schemaname !~ '^pg_toast'::text));
! pg_statio_user_tables| SELECT pg_statio_all_tables.relid,
!     pg_statio_all_tables.schemaname,
!     pg_statio_all_tables.relname,
!     pg_statio_all_tables.heap_blks_read,
!     pg_statio_all_tables.heap_blks_hit,
!     pg_statio_all_tables.idx_blks_read,
!     pg_statio_all_tables.idx_blks_hit,
!     pg_statio_all_tables.toast_blks_read,
!     pg_statio_all_tables.toast_blks_hit,
!     pg_statio_all_tables.tidx_blks_read,
!     pg_statio_all_tables.tidx_blks_hit
!    FROM pg_statio_all_tables
!   WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_tables.schemaname !~ '^pg_toast'::text));
! pg_stats| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     a.attname,
!     s.stainherit AS inherited,
!     s.stanullfrac AS null_frac,
!     s.stawidth AS avg_width,
!     s.stadistinct AS n_distinct,
!         CASE
!             WHEN (s.stakind1 = 1) THEN s.stavalues1
!             WHEN (s.stakind2 = 1) THEN s.stavalues2
!             WHEN (s.stakind3 = 1) THEN s.stavalues3
!             WHEN (s.stakind4 = 1) THEN s.stavalues4
!             WHEN (s.stakind5 = 1) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS most_common_vals,
!         CASE
!             WHEN (s.stakind1 = 1) THEN s.stanumbers1
!             WHEN (s.stakind2 = 1) THEN s.stanumbers2
!             WHEN (s.stakind3 = 1) THEN s.stanumbers3
!             WHEN (s.stakind4 = 1) THEN s.stanumbers4
!             WHEN (s.stakind5 = 1) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS most_common_freqs,
!         CASE
!             WHEN (s.stakind1 = 2) THEN s.stavalues1
!             WHEN (s.stakind2 = 2) THEN s.stavalues2
!             WHEN (s.stakind3 = 2) THEN s.stavalues3
!             WHEN (s.stakind4 = 2) THEN s.stavalues4
!             WHEN (s.stakind5 = 2) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS histogram_bounds,
!         CASE
!             WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]
!             WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]
!             WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]
!             WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]
!             WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]
!             ELSE NULL::real
!         END AS correlation,
!         CASE
!             WHEN (s.stakind1 = 4) THEN s.stavalues1
!             WHEN (s.stakind2 = 4) THEN s.stavalues2
!             WHEN (s.stakind3 = 4) THEN s.stavalues3
!             WHEN (s.stakind4 = 4) THEN s.stavalues4
!             WHEN (s.stakind5 = 4) THEN s.stavalues5
!             ELSE NULL::anyarray
!         END AS most_common_elems,
!         CASE
!             WHEN (s.stakind1 = 4) THEN s.stanumbers1
!             WHEN (s.stakind2 = 4) THEN s.stanumbers2
!             WHEN (s.stakind3 = 4) THEN s.stanumbers3
!             WHEN (s.stakind4 = 4) THEN s.stanumbers4
!             WHEN (s.stakind5 = 4) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS most_common_elem_freqs,
!         CASE
!             WHEN (s.stakind1 = 5) THEN s.stanumbers1
!             WHEN (s.stakind2 = 5) THEN s.stanumbers2
!             WHEN (s.stakind3 = 5) THEN s.stanumbers3
!             WHEN (s.stakind4 = 5) THEN s.stanumbers4
!             WHEN (s.stakind5 = 5) THEN s.stanumbers5
!             ELSE NULL::real[]
!         END AS elem_count_histogram
!    FROM (((pg_statistic s
!      JOIN pg_class c ON ((c.oid = s.starelid)))
!      JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text));
! pg_tables| SELECT n.nspname AS schemaname,
!     c.relname AS tablename,
!     pg_get_userbyid(c.relowner) AS tableowner,
!     t.spcname AS tablespace,
!     c.relhasindex AS hasindexes,
!     c.relhasrules AS hasrules,
!     c.relhastriggers AS hastriggers,
!     c.relrowsecurity AS rowsecurity
!    FROM ((pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
!   WHERE (c.relkind = 'r'::"char");
! pg_timezone_abbrevs| SELECT pg_timezone_abbrevs.abbrev,
!     pg_timezone_abbrevs.utc_offset,
!     pg_timezone_abbrevs.is_dst
!    FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);
! pg_timezone_names| SELECT pg_timezone_names.name,
!     pg_timezone_names.abbrev,
!     pg_timezone_names.utc_offset,
!     pg_timezone_names.is_dst
!    FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);
! pg_user| SELECT pg_shadow.usename,
!     pg_shadow.usesysid,
!     pg_shadow.usecreatedb,
!     pg_shadow.usesuper,
!     pg_shadow.usecatupd,
!     pg_shadow.userepl,
!     '********'::text AS passwd,
!     pg_shadow.valuntil,
!     pg_shadow.useconfig
!    FROM pg_shadow;
! pg_user_mappings| SELECT u.oid AS umid,
!     s.oid AS srvid,
!     s.srvname,
!     u.umuser,
!         CASE
!             WHEN (u.umuser = (0)::oid) THEN 'public'::name
!             ELSE a.rolname
!         END AS usename,
!         CASE
!             WHEN (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) THEN u.umoptions
!             ELSE NULL::text[]
!         END AS umoptions
!    FROM ((pg_user_mapping u
!      LEFT JOIN pg_authid a ON ((a.oid = u.umuser)))
!      JOIN pg_foreign_server s ON ((u.umserver = s.oid)));
! pg_views| SELECT n.nspname AS schemaname,
!     c.relname AS viewname,
!     pg_get_userbyid(c.relowner) AS viewowner,
!     pg_get_viewdef(c.oid) AS definition
!    FROM (pg_class c
!      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
!   WHERE (c.relkind = 'v'::"char");
! rtest_v1| SELECT rtest_t1.a,
!     rtest_t1.b
!    FROM rtest_t1;
! rtest_vcomp| SELECT x.part,
!     (x.size * y.factor) AS size_in_cm
!    FROM rtest_comp x,
!     rtest_unitfact y
!   WHERE (x.unit = y.unit);
! rtest_vview1| SELECT x.a,
!     x.b
!    FROM rtest_view1 x
!   WHERE (0 < ( SELECT count(*) AS count
!            FROM rtest_view2 y
!           WHERE (y.a = x.a)));
! rtest_vview2| SELECT rtest_view1.a,
!     rtest_view1.b
!    FROM rtest_view1
!   WHERE rtest_view1.v;
! rtest_vview3| SELECT x.a,
!     x.b
!    FROM rtest_vview2 x
!   WHERE (0 < ( SELECT count(*) AS count
!            FROM rtest_view2 y
!           WHERE (y.a = x.a)));
! rtest_vview4| SELECT x.a,
!     x.b,
!     count(y.a) AS refcount
!    FROM rtest_view1 x,
!     rtest_view2 y
!   WHERE (x.a = y.a)
!   GROUP BY x.a, x.b;
! rtest_vview5| SELECT rtest_view1.a,
!     rtest_view1.b,
!     rtest_viewfunc1(rtest_view1.a) AS refcount
!    FROM rtest_view1;
! shoe| SELECT sh.shoename,
!     sh.sh_avail,
!     sh.slcolor,
!     sh.slminlen,
!     (sh.slminlen * un.un_fact) AS slminlen_cm,
!     sh.slmaxlen,
!     (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,
!     sh.slunit
!    FROM shoe_data sh,
!     unit un
!   WHERE (sh.slunit = un.un_name);
! shoe_ready| SELECT rsh.shoename,
!     rsh.sh_avail,
!     rsl.sl_name,
!     rsl.sl_avail,
!     int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
!    FROM shoe rsh,
!     shoelace rsl
!   WHERE ((rsl.sl_color = rsh.slcolor) AND (rsl.sl_len_cm >= rsh.slminlen_cm) AND (rsl.sl_len_cm <= rsh.slmaxlen_cm));
! shoelace| SELECT s.sl_name,
!     s.sl_avail,
!     s.sl_color,
!     s.sl_len,
!     s.sl_unit,
!     (s.sl_len * u.un_fact) AS sl_len_cm
!    FROM shoelace_data s,
!     unit u
!   WHERE (s.sl_unit = u.un_name);
! shoelace_candelete| SELECT shoelace_obsolete.sl_name,
!     shoelace_obsolete.sl_avail,
!     shoelace_obsolete.sl_color,
!     shoelace_obsolete.sl_len,
!     shoelace_obsolete.sl_unit,
!     shoelace_obsolete.sl_len_cm
!    FROM shoelace_obsolete
!   WHERE (shoelace_obsolete.sl_avail = 0);
! shoelace_obsolete| SELECT shoelace.sl_name,
!     shoelace.sl_avail,
!     shoelace.sl_color,
!     shoelace.sl_len,
!     shoelace.sl_unit,
!     shoelace.sl_len_cm
!    FROM shoelace
!   WHERE (NOT (EXISTS ( SELECT shoe.shoename
!            FROM shoe
!           WHERE (shoe.slcolor = shoelace.sl_color))));
! street| SELECT r.name,
!     r.thepath,
!     c.cname
!    FROM ONLY road r,
!     real_city c
!   WHERE (c.outline ## r.thepath);
! toyemp| SELECT emp.name,
!     emp.age,
!     emp.location,
!     (12 * emp.salary) AS annualsal
!    FROM emp;
! tv| SELECT t.type,
!     sum(t.amt) AS totamt
!    FROM t
!   GROUP BY t.type;
! tvv| SELECT sum(tv.totamt) AS grandtot
!    FROM tv;
! tvvmv| SELECT tvvm.grandtot
!    FROM tvvm;
! SELECT tablename, rulename, definition FROM pg_rules
! 	ORDER BY tablename, rulename;
! pg_settings|pg_settings_n|CREATE RULE pg_settings_n AS
!     ON UPDATE TO pg_settings DO INSTEAD NOTHING;
! pg_settings|pg_settings_u|CREATE RULE pg_settings_u AS
!     ON UPDATE TO pg_settings
!    WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;
! rtest_emp|rtest_emp_del|CREATE RULE rtest_emp_del AS
!     ON DELETE TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);
! rtest_emp|rtest_emp_ins|CREATE RULE rtest_emp_ins AS
!     ON INSERT TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);
! rtest_emp|rtest_emp_upd|CREATE RULE rtest_emp_upd AS
!     ON UPDATE TO rtest_emp
!    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
!   VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);
! rtest_nothn1|rtest_nothn_r1|CREATE RULE rtest_nothn_r1 AS
!     ON INSERT TO rtest_nothn1
!    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
! rtest_nothn1|rtest_nothn_r2|CREATE RULE rtest_nothn_r2 AS
!     ON INSERT TO rtest_nothn1
!    WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;
! rtest_nothn2|rtest_nothn_r3|CREATE RULE rtest_nothn_r3 AS
!     ON INSERT TO rtest_nothn2
!    WHERE (new.a >= 100) DO INSTEAD  INSERT INTO rtest_nothn3 (a, b)
!   VALUES (new.a, new.b);
! rtest_nothn2|rtest_nothn_r4|CREATE RULE rtest_nothn_r4 AS
!     ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;
! rtest_order1|rtest_order_r1|CREATE RULE rtest_order_r1 AS
!     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 1 - this should run 1st'::text);
! rtest_order1|rtest_order_r2|CREATE RULE rtest_order_r2 AS
!     ON INSERT TO rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 2 - this should run 2nd'::text);
! rtest_order1|rtest_order_r3|CREATE RULE rtest_order_r3 AS
!     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 3 - this should run 3rd'::text);
! rtest_order1|rtest_order_r4|CREATE RULE rtest_order_r4 AS
!     ON INSERT TO rtest_order1
!    WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
!   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
! rtest_person|rtest_pers_del|CREATE RULE rtest_pers_del AS
!     ON DELETE TO rtest_person DO  DELETE FROM rtest_admin
!   WHERE (rtest_admin.pname = old.pname);
! rtest_person|rtest_pers_upd|CREATE RULE rtest_pers_upd AS
!     ON UPDATE TO rtest_person DO  UPDATE rtest_admin SET pname = new.pname
!   WHERE (rtest_admin.pname = old.pname);
! rtest_system|rtest_sys_del|CREATE RULE rtest_sys_del AS
!     ON DELETE TO rtest_system DO ( DELETE FROM rtest_interface
!   WHERE (rtest_interface.sysname = old.sysname);
!  DELETE FROM rtest_admin
!   WHERE (rtest_admin.sysname = old.sysname);
! );
! rtest_system|rtest_sys_upd|CREATE RULE rtest_sys_upd AS
!     ON UPDATE TO rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname
!   WHERE (rtest_interface.sysname = old.sysname);
!  UPDATE rtest_admin SET sysname = new.sysname
!   WHERE (rtest_admin.sysname = old.sysname);
! );
! rtest_t4|rtest_t4_ins1|CREATE RULE rtest_t4_ins1 AS
!     ON INSERT TO rtest_t4
!    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)
!   VALUES (new.a, new.b);
! rtest_t4|rtest_t4_ins2|CREATE RULE rtest_t4_ins2 AS
!     ON INSERT TO rtest_t4
!    WHERE ((new.a >= 20) AND (new.a < 30)) DO  INSERT INTO rtest_t6 (a, b)
!   VALUES (new.a, new.b);
! rtest_t5|rtest_t5_ins|CREATE RULE rtest_t5_ins AS
!     ON INSERT TO rtest_t5
!    WHERE (new.a > 15) DO  INSERT INTO rtest_t7 (a, b)
!   VALUES (new.a, new.b);
! rtest_t6|rtest_t6_ins|CREATE RULE rtest_t6_ins AS
!     ON INSERT TO rtest_t6
!    WHERE (new.a > 25) DO INSTEAD  INSERT INTO rtest_t8 (a, b)
!   VALUES (new.a, new.b);
! rtest_v1|rtest_v1_del|CREATE RULE rtest_v1_del AS
!     ON DELETE TO rtest_v1 DO INSTEAD  DELETE FROM rtest_t1
!   WHERE (rtest_t1.a = old.a);
! rtest_v1|rtest_v1_ins|CREATE RULE rtest_v1_ins AS
!     ON INSERT TO rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)
!   VALUES (new.a, new.b);
! rtest_v1|rtest_v1_upd|CREATE RULE rtest_v1_upd AS
!     ON UPDATE TO rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b
!   WHERE (rtest_t1.a = old.a);
! shoelace|shoelace_del|CREATE RULE shoelace_del AS
!     ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data
!   WHERE (shoelace_data.sl_name = old.sl_name);
! shoelace|shoelace_ins|CREATE RULE shoelace_ins AS
!     ON INSERT TO shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)
!   VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
! shoelace|shoelace_upd|CREATE RULE shoelace_upd AS
!     ON UPDATE TO shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit
!   WHERE (shoelace_data.sl_name = old.sl_name);
! shoelace_data|log_shoelace|CREATE RULE log_shoelace AS
!     ON UPDATE TO shoelace_data
!    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)
!   VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
! shoelace_ok|shoelace_ok_ins|CREATE RULE shoelace_ok_ins AS
!     ON INSERT TO shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)
!   WHERE (shoelace.sl_name = new.ok_name);
! -- restore normal output mode
! \a\t
! --
! -- CREATE OR REPLACE RULE
! --
! CREATE TABLE ruletest_tbl (a int, b int);
! CREATE TABLE ruletest_tbl2 (a int, b int);
! CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
! 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
! INSERT INTO ruletest_tbl VALUES (99, 99);
! CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
! 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
! INSERT INTO ruletest_tbl VALUES (99, 99);
! SELECT * FROM ruletest_tbl2;
!   a   |  b   
! ------+------
!    10 |   10
!  1000 | 1000
! (2 rows)
! 
! -- Check that rewrite rules splitting one INSERT into multiple
! -- conditional statements does not disable FK checking.
! create table rule_and_refint_t1 (
! 	id1a integer,
! 	id1b integer,
! 	primary key (id1a, id1b)
! );
! create table rule_and_refint_t2 (
! 	id2a integer,
! 	id2c integer,
! 	primary key (id2a, id2c)
! );
! create table rule_and_refint_t3 (
! 	id3a integer,
! 	id3b integer,
! 	id3c integer,
! 	data text,
! 	primary key (id3a, id3b, id3c),
! 	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
! 	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
! );
! insert into rule_and_refint_t1 values (1, 11);
! insert into rule_and_refint_t1 values (1, 12);
! insert into rule_and_refint_t1 values (2, 21);
! insert into rule_and_refint_t1 values (2, 22);
! insert into rule_and_refint_t2 values (1, 11);
! insert into rule_and_refint_t2 values (1, 12);
! insert into rule_and_refint_t2 values (2, 21);
! insert into rule_and_refint_t2 values (2, 22);
! insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
! insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
! insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
! insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
! insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
! insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
! create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
! 	where (exists (select 1 from rule_and_refint_t3
! 			where (((rule_and_refint_t3.id3a = new.id3a)
! 			and (rule_and_refint_t3.id3b = new.id3b))
! 			and (rule_and_refint_t3.id3c = new.id3c))))
! 	do instead update rule_and_refint_t3 set data = new.data
! 	where (((rule_and_refint_t3.id3a = new.id3a)
! 	and (rule_and_refint_t3.id3b = new.id3b))
! 	and (rule_and_refint_t3.id3c = new.id3c));
! insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
! insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
! --
! -- disallow dropping a view's rule (bug #5072)
! --
! create view fooview as select 'foo'::text;
! drop rule "_RETURN" on fooview;
! ERROR:  cannot drop rule _RETURN on view fooview because view fooview requires it
! HINT:  You can drop view fooview instead.
! drop view fooview;
! --
! -- test conversion of table to view (needed to load some pg_dump files)
! --
! create table fooview (x int, y text);
! select xmin, * from fooview;
!  xmin | x | y 
! ------+---+---
! (0 rows)
! 
! create rule "_RETURN" as on select to fooview do instead
!   select 1 as x, 'aaa'::text as y;
! select * from fooview;
!  x |  y  
! ---+-----
!  1 | aaa
! (1 row)
! 
! select xmin, * from fooview;  -- fail, views don't have such a column
! ERROR:  column "xmin" does not exist
! LINE 1: select xmin, * from fooview;
!                ^
! select reltoastrelid, relkind, relfrozenxid
!   from pg_class where oid = 'fooview'::regclass;
!  reltoastrelid | relkind | relfrozenxid 
! ---------------+---------+--------------
!              0 | v       |            0
! (1 row)
! 
! drop view fooview;
! --
! -- check for planner problems with complex inherited UPDATES
! --
! create table id (id serial primary key, name text);
! -- currently, must respecify PKEY for each inherited subtable
! create table test_1 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! create table test_2 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! create table test_3 (id integer primary key) inherits (id);
! NOTICE:  merging column "id" with inherited definition
! insert into test_1 (name) values ('Test 1');
! insert into test_1 (name) values ('Test 2');
! insert into test_2 (name) values ('Test 3');
! insert into test_2 (name) values ('Test 4');
! insert into test_3 (name) values ('Test 5');
! insert into test_3 (name) values ('Test 6');
! create view id_ordered as select * from id order by id;
! create rule update_id_ordered as on update to id_ordered
! 	do instead update id set name = new.name where id = old.id;
! select * from id_ordered;
!  id |  name  
! ----+--------
!   1 | Test 1
!   2 | Test 2
!   3 | Test 3
!   4 | Test 4
!   5 | Test 5
!   6 | Test 6
! (6 rows)
! 
! update id_ordered set name = 'update 2' where id = 2;
! update id_ordered set name = 'update 4' where id = 4;
! update id_ordered set name = 'update 5' where id = 5;
! select * from id_ordered;
!  id |   name   
! ----+----------
!   1 | Test 1
!   2 | update 2
!   3 | Test 3
!   4 | update 4
!   5 | update 5
!   6 | Test 6
! (6 rows)
! 
! set client_min_messages to warning; -- suppress cascade notices
! drop table id cascade;
! reset client_min_messages;
! --
! -- check corner case where an entirely-dummy subplan is created by
! -- constraint exclusion
! --
! create temp table t1 (a integer primary key);
! create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1);
! create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1);
! create rule t1_ins_1 as on insert to t1
! 	where new.a >= 0 and new.a < 10
! 	do instead
! 	insert into t1_1 values (new.a);
! create rule t1_ins_2 as on insert to t1
! 	where new.a >= 10 and new.a < 20
! 	do instead
! 	insert into t1_2 values (new.a);
! create rule t1_upd_1 as on update to t1
! 	where old.a >= 0 and old.a < 10
! 	do instead
! 	update t1_1 set a = new.a where a = old.a;
! create rule t1_upd_2 as on update to t1
! 	where old.a >= 10 and old.a < 20
! 	do instead
! 	update t1_2 set a = new.a where a = old.a;
! set constraint_exclusion = on;
! insert into t1 select * from generate_series(5,19,1) g;
! update t1 set a = 4 where a = 5;
! select * from only t1;
!  a 
! ---
! (0 rows)
! 
! select * from only t1_1;
!  a 
! ---
!  6
!  7
!  8
!  9
!  4
! (5 rows)
! 
! select * from only t1_2;
!  a  
! ----
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
! (10 rows)
! 
! -- test various flavors of pg_get_viewdef()
! select pg_get_viewdef('shoe'::regclass) as unpretty;
!                     unpretty                    
! ------------------------------------------------
!   SELECT sh.shoename,                          +
!      sh.sh_avail,                              +
!      sh.slcolor,                               +
!      sh.slminlen,                              +
!      (sh.slminlen * un.un_fact) AS slminlen_cm,+
!      sh.slmaxlen,                              +
!      (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,+
!      sh.slunit                                 +
!     FROM shoe_data sh,                         +
!      unit un                                   +
!    WHERE (sh.slunit = un.un_name);
! (1 row)
! 
! select pg_get_viewdef('shoe'::regclass,true) as pretty;
!                     pretty                    
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
! select pg_get_viewdef('shoe'::regclass,0) as prettier;
!                    prettier                   
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
! --
! -- check multi-row VALUES in rules
! --
! create table rules_src(f1 int, f2 int);
! create table rules_log(f1 int, f2 int, tag text);
! insert into rules_src values(1,2), (11,12);
! create rule r1 as on update to rules_src do also
!   insert into rules_log values(old.*, 'old'), (new.*, 'new');
! update rules_src set f2 = f2 + 1;
! update rules_src set f2 = f2 * 10;
! select * from rules_src;
!  f1 | f2  
! ----+-----
!   1 |  30
!  11 | 130
! (2 rows)
! 
! select * from rules_log;
!  f1 | f2  | tag 
! ----+-----+-----
!   1 |   2 | old
!   1 |   3 | new
!  11 |  12 | old
!  11 |  13 | new
!   1 |   3 | old
!   1 |  30 | new
!  11 |  13 | old
!  11 | 130 | new
! (8 rows)
! 
! create rule r2 as on update to rules_src do also
!   values(old.*, 'old'), (new.*, 'new');
! update rules_src set f2 = f2 / 10;
!  column1 | column2 | column3 
! ---------+---------+---------
!        1 |      30 | old
!        1 |       3 | new
!       11 |     130 | old
!       11 |      13 | new
! (4 rows)
! 
! select * from rules_src;
!  f1 | f2 
! ----+----
!   1 |  3
!  11 | 13
! (2 rows)
! 
! select * from rules_log;
!  f1 | f2  | tag 
! ----+-----+-----
!   1 |   2 | old
!   1 |   3 | new
!  11 |  12 | old
!  11 |  13 | new
!   1 |   3 | old
!   1 |  30 | new
!  11 |  13 | old
!  11 | 130 | new
!   1 |  30 | old
!   1 |   3 | new
!  11 | 130 | old
!  11 |  13 | new
! (12 rows)
! 
! create rule r3 as on delete to rules_src do notify rules_src_deletion;
! \d+ rules_src
!                       Table "public.rules_src"
!  Column |  Type   | Modifiers | Storage | Stats target | Description 
! --------+---------+-----------+---------+--------------+-------------
!  f1     | integer |           | plain   |              | 
!  f2     | integer |           | plain   |              | 
! Rules:
!     r1 AS
!     ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
!     r2 AS
!     ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
!     r3 AS
!     ON DELETE TO rules_src DO
!  NOTIFY rules_src_deletion
! 
! --
! -- check alter rename rule
! --
! CREATE TABLE rule_t1 (a INT);
! CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
! CREATE RULE InsertRule AS
!     ON INSERT TO rule_v1
!     DO INSTEAD
!         INSERT INTO rule_t1 VALUES(new.a);
! ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
! INSERT INTO rule_v1 VALUES(1);
! SELECT * FROM rule_v1;
!  a 
! ---
!  1
! (1 row)
! 
! \d+ rule_v1
!                 View "public.rule_v1"
!  Column |  Type   | Modifiers | Storage | Description 
! --------+---------+-----------+---------+-------------
!  a      | integer |           | plain   | 
! View definition:
!  SELECT rule_t1.a
!    FROM rule_t1;
! Rules:
!  newinsertrule AS
!     ON INSERT TO rule_v1 DO INSTEAD  INSERT INTO rule_t1 (a)
!   VALUES (new.a)
! 
! --
! -- error conditions for alter rename rule
! --
! ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist
! ERROR:  rule "insertrule" for relation "rule_v1" does not exist
! ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists
! ERROR:  rule "_RETURN" for relation "rule_v1" already exists
! ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed
! ERROR:  renaming an ON SELECT rule is not allowed
! DROP VIEW rule_v1;
! DROP TABLE rule_t1;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/event_trigger.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/event_trigger.out	2015-01-26 12:33:25.855031409 +0300
***************
*** 1,296 ****
! -- should fail, return type mismatch
! create event trigger regress_event_trigger
!    on ddl_command_start
!    execute procedure pg_backend_pid();
! ERROR:  function "pg_backend_pid" must return type "event_trigger"
! -- OK
! create function test_event_trigger() returns event_trigger as $$
! BEGIN
!     RAISE NOTICE 'test_event_trigger: % %', tg_event, tg_tag;
! END
! $$ language plpgsql;
! -- should fail, no elephant_bootstrap entry point
! create event trigger regress_event_trigger on elephant_bootstrap
!    execute procedure test_event_trigger();
! ERROR:  unrecognized event name "elephant_bootstrap"
! -- OK
! create event trigger regress_event_trigger on ddl_command_start
!    execute procedure test_event_trigger();
! -- OK
! create event trigger regress_event_trigger_end on ddl_command_end
!    execute procedure test_event_trigger();
! -- should fail, food is not a valid filter variable
! create event trigger regress_event_trigger2 on ddl_command_start
!    when food in ('sandwhich')
!    execute procedure test_event_trigger();
! ERROR:  unrecognized filter variable "food"
! -- should fail, sandwhich is not a valid command tag
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('sandwhich')
!    execute procedure test_event_trigger();
! ERROR:  filter value "sandwhich" not recognized for filter variable "tag"
! -- should fail, create skunkcabbage is not a valid comand tag
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table', 'create skunkcabbage')
!    execute procedure test_event_trigger();
! ERROR:  filter value "create skunkcabbage" not recognized for filter variable "tag"
! -- should fail, can't have event triggers on event triggers
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('DROP EVENT TRIGGER')
!    execute procedure test_event_trigger();
! ERROR:  event triggers are not supported for DROP EVENT TRIGGER
! -- should fail, can't have same filter variable twice
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table') and tag in ('CREATE FUNCTION')
!    execute procedure test_event_trigger();
! ERROR:  filter variable "tag" specified more than once
! -- OK
! create event trigger regress_event_trigger2 on ddl_command_start
!    when tag in ('create table', 'CREATE FUNCTION')
!    execute procedure test_event_trigger();
! -- OK
! comment on event trigger regress_event_trigger is 'test comment';
! -- should fail, event triggers are not schema objects
! comment on event trigger wrong.regress_event_trigger is 'test comment';
! ERROR:  event trigger name cannot be qualified
! -- drop as non-superuser should fail
! create role regression_bob;
! set role regression_bob;
! create event trigger regress_event_trigger_noperms on ddl_command_start
!    execute procedure test_event_trigger();
! ERROR:  permission denied to create event trigger "regress_event_trigger_noperms"
! HINT:  Must be superuser to create an event trigger.
! reset role;
! -- all OK
! alter event trigger regress_event_trigger enable replica;
! alter event trigger regress_event_trigger enable always;
! alter event trigger regress_event_trigger enable;
! alter event trigger regress_event_trigger disable;
! -- regress_event_trigger2 and regress_event_trigger_end should fire, but not
! -- regress_event_trigger
! create table event_trigger_fire1 (a int);
! NOTICE:  test_event_trigger: ddl_command_start CREATE TABLE
! NOTICE:  test_event_trigger: ddl_command_end CREATE TABLE
! -- regress_event_trigger_end should fire here
! drop table event_trigger_fire1;
! NOTICE:  test_event_trigger: ddl_command_end DROP TABLE
! -- alter owner to non-superuser should fail
! alter event trigger regress_event_trigger owner to regression_bob;
! ERROR:  permission denied to change owner of event trigger "regress_event_trigger"
! HINT:  The owner of an event trigger must be a superuser.
! -- alter owner to superuser should work
! alter role regression_bob superuser;
! alter event trigger regress_event_trigger owner to regression_bob;
! -- should fail, name collision
! alter event trigger regress_event_trigger rename to regress_event_trigger2;
! ERROR:  event trigger "regress_event_trigger2" already exists
! -- OK
! alter event trigger regress_event_trigger rename to regress_event_trigger3;
! -- should fail, doesn't exist any more
! drop event trigger regress_event_trigger;
! ERROR:  event trigger "regress_event_trigger" does not exist
! -- should fail, regression_bob owns regress_event_trigger2/3
! drop role regression_bob;
! ERROR:  role "regression_bob" cannot be dropped because some objects depend on it
! DETAIL:  owner of event trigger regress_event_trigger3
! -- cleanup before next test
! -- these are all OK; the second one should emit a NOTICE
! drop event trigger if exists regress_event_trigger2;
! drop event trigger if exists regress_event_trigger2;
! NOTICE:  event trigger "regress_event_trigger2" does not exist, skipping
! drop event trigger regress_event_trigger3;
! drop event trigger regress_event_trigger_end;
! -- test support for dropped objects
! CREATE SCHEMA schema_one authorization regression_bob;
! CREATE SCHEMA schema_two authorization regression_bob;
! CREATE SCHEMA audit_tbls authorization regression_bob;
! SET SESSION AUTHORIZATION regression_bob;
! CREATE TABLE schema_one.table_one(a int);
! CREATE TABLE schema_one."table two"(a int);
! CREATE TABLE schema_one.table_three(a int);
! CREATE TABLE audit_tbls.schema_one_table_two(the_value text);
! CREATE TABLE schema_two.table_two(a int);
! CREATE TABLE schema_two.table_three(a int, b text);
! CREATE TABLE audit_tbls.schema_two_table_three(the_value text);
! CREATE OR REPLACE FUNCTION schema_two.add(int, int) RETURNS int LANGUAGE plpgsql
!   CALLED ON NULL INPUT
!   AS $$ BEGIN RETURN coalesce($1,0) + coalesce($2,0); END; $$;
! CREATE AGGREGATE schema_two.newton
!   (BASETYPE = int, SFUNC = schema_two.add, STYPE = int);
! RESET SESSION AUTHORIZATION;
! CREATE TABLE undroppable_objs (
! 	object_type text,
! 	object_identity text
! );
! INSERT INTO undroppable_objs VALUES
! ('table', 'schema_one.table_three'),
! ('table', 'audit_tbls.schema_two_table_three');
! CREATE TABLE dropped_objects (
! 	type text,
! 	schema text,
! 	object text
! );
! -- This tests errors raised within event triggers; the one in audit_tbls
! -- uses 2nd-level recursive invocation via test_evtrig_dropped_objects().
! CREATE OR REPLACE FUNCTION undroppable() RETURNS event_trigger
! LANGUAGE plpgsql AS $$
! DECLARE
! 	obj record;
! BEGIN
! 	PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs';
! 	IF NOT FOUND THEN
! 		RAISE NOTICE 'table undroppable_objs not found, skipping';
! 		RETURN;
! 	END IF;
! 	FOR obj IN
! 		SELECT * FROM pg_event_trigger_dropped_objects() JOIN
! 			undroppable_objs USING (object_type, object_identity)
! 	LOOP
! 		RAISE EXCEPTION 'object % of type % cannot be dropped',
! 			obj.object_identity, obj.object_type;
! 	END LOOP;
! END;
! $$;
! CREATE EVENT TRIGGER undroppable ON sql_drop
! 	EXECUTE PROCEDURE undroppable();
! CREATE OR REPLACE FUNCTION test_evtrig_dropped_objects() RETURNS event_trigger
! LANGUAGE plpgsql AS $$
! DECLARE
!     obj record;
! BEGIN
!     FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
!     LOOP
!         IF obj.object_type = 'table' THEN
!                 EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I',
! 					format('%s_%s', obj.schema_name, obj.object_name));
!         END IF;
! 
! 	INSERT INTO dropped_objects
! 		(type, schema, object) VALUES
! 		(obj.object_type, obj.schema_name, obj.object_identity);
!     END LOOP;
! END
! $$;
! CREATE EVENT TRIGGER regress_event_trigger_drop_objects ON sql_drop
! 	WHEN TAG IN ('drop table', 'drop function', 'drop view',
! 		'drop owned', 'drop schema', 'alter table')
! 	EXECUTE PROCEDURE test_evtrig_dropped_objects();
! ALTER TABLE schema_one.table_one DROP COLUMN a;
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! ERROR:  object audit_tbls.schema_two_table_three of type table cannot be dropped
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! DELETE FROM undroppable_objs WHERE object_identity = 'audit_tbls.schema_two_table_three';
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_one" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_one"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls."schema_one_table two""
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! ERROR:  object schema_one.table_three of type table cannot be dropped
! DELETE FROM undroppable_objs WHERE object_identity = 'schema_one.table_three';
! DROP SCHEMA schema_one, schema_two CASCADE;
! NOTICE:  drop cascades to 7 other objects
! DETAIL:  drop cascades to table schema_two.table_two
! drop cascades to table schema_two.table_three
! drop cascades to function schema_two.add(integer,integer)
! drop cascades to function schema_two.newton(integer)
! drop cascades to table schema_one.table_one
! drop cascades to table schema_one."table two"
! drop cascades to table schema_one.table_three
! NOTICE:  table "schema_two_table_two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "audit_tbls_schema_two_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_one" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_one"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table two" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls."schema_one_table two""
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! NOTICE:  table "schema_one_table_three" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_one_table_three"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SELECT * FROM dropped_objects WHERE schema IS NULL OR schema <> 'pg_toast';
!      type     |   schema   |               object                
! --------------+------------+-------------------------------------
!  table column | schema_one | schema_one.table_one.a
!  schema       |            | schema_two
!  table        | schema_two | schema_two.table_two
!  type         | schema_two | schema_two.table_two
!  type         | schema_two | schema_two.table_two[]
!  table        | audit_tbls | audit_tbls.schema_two_table_three
!  type         | audit_tbls | audit_tbls.schema_two_table_three
!  type         | audit_tbls | audit_tbls.schema_two_table_three[]
!  table        | schema_two | schema_two.table_three
!  type         | schema_two | schema_two.table_three
!  type         | schema_two | schema_two.table_three[]
!  function     | schema_two | schema_two.add(integer,integer)
!  aggregate    | schema_two | schema_two.newton(integer)
!  schema       |            | schema_one
!  table        | schema_one | schema_one.table_one
!  type         | schema_one | schema_one.table_one
!  type         | schema_one | schema_one.table_one[]
!  table        | schema_one | schema_one."table two"
!  type         | schema_one | schema_one."table two"
!  type         | schema_one | schema_one."table two"[]
!  table        | schema_one | schema_one.table_three
!  type         | schema_one | schema_one.table_three
!  type         | schema_one | schema_one.table_three[]
! (23 rows)
! 
! DROP OWNED BY regression_bob;
! NOTICE:  schema "audit_tbls" does not exist, skipping
! CONTEXT:  SQL statement "DROP TABLE IF EXISTS audit_tbls.audit_tbls_schema_one_table_two"
! PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE statement
! SELECT * FROM dropped_objects WHERE type = 'schema';
!   type  | schema |   object   
! --------+--------+------------
!  schema |        | schema_two
!  schema |        | schema_one
!  schema |        | audit_tbls
! (3 rows)
! 
! DROP ROLE regression_bob;
! DROP EVENT TRIGGER regress_event_trigger_drop_objects;
! DROP EVENT TRIGGER undroppable;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/select_views.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/select_views.out	2015-01-26 12:33:25.931031413 +0300
***************
*** 1,1506 ****
! --
! -- SELECT_VIEWS
! -- test the views defined in CREATE_VIEWS
! --
! SELECT * FROM street;
!                 name                |                                                                                                                                                                                                                   thepath                                                                                                                                                                                                                    |   cname   
! ------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------
!  Access Rd 25                       | [(-121.9283,37.894),(-121.9283,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Ada                           St   | [(-122.2487,37.398),(-122.2496,37.401)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Agua Fria Creek                    | [(-121.9254,37.922),(-121.9281,37.889)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Allen                         Ct   | [(-122.0131,37.602),(-122.0117,37.597)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Alvarado Niles                Road | [(-122.0325,37.903),(-122.0316,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Andrea                        Cir  | [(-121.733218,37.88641),(-121.733286,37.90617)]                                                                                                                                                                                                                                                                                                                                                                                              | Oakland
!  Apricot                       Lane | [(-121.9471,37.401),(-121.9456,37.392)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Apricot                       Lane | [(-121.9471,37.401),(-121.9456,37.392)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arden                         Road | [(-122.0978,37.177),(-122.1,37.177)]                                                                                                                                                                                                                                                                                                                                                                                                         | Oakland
!  Arizona                       St   | [(-122.0381,37.901),(-122.0367,37.898)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Arlington                     Dr   | [(-121.8802,37.408),(-121.8807,37.394)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arlington                     Dr   | [(-121.8802,37.408),(-121.8807,37.394)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arlington                     Road | [(-121.7957,37.898),(-121.7956,37.906)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arroyo Las Positas                 | [(-121.7973,37.997),(-121.7957,37.005)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arroyo Las Positas                 | [(-121.7973,37.997),(-121.7957,37.005)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Arroyo Seco                        | [(-121.7073,37.766),(-121.6997,37.729)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Ash                           St   | [(-122.0408,37.31),(-122.04,37.292)]                                                                                                                                                                                                                                                                                                                                                                                                         | Oakland
!  Avenue 134th                       | [(-122.1823,37.002),(-122.1851,37.992)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Avenue 134th                       | [(-122.1823,37.002),(-122.1851,37.992)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Avenue 140th                       | [(-122.1656,37.003),(-122.1691,37.988)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Avenue 140th                       | [(-122.1656,37.003),(-122.1691,37.988)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Avenue D                           | [(-122.298,37.848),(-122.3024,37.849)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  B                             St   | [(-122.1749,37.451),(-122.1743,37.443)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Bancroft                      Ave  | [(-122.15714,37.4242),(-122.156,37.409)]                                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Bancroft                      Ave  | [(-122.1643,37.523),(-122.1631,37.508),(-122.1621,37.493)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Birch                         St   | [(-122.1617,37.425),(-122.1614,37.417)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Birch                         St   | [(-122.1673,37.509),(-122.1661,37.492)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Blacow                        Road | [(-122.0179,37.469),(-122.0167,37.465)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Bridgepointe                  Dr   | [(-122.0514,37.305),(-122.0509,37.299)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Broadmore                     Ave  | [(-122.095,37.522),(-122.0936,37.497)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Broadway                           | [(-122.2409,37.586),(-122.2395,37.601)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Buckingham                    Blvd | [(-122.2231,37.59),(-122.2214,37.606)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Butterfield                   Dr   | [(-122.0838,37.002),(-122.0834,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Butterfield                   Dr   | [(-122.0838,37.002),(-122.0834,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Butterfield                   Dr   | [(-122.0838,37.002),(-122.0834,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  C                             St   | [(-122.1768,37.46),(-122.1749,37.435)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Calaveras Creek                    | [(-121.8203,37.035),(-121.8207,37.931)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Calaveras Creek                    | [(-121.8203,37.035),(-121.8207,37.931)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  California                    St   | [(-122.2032,37.005),(-122.2016,37.996)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  California                    St   | [(-122.2032,37.005),(-122.2016,37.996)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Cameron                       Ave  | [(-122.1316,37.502),(-122.1327,37.481)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Campus                        Dr   | [(-122.1704,37.905),(-122.1678,37.868),(-122.1671,37.865)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Capricorn                     Ave  | [(-122.2176,37.404),(-122.2164,37.384)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Carson                        St   | [(-122.1846,37.9),(-122.1843,37.901)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Cedar                         Blvd | [(-122.0282,37.446),(-122.0265,37.43)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Cedar                         St   | [(-122.3011,37.737),(-122.2999,37.739)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Celia                         St   | [(-122.0611,37.3),(-122.0616,37.299)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Central                       Ave  | [(-122.2343,37.602),(-122.2331,37.595)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Chambers                      Dr   | [(-122.2004,37.352),(-122.1972,37.368)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Chambers                      Lane | [(-122.2001,37.359),(-122.1975,37.371)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Champion                      St   | [(-122.214,37.991),(-122.2147,37.002)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Champion                      St   | [(-122.214,37.991),(-122.2147,37.002)]                                                                                                                                                                                                                                                                                                                                                                                                       | Lafayette
!  Chapman                       Dr   | [(-122.0421,37.504),(-122.0414,37.498)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Charles                       St   | [(-122.0255,37.505),(-122.0252,37.499)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Cherry                        St   | [(-122.0437,37.42),(-122.0434,37.413)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Claremont                     Pl   | [(-122.0542,37.995),(-122.0542,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Claremont                     Pl   | [(-122.0542,37.995),(-122.0542,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Claremont                     Pl   | [(-122.0542,37.995),(-122.0542,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Coliseum                      Way  | [(-122.2001,37.47),(-122.1978,37.516)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Coliseum                      Way  | [(-122.2113,37.626),(-122.2085,37.592),(-122.2063,37.568)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Coolidge                      Ave  | [(-122.2007,37.058),(-122.1992,37.06)]                                                                                                                                                                                                                                                                                                                                                                                                       | Lafayette
!  Cornell                       Ave  | [(-122.2956,37.925),(-122.2949,37.906),(-122.2939,37.875)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Corriea                       Way  | [(-121.9501,37.402),(-121.9505,37.398)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Corriea                       Way  | [(-121.9501,37.402),(-121.9505,37.398)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Cowing                        Road | [(-122.0002,37.934),(-121.9772,37.782)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Creston                       Road | [(-122.2639,37.002),(-122.2613,37.986),(-122.2602,37.978),(-122.2598,37.973)]                                                                                                                                                                                                                                                                                                                                                                | Berkeley
!  Creston                       Road | [(-122.2639,37.002),(-122.2613,37.986),(-122.2602,37.978),(-122.2598,37.973)]                                                                                                                                                                                                                                                                                                                                                                | Lafayette
!  Crow Canyon Creek                  | [(-122.043,37.905),(-122.0368,37.71)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Crystaline                    Dr   | [(-121.925856,37),(-121.925869,37.00527)]                                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  Cull Canyon                   Road | [(-122.0536,37.435),(-122.0499,37.315)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Cull Creek                         | [(-122.0624,37.875),(-122.0582,37.527)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  D                             St   | [(-122.1811,37.505),(-122.1805,37.497)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Decoto                        Road | [(-122.0159,37.006),(-122.016,37.002),(-122.0164,37.993)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  Decoto                        Road | [(-122.0159,37.006),(-122.016,37.002),(-122.0164,37.993)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  Decoto                        Road | [(-122.0159,37.006),(-122.016,37.002),(-122.0164,37.993)]                                                                                                                                                                                                                                                                                                                                                                                    | Berkeley
!  Deering                       St   | [(-122.2146,37.904),(-122.2126,37.897)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Dimond                        Ave  | [(-122.2167,37.994),(-122.2162,37.006)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Dimond                        Ave  | [(-122.2167,37.994),(-122.2162,37.006)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Donna                         Way  | [(-122.1333,37.606),(-122.1316,37.599)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Driftwood                     Dr   | [(-122.0109,37.482),(-122.0113,37.477)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Driscoll                      Road | [(-121.9482,37.403),(-121.948451,37.39995)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Driscoll                      Road | [(-121.9482,37.403),(-121.948451,37.39995)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  E                             St   | [(-122.1832,37.505),(-122.1826,37.498),(-122.182,37.49)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Eden                          Ave  | [(-122.1143,37.505),(-122.1142,37.491)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Eden Creek                         | [(-122.022037,37.00675),(-122.0221,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Eden Creek                         | [(-122.022037,37.00675),(-122.0221,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Eden Creek                         | [(-122.022037,37.00675),(-122.0221,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                  | Berkeley
!  Edgewater                     Dr   | [(-122.201,37.379),(-122.2042,37.41)]                                                                                                                                                                                                                                                                                                                                                                                                        | Lafayette
!  Enos                          Way  | [(-121.7677,37.896),(-121.7673,37.91)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Euclid                        Ave  | [(-122.2671,37.009),(-122.2666,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Euclid                        Ave  | [(-122.2671,37.009),(-122.2666,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Fairview                      Ave  | [(-121.999,37.428),(-121.9863,37.351)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Fairview                      Ave  | [(-121.999,37.428),(-121.9863,37.351)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Foothill                      Blvd | [(-122.2414,37.9),(-122.2403,37.893)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Fountain                      St   | [(-122.2306,37.593),(-122.2293,37.605)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Gading                        Road | [(-122.0801,37.343),(-122.08,37.336)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Grizzly Peak                  Blvd | [(-122.2213,37.638),(-122.2127,37.581)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Grove                         Way  | [(-122.0643,37.884),(-122.062679,37.89162),(-122.061796,37.89578),(-122.0609,37.9)]                                                                                                                                                                                                                                                                                                                                                          | Berkeley
!  Harris                        Road | [(-122.0659,37.372),(-122.0675,37.363)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Heartwood                     Dr   | [(-122.2006,37.341),(-122.1992,37.338)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Hegenberger                   Exwy | [(-122.1946,37.52),(-122.1947,37.497)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Herrier                       St   | [(-122.1943,37.006),(-122.1936,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Herrier                       St   | [(-122.1943,37.006),(-122.1936,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Hesperian                     Blvd | [(-122.097,37.333),(-122.0956,37.31),(-122.0946,37.293)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Hesperian                     Blvd | [(-122.097,37.333),(-122.0956,37.31),(-122.0946,37.293)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Hesperian                     Blvd | [(-122.1132,37.6),(-122.1123,37.586)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Hollis                        St   | [(-122.2885,37.397),(-122.289,37.414)]                                                                                                                                                                                                                                                                                                                                                                                                       | Lafayette
!  I- 580                             | [(-121.727,37.074),(-121.7229,37.093),(-121.722301,37.09522),(-121.721001,37.10005),(-121.7194,37.106),(-121.7188,37.109),(-121.7168,37.12),(-121.7163,37.123),(-121.7145,37.127),(-121.7096,37.148),(-121.707731,37.1568),(-121.7058,37.166),(-121.7055,37.168),(-121.7044,37.174),(-121.7038,37.172),(-121.7037,37.172),(-121.7027,37.175),(-121.7001,37.181),(-121.6957,37.191),(-121.6948,37.192),(-121.6897,37.204),(-121.6697,37.185)] | Oakland
!  I- 580                             | [(-121.9322,37.989),(-121.9243,37.006),(-121.9217,37.014)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 580                             | [(-121.9322,37.989),(-121.9243,37.006),(-121.9217,37.014)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 580                             | [(-122.018,37.019),(-122.0009,37.032),(-121.9787,37.983),(-121.958,37.984),(-121.9571,37.986)]                                                                                                                                                                                                                                                                                                                                               | Oakland
!  I- 580                             | [(-122.018,37.019),(-122.0009,37.032),(-121.9787,37.983),(-121.958,37.984),(-121.9571,37.986)]                                                                                                                                                                                                                                                                                                                                               | Oakland
!  I- 580                             | [(-122.1108,37.023),(-122.1101,37.02),(-122.108103,37.00764),(-122.108,37.007),(-122.1069,37.998),(-122.1064,37.994),(-122.1053,37.982),(-122.1048,37.977),(-122.1032,37.958),(-122.1026,37.953),(-122.1013,37.938),(-122.0989,37.911),(-122.0984,37.91),(-122.098,37.908)]                                                                                                                                                                  | Oakland
!  I- 580                             | [(-122.1108,37.023),(-122.1101,37.02),(-122.108103,37.00764),(-122.108,37.007),(-122.1069,37.998),(-122.1064,37.994),(-122.1053,37.982),(-122.1048,37.977),(-122.1032,37.958),(-122.1026,37.953),(-122.1013,37.938),(-122.0989,37.911),(-122.0984,37.91),(-122.098,37.908)]                                                                                                                                                                  | Berkeley
!  I- 580                             | [(-122.1543,37.703),(-122.1535,37.694),(-122.1512,37.655),(-122.1475,37.603),(-122.1468,37.583),(-122.1472,37.569),(-122.149044,37.54874),(-122.1493,37.546),(-122.1501,37.532),(-122.1506,37.509),(-122.1495,37.482),(-122.1487,37.467),(-122.1477,37.447),(-122.1414,37.383),(-122.1404,37.376),(-122.1398,37.372),(-122.139,37.356),(-122.1388,37.353),(-122.1385,37.34),(-122.1382,37.33),(-122.1378,37.316)]                            | Oakland
!  I- 580                             | [(-122.1543,37.703),(-122.1535,37.694),(-122.1512,37.655),(-122.1475,37.603),(-122.1468,37.583),(-122.1472,37.569),(-122.149044,37.54874),(-122.1493,37.546),(-122.1501,37.532),(-122.1506,37.509),(-122.1495,37.482),(-122.1487,37.467),(-122.1477,37.447),(-122.1414,37.383),(-122.1404,37.376),(-122.1398,37.372),(-122.139,37.356),(-122.1388,37.353),(-122.1385,37.34),(-122.1382,37.33),(-122.1378,37.316)]                            | Berkeley
!  I- 580                             | [(-122.2197,37.99),(-122.22,37.99),(-122.222092,37.99523),(-122.2232,37.998),(-122.224146,37.99963),(-122.2261,37.003),(-122.2278,37.007),(-122.2302,37.026),(-122.2323,37.043),(-122.2344,37.059),(-122.235405,37.06427),(-122.2365,37.07)]                                                                                                                                                                                                 | Berkeley
!  I- 580                             | [(-122.2197,37.99),(-122.22,37.99),(-122.222092,37.99523),(-122.2232,37.998),(-122.224146,37.99963),(-122.2261,37.003),(-122.2278,37.007),(-122.2302,37.026),(-122.2323,37.043),(-122.2344,37.059),(-122.235405,37.06427),(-122.2365,37.07)]                                                                                                                                                                                                 | Lafayette
!  I- 580                        Ramp | [(-121.8521,37.011),(-121.8479,37.999),(-121.8476,37.999),(-121.8456,37.01),(-121.8455,37.011)]                                                                                                                                                                                                                                                                                                                                              | Oakland
!  I- 580                        Ramp | [(-121.8521,37.011),(-121.8479,37.999),(-121.8476,37.999),(-121.8456,37.01),(-121.8455,37.011)]                                                                                                                                                                                                                                                                                                                                              | Oakland
!  I- 580                        Ramp | [(-121.8743,37.014),(-121.8722,37.999),(-121.8714,37.999)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 580                        Ramp | [(-121.8743,37.014),(-121.8722,37.999),(-121.8714,37.999)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 580                        Ramp | [(-121.9043,37.998),(-121.9036,37.013),(-121.902632,37.0174),(-121.9025,37.018)]                                                                                                                                                                                                                                                                                                                                                             | Oakland
!  I- 580                        Ramp | [(-121.9043,37.998),(-121.9036,37.013),(-121.902632,37.0174),(-121.9025,37.018)]                                                                                                                                                                                                                                                                                                                                                             | Oakland
!  I- 580                        Ramp | [(-121.9368,37.986),(-121.936483,37.98832),(-121.9353,37.997),(-121.93504,37.00035),(-121.9346,37.006),(-121.933764,37.00031),(-121.9333,37.997),(-121.9322,37.989)]                                                                                                                                                                                                                                                                         | Oakland
!  I- 580                        Ramp | [(-121.9368,37.986),(-121.936483,37.98832),(-121.9353,37.997),(-121.93504,37.00035),(-121.9346,37.006),(-121.933764,37.00031),(-121.9333,37.997),(-121.9322,37.989)]                                                                                                                                                                                                                                                                         | Oakland
!  I- 580                        Ramp | [(-122.093241,37.90351),(-122.09364,37.89634),(-122.093788,37.89212)]                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  I- 580                        Ramp | [(-122.0934,37.896),(-122.09257,37.89961),(-122.0911,37.906)]                                                                                                                                                                                                                                                                                                                                                                                | Berkeley
!  I- 580                        Ramp | [(-122.0941,37.897),(-122.0943,37.902)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  I- 580                        Ramp | [(-122.096,37.888),(-122.0962,37.891),(-122.0964,37.9)]                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  I- 580                        Ramp | [(-122.101,37.898),(-122.1005,37.902),(-122.0989,37.911)]                                                                                                                                                                                                                                                                                                                                                                                    | Berkeley
!  I- 580                        Ramp | [(-122.1086,37.003),(-122.1068,37.993),(-122.1066,37.992),(-122.1053,37.982)]                                                                                                                                                                                                                                                                                                                                                                | Oakland
!  I- 580                        Ramp | [(-122.1086,37.003),(-122.1068,37.993),(-122.1066,37.992),(-122.1053,37.982)]                                                                                                                                                                                                                                                                                                                                                                | Berkeley
!  I- 580                        Ramp | [(-122.1414,37.383),(-122.1407,37.376),(-122.1403,37.372),(-122.139,37.356)]                                                                                                                                                                                                                                                                                                                                                                 | Oakland
!  I- 580/I-680                  Ramp | ((-121.9207,37.988),(-121.9192,37.016))                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  I- 580/I-680                  Ramp | ((-121.9207,37.988),(-121.9192,37.016))                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  I- 680                             | ((-121.939,37.15),(-121.9387,37.145),(-121.9373,37.125),(-121.934242,37.07643),(-121.933886,37.0709),(-121.9337,37.068),(-121.933122,37.06139),(-121.932736,37.05698),(-121.93222,37.05108),(-121.931844,37.04678),(-121.930113,37.027),(-121.926829,37),(-121.9265,37.998),(-121.9217,37.96),(-121.9203,37.949),(-121.9184,37.934))                                                                                                         | Oakland
!  I- 680                             | ((-121.939,37.15),(-121.9387,37.145),(-121.9373,37.125),(-121.934242,37.07643),(-121.933886,37.0709),(-121.9337,37.068),(-121.933122,37.06139),(-121.932736,37.05698),(-121.93222,37.05108),(-121.931844,37.04678),(-121.930113,37.027),(-121.926829,37),(-121.9265,37.998),(-121.9217,37.96),(-121.9203,37.949),(-121.9184,37.934))                                                                                                         | Oakland
!  I- 680                             | [(-121.9101,37.715),(-121.911269,37.74682),(-121.9119,37.764),(-121.9124,37.776),(-121.9174,37.905),(-121.9194,37.957),(-121.9207,37.988)]                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 680                             | [(-121.9184,37.934),(-121.917,37.913),(-121.9122,37.83),(-121.9052,37.702)]                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  I- 680                        Ramp | [(-121.8833,37.376),(-121.8833,37.392),(-121.883,37.4),(-121.8835,37.402),(-121.8852,37.422)]                                                                                                                                                                                                                                                                                                                                                | Oakland
!  I- 680                        Ramp | [(-121.8833,37.376),(-121.8833,37.392),(-121.883,37.4),(-121.8835,37.402),(-121.8852,37.422)]                                                                                                                                                                                                                                                                                                                                                | Oakland
!  I- 680                        Ramp | [(-121.92,37.438),(-121.9218,37.424),(-121.9238,37.408),(-121.9252,37.392)]                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  I- 680                        Ramp | [(-121.92,37.438),(-121.9218,37.424),(-121.9238,37.408),(-121.9252,37.392)]                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  I- 680                        Ramp | [(-121.9238,37.402),(-121.9234,37.395),(-121.923,37.399)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  I- 680                        Ramp | [(-121.9238,37.402),(-121.9234,37.395),(-121.923,37.399)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  I- 80                              | ((-122.2937,37.277),(-122.3016,37.262))                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  I- 80                              | ((-122.2962,37.273),(-122.3004,37.264))                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  I- 80                         Ramp | [(-122.2962,37.413),(-122.2959,37.382),(-122.2951,37.372)]                                                                                                                                                                                                                                                                                                                                                                                   | Lafayette
!  I- 880                             | ((-121.9669,37.075),(-121.9663,37.071),(-121.9656,37.065),(-121.9618,37.037),(-121.95689,37),(-121.948,37.933))                                                                                                                                                                                                                                                                                                                              | Oakland
!  I- 880                             | ((-121.9669,37.075),(-121.9663,37.071),(-121.9656,37.065),(-121.9618,37.037),(-121.95689,37),(-121.948,37.933))                                                                                                                                                                                                                                                                                                                              | Oakland
!  I- 880                             | [(-121.948,37.933),(-121.9471,37.925),(-121.9467,37.923),(-121.946,37.918),(-121.9452,37.912),(-121.937,37.852)]                                                                                                                                                                                                                                                                                                                             | Oakland
!  I- 880                             | [(-122.0219,37.466),(-122.0205,37.447),(-122.020331,37.44447),(-122.020008,37.43962),(-122.0195,37.432),(-122.0193,37.429),(-122.0164,37.393),(-122.010219,37.34771),(-122.0041,37.313)]                                                                                                                                                                                                                                                     | Oakland
!  I- 880                             | [(-122.0375,37.632),(-122.0359,37.619),(-122.0358,37.616),(-122.034514,37.60409),(-122.031876,37.57965),(-122.031193,37.57332),(-122.03016,37.56375),(-122.02943,37.55698),(-122.028689,37.54929),(-122.027833,37.53908),(-122.025979,37.51698),(-122.0238,37.491)]                                                                                                                                                                          | Oakland
!  I- 880                             | [(-122.0375,37.632),(-122.0359,37.619),(-122.0358,37.616),(-122.034514,37.60409),(-122.031876,37.57965),(-122.031193,37.57332),(-122.03016,37.56375),(-122.02943,37.55698),(-122.028689,37.54929),(-122.027833,37.53908),(-122.025979,37.51698),(-122.0238,37.491)]                                                                                                                                                                          | Berkeley
!  I- 880                             | [(-122.0612,37.003),(-122.0604,37.991),(-122.0596,37.982),(-122.0585,37.967),(-122.0583,37.961),(-122.0553,37.918),(-122.053635,37.89475),(-122.050759,37.8546),(-122.05,37.844),(-122.0485,37.817),(-122.0483,37.813),(-122.0482,37.811)]                                                                                                                                                                                                   | Oakland
!  I- 880                             | [(-122.0612,37.003),(-122.0604,37.991),(-122.0596,37.982),(-122.0585,37.967),(-122.0583,37.961),(-122.0553,37.918),(-122.053635,37.89475),(-122.050759,37.8546),(-122.05,37.844),(-122.0485,37.817),(-122.0483,37.813),(-122.0482,37.811)]                                                                                                                                                                                                   | Oakland
!  I- 880                             | [(-122.0612,37.003),(-122.0604,37.991),(-122.0596,37.982),(-122.0585,37.967),(-122.0583,37.961),(-122.0553,37.918),(-122.053635,37.89475),(-122.050759,37.8546),(-122.05,37.844),(-122.0485,37.817),(-122.0483,37.813),(-122.0482,37.811)]                                                                                                                                                                                                   | Berkeley
!  I- 880                             | [(-122.0831,37.312),(-122.0819,37.296),(-122.081,37.285),(-122.0786,37.248),(-122.078,37.24),(-122.077642,37.23496),(-122.076983,37.22567),(-122.076599,37.22026),(-122.076229,37.21505),(-122.0758,37.209)]                                                                                                                                                                                                                                 | Oakland
!  I- 880                             | [(-122.0978,37.528),(-122.096,37.496),(-122.0931,37.453),(-122.09277,37.4496),(-122.090189,37.41442),(-122.0896,37.405),(-122.085,37.34)]                                                                                                                                                                                                                                                                                                    | Oakland
!  I- 880                             | [(-122.1365,37.902),(-122.1358,37.898),(-122.1333,37.881),(-122.1323,37.874),(-122.1311,37.866),(-122.1308,37.865),(-122.1307,37.864),(-122.1289,37.851),(-122.1277,37.843),(-122.1264,37.834),(-122.1231,37.812),(-122.1165,37.766),(-122.1104,37.72),(-122.109695,37.71094),(-122.109,37.702),(-122.108312,37.69168),(-122.1076,37.681)]                                                                                                   | Berkeley
!  I- 880                             | [(-122.1755,37.185),(-122.1747,37.178),(-122.1742,37.173),(-122.1692,37.126),(-122.167792,37.11594),(-122.16757,37.11435),(-122.1671,37.111),(-122.1655,37.1),(-122.165169,37.09811),(-122.1641,37.092),(-122.1596,37.061),(-122.158381,37.05275),(-122.155991,37.03657),(-122.1531,37.017),(-122.1478,37.98),(-122.1407,37.932),(-122.1394,37.924),(-122.1389,37.92),(-122.1376,37.91)]                                                     | Oakland
!  I- 880                             | [(-122.1755,37.185),(-122.1747,37.178),(-122.1742,37.173),(-122.1692,37.126),(-122.167792,37.11594),(-122.16757,37.11435),(-122.1671,37.111),(-122.1655,37.1),(-122.165169,37.09811),(-122.1641,37.092),(-122.1596,37.061),(-122.158381,37.05275),(-122.155991,37.03657),(-122.1531,37.017),(-122.1478,37.98),(-122.1407,37.932),(-122.1394,37.924),(-122.1389,37.92),(-122.1376,37.91)]                                                     | Berkeley
!  I- 880                             | [(-122.2214,37.711),(-122.2202,37.699),(-122.2199,37.695),(-122.219,37.682),(-122.2184,37.672),(-122.2173,37.652),(-122.2159,37.638),(-122.2144,37.616),(-122.2138,37.612),(-122.2135,37.609),(-122.212,37.592),(-122.2116,37.586),(-122.2111,37.581)]                                                                                                                                                                                       | Berkeley
!  I- 880                             | [(-122.2707,37.975),(-122.2693,37.972),(-122.2681,37.966),(-122.267,37.962),(-122.2659,37.957),(-122.2648,37.952),(-122.2636,37.946),(-122.2625,37.935),(-122.2617,37.927),(-122.2607,37.921),(-122.2593,37.916),(-122.258,37.911),(-122.2536,37.898),(-122.2432,37.858),(-122.2408,37.845),(-122.2386,37.827),(-122.2374,37.811)]                                                                                                           | Berkeley
!  I- 880                        Ramp | [(-122.0019,37.301),(-122.002,37.293)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  I- 880                        Ramp | [(-122.0041,37.313),(-122.0018,37.315),(-122.0007,37.315),(-122.0005,37.313),(-122.0002,37.308),(-121.9995,37.289)]                                                                                                                                                                                                                                                                                                                          | Oakland
!  I- 880                        Ramp | [(-122.0041,37.313),(-122.0038,37.308),(-122.0039,37.284),(-122.0013,37.287),(-121.9995,37.289)]                                                                                                                                                                                                                                                                                                                                             | Oakland
!  I- 880                        Ramp | [(-122.0236,37.488),(-122.0231,37.458),(-122.0227,37.458),(-122.0223,37.452),(-122.0205,37.447)]                                                                                                                                                                                                                                                                                                                                             | Oakland
!  I- 880                        Ramp | [(-122.0238,37.491),(-122.0215,37.483),(-122.0211,37.477),(-122.0205,37.447)]                                                                                                                                                                                                                                                                                                                                                                | Oakland
!  I- 880                        Ramp | [(-122.059,37.982),(-122.0577,37.984),(-122.0612,37.003)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  I- 880                        Ramp | [(-122.059,37.982),(-122.0577,37.984),(-122.0612,37.003)]                                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  I- 880                        Ramp | [(-122.059,37.982),(-122.0577,37.984),(-122.0612,37.003)]                                                                                                                                                                                                                                                                                                                                                                                    | Berkeley
!  I- 880                        Ramp | [(-122.0618,37.011),(-122.0631,37.982),(-122.0585,37.967)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 880                        Ramp | [(-122.0618,37.011),(-122.0631,37.982),(-122.0585,37.967)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  I- 880                        Ramp | [(-122.0618,37.011),(-122.0631,37.982),(-122.0585,37.967)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  I- 880                        Ramp | [(-122.085,37.34),(-122.0801,37.316),(-122.081,37.285)]                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  I- 880                        Ramp | [(-122.085,37.34),(-122.0801,37.316),(-122.081,37.285)]                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  I- 880                        Ramp | [(-122.085,37.34),(-122.0866,37.316),(-122.0819,37.296)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  I- 880                        Ramp | [(-122.085,37.34),(-122.0866,37.316),(-122.0819,37.296)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  I- 880                        Ramp | [(-122.1029,37.61),(-122.1013,37.587),(-122.0999,37.569)]                                                                                                                                                                                                                                                                                                                                                                                    | Berkeley
!  I- 880                        Ramp | [(-122.1379,37.891),(-122.1383,37.897),(-122.1377,37.902)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  I- 880                        Ramp | [(-122.1379,37.931),(-122.137597,37.92736),(-122.1374,37.925),(-122.1373,37.924),(-122.1369,37.914),(-122.1358,37.905),(-122.1365,37.908),(-122.1358,37.898)]                                                                                                                                                                                                                                                                                | Berkeley
!  I- 880                        Ramp | [(-122.2536,37.898),(-122.254,37.902)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  I- 880                        Ramp | [(-122.2771,37.002),(-122.278,37)]                                                                                                                                                                                                                                                                                                                                                                                                           | Lafayette
!  Indian                        Way  | [(-122.2066,37.398),(-122.2045,37.411)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Jackson                       St   | [(-122.0845,37.6),(-122.0842,37.606)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Johnson                       Dr   | [(-121.9145,37.901),(-121.915,37.877)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Joyce                         St   | [(-122.0792,37.604),(-122.0774,37.581)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Juniper                       St   | [(-121.7823,37.897),(-121.7815,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Kaiser                        Dr   | [(-122.067163,37.47821),(-122.060402,37.51961)]                                                                                                                                                                                                                                                                                                                                                                                              | Oakland
!  Keeler                        Ave  | [(-122.2578,37.906),(-122.2579,37.899)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Kildare                       Road | [(-122.0968,37.016),(-122.0959,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Oakland
!  La Playa                      Dr   | [(-122.1039,37.545),(-122.101,37.493)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Laguna                        Ave  | [(-122.2099,37.989),(-122.2089,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Berkeley
!  Laguna                        Ave  | [(-122.2099,37.989),(-122.2089,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Lafayette
!  Lakehurst                     Cir  | [(-122.284729,37.89025),(-122.286096,37.90364)]                                                                                                                                                                                                                                                                                                                                                                                              | Berkeley
!  Lakeshore                     Ave  | [(-122.2586,37.99),(-122.2556,37.006)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Lakeshore                     Ave  | [(-122.2586,37.99),(-122.2556,37.006)]                                                                                                                                                                                                                                                                                                                                                                                                       | Lafayette
!  Las Positas                   Road | [(-121.764488,37.99199),(-121.75569,37.02022)]                                                                                                                                                                                                                                                                                                                                                                                               | Oakland
!  Las Positas                   Road | [(-121.764488,37.99199),(-121.75569,37.02022)]                                                                                                                                                                                                                                                                                                                                                                                               | Oakland
!  Linden                        St   | [(-122.2867,37.998),(-122.2864,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Linden                        St   | [(-122.2867,37.998),(-122.2864,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Livermore                     Ave  | [(-121.7687,37.448),(-121.769,37.375)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Livermore                     Ave  | [(-121.7687,37.448),(-121.769,37.375)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Livermore                     Ave  | [(-121.772719,37.99085),(-121.7728,37.001)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Livermore                     Ave  | [(-121.772719,37.99085),(-121.7728,37.001)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Locust                        St   | [(-122.1606,37.007),(-122.1593,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Locust                        St   | [(-122.1606,37.007),(-122.1593,37.987)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Logan                         Ct   | [(-122.0053,37.492),(-122.0061,37.484)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Magnolia                      St   | [(-122.0971,37.5),(-122.0962,37.484)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Mandalay                      Road | [(-122.2322,37.397),(-122.2321,37.403)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Marin                         Ave  | [(-122.2741,37.894),(-122.272,37.901)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Martin Luther King Jr         Way  | [(-122.2712,37.608),(-122.2711,37.599)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Mattos                        Dr   | [(-122.0005,37.502),(-122.000898,37.49683)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Maubert                       Ave  | [(-122.1114,37.009),(-122.1096,37.995)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Maubert                       Ave  | [(-122.1114,37.009),(-122.1096,37.995)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  McClure                       Ave  | [(-122.1431,37.001),(-122.1436,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  McClure                       Ave  | [(-122.1431,37.001),(-122.1436,37.998)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Medlar                        Dr   | [(-122.0627,37.378),(-122.0625,37.375)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Mildred                       Ct   | [(-122.0002,37.388),(-121.9998,37.386)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Miller                        Road | [(-122.0902,37.645),(-122.0865,37.545)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Miramar                       Ave  | [(-122.1009,37.025),(-122.099089,37.03209)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Mission                       Blvd | [(-121.918886,37),(-121.9194,37.976),(-121.9198,37.975)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Mission                       Blvd | [(-121.918886,37),(-121.9194,37.976),(-121.9198,37.975)]                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Mission                       Blvd | [(-122.0006,37.896),(-121.9989,37.88)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Mission                       Blvd | [(-122.0006,37.896),(-121.9989,37.88)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Moores                        Ave  | [(-122.0087,37.301),(-122.0094,37.292)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  National                      Ave  | [(-122.1192,37.5),(-122.1281,37.489)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Navajo                        Ct   | [(-121.8779,37.901),(-121.8783,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Newark                        Blvd | [(-122.0352,37.438),(-122.0341,37.423)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Oakland Inner Harbor               | [(-122.2625,37.913),(-122.260016,37.89484)]                                                                                                                                                                                                                                                                                                                                                                                                  | Berkeley
!  Oakridge                      Road | [(-121.8316,37.049),(-121.828382,37)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Oneil                         Ave  | [(-122.076754,37.62476),(-122.0745,37.595)]                                                                                                                                                                                                                                                                                                                                                                                                  | Berkeley
!  Parkridge                     Dr   | [(-122.1438,37.884),(-122.1428,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Parkside                      Dr   | [(-122.0475,37.603),(-122.0443,37.596)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Paseo Padre                   Pkwy | [(-121.9143,37.005),(-121.913522,37)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Paseo Padre                   Pkwy | [(-122.0021,37.639),(-121.996,37.628)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Paseo Padre                   Pkwy | [(-122.0021,37.639),(-121.996,37.628)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Pearl                         St   | [(-122.2383,37.594),(-122.2366,37.615)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Periwinkle                    Road | [(-122.0451,37.301),(-122.044758,37.29844)]                                                                                                                                                                                                                                                                                                                                                                                                  | Oakland
!  Pimlico                       Dr   | [(-121.8616,37.998),(-121.8618,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Pimlico                       Dr   | [(-121.8616,37.998),(-121.8618,37.008)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Portsmouth                    Ave  | [(-122.1064,37.315),(-122.1064,37.308)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Proctor                       Ave  | [(-122.2267,37.406),(-122.2251,37.386)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Railroad                      Ave  | [(-122.0245,37.013),(-122.0234,37.003),(-122.0223,37.993)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Railroad                      Ave  | [(-122.0245,37.013),(-122.0234,37.003),(-122.0223,37.993)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Railroad                      Ave  | [(-122.0245,37.013),(-122.0234,37.003),(-122.0223,37.993)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Ranspot                       Dr   | [(-122.0972,37.999),(-122.0959,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Oakland
!  Ranspot                       Dr   | [(-122.0972,37.999),(-122.0959,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Oakland
!  Ranspot                       Dr   | [(-122.0972,37.999),(-122.0959,37)]                                                                                                                                                                                                                                                                                                                                                                                                          | Berkeley
!  Redding                       St   | [(-122.1978,37.901),(-122.1975,37.895)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Redwood                       Road | [(-122.1493,37.98),(-122.1437,37.001)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Redwood                       Road | [(-122.1493,37.98),(-122.1437,37.001)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Roca                          Dr   | [(-122.0335,37.609),(-122.0314,37.599)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Rosedale                      Ct   | [(-121.9232,37.9),(-121.924,37.897)]                                                                                                                                                                                                                                                                                                                                                                                                         | Oakland
!  Sacramento                    St   | [(-122.2799,37.606),(-122.2797,37.597)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Saddle Brook                  Dr   | [(-122.1478,37.909),(-122.1454,37.904),(-122.1451,37.888)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Saginaw                       Ct   | [(-121.8803,37.898),(-121.8806,37.901)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  San Andreas                   Dr   | [(-122.0609,37.9),(-122.0614,37.895)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Santa Maria                   Ave  | [(-122.0773,37),(-122.0773,37.98)]                                                                                                                                                                                                                                                                                                                                                                                                           | Oakland
!  Santa Maria                   Ave  | [(-122.0773,37),(-122.0773,37.98)]                                                                                                                                                                                                                                                                                                                                                                                                           | Oakland
!  Santa Maria                   Ave  | [(-122.0773,37),(-122.0773,37.98)]                                                                                                                                                                                                                                                                                                                                                                                                           | Berkeley
!  Shattuck                      Ave  | [(-122.2686,37.904),(-122.2686,37.897)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Sheridan                      Road | [(-122.2279,37.425),(-122.2253,37.411),(-122.2223,37.377)]                                                                                                                                                                                                                                                                                                                                                                                   | Lafayette
!  Shoreline                     Dr   | [(-122.2657,37.603),(-122.2648,37.6)]                                                                                                                                                                                                                                                                                                                                                                                                        | Berkeley
!  Skyline                       Blvd | [(-122.1738,37.01),(-122.1714,37.996)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Skyline                       Blvd | [(-122.1738,37.01),(-122.1714,37.996)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Skyline                       Dr   | [(-122.0277,37.5),(-122.0284,37.498)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Skywest                       Dr   | [(-122.1161,37.62),(-122.1123,37.586)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  Southern Pacific Railroad          | [(-122.3002,37.674),(-122.2999,37.661)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Sp Railroad                        | [(-121.893564,37.99009),(-121.897,37.016)]                                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Sp Railroad                        | [(-121.893564,37.99009),(-121.897,37.016)]                                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Sp Railroad                        | [(-121.9565,37.898),(-121.9562,37.9)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Sp Railroad                        | [(-122.0734,37.001),(-122.0734,37.997)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Sp Railroad                        | [(-122.0734,37.001),(-122.0734,37.997)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Sp Railroad                        | [(-122.0734,37.001),(-122.0734,37.997)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Sp Railroad                        | [(-122.0914,37.601),(-122.087,37.56),(-122.086408,37.5551)]                                                                                                                                                                                                                                                                                                                                                                                  | Berkeley
!  Sp Railroad                        | [(-122.137792,37.003),(-122.1365,37.992),(-122.131257,37.94612)]                                                                                                                                                                                                                                                                                                                                                                             | Oakland
!  Sp Railroad                        | [(-122.137792,37.003),(-122.1365,37.992),(-122.131257,37.94612)]                                                                                                                                                                                                                                                                                                                                                                             | Berkeley
!  Sp Railroad                        | [(-122.1947,37.497),(-122.193328,37.4848)]                                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Stanton                       Ave  | [(-122.100392,37.0697),(-122.099513,37.06052)]                                                                                                                                                                                                                                                                                                                                                                                               | Oakland
!  State Hwy 123                      | [(-122.3004,37.986),(-122.2998,37.969),(-122.2995,37.962),(-122.2992,37.952),(-122.299,37.942),(-122.2987,37.935),(-122.2984,37.924),(-122.2982,37.92),(-122.2976,37.904),(-122.297,37.88),(-122.2966,37.869),(-122.2959,37.848),(-122.2961,37.843)]                                                                                                                                                                                         | Berkeley
!  State Hwy 13                       | [(-122.1797,37.943),(-122.179871,37.91849),(-122.18,37.9),(-122.179023,37.86615),(-122.1787,37.862),(-122.1781,37.851),(-122.1777,37.845),(-122.1773,37.839),(-122.177,37.833)]                                                                                                                                                                                                                                                              | Berkeley
!  State Hwy 13                       | [(-122.2049,37.2),(-122.20328,37.17975),(-122.1989,37.125),(-122.198078,37.11641),(-122.1975,37.11)]                                                                                                                                                                                                                                                                                                                                         | Lafayette
!  State Hwy 13                  Ramp | [(-122.2244,37.427),(-122.223,37.414),(-122.2214,37.396),(-122.2213,37.388)]                                                                                                                                                                                                                                                                                                                                                                 | Lafayette
!  State Hwy 238                      | ((-122.098,37.908),(-122.0983,37.907),(-122.099,37.905),(-122.101,37.898),(-122.101535,37.89711),(-122.103173,37.89438),(-122.1046,37.892),(-122.106,37.89))                                                                                                                                                                                                                                                                                 | Berkeley
!  State Hwy 238                 Ramp | [(-122.1288,37.9),(-122.1293,37.895),(-122.1296,37.906)]                                                                                                                                                                                                                                                                                                                                                                                     | Berkeley
!  State Hwy 24                       | [(-122.2674,37.246),(-122.2673,37.248),(-122.267,37.261),(-122.2668,37.271),(-122.2663,37.298),(-122.2659,37.315),(-122.2655,37.336),(-122.265007,37.35882),(-122.264443,37.37286),(-122.2641,37.381),(-122.2638,37.388),(-122.2631,37.396),(-122.2617,37.405),(-122.2615,37.407),(-122.2605,37.412)]                                                                                                                                        | Lafayette
!  State Hwy 84                       | [(-121.9565,37.898),(-121.956589,37.89911),(-121.9569,37.903),(-121.956,37.91),(-121.9553,37.919)]                                                                                                                                                                                                                                                                                                                                           | Oakland
!  State Hwy 84                       | [(-122.0671,37.426),(-122.07,37.402),(-122.074,37.37),(-122.0773,37.338)]                                                                                                                                                                                                                                                                                                                                                                    | Oakland
!  State Hwy 92                       | [(-122.1085,37.326),(-122.1095,37.322),(-122.1111,37.316),(-122.1119,37.313),(-122.1125,37.311),(-122.1131,37.308),(-122.1167,37.292),(-122.1187,37.285),(-122.12,37.28)]                                                                                                                                                                                                                                                                    | Oakland
!  State Hwy 92                  Ramp | [(-122.1086,37.321),(-122.1089,37.315),(-122.1111,37.316)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Stuart                        St   | [(-122.2518,37.6),(-122.2507,37.601),(-122.2491,37.606)]                                                                                                                                                                                                                                                                                                                                                                                     | Berkeley
!  Sunol Ridge                   Trl  | [(-121.9419,37.455),(-121.9345,37.38)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Sunol Ridge                   Trl  | [(-121.9419,37.455),(-121.9345,37.38)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Tassajara Creek                    | [(-121.87866,37.98898),(-121.8782,37.015)]                                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Tassajara Creek                    | [(-121.87866,37.98898),(-121.8782,37.015)]                                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Taurus                        Ave  | [(-122.2159,37.416),(-122.2128,37.389)]                                                                                                                                                                                                                                                                                                                                                                                                      | Lafayette
!  Tennyson                      Road | [(-122.0891,37.317),(-122.0927,37.317)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Thackeray                     Ave  | [(-122.072,37.305),(-122.0715,37.298)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Theresa                       Way  | [(-121.7289,37.906),(-121.728,37.899)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  Tissiack                      Way  | [(-121.920364,37),(-121.9208,37.995)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Tissiack                      Way  | [(-121.920364,37),(-121.9208,37.995)]                                                                                                                                                                                                                                                                                                                                                                                                        | Oakland
!  Tupelo                        Ter  | [(-122.059087,37.6113),(-122.057021,37.59942)]                                                                                                                                                                                                                                                                                                                                                                                               | Berkeley
!  Vallecitos                    Road | [(-121.8699,37.916),(-121.8703,37.891)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Warm Springs                  Blvd | [(-121.933956,37),(-121.9343,37.97)]                                                                                                                                                                                                                                                                                                                                                                                                         | Oakland
!  Warm Springs                  Blvd | [(-121.933956,37),(-121.9343,37.97)]                                                                                                                                                                                                                                                                                                                                                                                                         | Oakland
!  Welch Creek                   Road | [(-121.7695,37.386),(-121.7737,37.413)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Welch Creek                   Road | [(-121.7695,37.386),(-121.7737,37.413)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  West Loop                     Road | [(-122.0576,37.604),(-122.0602,37.586)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Western Pacific Railroad Spur      | [(-122.0394,37.018),(-122.0394,37.961)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Western Pacific Railroad Spur      | [(-122.0394,37.018),(-122.0394,37.961)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Western Pacific Railroad Spur      | [(-122.0394,37.018),(-122.0394,37.961)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  Whitlock Creek                     | [(-121.74683,37.91276),(-121.733107,37)]                                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Whitlock Creek                     | [(-121.74683,37.91276),(-121.733107,37)]                                                                                                                                                                                                                                                                                                                                                                                                     | Oakland
!  Willimet                      Way  | [(-122.0964,37.517),(-122.0949,37.493)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  Wisconsin                     St   | [(-122.1994,37.017),(-122.1975,37.998),(-122.1971,37.994)]                                                                                                                                                                                                                                                                                                                                                                                   | Oakland
!  Wisconsin                     St   | [(-122.1994,37.017),(-122.1975,37.998),(-122.1971,37.994)]                                                                                                                                                                                                                                                                                                                                                                                   | Berkeley
!  Wp Railroad                        | [(-122.254,37.902),(-122.2506,37.891)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  100th                         Ave  | [(-122.1657,37.429),(-122.1647,37.432)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  107th                         Ave  | [(-122.1555,37.403),(-122.1531,37.41)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  14th                          St   | [(-122.299,37.147),(-122.3,37.148)]                                                                                                                                                                                                                                                                                                                                                                                                          | Lafayette
!  19th                          Ave  | [(-122.2366,37.897),(-122.2359,37.905)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  1st                           St   | [(-121.75508,37.89294),(-121.753581,37.90031)]                                                                                                                                                                                                                                                                                                                                                                                               | Oakland
!  5th                           St   | [(-122.278,37),(-122.2792,37.005),(-122.2803,37.009)]                                                                                                                                                                                                                                                                                                                                                                                        | Lafayette
!  5th                           St   | [(-122.296,37.615),(-122.2953,37.598)]                                                                                                                                                                                                                                                                                                                                                                                                       | Berkeley
!  82nd                          Ave  | [(-122.1695,37.596),(-122.1681,37.603)]                                                                                                                                                                                                                                                                                                                                                                                                      | Berkeley
!  85th                          Ave  | [(-122.1877,37.466),(-122.186,37.476)]                                                                                                                                                                                                                                                                                                                                                                                                       | Oakland
!  89th                          Ave  | [(-122.1822,37.459),(-122.1803,37.471)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  98th                          Ave  | [(-122.1568,37.498),(-122.1558,37.502)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  98th                          Ave  | [(-122.1693,37.438),(-122.1682,37.444)]                                                                                                                                                                                                                                                                                                                                                                                                      | Oakland
!  98th                          Ave  | [(-122.2001,37.258),(-122.1974,37.27)]                                                                                                                                                                                                                                                                                                                                                                                                       | Lafayette
! (333 rows)
! 
! SELECT name, #thepath FROM iexit ORDER BY 1, 2;
!                 name                | ?column? 
! ------------------------------------+----------
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        2
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        3
!  I- 580                             |        4
!  I- 580                             |        4
!  I- 580                             |        4
!  I- 580                             |        4
!  I- 580                             |        5
!  I- 580                             |        5
!  I- 580                             |        5
!  I- 580                             |        5
!  I- 580                             |        5
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        6
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        7
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        8
!  I- 580                             |        9
!  I- 580                             |        9
!  I- 580                             |        9
!  I- 580                             |        9
!  I- 580                             |        9
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       12
!  I- 580                             |       13
!  I- 580                             |       13
!  I- 580                             |       13
!  I- 580                             |       13
!  I- 580                             |       13
!  I- 580                             |       13
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       14
!  I- 580                             |       18
!  I- 580                             |       18
!  I- 580                             |       18
!  I- 580                             |       18
!  I- 580                             |       18
!  I- 580                             |       18
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       21
!  I- 580                             |       22
!  I- 580                             |       22
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        2
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        3
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        4
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        5
!  I- 580                        Ramp |        6
!  I- 580                        Ramp |        6
!  I- 580                        Ramp |        6
!  I- 580                        Ramp |        7
!  I- 580                        Ramp |        8
!  I- 580                        Ramp |        8
!  I- 580                        Ramp |        8
!  I- 580                        Ramp |        8
!  I- 580                        Ramp |        8
!  I- 580                        Ramp |        8
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        2
!  I- 580/I-680                  Ramp |        4
!  I- 580/I-680                  Ramp |        4
!  I- 580/I-680                  Ramp |        4
!  I- 580/I-680                  Ramp |        4
!  I- 580/I-680                  Ramp |        5
!  I- 580/I-680                  Ramp |        6
!  I- 580/I-680                  Ramp |        6
!  I- 580/I-680                  Ramp |        6
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        2
!  I- 680                             |        3
!  I- 680                             |        3
!  I- 680                             |        3
!  I- 680                             |        4
!  I- 680                             |        4
!  I- 680                             |        4
!  I- 680                             |        5
!  I- 680                             |        5
!  I- 680                             |        5
!  I- 680                             |        7
!  I- 680                             |        7
!  I- 680                             |        7
!  I- 680                             |        7
!  I- 680                             |        8
!  I- 680                             |        8
!  I- 680                             |        8
!  I- 680                             |        8
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       10
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                             |       16
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        2
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        3
!  I- 680                        Ramp |        4
!  I- 680                        Ramp |        4
!  I- 680                        Ramp |        4
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        5
!  I- 680                        Ramp |        6
!  I- 680                        Ramp |        6
!  I- 680                        Ramp |        6
!  I- 680                        Ramp |        6
!  I- 680                        Ramp |        7
!  I- 680                        Ramp |        7
!  I- 680                        Ramp |        7
!  I- 680                        Ramp |        7
!  I- 680                        Ramp |        8
!  I- 680                        Ramp |        8
!  I- 680                        Ramp |        8
!  I- 680                        Ramp |        8
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        2
!  I- 80                              |        3
!  I- 80                              |        3
!  I- 80                              |        3
!  I- 80                              |        4
!  I- 80                              |        4
!  I- 80                              |        4
!  I- 80                              |        4
!  I- 80                              |        4
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |        5
!  I- 80                              |       11
!  I- 80                              |       11
!  I- 80                              |       11
!  I- 80                              |       11
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        2
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        3
!  I- 80                         Ramp |        4
!  I- 80                         Ramp |        4
!  I- 80                         Ramp |        4
!  I- 80                         Ramp |        4
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        5
!  I- 80                         Ramp |        7
!  I- 80                         Ramp |        7
!  I- 80                         Ramp |        7
!  I- 80                         Ramp |        7
!  I- 880                             |        2
!  I- 880                             |        2
!  I- 880                             |        2
!  I- 880                             |        2
!  I- 880                             |        2
!  I- 880                             |        5
!  I- 880                             |        5
!  I- 880                             |        5
!  I- 880                             |        5
!  I- 880                             |        5
!  I- 880                             |        5
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        6
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        7
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |        9
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       10
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       12
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       13
!  I- 880                             |       14
!  I- 880                             |       14
!  I- 880                             |       14
!  I- 880                             |       14
!  I- 880                             |       14
!  I- 880                             |       14
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       17
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                             |       19
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        2
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        3
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        4
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        5
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        6
!  I- 880                        Ramp |        8
!  I- 880                        Ramp |        8
!  I- 880                        Ramp |        8
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        2
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        3
!  I- 980                             |        4
!  I- 980                             |        4
!  I- 980                             |        5
!  I- 980                             |        5
!  I- 980                             |        7
!  I- 980                             |        7
!  I- 980                             |        7
!  I- 980                             |        7
!  I- 980                             |       12
!  I- 980                        Ramp |        3
!  I- 980                        Ramp |        3
!  I- 980                        Ramp |        3
!  I- 980                        Ramp |        7
! (896 rows)
! 
! SELECT * FROM toyemp WHERE name = 'sharon';
!   name  | age | location | annualsal 
! --------+-----+----------+-----------
!  sharon |  25 | (15,12)  |     12000
! (1 row)
! 
! --
! -- Test for Leaky view scenario
! --
! CREATE ROLE regress_alice;
! CREATE FUNCTION f_leak (text)
!        RETURNS bool LANGUAGE 'plpgsql' COST 0.0000001
!        AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END';
! CREATE TABLE customer (
!        cid      int primary key,
!        name     text not null,
!        tel      text,
!        passwd	text
! );
! CREATE TABLE credit_card (
!        cid      int references customer(cid),
!        cnum     text,
!        climit   int
! );
! CREATE TABLE credit_usage (
!        cid      int references customer(cid),
!        ymd      date,
!        usage    int
! );
! INSERT INTO customer
!        VALUES (101, 'regress_alice', '+81-12-3456-7890', 'passwd123'),
!               (102, 'regress_bob',   '+01-234-567-8901', 'beafsteak'),
!               (103, 'regress_eve',   '+49-8765-43210',   'hamburger');
! INSERT INTO credit_card
!        VALUES (101, '1111-2222-3333-4444', 4000),
!               (102, '5555-6666-7777-8888', 3000),
!               (103, '9801-2345-6789-0123', 2000);
! INSERT INTO credit_usage
!        VALUES (101, '2011-09-15', 120),
! 	      (101, '2011-10-05',  90),
! 	      (101, '2011-10-18', 110),
! 	      (101, '2011-10-21', 200),
! 	      (101, '2011-11-10',  80),
! 	      (102, '2011-09-22', 300),
! 	      (102, '2011-10-12', 120),
! 	      (102, '2011-10-28', 200),
! 	      (103, '2011-10-15', 480);
! CREATE VIEW my_property_normal AS
!        SELECT * FROM customer WHERE name = current_user;
! CREATE VIEW my_property_secure WITH (security_barrier) AS
!        SELECT * FROM customer WHERE name = current_user;
! CREATE VIEW my_credit_card_normal AS
!        SELECT * FROM customer l NATURAL JOIN credit_card r
!        WHERE l.name = current_user;
! CREATE VIEW my_credit_card_secure WITH (security_barrier) AS
!        SELECT * FROM customer l NATURAL JOIN credit_card r
!        WHERE l.name = current_user;
! CREATE VIEW my_credit_card_usage_normal AS
!        SELECT * FROM my_credit_card_secure l NATURAL JOIN credit_usage r;
! CREATE VIEW my_credit_card_usage_secure WITH (security_barrier) AS
!        SELECT * FROM my_credit_card_secure l NATURAL JOIN credit_usage r;
! GRANT SELECT ON my_property_normal TO public;
! GRANT SELECT ON my_property_secure TO public;
! GRANT SELECT ON my_credit_card_normal TO public;
! GRANT SELECT ON my_credit_card_secure TO public;
! GRANT SELECT ON my_credit_card_usage_normal TO public;
! GRANT SELECT ON my_credit_card_usage_secure TO public;
! --
! -- Run leaky view scenarios
! --
! SET SESSION AUTHORIZATION regress_alice;
! --
! -- scenario: if a qualifier with tiny-cost is given, it shall be launched
! --           prior to the security policy of the view.
! --
! SELECT * FROM my_property_normal WHERE f_leak(passwd);
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f_leak(passwd);
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Seq Scan on customer
!    Filter: (f_leak(passwd) AND (name = ("current_user"())::text))
! (2 rows)
! 
! SELECT * FROM my_property_secure WHERE f_leak(passwd);
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f_leak(passwd);
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Subquery Scan on my_property_secure
!    Filter: f_leak(my_property_secure.passwd)
!    ->  Seq Scan on customer
!          Filter: (name = ("current_user"())::text)
! (4 rows)
! 
! --
! -- scenario: if a qualifier references only one-side of a particular join-
! --           tree, it shall be distributed to the most deep scan plan as
! --           possible as we can.
! --
! SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 5555-6666-7777-8888
! NOTICE:  f_leak => 9801-2345-6789-0123
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!                        QUERY PLAN                        
! ---------------------------------------------------------
!  Hash Join
!    Hash Cond: (r.cid = l.cid)
!    ->  Seq Scan on credit_card r
!          Filter: f_leak(cnum)
!    ->  Hash
!          ->  Seq Scan on customer l
!                Filter: (name = ("current_user"())::text)
! (7 rows)
! 
! SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Subquery Scan on my_credit_card_secure
!    Filter: f_leak(my_credit_card_secure.cnum)
!    ->  Hash Join
!          Hash Cond: (r.cid = l.cid)
!          ->  Seq Scan on credit_card r
!          ->  Hash
!                ->  Seq Scan on customer l
!                      Filter: (name = ("current_user"())::text)
! (8 rows)
! 
! --
! -- scenario: an external qualifier can be pushed-down by in-front-of the
! --           views with "security_barrier" attribute, except for operators
! --           implemented with leakproof functions.
! --
! SELECT * FROM my_credit_card_usage_normal
!        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-05-2011 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-18-2011 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-21-2011 |   200
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal
!        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                   QUERY PLAN                                  
! ------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (l.cid = r.cid)
!    ->  Seq Scan on credit_usage r
!          Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
!    ->  Materialize
!          ->  Subquery Scan on l
!                Filter: f_leak(l.cnum)
!                ->  Hash Join
!                      Hash Cond: (r_1.cid = l_1.cid)
!                      ->  Seq Scan on credit_card r_1
!                      ->  Hash
!                            ->  Seq Scan on customer l_1
!                                  Filter: (name = ("current_user"())::text)
! (13 rows)
! 
! SELECT * FROM my_credit_card_usage_secure
!        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-05-2011 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-18-2011 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-21-2011 |   200
! (3 rows)
! 
! EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure
!        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Subquery Scan on my_credit_card_usage_secure
!    Filter: f_leak(my_credit_card_usage_secure.cnum)
!    ->  Nested Loop
!          Join Filter: (l.cid = r.cid)
!          ->  Seq Scan on credit_usage r
!                Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
!          ->  Materialize
!                ->  Hash Join
!                      Hash Cond: (r_1.cid = l.cid)
!                      ->  Seq Scan on credit_card r_1
!                      ->  Hash
!                            ->  Seq Scan on customer l
!                                  Filter: (name = ("current_user"())::text)
! (13 rows)
! 
! --
! -- Test for the case when security_barrier gets changed between rewriter
! -- and planner stage.
! --
! PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
! PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(passwd);
! EXECUTE p1;
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! EXECUTE p2;
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! RESET SESSION AUTHORIZATION;
! ALTER VIEW my_property_normal SET (security_barrier=true);
! ALTER VIEW my_property_secure SET (security_barrier=false);
! SET SESSION AUTHORIZATION regress_alice;
! EXECUTE p1;		-- To be perform as a view with security-barrier
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! EXECUTE p2;		-- To be perform as a view without security-barrier
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
! -- Cleanup.
! RESET SESSION AUTHORIZATION;
! DROP ROLE regress_alice;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/portals_p2.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/portals_p2.out	2015-01-26 12:33:25.935031414 +0300
***************
*** 1,122 ****
! --
! -- PORTALS_P2
! --
! BEGIN;
! DECLARE foo13 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 50;
! DECLARE foo14 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 51;
! DECLARE foo15 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 52;
! DECLARE foo16 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 53;
! DECLARE foo17 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 54;
! DECLARE foo18 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 55;
! DECLARE foo19 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 56;
! DECLARE foo20 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 57;
! DECLARE foo21 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 58;
! DECLARE foo22 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 59;
! DECLARE foo23 CURSOR FOR
!    SELECT * FROM onek WHERE unique1 = 60;
! DECLARE foo24 CURSOR FOR
!    SELECT * FROM onek2 WHERE unique1 = 50;
! DECLARE foo25 CURSOR FOR
!    SELECT * FROM onek2 WHERE unique1 = 60;
! FETCH all in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       50 |     253 |   0 |    2 |   0 |     10 |       0 |       50 |          50 |        50 |       50 |   0 |    1 | YBAAAA   | TJAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       51 |      76 |   1 |    3 |   1 |     11 |       1 |       51 |          51 |        51 |       51 |   2 |    3 | ZBAAAA   | YCAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       52 |     985 |   0 |    0 |   2 |     12 |       2 |       52 |          52 |        52 |       52 |   4 |    5 | ACAAAA   | XLBAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       53 |     196 |   1 |    1 |   3 |     13 |       3 |       53 |          53 |        53 |       53 |   6 |    7 | BCAAAA   | OHAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       54 |     356 |   0 |    2 |   4 |     14 |       4 |       54 |          54 |        54 |       54 |   8 |    9 | CCAAAA   | SNAAAA   | AAAAxx
! (1 row)
! 
! FETCH all in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       55 |     627 |   1 |    3 |   5 |     15 |       5 |       55 |          55 |        55 |       55 |  10 |   11 | DCAAAA   | DYAAAA   | VVVVxx
! (1 row)
! 
! FETCH all in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       56 |      54 |   0 |    0 |   6 |     16 |       6 |       56 |          56 |        56 |       56 |  12 |   13 | ECAAAA   | CCAAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       57 |     942 |   1 |    1 |   7 |     17 |       7 |       57 |          57 |        57 |       57 |  14 |   15 | FCAAAA   | GKBAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       58 |     114 |   0 |    2 |   8 |     18 |       8 |       58 |          58 |        58 |       58 |  16 |   17 | GCAAAA   | KEAAAA   | OOOOxx
! (1 row)
! 
! FETCH all in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       59 |     593 |   1 |    3 |   9 |     19 |       9 |       59 |          59 |        59 |       59 |  18 |   19 | HCAAAA   | VWAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       60 |     483 |   0 |    0 |   0 |      0 |       0 |       60 |          60 |        60 |       60 |   0 |    1 | ICAAAA   | PSAAAA   | VVVVxx
! (1 row)
! 
! FETCH all in foo24;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       50 |     253 |   0 |    2 |   0 |     10 |       0 |       50 |          50 |        50 |       50 |   0 |    1 | YBAAAA   | TJAAAA   | HHHHxx
! (1 row)
! 
! FETCH all in foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       60 |     483 |   0 |    0 |   0 |      0 |       0 |       60 |          60 |        60 |       60 |   0 |    1 | ICAAAA   | PSAAAA   | VVVVxx
! (1 row)
! 
! CLOSE foo13;
! CLOSE foo14;
! CLOSE foo15;
! CLOSE foo16;
! CLOSE foo17;
! CLOSE foo18;
! CLOSE foo19;
! CLOSE foo20;
! CLOSE foo21;
! CLOSE foo22;
! CLOSE foo23;
! CLOSE foo24;
! CLOSE foo25;
! END;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/foreign_key.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/foreign_key.out	2015-01-26 12:33:25.943031414 +0300
***************
*** 1,1356 ****
! --
! -- FOREIGN KEY
! --
! -- MATCH FULL
! --
! -- First test, check and cascade
! --
! CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
! CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 'Test1');
! INSERT INTO PKTABLE VALUES (2, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2);
! INSERT INTO FKTABLE VALUES (2, 3);
! INSERT INTO FKTABLE VALUES (3, 4);
! INSERT INTO FKTABLE VALUES (NULL, 1);
! -- Insert a failed row into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1;
! -- Check FKTABLE for removal of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       2 |      3
!       3 |      4
!         |      1
! (3 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       3 |      4
!         |      1
!       1 |      3
! (3 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! --
! -- check set NULL and table constraint on multiple columns
! --
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)
!                        REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
! -- Test comments
! COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
! ERROR:  constraint "constrname_wrong" for table "fktable" does not exist
! COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
! COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
! INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
! INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2, 4);
! INSERT INTO FKTABLE VALUES (1, 3, 5);
! INSERT INTO FKTABLE VALUES (2, 4, 8);
! INSERT INTO FKTABLE VALUES (3, 6, 12);
! INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
! -- Insert failed rows into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
! -- Check FKTABLE for removal of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
! -- Delete another row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
! -- Check FKTABLE (should be no change)
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
! -- Try altering the column type where foreign keys are involved
! ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
! ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 | ptest3  
! --------+--------+---------
!       1 |      3 | Test1-2
!       3 |      6 | Test3
!       4 |      8 | Test4
!       1 |      4 | Test2
! (4 rows)
! 
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
! DROP TABLE PKTABLE CASCADE;
! NOTICE:  drop cascades to constraint constrname on table fktable
! DROP TABLE FKTABLE;
! --
! -- check set default and table constraint on multiple columns
! --
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)
!                        REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
! -- Insert a value in PKTABLE for default
! INSERT INTO PKTABLE VALUES (-1, -2, 'The Default!');
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
! INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
! INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2, 4);
! INSERT INTO FKTABLE VALUES (1, 3, 5);
! INSERT INTO FKTABLE VALUES (2, 4, 8);
! INSERT INTO FKTABLE VALUES (3, 6, 12);
! INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
! -- Insert failed rows into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
! INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
! -- Delete a row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
! -- Check FKTABLE to check for removal
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
! (5 rows)
! 
! -- Delete another row from PK TABLE
! DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
! -- Check FKTABLE (should be no change)
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
! (5 rows)
! 
! -- Update a row from PK TABLE
! UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
! -- Check FKTABLE for update of matched row
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!      -1 |     -2 |      4
!      -1 |     -2 |      8
! (5 rows)
! 
! -- this should fail for lack of CASCADE
! DROP TABLE PKTABLE;
! ERROR:  cannot drop table pktable because other objects depend on it
! DETAIL:  constraint constrname2 on table fktable depends on table pktable
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TABLE PKTABLE CASCADE;
! NOTICE:  drop cascades to constraint constrname2 on table fktable
! DROP TABLE FKTABLE;
! --
! -- First test, check with no on delete or on update
! --
! CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
! CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL, ftest2 int );
! -- Insert test data into PKTABLE
! INSERT INTO PKTABLE VALUES (1, 'Test1');
! INSERT INTO PKTABLE VALUES (2, 'Test2');
! INSERT INTO PKTABLE VALUES (3, 'Test3');
! INSERT INTO PKTABLE VALUES (4, 'Test4');
! INSERT INTO PKTABLE VALUES (5, 'Test5');
! -- Insert successful rows into FK TABLE
! INSERT INTO FKTABLE VALUES (1, 2);
! INSERT INTO FKTABLE VALUES (2, 3);
! INSERT INTO FKTABLE VALUES (3, 4);
! INSERT INTO FKTABLE VALUES (NULL, 1);
! -- Insert a failed row into FK TABLE
! INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
! -- Check FKTABLE
! SELECT * FROM FKTABLE;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
! -- Check PKTABLE
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       4 | Test4
!       5 | Test5
! (5 rows)
! 
! -- Delete a row from PK TABLE (should fail)
! DELETE FROM PKTABLE WHERE ptest1=1;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (ptest1)=(1) is still referenced from table "fktable".
! -- Delete a row from PK TABLE (should succeed)
! DELETE FROM PKTABLE WHERE ptest1=5;
! -- Check PKTABLE for deletes
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       4 | Test4
! (4 rows)
! 
! -- Update a row from PK TABLE (should fail)
! UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (ptest1)=(2) is still referenced from table "fktable".
! -- Update a row from PK TABLE (should succeed)
! UPDATE PKTABLE SET ptest1=0 WHERE ptest1=4;
! -- Check PKTABLE for updates
! SELECT * FROM PKTABLE;
!  ptest1 | ptest2 
! --------+--------
!       1 | Test1
!       2 | Test2
!       3 | Test3
!       0 | Test4
! (4 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- MATCH SIMPLE
! -- Base test restricting update/delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! -- Try to update something that should fail
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
! DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
! -- Try to update something that should succeed
! UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
! -- Try to delete something that should fail
! DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
! DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
! -- Try to delete something that should work
! DELETE FROM PKTABLE where ptest1=2;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       1 |      2 |      3 | test1
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- cascade update/delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE CASCADE ON UPDATE CASCADE);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
! -- Try to update something that will cascade
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! -- Try to update something that should not cascade
! UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       1 |      5 |      3 |      1
! (5 rows)
! 
! -- Try to delete something that should cascade
! DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
! -- Try to delete something that should not have a cascade
! DELETE FROM PKTABLE where ptest1=2;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       1 |      3 |      3 | test2
!       1 |      3 |      4 | test3
! (2 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- set null update / set default delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE SET DEFAULT ON UPDATE SET NULL);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (6 rows)
! 
! -- Try to update something that will set null
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! -- Try to update something that should not set null
! UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      3 |      4 | test3
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      2 |      3 | test2
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (6 rows)
! 
! -- Try to delete something that should set default
! DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      5 |      3 | test1
!       1 |      2 |      3 | test2
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
!       0 |        |        |      1
! (6 rows)
! 
! -- Try to delete something that should not set default
! DELETE FROM PKTABLE where ptest2=5;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      4 |      5 | test4
!       1 |      2 |      3 | test2
! (2 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
!       0 |        |        |      1
! (6 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- set default update / set null delete
! CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
! CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3
! 			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
! 			ON DELETE SET NULL ON UPDATE SET DEFAULT);
! -- Insert Primary Key values
! INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
! INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
! INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
! INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
! INSERT INTO PKTABLE VALUES (2, -1, 5, 'test5');
! -- Insert Foreign Key values
! INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
! INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
! INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
! INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
! INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
! INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
! INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
! -- Insert a failed values
! INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
! -- Show FKTABLE
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!       2 |      4 |      5 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (7 rows)
! 
! -- Try to update something that will fail
! UPDATE PKTABLE set ptest2=5 where ptest2=2;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(0, -1, -2) is not present in table "pktable".
! -- Try to update something that will set default
! UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
! UPDATE PKTABLE set ptest2=10 where ptest2=4;
! -- Try to update something that should not set default
! UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |      3 |      4 | test3
!       2 |     -1 |      5 | test5
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (5 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |      3 |      4 |      1
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
! (7 rows)
! 
! -- Try to delete something that should set null
! DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       2 |     -1 |      5 | test5
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (4 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!         |        |        |      1
! (7 rows)
! 
! -- Try to delete something that should not set null
! DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
! -- Show PKTABLE and FKTABLE
! SELECT * from PKTABLE;
!  ptest1 | ptest2 | ptest3 | ptest4 
! --------+--------+--------+--------
!       0 |     -1 |     -2 | test1
!       2 |     10 |      5 | test4
!       1 |      2 |      3 | test2
! (3 rows)
! 
! SELECT * from FKTABLE;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!         |      2 |      3 |      2
!       2 |        |      3 |      3
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!         |        |        |      1
! (7 rows)
! 
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
! CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
! ERROR:  column "ftest2" referenced in foreign key constraint does not exist
! CREATE TABLE FKTABLE_FAIL2 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest1) REFERENCES PKTABLE(ptest2));
! ERROR:  column "ptest2" referenced in foreign key constraint does not exist
! DROP TABLE FKTABLE_FAIL1;
! ERROR:  table "fktable_fail1" does not exist
! DROP TABLE FKTABLE_FAIL2;
! ERROR:  table "fktable_fail2" does not exist
! DROP TABLE PKTABLE;
! -- Test for referencing column number smaller than referenced constraint
! CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
! CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
! ERROR:  there is no unique constraint matching given keys for referenced table "pktable"
! DROP TABLE FKTABLE_FAIL1;
! ERROR:  table "fktable_fail1" does not exist
! DROP TABLE PKTABLE;
! --
! -- Tests for mismatched types
! --
! -- Basic one column, two table setup
! CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! -- This next should fail, because int=inet does not exist
! CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! -- This should also fail for the same reason, but here we
! -- give the column name
! CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! -- This should succeed, even though they are different types,
! -- because int=int8 exists and is a member of the integer opfamily
! CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable);
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
! UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! -- This should fail, because we'd have to cast numeric to int which is
! -- not an implicit coercion (or use numeric=numeric, but that's not part
! -- of the integer opfamily)
! CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
! DROP TABLE PKTABLE;
! -- On the other hand, this should work because int implicitly promotes to
! -- numeric, and we allow promotion on the FK side
! CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! CREATE TABLE FKTABLE (ftest1 int REFERENCES pktable);
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
! UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- Two columns, two tables
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2));
! -- This should fail, because we just chose really odd types
! CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! -- Again, so should this...
! CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! -- This fails because we mixed up the column ordering
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
! -- As does this...
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
! -- And again..
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
! -- This works...
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1));
! DROP TABLE FKTABLE;
! -- As does this
! CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- Two columns, same table
! -- Make sure this still works...
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable(ptest1, ptest2));
! DROP TABLE PKTABLE;
! -- And this,
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable);
! DROP TABLE PKTABLE;
! -- This shouldn't (mixed up columns)
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
! ptest4) REFERENCES pktable(ptest2, ptest1));
! ERROR:  foreign key constraint "pktable_ptest3_fkey" cannot be implemented
! DETAIL:  Key columns "ptest3" and "ptest2" are of incompatible types: integer and inet.
! -- Nor should this... (same reason, we have 4,3 referencing 1,2 which mismatches types
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
! ptest3) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
! -- Not this one either... Same as the last one except we didn't defined the columns being referenced.
! CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
! ptest3) REFERENCES pktable);
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
! --
! -- Now some cases with inheritance
! -- Basic 2 table case: 1 column of matching types.
! create table pktable_base (base1 int not null);
! create table pktable (ptest1 int, primary key(base1), unique(base1, ptest1)) inherits (pktable_base);
! create table fktable (ftest1 int references pktable(base1));
! -- now some ins, upd, del
! insert into pktable(base1) values (1);
! insert into pktable(base1) values (2);
! --  let's insert a non-existent fktable value
! insert into fktable(ftest1) values (3);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(3) is not present in table "pktable".
! --  let's make a valid row for that
! insert into pktable(base1) values (3);
! insert into fktable(ftest1) values (3);
! -- let's try removing a row that should fail from pktable
! delete from pktable where base1>2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
! -- okay, let's try updating all of the base1 values to *4
! -- which should fail.
! update pktable set base1=base1*4;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
! -- okay, let's try an update that should work.
! update pktable set base1=base1*4 where base1<3;
! -- and a delete that should work
! delete from pktable where base1>3;
! -- cleanup
! drop table fktable;
! delete from pktable;
! -- Now 2 columns 2 tables, matching types
! create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
! -- now some ins, upd, del
! insert into pktable(base1, ptest1) values (1, 1);
! insert into pktable(base1, ptest1) values (2, 2);
! --  let's insert a non-existent fktable value
! insert into fktable(ftest1, ftest2) values (3, 1);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1, ftest2)=(3, 1) is not present in table "pktable".
! --  let's make a valid row for that
! insert into pktable(base1,ptest1) values (3, 1);
! insert into fktable(ftest1, ftest2) values (3, 1);
! -- let's try removing a row that should fail from pktable
! delete from pktable where base1>2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
! -- okay, let's try updating all of the base1 values to *4
! -- which should fail.
! update pktable set base1=base1*4;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
! DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
! -- okay, let's try an update that should work.
! update pktable set base1=base1*4 where base1<3;
! -- and a delete that should work
! delete from pktable where base1>3;
! -- cleanup
! drop table fktable;
! drop table pktable;
! drop table pktable_base;
! -- Now we'll do one all in 1 table with 2 columns of matching types
! create table pktable_base(base1 int not null, base2 int);
! create table pktable(ptest1 int, ptest2 int, primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);
! insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);
! -- fails (3,2) isn't in base1, ptest1
! insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
! ERROR:  insert or update on table "pktable" violates foreign key constraint "pktable_base2_fkey"
! DETAIL:  Key (base2, ptest2)=(3, 2) is not present in table "pktable".
! -- fails (2,2) is being referenced
! delete from pktable where base1=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(2, 2) is still referenced from table "pktable".
! -- fails (1,1) is being referenced (twice)
! update pktable set base1=3 where base1=1;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(1, 1) is still referenced from table "pktable".
! -- this sequence of two deletes will work, since after the first there will be no (2,*) references
! delete from pktable where base2=2;
! delete from pktable where base1=2;
! drop table pktable;
! drop table pktable_base;
! -- 2 columns (2 tables), mismatched types
! create table pktable_base(base1 int not null);
! create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
! -- just generally bad types (with and without column references on the referenced table)
! create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
! create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
! -- let's mix up which columns reference which
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable);
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1));
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
! create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: integer and inet.
! drop table pktable;
! drop table pktable_base;
! -- 2 columns (1 table), mismatched types
! create table pktable_base(base1 int not null, base2 int);
! create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_base2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "ptest1" are of incompatible types: inet[] and inet.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(base2, ptest2) references
!                                              pktable(ptest1, base1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_base2_fkey" cannot be implemented
! DETAIL:  Key columns "base2" and "ptest1" are of incompatible types: integer and inet.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_ptest2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
! create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
!                                              pktable(base1, ptest1)) inherits (pktable_base);
! ERROR:  foreign key constraint "pktable_ptest2_fkey" cannot be implemented
! DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
! drop table pktable;
! ERROR:  table "pktable" does not exist
! drop table pktable_base;
! --
! -- Deferrable constraints
! --		(right now, only FOREIGN KEY constraints can be deferred)
! --
! -- deferrable, explicitly deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE
! );
! -- default to immediate: should fail
! INSERT INTO fktable VALUES (5, 10);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(10) is not present in table "pktable".
! -- explicitly defer the constraint
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! INSERT INTO fktable VALUES (10, 15);
! INSERT INTO pktable VALUES (15, 0); -- make the FK insert valid
! COMMIT;
! DROP TABLE fktable, pktable;
! -- deferrable, initially deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
! );
! -- default to deferred, should succeed
! BEGIN;
! INSERT INTO fktable VALUES (100, 200);
! INSERT INTO pktable VALUES (200, 500); -- make the FK insert valid
! COMMIT;
! -- default to deferred, explicitly make immediate
! BEGIN;
! SET CONSTRAINTS ALL IMMEDIATE;
! -- should fail
! INSERT INTO fktable VALUES (500, 1000);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(1000) is not present in table "pktable".
! COMMIT;
! DROP TABLE fktable, pktable;
! -- tricky behavior: according to SQL99, if a deferred constraint is set
! -- to 'immediate' mode, it should be checked for validity *immediately*,
! -- not when the current transaction commits (i.e. the mode change applies
! -- retroactively)
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE
! );
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! -- should succeed, for now
! INSERT INTO fktable VALUES (1000, 2000);
! -- should cause transaction abort, due to preceding error
! SET CONSTRAINTS ALL IMMEDIATE;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(2000) is not present in table "pktable".
! INSERT INTO pktable VALUES (2000, 3); -- too late
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! COMMIT;
! DROP TABLE fktable, pktable;
! -- deferrable, initially deferred
! CREATE TABLE pktable (
! 	id		INT4 PRIMARY KEY,
! 	other	INT4
! );
! CREATE TABLE fktable (
! 	id		INT4 PRIMARY KEY,
! 	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
! );
! BEGIN;
! -- no error here
! INSERT INTO fktable VALUES (100, 200);
! -- error here on commit
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(200) is not present in table "pktable".
! DROP TABLE pktable, fktable;
! -- test notice about expensive referential integrity checks,
! -- where the index cannot be used because of type incompatibilities.
! CREATE TEMP TABLE pktable (
!         id1     INT4 PRIMARY KEY,
!         id2     VARCHAR(4) UNIQUE,
!         id3     REAL UNIQUE,
!         UNIQUE(id1, id2, id3)
! );
! CREATE TEMP TABLE fktable (
!         x1      INT4 REFERENCES pktable(id1),
!         x2      VARCHAR(4) REFERENCES pktable(id2),
!         x3      REAL REFERENCES pktable(id3),
!         x4      TEXT,
!         x5      INT2
! );
! -- check individual constraints with alter table.
! -- should fail
! -- varchar does not promote to real
! ALTER TABLE fktable ADD CONSTRAINT fk_2_3
! FOREIGN KEY (x2) REFERENCES pktable(id3);
! ERROR:  foreign key constraint "fk_2_3" cannot be implemented
! DETAIL:  Key columns "x2" and "id3" are of incompatible types: character varying and real.
! -- nor to int4
! ALTER TABLE fktable ADD CONSTRAINT fk_2_1
! FOREIGN KEY (x2) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_2_1" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
! -- real does not promote to int4
! ALTER TABLE fktable ADD CONSTRAINT fk_3_1
! FOREIGN KEY (x3) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_3_1" cannot be implemented
! DETAIL:  Key columns "x3" and "id1" are of incompatible types: real and integer.
! -- int4 does not promote to text
! ALTER TABLE fktable ADD CONSTRAINT fk_1_2
! FOREIGN KEY (x1) REFERENCES pktable(id2);
! ERROR:  foreign key constraint "fk_1_2" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
! -- should succeed
! -- int4 promotes to real
! ALTER TABLE fktable ADD CONSTRAINT fk_1_3
! FOREIGN KEY (x1) REFERENCES pktable(id3);
! -- text is compatible with varchar
! ALTER TABLE fktable ADD CONSTRAINT fk_4_2
! FOREIGN KEY (x4) REFERENCES pktable(id2);
! -- int2 is part of integer opfamily as of 8.0
! ALTER TABLE fktable ADD CONSTRAINT fk_5_1
! FOREIGN KEY (x5) REFERENCES pktable(id1);
! -- check multikey cases, especially out-of-order column lists
! -- these should work
! ALTER TABLE fktable ADD CONSTRAINT fk_123_123
! FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
! ALTER TABLE fktable ADD CONSTRAINT fk_213_213
! FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
! ALTER TABLE fktable ADD CONSTRAINT fk_253_213
! FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
! -- these should fail
! ALTER TABLE fktable ADD CONSTRAINT fk_123_231
! FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
! ERROR:  foreign key constraint "fk_123_231" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
! ALTER TABLE fktable ADD CONSTRAINT fk_241_132
! FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
! ERROR:  foreign key constraint "fk_241_132" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
! DROP TABLE pktable, fktable;
! -- test a tricky case: we can elide firing the FK check trigger during
! -- an UPDATE if the UPDATE did not change the foreign key
! -- field. However, we can't do this if our transaction was the one that
! -- created the updated row and the trigger is deferred, since our UPDATE
! -- will have invalidated the original newly-inserted tuple, and therefore
! -- cause the on-INSERT RI trigger not to be fired.
! CREATE TEMP TABLE pktable (
!     id int primary key,
!     other int
! );
! CREATE TEMP TABLE fktable (
!     id int primary key,
!     fk int references pktable deferrable initially deferred
! );
! -- check ALTER CONSTRAINT
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
! -- illegal option
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
! ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE
! LINE 1: ...e ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY ...
!                                                              ^
! -- reset
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY DEFERRED;
! INSERT INTO pktable VALUES (5, 10);
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! -- change the constraint definition and retest
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
! BEGIN;
! -- doesn't match PK, should throw error now
! INSERT INTO fktable VALUES (0, 20);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! COMMIT;
! -- reset
! ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY DEFERRED;
! -- check same case when insert is in a different subtransaction than update
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- UPDATE will be in a subxact
! SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! BEGIN;
! -- INSERT will be in a subxact
! SAVEPOINT savept1;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! RELEASE SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! BEGIN;
! -- doesn't match PK, but no error yet
! INSERT INTO fktable VALUES (0, 20);
! -- UPDATE will be in a subxact
! SAVEPOINT savept1;
! -- don't change FK
! UPDATE fktable SET id = id + 1;
! -- Roll back the UPDATE
! ROLLBACK TO savept1;
! -- should catch error from initial INSERT
! COMMIT;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
! -- test order of firing of FK triggers when several RI-induced changes need to
! -- be made to the same row.  This was broken by subtransaction-related
! -- changes in 8.0.
! CREATE TEMP TABLE users (
!   id INT PRIMARY KEY,
!   name VARCHAR NOT NULL
! );
! INSERT INTO users VALUES (1, 'Jozko');
! INSERT INTO users VALUES (2, 'Ferko');
! INSERT INTO users VALUES (3, 'Samko');
! CREATE TEMP TABLE tasks (
!   id INT PRIMARY KEY,
!   owner INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
!   worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
!   checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL
! );
! INSERT INTO tasks VALUES (1,1,NULL,NULL);
! INSERT INTO tasks VALUES (2,2,2,NULL);
! INSERT INTO tasks VALUES (3,3,3,3);
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     3 |      3 |          3
! (3 rows)
! 
! UPDATE users SET id = 4 WHERE id = 3;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     4 |      4 |          4
! (3 rows)
! 
! DELETE FROM users WHERE id = 4;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |       |        |           
! (3 rows)
! 
! -- could fail with only 2 changes to make, if row was already updated
! BEGIN;
! UPDATE tasks set id=id WHERE id=2;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   3 |       |        |           
!   2 |     2 |      2 |           
! (3 rows)
! 
! DELETE FROM users WHERE id = 2;
! SELECT * FROM tasks;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   3 |       |        |           
!   2 |       |        |           
! (3 rows)
! 
! COMMIT;
! --
! -- Test self-referential FK with CASCADE (bug #6268)
! --
! create temp table selfref (
!     a int primary key,
!     b int,
!     foreign key (b) references selfref (a)
!         on update cascade on delete cascade
! );
! insert into selfref (a, b)
! values
!     (0, 0),
!     (1, 1);
! begin;
!     update selfref set a = 123 where a = 0;
!     select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  123 | 123
! (2 rows)
! 
!     update selfref set a = 456 where a = 123;
!     select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  456 | 456
! (2 rows)
! 
! commit;
! --
! -- Test that SET DEFAULT actions recognize updates to default values
! --
! create temp table defp (f1 int primary key);
! create temp table defc (f1 int default 0
!                         references defp on delete set default);
! insert into defp values (0), (1), (2);
! insert into defc values (2);
! select * from defc;
!  f1 
! ----
!   2
! (1 row)
! 
! delete from defp where f1 = 2;
! select * from defc;
!  f1 
! ----
!   0
! (1 row)
! 
! delete from defp where f1 = 0; -- fail
! ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
! DETAIL:  Key (f1)=(0) is still referenced from table "defc".
! alter table defc alter column f1 set default 1;
! delete from defp where f1 = 0;
! select * from defc;
!  f1 
! ----
!   1
! (1 row)
! 
! delete from defp where f1 = 1; -- fail
! ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
! DETAIL:  Key (f1)=(1) is still referenced from table "defc".
! --
! -- Test the difference between NO ACTION and RESTRICT
! --
! create temp table pp (f1 int primary key);
! create temp table cc (f1 int references pp on update no action);
! insert into pp values(12);
! insert into pp values(11);
! update pp set f1=f1+1;
! insert into cc values(13);
! update pp set f1=f1+1;
! update pp set f1=f1+1; -- fail
! ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
! DETAIL:  Key (f1)=(13) is still referenced from table "cc".
! drop table pp, cc;
! create temp table pp (f1 int primary key);
! create temp table cc (f1 int references pp on update restrict);
! insert into pp values(12);
! insert into pp values(11);
! update pp set f1=f1+1;
! insert into cc values(13);
! update pp set f1=f1+1; -- fail
! ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
! DETAIL:  Key (f1)=(13) is still referenced from table "cc".
! drop table pp, cc;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/cluster.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/cluster.out	2015-01-26 12:33:25.963031415 +0300
***************
*** 1,447 ****
! --
! --  CLUSTER
! --
! CREATE TABLE clstr_tst_s (rf_a SERIAL PRIMARY KEY,
! 	b INT);
! CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,
! 	b INT,
! 	c TEXT,
! 	d TEXT,
! 	CONSTRAINT clstr_tst_con FOREIGN KEY (b) REFERENCES clstr_tst_s);
! CREATE INDEX clstr_tst_b ON clstr_tst (b);
! CREATE INDEX clstr_tst_c ON clstr_tst (c);
! CREATE INDEX clstr_tst_c_b ON clstr_tst (c,b);
! CREATE INDEX clstr_tst_b_c ON clstr_tst (b,c);
! INSERT INTO clstr_tst_s (b) VALUES (0);
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
! CREATE TABLE clstr_tst_inh () INHERITS (clstr_tst);
! INSERT INTO clstr_tst (b, c) VALUES (11, 'once');
! INSERT INTO clstr_tst (b, c) VALUES (10, 'diez');
! INSERT INTO clstr_tst (b, c) VALUES (31, 'treinta y uno');
! INSERT INTO clstr_tst (b, c) VALUES (22, 'veintidos');
! INSERT INTO clstr_tst (b, c) VALUES (3, 'tres');
! INSERT INTO clstr_tst (b, c) VALUES (20, 'veinte');
! INSERT INTO clstr_tst (b, c) VALUES (23, 'veintitres');
! INSERT INTO clstr_tst (b, c) VALUES (21, 'veintiuno');
! INSERT INTO clstr_tst (b, c) VALUES (4, 'cuatro');
! INSERT INTO clstr_tst (b, c) VALUES (14, 'catorce');
! INSERT INTO clstr_tst (b, c) VALUES (2, 'dos');
! INSERT INTO clstr_tst (b, c) VALUES (18, 'dieciocho');
! INSERT INTO clstr_tst (b, c) VALUES (27, 'veintisiete');
! INSERT INTO clstr_tst (b, c) VALUES (25, 'veinticinco');
! INSERT INTO clstr_tst (b, c) VALUES (13, 'trece');
! INSERT INTO clstr_tst (b, c) VALUES (28, 'veintiocho');
! INSERT INTO clstr_tst (b, c) VALUES (32, 'treinta y dos');
! INSERT INTO clstr_tst (b, c) VALUES (5, 'cinco');
! INSERT INTO clstr_tst (b, c) VALUES (29, 'veintinueve');
! INSERT INTO clstr_tst (b, c) VALUES (1, 'uno');
! INSERT INTO clstr_tst (b, c) VALUES (24, 'veinticuatro');
! INSERT INTO clstr_tst (b, c) VALUES (30, 'treinta');
! INSERT INTO clstr_tst (b, c) VALUES (12, 'doce');
! INSERT INTO clstr_tst (b, c) VALUES (17, 'diecisiete');
! INSERT INTO clstr_tst (b, c) VALUES (9, 'nueve');
! INSERT INTO clstr_tst (b, c) VALUES (19, 'diecinueve');
! INSERT INTO clstr_tst (b, c) VALUES (26, 'veintiseis');
! INSERT INTO clstr_tst (b, c) VALUES (15, 'quince');
! INSERT INTO clstr_tst (b, c) VALUES (7, 'siete');
! INSERT INTO clstr_tst (b, c) VALUES (16, 'dieciseis');
! INSERT INTO clstr_tst (b, c) VALUES (8, 'ocho');
! -- This entry is needed to test that TOASTED values are copied correctly.
! INSERT INTO clstr_tst (b, c, d) VALUES (6, 'seis', repeat('xyzzy', 100000));
! CLUSTER clstr_tst_c ON clstr_tst;
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  10 | 14 | catorce       |                                |       
!  18 |  5 | cinco         |                                |       
!   9 |  4 | cuatro        |                                |       
!  26 | 19 | diecinueve    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!   2 | 10 | diez          |                                |       
!  23 | 12 | doce          |                                |       
!  11 |  2 | dos           |                                |       
!  25 |  9 | nueve         |                                |       
!  31 |  8 | ocho          |                                |       
!   1 | 11 | once          |                                |       
!  28 | 15 | quince        |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  15 | 13 | trece         |                                |       
!  22 | 30 | treinta       |                                |       
!  17 | 32 | treinta y dos |                                |       
!   3 | 31 | treinta y uno |                                |       
!   5 |  3 | tres          |                                |       
!  20 |  1 | uno           |                                |       
!   6 | 20 | veinte        |                                |       
!  14 | 25 | veinticinco   |                                |       
!  21 | 24 | veinticuatro  |                                |       
!   4 | 22 | veintidos     |                                |       
!  19 | 29 | veintinueve   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!   1 | 11 | once          |                                |       
!   2 | 10 | diez          |                                |       
!   3 | 31 | treinta y uno |                                |       
!   4 | 22 | veintidos     |                                |       
!   5 |  3 | tres          |                                |       
!   6 | 20 | veinte        |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
!   9 |  4 | cuatro        |                                |       
!  10 | 14 | catorce       |                                |       
!  11 |  2 | dos           |                                |       
!  12 | 18 | dieciocho     |                                |       
!  13 | 27 | veintisiete   |                                |       
!  14 | 25 | veinticinco   |                                |       
!  15 | 13 | trece         |                                |       
!  16 | 28 | veintiocho    |                                |       
!  17 | 32 | treinta y dos |                                |       
!  18 |  5 | cinco         |                                |       
!  19 | 29 | veintinueve   |                                |       
!  20 |  1 | uno           |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  22 | 30 | treinta       |                                |       
!  23 | 12 | doce          |                                |       
!  24 | 17 | diecisiete    |                                |       
!  25 |  9 | nueve         |                                |       
!  26 | 19 | diecinueve    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  28 | 15 | quince        |                                |       
!  29 |  7 | siete         |                                |       
!  30 | 16 | dieciseis     |                                |       
!  31 |  8 | ocho          |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY b;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  20 |  1 | uno           |                                |       
!  11 |  2 | dos           |                                |       
!   5 |  3 | tres          |                                |       
!   9 |  4 | cuatro        |                                |       
!  18 |  5 | cinco         |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  31 |  8 | ocho          |                                |       
!  25 |  9 | nueve         |                                |       
!   2 | 10 | diez          |                                |       
!   1 | 11 | once          |                                |       
!  23 | 12 | doce          |                                |       
!  15 | 13 | trece         |                                |       
!  10 | 14 | catorce       |                                |       
!  28 | 15 | quince        |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  26 | 19 | diecinueve    |                                |       
!   6 | 20 | veinte        |                                |       
!   8 | 21 | veintiuno     |                                |       
!   4 | 22 | veintidos     |                                |       
!   7 | 23 | veintitres    |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  14 | 25 | veinticinco   |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  19 | 29 | veintinueve   |                                |       
!  22 | 30 | treinta       |                                |       
!   3 | 31 | treinta y uno |                                |       
!  17 | 32 | treinta y dos |                                |       
! (32 rows)
! 
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY c;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  10 | 14 | catorce       |                                |       
!  18 |  5 | cinco         |                                |       
!   9 |  4 | cuatro        |                                |       
!  26 | 19 | diecinueve    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!   2 | 10 | diez          |                                |       
!  23 | 12 | doce          |                                |       
!  11 |  2 | dos           |                                |       
!  25 |  9 | nueve         |                                |       
!  31 |  8 | ocho          |                                |       
!   1 | 11 | once          |                                |       
!  28 | 15 | quince        |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  15 | 13 | trece         |                                |       
!  22 | 30 | treinta       |                                |       
!  17 | 32 | treinta y dos |                                |       
!   3 | 31 | treinta y uno |                                |       
!   5 |  3 | tres          |                                |       
!  20 |  1 | uno           |                                |       
!   6 | 20 | veinte        |                                |       
!  14 | 25 | veinticinco   |                                |       
!  21 | 24 | veinticuatro  |                                |       
!   4 | 22 | veintidos     |                                |       
!  19 | 29 | veintinueve   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
! (32 rows)
! 
! -- Verify that inheritance link still works
! INSERT INTO clstr_tst_inh VALUES (0, 100, 'in child table');
! SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
!  a  |  b  |       c        |           substring            | length 
! ----+-----+----------------+--------------------------------+--------
!  10 |  14 | catorce        |                                |       
!  18 |   5 | cinco          |                                |       
!   9 |   4 | cuatro         |                                |       
!  26 |  19 | diecinueve     |                                |       
!  12 |  18 | dieciocho      |                                |       
!  30 |  16 | dieciseis      |                                |       
!  24 |  17 | diecisiete     |                                |       
!   2 |  10 | diez           |                                |       
!  23 |  12 | doce           |                                |       
!  11 |   2 | dos            |                                |       
!  25 |   9 | nueve          |                                |       
!  31 |   8 | ocho           |                                |       
!   1 |  11 | once           |                                |       
!  28 |  15 | quince         |                                |       
!  32 |   6 | seis           | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |   7 | siete          |                                |       
!  15 |  13 | trece          |                                |       
!  22 |  30 | treinta        |                                |       
!  17 |  32 | treinta y dos  |                                |       
!   3 |  31 | treinta y uno  |                                |       
!   5 |   3 | tres           |                                |       
!  20 |   1 | uno            |                                |       
!   6 |  20 | veinte         |                                |       
!  14 |  25 | veinticinco    |                                |       
!  21 |  24 | veinticuatro   |                                |       
!   4 |  22 | veintidos      |                                |       
!  19 |  29 | veintinueve    |                                |       
!  16 |  28 | veintiocho     |                                |       
!  27 |  26 | veintiseis     |                                |       
!  13 |  27 | veintisiete    |                                |       
!   7 |  23 | veintitres     |                                |       
!   8 |  21 | veintiuno      |                                |       
!   0 | 100 | in child table |                                |       
! (33 rows)
! 
! -- Verify that foreign key link still works
! INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail');
! ERROR:  insert or update on table "clstr_tst" violates foreign key constraint "clstr_tst_con"
! DETAIL:  Key (b)=(1111) is not present in table "clstr_tst_s".
! SELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst'::regclass
! ORDER BY 1;
!     conname     
! ----------------
!  clstr_tst_con
!  clstr_tst_pkey
! (2 rows)
! 
! SELECT relname, relkind,
!     EXISTS(SELECT 1 FROM pg_class WHERE oid = c.reltoastrelid) AS hastoast
! FROM pg_class c WHERE relname LIKE 'clstr_tst%' ORDER BY relname;
!        relname        | relkind | hastoast 
! ----------------------+---------+----------
!  clstr_tst            | r       | t
!  clstr_tst_a_seq      | S       | f
!  clstr_tst_b          | i       | f
!  clstr_tst_b_c        | i       | f
!  clstr_tst_c          | i       | f
!  clstr_tst_c_b        | i       | f
!  clstr_tst_inh        | r       | t
!  clstr_tst_pkey       | i       | f
!  clstr_tst_s          | r       | f
!  clstr_tst_s_pkey     | i       | f
!  clstr_tst_s_rf_a_seq | S       | f
! (11 rows)
! 
! -- Verify that indisclustered is correctly set
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!    relname   
! -------------
!  clstr_tst_c
! (1 row)
! 
! -- Try changing indisclustered
! ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!     relname    
! ---------------
!  clstr_tst_b_c
! (1 row)
! 
! -- Try turning off all clustering
! ALTER TABLE clstr_tst SET WITHOUT CLUSTER;
! SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
! WHERE pg_class.oid=indexrelid
! 	AND indrelid=pg_class_2.oid
! 	AND pg_class_2.relname = 'clstr_tst'
! 	AND indisclustered;
!  relname 
! ---------
! (0 rows)
! 
! -- Verify that clustering all tables does in fact cluster the right ones
! CREATE USER clstr_user;
! CREATE TABLE clstr_1 (a INT PRIMARY KEY);
! CREATE TABLE clstr_2 (a INT PRIMARY KEY);
! CREATE TABLE clstr_3 (a INT PRIMARY KEY);
! ALTER TABLE clstr_1 OWNER TO clstr_user;
! ALTER TABLE clstr_3 OWNER TO clstr_user;
! GRANT SELECT ON clstr_2 TO clstr_user;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! INSERT INTO clstr_2 VALUES (2);
! INSERT INTO clstr_2 VALUES (1);
! INSERT INTO clstr_3 VALUES (2);
! INSERT INTO clstr_3 VALUES (1);
! -- "CLUSTER <tablename>" on a table that hasn't been clustered
! CLUSTER clstr_2;
! ERROR:  there is no previously clustered index for table "clstr_2"
! CLUSTER clstr_1_pkey ON clstr_1;
! CLUSTER clstr_2 USING clstr_2_pkey;
! SELECT * FROM clstr_1 UNION ALL
!   SELECT * FROM clstr_2 UNION ALL
!   SELECT * FROM clstr_3;
!  a 
! ---
!  1
!  2
!  1
!  2
!  2
!  1
! (6 rows)
! 
! -- revert to the original state
! DELETE FROM clstr_1;
! DELETE FROM clstr_2;
! DELETE FROM clstr_3;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! INSERT INTO clstr_2 VALUES (2);
! INSERT INTO clstr_2 VALUES (1);
! INSERT INTO clstr_3 VALUES (2);
! INSERT INTO clstr_3 VALUES (1);
! -- this user can only cluster clstr_1 and clstr_3, but the latter
! -- has not been clustered
! SET SESSION AUTHORIZATION clstr_user;
! CLUSTER;
! SELECT * FROM clstr_1 UNION ALL
!   SELECT * FROM clstr_2 UNION ALL
!   SELECT * FROM clstr_3;
!  a 
! ---
!  1
!  2
!  2
!  1
!  2
!  1
! (6 rows)
! 
! -- cluster a single table using the indisclustered bit previously set
! DELETE FROM clstr_1;
! INSERT INTO clstr_1 VALUES (2);
! INSERT INTO clstr_1 VALUES (1);
! CLUSTER clstr_1;
! SELECT * FROM clstr_1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- Test MVCC-safety of cluster. There isn't much we can do to verify the
! -- results with a single backend...
! CREATE TABLE clustertest (key int PRIMARY KEY);
! INSERT INTO clustertest VALUES (10);
! INSERT INTO clustertest VALUES (20);
! INSERT INTO clustertest VALUES (30);
! INSERT INTO clustertest VALUES (40);
! INSERT INTO clustertest VALUES (50);
! -- Use a transaction so that updates are not committed when CLUSTER sees 'em
! BEGIN;
! -- Test update where the old row version is found first in the scan
! UPDATE clustertest SET key = 100 WHERE key = 10;
! -- Test update where the new row version is found first in the scan
! UPDATE clustertest SET key = 35 WHERE key = 40;
! -- Test longer update chain
! UPDATE clustertest SET key = 60 WHERE key = 50;
! UPDATE clustertest SET key = 70 WHERE key = 60;
! UPDATE clustertest SET key = 80 WHERE key = 70;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!  100
!   35
!   80
! (5 rows)
! 
! CLUSTER clustertest_pkey ON clustertest;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
! COMMIT;
! SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
! -- check that temp tables can be clustered
! create temp table clstr_temp (col1 int primary key, col2 text);
! insert into clstr_temp values (2, 'two'), (1, 'one');
! cluster clstr_temp using clstr_temp_pkey;
! select * from clstr_temp;
!  col1 | col2 
! ------+------
!     1 | one
!     2 | two
! (2 rows)
! 
! drop table clstr_temp;
! -- clean up
! \c -
! DROP TABLE clustertest;
! DROP TABLE clstr_1;
! DROP TABLE clstr_2;
! DROP TABLE clstr_3;
! DROP USER clstr_user;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/dependency.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/dependency.out	2015-01-26 12:33:25.967031415 +0300
***************
*** 1,114 ****
! --
! -- DEPENDENCIES
! --
! CREATE USER regression_user;
! CREATE USER regression_user2;
! CREATE USER regression_user3;
! CREATE GROUP regression_group;
! CREATE TABLE deptest (f1 serial primary key, f2 text);
! GRANT SELECT ON TABLE deptest TO GROUP regression_group;
! GRANT ALL ON TABLE deptest TO regression_user, regression_user2;
! -- can't drop neither because they have privileges somewhere
! DROP USER regression_user;
! ERROR:  role "regression_user" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! DROP GROUP regression_group;
! ERROR:  role "regression_group" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! -- if we revoke the privileges we can drop the group
! REVOKE SELECT ON deptest FROM GROUP regression_group;
! DROP GROUP regression_group;
! -- can't drop the user if we revoke the privileges partially
! REVOKE SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES ON deptest FROM regression_user;
! DROP USER regression_user;
! ERROR:  role "regression_user" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest
! -- now we are OK to drop him
! REVOKE TRIGGER ON deptest FROM regression_user;
! DROP USER regression_user;
! -- we are OK too if we drop the privileges all at once
! REVOKE ALL ON deptest FROM regression_user2;
! DROP USER regression_user2;
! -- can't drop the owner of an object
! -- the error message detail here would include a pg_toast_nnn name that
! -- is not constant, so suppress it
! \set VERBOSITY terse
! ALTER TABLE deptest OWNER TO regression_user3;
! DROP USER regression_user3;
! ERROR:  role "regression_user3" cannot be dropped because some objects depend on it
! \set VERBOSITY default
! -- if we drop the object, we can drop the user too
! DROP TABLE deptest;
! DROP USER regression_user3;
! -- Test DROP OWNED
! CREATE USER regression_user0;
! CREATE USER regression_user1;
! CREATE USER regression_user2;
! SET SESSION AUTHORIZATION regression_user0;
! -- permission denied
! DROP OWNED BY regression_user1;
! ERROR:  permission denied to drop objects
! DROP OWNED BY regression_user0, regression_user2;
! ERROR:  permission denied to drop objects
! REASSIGN OWNED BY regression_user0 TO regression_user1;
! ERROR:  permission denied to reassign objects
! REASSIGN OWNED BY regression_user1 TO regression_user0;
! ERROR:  permission denied to reassign objects
! -- this one is allowed
! DROP OWNED BY regression_user0;
! CREATE TABLE deptest1 (f1 int unique);
! GRANT ALL ON deptest1 TO regression_user1 WITH GRANT OPTION;
! SET SESSION AUTHORIZATION regression_user1;
! CREATE TABLE deptest (a serial primary key, b text);
! GRANT ALL ON deptest1 TO regression_user2;
! RESET SESSION AUTHORIZATION;
! \z deptest1
!                                               Access privileges
!  Schema |   Name   | Type  |                Access privileges                 | Column privileges | Policies 
! --------+----------+-------+--------------------------------------------------+-------------------+----------
!  public | deptest1 | table | regression_user0=arwdDxt/regression_user0       +|                   | 
!         |          |       | regression_user1=a*r*w*d*D*x*t*/regression_user0+|                   | 
!         |          |       | regression_user2=arwdDxt/regression_user1        |                   | 
! (1 row)
! 
! DROP OWNED BY regression_user1;
! -- all grants revoked
! \z deptest1
!                                           Access privileges
!  Schema |   Name   | Type  |             Access privileges             | Column privileges | Policies 
! --------+----------+-------+-------------------------------------------+-------------------+----------
!  public | deptest1 | table | regression_user0=arwdDxt/regression_user0 |                   | 
! (1 row)
! 
! -- table was dropped
! \d deptest
! -- Test REASSIGN OWNED
! GRANT ALL ON deptest1 TO regression_user1;
! SET SESSION AUTHORIZATION regression_user1;
! CREATE TABLE deptest (a serial primary key, b text);
! CREATE TABLE deptest2 (f1 int);
! -- make a serial column the hard way
! CREATE SEQUENCE ss1;
! ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
! ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
! RESET SESSION AUTHORIZATION;
! REASSIGN OWNED BY regression_user1 TO regression_user2;
! \dt deptest
!               List of relations
!  Schema |  Name   | Type  |      Owner       
! --------+---------+-------+------------------
!  public | deptest | table | regression_user2
! (1 row)
! 
! -- doesn't work: grant still exists
! DROP USER regression_user1;
! ERROR:  role "regression_user1" cannot be dropped because some objects depend on it
! DETAIL:  privileges for table deptest1
! DROP OWNED BY regression_user1;
! DROP USER regression_user1;
! \set VERBOSITY terse
! DROP USER regression_user2;
! ERROR:  role "regression_user2" cannot be dropped because some objects depend on it
! DROP OWNED BY regression_user2, regression_user0;
! DROP USER regression_user2;
! DROP USER regression_user0;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/guc.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/guc.out	2015-01-26 12:33:25.935031414 +0300
***************
*** 1,738 ****
! -- pg_regress should ensure that this default value applies; however
! -- we can't rely on any specific default value of vacuum_cost_delay
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! -- SET to some nondefault value
! SET vacuum_cost_delay TO 40;
! SET datestyle = 'ISO, YMD';
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET LOCAL has no effect outside of a transaction
! SET LOCAL vacuum_cost_delay TO 50;
! WARNING:  SET LOCAL can only be used in transaction blocks
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SET LOCAL datestyle = 'SQL';
! WARNING:  SET LOCAL can only be used in transaction blocks
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET LOCAL within a transaction that commits
! BEGIN;
! SET LOCAL vacuum_cost_delay TO 50;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  50ms
! (1 row)
! 
! SET LOCAL datestyle = 'SQL';
! SHOW datestyle;
!  DateStyle 
! -----------
!  SQL, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!        timestamptz       
! -------------------------
!  08/13/2006 12:34:56 PDT
! (1 row)
! 
! COMMIT;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET should be reverted after ROLLBACK
! BEGIN;
! SET vacuum_cost_delay TO 60;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  60ms
! (1 row)
! 
! SET datestyle = 'German';
! SHOW datestyle;
!   DateStyle  
! -------------
!  German, DMY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!        timestamptz       
! -------------------------
!  13.08.2006 12:34:56 PDT
! (1 row)
! 
! ROLLBACK;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- Some tests with subtransactions
! BEGIN;
! SET vacuum_cost_delay TO 70;
! SET datestyle = 'MDY';
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! SAVEPOINT first_sp;
! SET vacuum_cost_delay TO 80;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  80ms
! (1 row)
! 
! SET datestyle = 'German, DMY';
! SHOW datestyle;
!   DateStyle  
! -------------
!  German, DMY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!        timestamptz       
! -------------------------
!  13.08.2006 12:34:56 PDT
! (1 row)
! 
! ROLLBACK TO first_sp;
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! SAVEPOINT second_sp;
! SET vacuum_cost_delay TO 90;
! SET datestyle = 'SQL, YMD';
! SHOW datestyle;
!  DateStyle 
! -----------
!  SQL, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!        timestamptz       
! -------------------------
!  08/13/2006 12:34:56 PDT
! (1 row)
! 
! SAVEPOINT third_sp;
! SET vacuum_cost_delay TO 100;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  100ms
! (1 row)
! 
! SET datestyle = 'Postgres, MDY';
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! ROLLBACK TO third_sp;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  90ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  SQL, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!        timestamptz       
! -------------------------
!  08/13/2006 12:34:56 PDT
! (1 row)
! 
! ROLLBACK TO second_sp;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  70ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! ROLLBACK;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET LOCAL with Savepoints
! BEGIN;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! SAVEPOINT sp;
! SET LOCAL vacuum_cost_delay TO 30;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  30ms
! (1 row)
! 
! SET LOCAL datestyle = 'Postgres, MDY';
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! ROLLBACK TO sp;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! ROLLBACK;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET LOCAL persists through RELEASE (which was not true in 8.0-8.2)
! BEGIN;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! SAVEPOINT sp;
! SET LOCAL vacuum_cost_delay TO 30;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  30ms
! (1 row)
! 
! SET LOCAL datestyle = 'Postgres, MDY';
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! RELEASE SAVEPOINT sp;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  30ms
! (1 row)
! 
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! ROLLBACK;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! -- SET followed by SET LOCAL
! BEGIN;
! SET vacuum_cost_delay TO 40;
! SET LOCAL vacuum_cost_delay TO 50;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  50ms
! (1 row)
! 
! SET datestyle = 'ISO, DMY';
! SET LOCAL datestyle = 'Postgres, MDY';
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! COMMIT;
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  40ms
! (1 row)
! 
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, DMY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! --
! -- Test RESET.  We use datestyle because the reset value is forced by
! -- pg_regress, so it doesn't depend on the installation's configuration.
! --
! SET datestyle = iso, ymd;
! SHOW datestyle;
!  DateStyle 
! -----------
!  ISO, YMD
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!       timestamptz       
! ------------------------
!  2006-08-13 12:34:56-07
! (1 row)
! 
! RESET datestyle;
! SHOW datestyle;
!    DateStyle   
! ---------------
!  Postgres, MDY
! (1 row)
! 
! SELECT '2006-08-13 12:34:56'::timestamptz;
!          timestamptz          
! ------------------------------
!  Sun Aug 13 12:34:56 2006 PDT
! (1 row)
! 
! --
! -- Test DISCARD TEMP
! --
! CREATE TEMP TABLE reset_test ( data text ) ON COMMIT DELETE ROWS;
! SELECT relname FROM pg_class WHERE relname = 'reset_test';
!   relname   
! ------------
!  reset_test
! (1 row)
! 
! DISCARD TEMP;
! SELECT relname FROM pg_class WHERE relname = 'reset_test';
!  relname 
! ---------
! (0 rows)
! 
! --
! -- Test DISCARD ALL
! --
! -- do changes
! DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
! PREPARE foo AS SELECT 1;
! LISTEN foo_event;
! SET vacuum_cost_delay = 13;
! CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS;
! CREATE ROLE temp_reset_user;
! SET SESSION AUTHORIZATION temp_reset_user;
! -- look changes
! SELECT pg_listening_channels();
!  pg_listening_channels 
! -----------------------
!  foo_event
! (1 row)
! 
! SELECT name FROM pg_prepared_statements;
!  name 
! ------
!  foo
! (1 row)
! 
! SELECT name FROM pg_cursors;
!  name 
! ------
!  foo
! (1 row)
! 
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  13ms
! (1 row)
! 
! SELECT relname from pg_class where relname = 'tmp_foo';
!  relname 
! ---------
!  tmp_foo
! (1 row)
! 
! SELECT current_user = 'temp_reset_user';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- discard everything
! DISCARD ALL;
! -- look again
! SELECT pg_listening_channels();
!  pg_listening_channels 
! -----------------------
! (0 rows)
! 
! SELECT name FROM pg_prepared_statements;
!  name 
! ------
! (0 rows)
! 
! SELECT name FROM pg_cursors;
!  name 
! ------
! (0 rows)
! 
! SHOW vacuum_cost_delay;
!  vacuum_cost_delay 
! -------------------
!  0
! (1 row)
! 
! SELECT relname from pg_class where relname = 'tmp_foo';
!  relname 
! ---------
! (0 rows)
! 
! SELECT current_user = 'temp_reset_user';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! DROP ROLE temp_reset_user;
! --
! -- search_path should react to changes in pg_namespace
! --
! set search_path = foo, public, not_there_initially;
! select current_schemas(false);
!  current_schemas 
! -----------------
!  {public}
! (1 row)
! 
! create schema not_there_initially;
! select current_schemas(false);
!        current_schemas        
! ------------------------------
!  {public,not_there_initially}
! (1 row)
! 
! drop schema not_there_initially;
! select current_schemas(false);
!  current_schemas 
! -----------------
!  {public}
! (1 row)
! 
! reset search_path;
! --
! -- Tests for function-local GUC settings
! --
! set work_mem = '3MB';
! create function report_guc(text) returns text as
! $$ select current_setting($1) $$ language sql
! set work_mem = '1MB';
! select report_guc('work_mem'), current_setting('work_mem');
!  report_guc | current_setting 
! ------------+-----------------
!  1MB        | 3MB
! (1 row)
! 
! alter function report_guc(text) set work_mem = '2MB';
! select report_guc('work_mem'), current_setting('work_mem');
!  report_guc | current_setting 
! ------------+-----------------
!  2MB        | 3MB
! (1 row)
! 
! alter function report_guc(text) reset all;
! select report_guc('work_mem'), current_setting('work_mem');
!  report_guc | current_setting 
! ------------+-----------------
!  3MB        | 3MB
! (1 row)
! 
! -- SET LOCAL is restricted by a function SET option
! create or replace function myfunc(int) returns text as $$
! begin
!   set local work_mem = '2MB';
!   return current_setting('work_mem');
! end $$
! language plpgsql
! set work_mem = '1MB';
! select myfunc(0), current_setting('work_mem');
!  myfunc | current_setting 
! --------+-----------------
!  2MB    | 3MB
! (1 row)
! 
! alter function myfunc(int) reset all;
! select myfunc(0), current_setting('work_mem');
!  myfunc | current_setting 
! --------+-----------------
!  2MB    | 2MB
! (1 row)
! 
! set work_mem = '3MB';
! -- but SET isn't
! create or replace function myfunc(int) returns text as $$
! begin
!   set work_mem = '2MB';
!   return current_setting('work_mem');
! end $$
! language plpgsql
! set work_mem = '1MB';
! select myfunc(0), current_setting('work_mem');
!  myfunc | current_setting 
! --------+-----------------
!  2MB    | 2MB
! (1 row)
! 
! set work_mem = '3MB';
! -- it should roll back on error, though
! create or replace function myfunc(int) returns text as $$
! begin
!   set work_mem = '2MB';
!   perform 1/$1;
!   return current_setting('work_mem');
! end $$
! language plpgsql
! set work_mem = '1MB';
! select myfunc(0);
! ERROR:  division by zero
! CONTEXT:  SQL statement "SELECT 1/$1"
! PL/pgSQL function myfunc(integer) line 4 at PERFORM
! select current_setting('work_mem');
!  current_setting 
! -----------------
!  3MB
! (1 row)
! 
! select myfunc(1), current_setting('work_mem');
!  myfunc | current_setting 
! --------+-----------------
!  2MB    | 2MB
! (1 row)
! 
! -- Normally, CREATE FUNCTION should complain about invalid values in
! -- function SET options; but not if check_function_bodies is off,
! -- because that creates ordering hazards for pg_dump
! create function func_with_bad_set() returns int as $$ select 1 $$
! language sql
! set default_text_search_config = no_such_config;
! NOTICE:  text search configuration "no_such_config" does not exist
! ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
! set check_function_bodies = off;
! create function func_with_bad_set() returns int as $$ select 1 $$
! language sql
! set default_text_search_config = no_such_config;
! NOTICE:  text search configuration "no_such_config" does not exist
! select func_with_bad_set();
! ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
! reset check_function_bodies;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/bitmapops.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/bitmapops.out	2015-01-26 12:33:25.943031414 +0300
***************
*** 1,38 ****
! -- Test bitmap AND and OR
! -- Generate enough data that we can test the lossy bitmaps.
! -- There's 55 tuples per page in the table. 53 is just
! -- below 55, so that an index scan with qual a = constant
! -- will return at least one hit per page. 59 is just above
! -- 55, so that an index scan with qual b = constant will return
! -- hits on most but not all pages. 53 and 59 are prime, so that
! -- there's a maximum number of a,b combinations in the table.
! -- That allows us to test all the different combinations of
! -- lossy and non-lossy pages with the minimum amount of data
! CREATE TABLE bmscantest (a int, b int, t text);
! INSERT INTO bmscantest
!   SELECT (r%53), (r%59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
!   FROM generate_series(1,70000) r;
! CREATE INDEX i_bmtest_a ON bmscantest(a);
! CREATE INDEX i_bmtest_b ON bmscantest(b);
! -- We want to use bitmapscans. With default settings, the planner currently
! -- chooses a bitmap scan for the queries below anyway, but let's make sure.
! set enable_indexscan=false;
! set enable_seqscan=false;
! -- Lower work_mem to trigger use of lossy bitmaps
! set work_mem = 64;
! -- Test bitmap-and.
! SELECT count(*) FROM bmscantest WHERE a = 1 AND b = 1;
!  count 
! -------
!     23
! (1 row)
! 
! -- Test bitmap-or.
! SELECT count(*) FROM bmscantest WHERE a = 1 OR b = 1;
!  count 
! -------
!   2485
! (1 row)
! 
! -- clean up
! DROP TABLE bmscantest;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/combocid.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/combocid.out	2015-01-26 12:33:25.939031414 +0300
***************
*** 1,142 ****
! --
! -- Tests for some likely failure cases with combo cmin/cmax mechanism
! --
! CREATE TEMP TABLE combocidtest (foobar int);
! BEGIN;
! -- a few dummy ops to push up the CommandId counter
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest VALUES (1);
! INSERT INTO combocidtest VALUES (2);
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   10 |      1
!  (0,2) |   11 |      2
! (2 rows)
! 
! SAVEPOINT s1;
! UPDATE combocidtest SET foobar = foobar + 10;
! -- here we should see only updated tuples
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,3) |   12 |     11
!  (0,4) |   12 |     12
! (2 rows)
! 
! ROLLBACK TO s1;
! -- now we should see old tuples, but with combo CIDs starting at 0
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    0 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! COMMIT;
! -- combo data is not there anymore, but should still see tuples
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    0 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! -- Test combo cids with portals
! BEGIN;
! INSERT INTO combocidtest VALUES (333);
! DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
! DELETE FROM combocidtest;
! FETCH ALL FROM c;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,5) |    0 |    333
! (3 rows)
! 
! ROLLBACK;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
! (2 rows)
! 
! -- check behavior with locked tuples
! BEGIN;
! -- a few dummy ops to push up the CommandId counter
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest SELECT 1 LIMIT 0;
! INSERT INTO combocidtest VALUES (444);
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! SAVEPOINT s1;
! -- this doesn't affect cmin
! SELECT ctid,cmin,* FROM combocidtest FOR UPDATE;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |    1 |      1
!  (0,2) |    1 |      2
!  (0,6) |   10 |    444
! (3 rows)
! 
! -- but this does
! UPDATE combocidtest SET foobar = foobar + 10;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,7) |   12 |     11
!  (0,8) |   12 |     12
!  (0,9) |   12 |    454
! (3 rows)
! 
! ROLLBACK TO s1;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   12 |      1
!  (0,2) |   12 |      2
!  (0,6) |    0 |    444
! (3 rows)
! 
! COMMIT;
! SELECT ctid,cmin,* FROM combocidtest;
!  ctid  | cmin | foobar 
! -------+------+--------
!  (0,1) |   12 |      1
!  (0,2) |   12 |      2
!  (0,6) |    0 |    444
! (3 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/tsearch.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/tsearch.out	2015-01-26 12:33:25.943031414 +0300
***************
*** 1,1128 ****
! --
! -- Sanity checks for text search catalogs
! --
! -- NB: we assume the oidjoins test will have caught any dangling links,
! -- that is OID or REGPROC fields that are not zero and do not match some
! -- row in the linked-to table.  However, if we want to enforce that a link
! -- field can't be 0, we have to check it here.
! -- Find unexpected zero link entries
! SELECT oid, prsname
! FROM pg_ts_parser
! WHERE prsnamespace = 0 OR prsstart = 0 OR prstoken = 0 OR prsend = 0 OR
!       -- prsheadline is optional
!       prslextype = 0;
!  oid | prsname 
! -----+---------
! (0 rows)
! 
! SELECT oid, dictname
! FROM pg_ts_dict
! WHERE dictnamespace = 0 OR dictowner = 0 OR dicttemplate = 0;
!  oid | dictname 
! -----+----------
! (0 rows)
! 
! SELECT oid, tmplname
! FROM pg_ts_template
! WHERE tmplnamespace = 0 OR tmpllexize = 0;  -- tmplinit is optional
!  oid | tmplname 
! -----+----------
! (0 rows)
! 
! SELECT oid, cfgname
! FROM pg_ts_config
! WHERE cfgnamespace = 0 OR cfgowner = 0 OR cfgparser = 0;
!  oid | cfgname 
! -----+---------
! (0 rows)
! 
! SELECT mapcfg, maptokentype, mapseqno
! FROM pg_ts_config_map
! WHERE mapcfg = 0 OR mapdict = 0;
!  mapcfg | maptokentype | mapseqno 
! --------+--------------+----------
! (0 rows)
! 
! -- Look for pg_ts_config_map entries that aren't one of parser's token types
! SELECT * FROM
!   ( SELECT oid AS cfgid, (ts_token_type(cfgparser)).tokid AS tokid
!     FROM pg_ts_config ) AS tt
! RIGHT JOIN pg_ts_config_map AS m
!     ON (tt.cfgid=m.mapcfg AND tt.tokid=m.maptokentype)
! WHERE
!     tt.cfgid IS NULL OR tt.tokid IS NULL;
!  cfgid | tokid | mapcfg | maptokentype | mapseqno | mapdict 
! -------+-------+--------+--------------+----------+---------
! (0 rows)
! 
! -- test basic text search behavior without indexes, then with
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! create index wowidx on test_tsvector using gist (a);
! SET enable_seqscan=OFF;
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
!  count 
! -------
!    158
! (1 row)
! 
! RESET enable_seqscan;
! DROP INDEX wowidx;
! CREATE INDEX wowidx ON test_tsvector USING gin (a);
! SET enable_seqscan=OFF;
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
!  count 
! -------
!    158
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
!  count 
! -------
!     17
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
!  count 
! -------
!      6
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
!  count 
! -------
!     98
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
!  count 
! -------
!     23
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
!  count 
! -------
!     39
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
!  count 
! -------
!    494
! (1 row)
! 
! SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
!  count 
! -------
!    158
! (1 row)
! 
! RESET enable_seqscan;
! INSERT INTO test_tsvector VALUES ('???', 'DFG:1A,2B,6C,10 FGH');
! SELECT * FROM ts_stat('SELECT a FROM test_tsvector') ORDER BY ndoc DESC, nentry DESC, word LIMIT 10;
!  word | ndoc | nentry 
! ------+------+--------
!  qq   |  108 |    108
!  qt   |  102 |    102
!  qe   |  100 |    100
!  qh   |   98 |     98
!  qw   |   98 |     98
!  qa   |   97 |     97
!  ql   |   94 |     94
!  qs   |   94 |     94
!  qi   |   92 |     92
!  qr   |   92 |     92
! (10 rows)
! 
! SELECT * FROM ts_stat('SELECT a FROM test_tsvector', 'AB') ORDER BY ndoc DESC, nentry DESC, word;
!  word | ndoc | nentry 
! ------+------+--------
!  DFG  |    1 |      2
! (1 row)
! 
! --dictionaries and to_tsvector
! SELECT ts_lexize('english_stem', 'skies');
!  ts_lexize 
! -----------
!  {sky}
! (1 row)
! 
! SELECT ts_lexize('english_stem', 'identity');
!  ts_lexize 
! -----------
!  {ident}
! (1 row)
! 
! SELECT * FROM ts_token_type('default');
!  tokid |      alias      |               description                
! -------+-----------------+------------------------------------------
!      1 | asciiword       | Word, all ASCII
!      2 | word            | Word, all letters
!      3 | numword         | Word, letters and digits
!      4 | email           | Email address
!      5 | url             | URL
!      6 | host            | Host
!      7 | sfloat          | Scientific notation
!      8 | version         | Version number
!      9 | hword_numpart   | Hyphenated word part, letters and digits
!     10 | hword_part      | Hyphenated word part, all letters
!     11 | hword_asciipart | Hyphenated word part, all ASCII
!     12 | blank           | Space symbols
!     13 | tag             | XML tag
!     14 | protocol        | Protocol head
!     15 | numhword        | Hyphenated word, letters and digits
!     16 | asciihword      | Hyphenated word, all ASCII
!     17 | hword           | Hyphenated word, all letters
!     18 | url_path        | URL path
!     19 | file            | File or path name
!     20 | float           | Decimal notation
!     21 | int             | Signed integer
!     22 | uint            | Unsigned integer
!     23 | entity          | XML entity
! (23 rows)
! 
! SELECT * FROM ts_parse('default', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty');
!  tokid |                token                 
! -------+--------------------------------------
!     22 | 345
!     12 |  
!      1 | qwe
!     12 | @
!     19 | efd.r
!     12 |  ' 
!     14 | http://
!      6 | www.com
!     12 | / 
!     14 | http://
!      5 | aew.werc.ewr/?ad=qwe&dw
!      6 | aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!      5 | 1aew.werc.ewr/?ad=qwe&dw
!      6 | 1aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!      6 | 2aew.werc.ewr
!     12 |  
!     14 | http://
!      5 | 3aew.werc.ewr/?ad=qwe&dw
!      6 | 3aew.werc.ewr
!     18 | /?ad=qwe&dw
!     12 |  
!     14 | http://
!      6 | 4aew.werc.ewr
!     12 |  
!     14 | http://
!      5 | 5aew.werc.ewr:8100/?
!      6 | 5aew.werc.ewr:8100
!     18 | /?
!     12 |   
!      1 | ad
!     12 | =
!      1 | qwe
!     12 | &
!      1 | dw
!     12 |  
!      5 | 6aew.werc.ewr:8100/?ad=qwe&dw
!      6 | 6aew.werc.ewr:8100
!     18 | /?ad=qwe&dw
!     12 |  
!      5 | 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32
!      6 | 7aew.werc.ewr:8100
!     18 | /?ad=qwe&dw=%20%32
!     12 |  
!      7 | +4.0e-10
!     12 |  
!      1 | qwe
!     12 |  
!      1 | qwe
!     12 |  
!      1 | qwqwe
!     12 |  
!     20 | 234.435
!     12 |  
!     22 | 455
!     12 |  
!     20 | 5.005
!     12 |  
!      4 | teodor@stack.net
!     12 |  
!     16 | qwe-wer
!     11 | qwe
!     12 | -
!     11 | wer
!     12 |  
!      1 | asdf
!     12 |  
!     13 | <fr>
!      1 | qwer
!     12 |  
!      1 | jf
!     12 |  
!      1 | sdjk
!     12 | <
!      1 | we
!     12 |  
!      1 | hjwer
!     12 |  
!     13 | <werrwe>
!     12 |  
!      3 | ewr1
!     12 | > 
!      3 | ewri2
!     12 |  
!     13 | <a href="qwe<qwe>">
!     12 |                                     +
!        | 
!     19 | /usr/local/fff
!     12 |  
!     19 | /awdf/dwqe/4325
!     12 |  
!     19 | rewt/ewr
!     12 |  
!      1 | wefjn
!     12 |  
!     19 | /wqe-324/ewr
!     12 |  
!     19 | gist.h
!     12 |  
!     19 | gist.h.c
!     12 |  
!     19 | gist.c
!     12 | . 
!      1 | readline
!     12 |  
!     20 | 4.2
!     12 |  
!     20 | 4.2
!     12 | . 
!     20 | 4.2
!     12 | , 
!      1 | readline
!     20 | -4.2
!     12 |  
!      1 | readline
!     20 | -4.2
!     12 | . 
!     22 | 234
!     12 |                                     +
!        | 
!     12 | <
!      1 | i
!     12 |  
!     13 | <b>
!     12 |  
!      1 | wow
!     12 |   
!     12 | < 
!      1 | jqw
!     12 |  
!     12 | <> 
!      1 | qwerty
! (133 rows)
! 
! SELECT to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty');
!                                                                                                                                                                                                                                                                                                                                                                                                                                        to_tsvector                                                                                                                                                                                                                                                                                                                                                                                                                                        
! ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  '+4.0e-10':28 '-4.2':60,62 '/?':18 '/?ad=qwe&dw':7,10,14,24 '/?ad=qwe&dw=%20%32':27 '/awdf/dwqe/4325':48 '/usr/local/fff':47 '/wqe-324/ewr':51 '1aew.werc.ewr':9 '1aew.werc.ewr/?ad=qwe&dw':8 '234':63 '234.435':32 '2aew.werc.ewr':11 '345':1 '3aew.werc.ewr':13 '3aew.werc.ewr/?ad=qwe&dw':12 '4.2':56,57,58 '455':33 '4aew.werc.ewr':15 '5.005':34 '5aew.werc.ewr:8100':17 '5aew.werc.ewr:8100/?':16 '6aew.werc.ewr:8100':23 '6aew.werc.ewr:8100/?ad=qwe&dw':22 '7aew.werc.ewr:8100':26 '7aew.werc.ewr:8100/?ad=qwe&dw=%20%32':25 'ad':19 'aew.werc.ewr':6 'aew.werc.ewr/?ad=qwe&dw':5 'asdf':39 'dw':21 'efd.r':3 'ewr1':45 'ewri2':46 'gist.c':54 'gist.h':52 'gist.h.c':53 'hjwer':44 'jf':41 'jqw':66 'qwe':2,20,29,30,37 'qwe-wer':36 'qwer':40 'qwerti':67 'qwqwe':31 'readlin':55,59,61 'rewt/ewr':49 'sdjk':42 'teodor@stack.net':35 'wefjn':50 'wer':38 'wow':65 'www.com':4
! (1 row)
! 
! SELECT length(to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
! /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
! <i <b> wow  < jqw <> qwerty'));
!  length 
! --------
!      53
! (1 row)
! 
! -- ts_debug
! SELECT * from ts_debug('english', '<myns:foo-bar_baz.blurfl>abc&nm1;def&#xa9;ghi&#245;jkl</myns:foo-bar_baz.blurfl>');
!    alias   |   description   |           token            |  dictionaries  |  dictionary  | lexemes 
! -----------+-----------------+----------------------------+----------------+--------------+---------
!  tag       | XML tag         | <myns:foo-bar_baz.blurfl>  | {}             |              | 
!  asciiword | Word, all ASCII | abc                        | {english_stem} | english_stem | {abc}
!  entity    | XML entity      | &nm1;                      | {}             |              | 
!  asciiword | Word, all ASCII | def                        | {english_stem} | english_stem | {def}
!  entity    | XML entity      | &#xa9;                     | {}             |              | 
!  asciiword | Word, all ASCII | ghi                        | {english_stem} | english_stem | {ghi}
!  entity    | XML entity      | &#245;                     | {}             |              | 
!  asciiword | Word, all ASCII | jkl                        | {english_stem} | english_stem | {jkl}
!  tag       | XML tag         | </myns:foo-bar_baz.blurfl> | {}             |              | 
! (9 rows)
! 
! -- check parsing of URLs
! SELECT * from ts_debug('english', 'http://www.harewoodsolutions.co.uk/press.aspx</span>');
!   alias   |  description  |                 token                  | dictionaries | dictionary |                 lexemes                  
! ----------+---------------+----------------------------------------+--------------+------------+------------------------------------------
!  protocol | Protocol head | http://                                | {}           |            | 
!  url      | URL           | www.harewoodsolutions.co.uk/press.aspx | {simple}     | simple     | {www.harewoodsolutions.co.uk/press.aspx}
!  host     | Host          | www.harewoodsolutions.co.uk            | {simple}     | simple     | {www.harewoodsolutions.co.uk}
!  url_path | URL path      | /press.aspx                            | {simple}     | simple     | {/press.aspx}
!  tag      | XML tag       | </span>                                | {}           |            | 
! (5 rows)
! 
! SELECT * from ts_debug('english', 'http://aew.wer0c.ewr/id?ad=qwe&dw<span>');
!   alias   |  description  |           token            | dictionaries | dictionary |           lexemes            
! ----------+---------------+----------------------------+--------------+------------+------------------------------
!  protocol | Protocol head | http://                    | {}           |            | 
!  url      | URL           | aew.wer0c.ewr/id?ad=qwe&dw | {simple}     | simple     | {aew.wer0c.ewr/id?ad=qwe&dw}
!  host     | Host          | aew.wer0c.ewr              | {simple}     | simple     | {aew.wer0c.ewr}
!  url_path | URL path      | /id?ad=qwe&dw              | {simple}     | simple     | {/id?ad=qwe&dw}
!  tag      | XML tag       | <span>                     | {}           |            | 
! (5 rows)
! 
! SELECT * from ts_debug('english', 'http://5aew.werc.ewr:8100/?');
!   alias   |  description  |        token         | dictionaries | dictionary |        lexemes         
! ----------+---------------+----------------------+--------------+------------+------------------------
!  protocol | Protocol head | http://              | {}           |            | 
!  url      | URL           | 5aew.werc.ewr:8100/? | {simple}     | simple     | {5aew.werc.ewr:8100/?}
!  host     | Host          | 5aew.werc.ewr:8100   | {simple}     | simple     | {5aew.werc.ewr:8100}
!  url_path | URL path      | /?                   | {simple}     | simple     | {/?}
! (4 rows)
! 
! SELECT * from ts_debug('english', '5aew.werc.ewr:8100/?xx');
!   alias   | description |         token          | dictionaries | dictionary |         lexemes          
! ----------+-------------+------------------------+--------------+------------+--------------------------
!  url      | URL         | 5aew.werc.ewr:8100/?xx | {simple}     | simple     | {5aew.werc.ewr:8100/?xx}
!  host     | Host        | 5aew.werc.ewr:8100     | {simple}     | simple     | {5aew.werc.ewr:8100}
!  url_path | URL path    | /?xx                   | {simple}     | simple     | {/?xx}
! (3 rows)
! 
! -- to_tsquery
! SELECT to_tsquery('english', 'qwe & sKies ');
!   to_tsquery   
! ---------------
!  'qwe' & 'sky'
! (1 row)
! 
! SELECT to_tsquery('simple', 'qwe & sKies ');
!    to_tsquery    
! -----------------
!  'qwe' & 'skies'
! (1 row)
! 
! SELECT to_tsquery('english', '''the wether'':dc & ''           sKies '':BC ');
!        to_tsquery       
! ------------------------
!  'wether':CD & 'sky':BC
! (1 row)
! 
! SELECT to_tsquery('english', 'asd&(and|fghj)');
!    to_tsquery   
! ----------------
!  'asd' & 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(asd&and)|fghj');
!    to_tsquery   
! ----------------
!  'asd' | 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(asd&!and)|fghj');
!    to_tsquery   
! ----------------
!  'asd' | 'fghj'
! (1 row)
! 
! SELECT to_tsquery('english', '(the|and&(i&1))&fghj');
!   to_tsquery  
! --------------
!  '1' & 'fghj'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'the and z 1))& fghj');
!   plainto_tsquery   
! --------------------
!  'z' & '1' & 'fghj'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') && plainto_tsquery('english', 'asd');
!        ?column?        
! -----------------------
!  'foo' & 'bar' & 'asd'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') || plainto_tsquery('english', 'asd fg');
!            ?column?           
! ------------------------------
!  'foo' & 'bar' | 'asd' & 'fg'
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') || !!plainto_tsquery('english', 'asd fg');
!              ?column?              
! -----------------------------------
!  'foo' & 'bar' | !( 'asd' & 'fg' )
! (1 row)
! 
! SELECT plainto_tsquery('english', 'foo bar') && 'asd | fg';
!              ?column?             
! ----------------------------------
!  'foo' & 'bar' & ( 'asd' | 'fg' )
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'paint&water'));
!  ts_rank_cd 
! ------------
!        0.05
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'breath&motion&water'));
!  ts_rank_cd 
! ------------
!  0.00833333
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! '), to_tsquery('english', 'ocean'));
!  ts_rank_cd 
! ------------
!         0.1
! (1 row)
! 
! SELECT ts_rank_cd(strip(to_tsvector('both stripped')),
!                   to_tsquery('both & stripped'));
!  ts_rank_cd 
! ------------
!           0
! (1 row)
! 
! SELECT ts_rank_cd(to_tsvector('unstripped') || strip(to_tsvector('stripped')),
!                   to_tsquery('unstripped & stripped'));
!  ts_rank_cd 
! ------------
!           0
! (1 row)
! 
! --headline tests
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'paint&water'));
!                ts_headline               
! -----------------------------------------
!  <b>painted</b> Ocean.                  +
!  <b>Water</b>, <b>water</b>, every where+
!    And all the boards did shrink;       +
!  <b>Water</b>, <b>water</b>, every
! (1 row)
! 
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'breath&motion&water'));
!            ts_headline            
! ----------------------------------
!  <b>breath</b> nor <b>motion</b>,+
!  As idle as a painted Ship       +
!    Upon a painted Ocean.         +
!  <b>Water</b>, <b>water</b>
! (1 row)
! 
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean'));
!            ts_headline            
! ----------------------------------
!  <b>Ocean</b>.                   +
!  Water, water, every where       +
!    And all the boards did shrink;+
!  Water, water, every where
! (1 row)
! 
! SELECT ts_headline('english', '
! <html>
! <!-- some comment -->
! <body>
! Sea view wow <u>foo bar</u> <i>qq</i>
! <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>
! ff-bg
! <script>
!        document.write(15);
! </script>
! </body>
! </html>',
! to_tsquery('english', 'sea&foo'), 'HighlightAll=true');
!                                  ts_headline                                 
! -----------------------------------------------------------------------------
!                                                                             +
!  <html>                                                                     +
!  <!-- some comment -->                                                      +
!  <body>                                                                     +
!  <b>Sea</b> view wow <u><b>foo</b> bar</u> <i>qq</i>                        +
!  <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>+
!  ff-bg                                                                      +
!  <script>                                                                   +
!         document.write(15);                                                 +
!  </script>                                                                  +
!  </body>                                                                    +
!  </html>
! (1 row)
! 
! --Check if headline fragments work
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean'), 'MaxFragments=1');
!             ts_headline             
! ------------------------------------
!  after day,                        +
!    We stuck, nor breath nor motion,+
!  As idle as a painted Ship         +
!    Upon a painted <b>Ocean</b>.    +
!  Water, water, every where         +
!    And all the boards did shrink;  +
!  Water, water, every where,        +
!    Nor any drop
! (1 row)
! 
! --Check if more than one fragments are displayed
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2');
!                  ts_headline                  
! ----------------------------------------------
!  after day, day after day,                   +
!    We <b>stuck</b>, nor breath nor motion,   +
!  As idle as a painted Ship                   +
!    Upon a painted Ocean.                     +
!  Water, water, every where                   +
!    And all the boards did shrink;            +
!  Water, water, every where ... drop to drink.+
!  S. T. <b>Coleridge</b>
! (1 row)
! 
! --Fragments when there all query words are not in the document
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'ocean & seahorse'), 'MaxFragments=1');
!             ts_headline             
! ------------------------------------
!                                    +
!  Day after day, day after day,     +
!    We stuck, nor breath nor motion,+
!  As idle as
! (1 row)
! 
! --FragmentDelimiter option
! SELECT ts_headline('english', '
! Day after day, day after day,
!   We stuck, nor breath nor motion,
! As idle as a painted Ship
!   Upon a painted Ocean.
! Water, water, every where
!   And all the boards did shrink;
! Water, water, every where,
!   Nor any drop to drink.
! S. T. Coleridge (1772-1834)
! ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2,FragmentDelimiter=***');
!                 ts_headline                 
! --------------------------------------------
!  after day, day after day,                 +
!    We <b>stuck</b>, nor breath nor motion, +
!  As idle as a painted Ship                 +
!    Upon a painted Ocean.                   +
!  Water, water, every where                 +
!    And all the boards did shrink;          +
!  Water, water, every where***drop to drink.+
!  S. T. <b>Coleridge</b>
! (1 row)
! 
! --Rewrite sub system
! CREATE TABLE test_tsquery (txtkeyword TEXT, txtsample TEXT);
! \set ECHO none
! ALTER TABLE test_tsquery ADD COLUMN keyword tsquery;
! UPDATE test_tsquery SET keyword = to_tsquery('english', txtkeyword);
! ALTER TABLE test_tsquery ADD COLUMN sample tsquery;
! UPDATE test_tsquery SET sample = to_tsquery('english', txtsample::text);
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new & york';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! CREATE UNIQUE INDEX bt_tsq ON test_tsquery (keyword);
! SET enable_seqscan=OFF;
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new & york';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new & york';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new & york';
!  count 
! -------
!      2
! (1 row)
! 
! RESET enable_seqscan;
! SELECT ts_rewrite('foo & bar & qq & new & york',  'new & york'::tsquery, 'big & apple | nyc | new & york & city');
!                                     ts_rewrite                                    
! ----------------------------------------------------------------------------------
!  'foo' & 'bar' & 'qq' & ( 'city' & 'new' & 'york' | ( 'nyc' | 'big' & 'apple' ) )
! (1 row)
! 
! SELECT ts_rewrite('moscow', 'SELECT keyword, sample FROM test_tsquery'::text );
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite('moscow & hotel', 'SELECT keyword, sample FROM test_tsquery'::text );
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite('bar & new & qq & foo & york', 'SELECT keyword, sample FROM test_tsquery'::text );
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( 'moscow', 'SELECT keyword, sample FROM test_tsquery');
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( 'moscow & hotel', 'SELECT keyword, sample FROM test_tsquery');
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( 'bar & new & qq & foo & york', 'SELECT keyword, sample FROM test_tsquery');
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
!     keyword     
! ----------------
!  'new' & 'york'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
!  keyword 
! ---------
! (0 rows)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar &  new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! CREATE INDEX qq ON test_tsquery USING gist (keyword tsquery_ops);
! SET enable_seqscan=OFF;
! SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
!     keyword     
! ----------------
!  'new' & 'york'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
!  keyword 
! ---------
! (0 rows)
! 
! SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
!  keyword  
! ----------
!  'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
!      ts_rewrite      
! ---------------------
!  'moskva' | 'moscow'
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
!             ts_rewrite             
! -----------------------------------
!  'hotel' & ( 'moskva' | 'moscow' )
! (1 row)
! 
! SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar &  new & qq & foo & york') AS query;
!                                      ts_rewrite                                      
! -------------------------------------------------------------------------------------
!  'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | ( 'big' & 'appl' | 'new' & 'york' ) )
! (1 row)
! 
! RESET enable_seqscan;
! --test GUC
! SET default_text_search_config=simple;
! SELECT to_tsvector('SKIES My booKs');
!         to_tsvector         
! ----------------------------
!  'books':3 'my':2 'skies':1
! (1 row)
! 
! SELECT plainto_tsquery('SKIES My booKs');
!      plainto_tsquery      
! --------------------------
!  'skies' & 'my' & 'books'
! (1 row)
! 
! SELECT to_tsquery('SKIES & My | booKs');
!         to_tsquery        
! --------------------------
!  'skies' & 'my' | 'books'
! (1 row)
! 
! SET default_text_search_config=english;
! SELECT to_tsvector('SKIES My booKs');
!    to_tsvector    
! ------------------
!  'book':3 'sky':1
! (1 row)
! 
! SELECT plainto_tsquery('SKIES My booKs');
!  plainto_tsquery 
! -----------------
!  'sky' & 'book'
! (1 row)
! 
! SELECT to_tsquery('SKIES & My | booKs');
!    to_tsquery   
! ----------------
!  'sky' | 'book'
! (1 row)
! 
! --trigger
! CREATE TRIGGER tsvectorupdate
! BEFORE UPDATE OR INSERT ON test_tsvector
! FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      0
! (1 row)
! 
! INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      1
! (1 row)
! 
! UPDATE test_tsvector SET t = null WHERE t = '345 qwerty';
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      0
! (1 row)
! 
! INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
! SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
!  count 
! -------
!      1
! (1 row)
! 
! -- test finding items in GIN's pending list
! create temp table pendtest (ts tsvector);
! create index pendtest_idx on pendtest using gin(ts);
! insert into pendtest values (to_tsvector('Lore ipsam'));
! insert into pendtest values (to_tsvector('Lore ipsum'));
! select * from pendtest where 'ipsu:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsum':2 'lore':1
! (1 row)
! 
! select * from pendtest where 'ipsa:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsam':2 'lore':1
! (1 row)
! 
! select * from pendtest where 'ips:*'::tsquery @@ ts;
!          ts         
! --------------------
!  'ipsam':2 'lore':1
!  'ipsum':2 'lore':1
! (2 rows)
! 
! select * from pendtest where 'ipt:*'::tsquery @@ ts;
!  ts 
! ----
! (0 rows)
! 
! select * from pendtest where 'ipi:*'::tsquery @@ ts;
!  ts 
! ----
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/tsdicts.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/tsdicts.out	2015-01-26 12:33:25.931031413 +0300
***************
*** 1,336 ****
! --Test text search dictionaries and configurations
! -- Test ISpell dictionary with ispell affix file
! CREATE TEXT SEARCH DICTIONARY ispell (
!                         Template=ispell,
!                         DictFile=ispell_sample,
!                         AffFile=ispell_sample
! );
! SELECT ts_lexize('ispell', 'skies');
!  ts_lexize 
! -----------
!  {sky}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'bookings');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'booking');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'foot');
!  ts_lexize 
! -----------
!  {foot}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'foots');
!  ts_lexize 
! -----------
!  {foot}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'rebookings');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'rebooking');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'rebook');
!  ts_lexize 
! -----------
!  
! (1 row)
! 
! SELECT ts_lexize('ispell', 'unbookings');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'unbooking');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'unbook');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'footklubber');
!    ts_lexize    
! ----------------
!  {foot,klubber}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'footballklubber');
!                       ts_lexize                       
! ------------------------------------------------------
!  {footballklubber,foot,ball,klubber,football,klubber}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'ballyklubber');
!    ts_lexize    
! ----------------
!  {ball,klubber}
! (1 row)
! 
! SELECT ts_lexize('ispell', 'footballyklubber');
!       ts_lexize      
! ---------------------
!  {foot,ball,klubber}
! (1 row)
! 
! -- Test ISpell dictionary with hunspell affix file
! CREATE TEXT SEARCH DICTIONARY hunspell (
!                         Template=ispell,
!                         DictFile=ispell_sample,
!                         AffFile=hunspell_sample
! );
! SELECT ts_lexize('hunspell', 'skies');
!  ts_lexize 
! -----------
!  {sky}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'bookings');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'booking');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'foot');
!  ts_lexize 
! -----------
!  {foot}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'foots');
!  ts_lexize 
! -----------
!  {foot}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'rebookings');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'rebooking');
!    ts_lexize    
! ----------------
!  {booking,book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'rebook');
!  ts_lexize 
! -----------
!  
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'unbookings');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'unbooking');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'unbook');
!  ts_lexize 
! -----------
!  {book}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'footklubber');
!    ts_lexize    
! ----------------
!  {foot,klubber}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'footballklubber');
!                       ts_lexize                       
! ------------------------------------------------------
!  {footballklubber,foot,ball,klubber,football,klubber}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'ballyklubber');
!    ts_lexize    
! ----------------
!  {ball,klubber}
! (1 row)
! 
! SELECT ts_lexize('hunspell', 'footballyklubber');
!       ts_lexize      
! ---------------------
!  {foot,ball,klubber}
! (1 row)
! 
! -- Synonim dictionary
! CREATE TEXT SEARCH DICTIONARY synonym (
! 						Template=synonym,
! 						Synonyms=synonym_sample
! );
! SELECT ts_lexize('synonym', 'PoStGrEs');
!  ts_lexize 
! -----------
!  {pgsql}
! (1 row)
! 
! SELECT ts_lexize('synonym', 'Gogle');
!  ts_lexize 
! -----------
!  {googl}
! (1 row)
! 
! SELECT ts_lexize('synonym', 'indices');
!  ts_lexize 
! -----------
!  {index}
! (1 row)
! 
! -- Create and simple test thesaurus dictionary
! -- More tests in configuration checks because ts_lexize()
! -- cannot pass more than one word to thesaurus.
! CREATE TEXT SEARCH DICTIONARY thesaurus (
!                         Template=thesaurus,
! 						DictFile=thesaurus_sample,
! 						Dictionary=english_stem
! );
! SELECT ts_lexize('thesaurus', 'one');
!  ts_lexize 
! -----------
!  {1}
! (1 row)
! 
! -- Test ispell dictionary in configuration
! CREATE TEXT SEARCH CONFIGURATION ispell_tst (
! 						COPY=english
! );
! ALTER TEXT SEARCH CONFIGURATION ispell_tst ALTER MAPPING FOR
! 	word, numword, asciiword, hword, numhword, asciihword, hword_part, hword_numpart, hword_asciipart
! 	WITH ispell, english_stem;
! SELECT to_tsvector('ispell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
!                                             to_tsvector                                             
! ----------------------------------------------------------------------------------------------------
!  'ball':7 'book':1,5 'booking':1,5 'foot':7,10 'football':7 'footballklubber':7 'klubber':7 'sky':3
! (1 row)
! 
! SELECT to_tsquery('ispell_tst', 'footballklubber');
!                                   to_tsquery                                  
! ------------------------------------------------------------------------------
!  ( 'footballklubber' | 'foot' & 'ball' & 'klubber' ) | 'football' & 'klubber'
! (1 row)
! 
! SELECT to_tsquery('ispell_tst', 'footballyklubber:b & rebookings:A & sky');
!                                to_tsquery                               
! ------------------------------------------------------------------------
!  'foot':B & 'ball':B & 'klubber':B & ( 'booking':A | 'book':A ) & 'sky'
! (1 row)
! 
! -- Test ispell dictionary with hunspell affix in configuration
! CREATE TEXT SEARCH CONFIGURATION hunspell_tst (
! 						COPY=ispell_tst
! );
! ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING
! 	REPLACE ispell WITH hunspell;
! SELECT to_tsvector('hunspell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
!                                             to_tsvector                                             
! ----------------------------------------------------------------------------------------------------
!  'ball':7 'book':1,5 'booking':1,5 'foot':7,10 'football':7 'footballklubber':7 'klubber':7 'sky':3
! (1 row)
! 
! SELECT to_tsquery('hunspell_tst', 'footballklubber');
!                                   to_tsquery                                  
! ------------------------------------------------------------------------------
!  ( 'footballklubber' | 'foot' & 'ball' & 'klubber' ) | 'football' & 'klubber'
! (1 row)
! 
! SELECT to_tsquery('hunspell_tst', 'footballyklubber:b & rebookings:A & sky');
!                                to_tsquery                               
! ------------------------------------------------------------------------
!  'foot':B & 'ball':B & 'klubber':B & ( 'booking':A | 'book':A ) & 'sky'
! (1 row)
! 
! -- Test synonym dictionary in configuration
! CREATE TEXT SEARCH CONFIGURATION synonym_tst (
! 						COPY=english
! );
! ALTER TEXT SEARCH CONFIGURATION synonym_tst ALTER MAPPING FOR
! 	asciiword, hword_asciipart, asciihword
! 	WITH synonym, english_stem;
! SELECT to_tsvector('synonym_tst', 'Postgresql is often called as postgres or pgsql and pronounced as postgre');
!                     to_tsvector                    
! ---------------------------------------------------
!  'call':4 'often':3 'pgsql':1,6,8,12 'pronounc':10
! (1 row)
! 
! SELECT to_tsvector('synonym_tst', 'Most common mistake is to write Gogle instead of Google');
!                        to_tsvector                        
! ----------------------------------------------------------
!  'common':2 'googl':7,10 'instead':8 'mistak':3 'write':6
! (1 row)
! 
! SELECT to_tsvector('synonym_tst', 'Indexes or indices - Which is right plural form of index?');
!                  to_tsvector                  
! ----------------------------------------------
!  'form':8 'index':1,3,10 'plural':7 'right':6
! (1 row)
! 
! SELECT to_tsquery('synonym_tst', 'Index & indices');
!      to_tsquery      
! ---------------------
!  'index' & 'index':*
! (1 row)
! 
! -- test thesaurus in configuration
! -- see thesaurus_sample.ths to understand 'odd' resulting tsvector
! CREATE TEXT SEARCH CONFIGURATION thesaurus_tst (
! 						COPY=synonym_tst
! );
! ALTER TEXT SEARCH CONFIGURATION thesaurus_tst ALTER MAPPING FOR
! 	asciiword, hword_asciipart, asciihword
! 	WITH synonym, thesaurus, english_stem;
! SELECT to_tsvector('thesaurus_tst', 'one postgres one two one two three one');
!            to_tsvector            
! ----------------------------------
!  '1':1,5 '12':3 '123':4 'pgsql':2
! (1 row)
! 
! SELECT to_tsvector('thesaurus_tst', 'Supernovae star is very new star and usually called supernovae (abbrevation SN)');
!                          to_tsvector                         
! -------------------------------------------------------------
!  'abbrev':10 'call':8 'new':4 'sn':1,9,11 'star':5 'usual':7
! (1 row)
! 
! SELECT to_tsvector('thesaurus_tst', 'Booking tickets is looking like a booking a tickets');
!                       to_tsvector                      
! -------------------------------------------------------
!  'card':3,10 'invit':2,9 'like':6 'look':5 'order':1,8
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/foreign_data.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/foreign_data.out	2015-01-26 12:33:25.919031413 +0300
***************
*** 1,1266 ****
! --
! -- Test foreign-data wrapper and server management.
! --
! -- Clean up in case a prior regression run failed
! -- Suppress NOTICE messages when roles don't exist
! SET client_min_messages TO 'error';
! DROP ROLE IF EXISTS foreign_data_user, regress_test_role, regress_test_role2, regress_test_role_super, regress_test_indirect, unpriviled_role;
! RESET client_min_messages;
! CREATE ROLE foreign_data_user LOGIN SUPERUSER;
! SET SESSION AUTHORIZATION 'foreign_data_user';
! CREATE ROLE regress_test_role;
! CREATE ROLE regress_test_role2;
! CREATE ROLE regress_test_role_super SUPERUSER;
! CREATE ROLE regress_test_indirect;
! CREATE ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER dummy;
! COMMENT ON FOREIGN DATA WRAPPER dummy IS 'useless';
! CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
! -- At this point we should have 2 built-in wrappers and no servers.
! SELECT fdwname, fdwhandler::regproc, fdwvalidator::regproc, fdwoptions FROM pg_foreign_data_wrapper ORDER BY 1, 2, 3;
!   fdwname   | fdwhandler |       fdwvalidator       | fdwoptions 
! ------------+------------+--------------------------+------------
!  dummy      | -          | -                        | 
!  postgresql | -          | postgresql_fdw_validator | 
! (2 rows)
! 
! SELECT srvname, srvoptions FROM pg_foreign_server;
!  srvname | srvoptions 
! ---------+------------
! (0 rows)
! 
! SELECT * FROM pg_user_mapping;
!  umuser | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
! -- CREATE FOREIGN DATA WRAPPER
! CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERROR
! ERROR:  function bar(text[], oid) does not exist
! CREATE FOREIGN DATA WRAPPER foo;
! \dew
!                     List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         
! ------------+-------------------+---------+--------------------------
!  dummy      | foreign_data_user | -       | -
!  foo        | foreign_data_user | -       | -
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator
! (3 rows)
! 
! CREATE FOREIGN DATA WRAPPER foo; -- duplicate
! ERROR:  foreign-data wrapper "foo" already exists
! DROP FOREIGN DATA WRAPPER foo;
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options  | Description 
! ------------+-------------------+---------+--------------------------+-------------------+---------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |               | useless
!  foo        | foreign_data_user | -       | -                        |                   | (testing '1') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |               | 
! (3 rows)
! 
! DROP FOREIGN DATA WRAPPER foo;
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERROR
! ERROR:  option "testing" provided more than once
! CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
! \dew+
!                                                    List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |        FDW Options         | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                            | useless
!  foo        | foreign_data_user | -       | -                        |                   | (testing '1', another '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                            | 
! (3 rows)
! 
! DROP FOREIGN DATA WRAPPER foo;
! SET ROLE regress_test_role;
! CREATE FOREIGN DATA WRAPPER foo; -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foo"
! HINT:  Must be superuser to create a foreign-data wrapper.
! RESET ROLE;
! CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! -- ALTER FOREIGN DATA WRAPPER
! ALTER FOREIGN DATA WRAPPER foo;                             -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: ALTER FOREIGN DATA WRAPPER foo;
!                                       ^
! ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERROR
! ERROR:  function bar(text[], oid) does not exist
! ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | -                        |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERROR
! ERROR:  option "c" not found
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERROR
! ERROR:  option "c" not found
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options   | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                | useless
!  foo        | foreign_data_user | -       | -                        |                   | (a '1', b '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP a, SET b '3', ADD c '4');
! \dew+
!                                              List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |  FDW Options   | Description 
! ------------+-------------------+---------+--------------------------+-------------------+----------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERROR
! ERROR:  option "b" provided more than once
! \dew+
!                                                  List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |      FDW Options      | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-----------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                       | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4', a '2') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                       | 
! (3 rows)
! 
! SET ROLE regress_test_role;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! SET ROLE regress_test_role_super;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
! \dew+
!                                                     List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |                              | useless
!  foo        | foreign_data_user | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role;  -- ERROR
! ERROR:  permission denied to change owner of foreign-data wrapper "foo"
! HINT:  The owner of a foreign-data wrapper must be a superuser.
! ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role_super;
! ALTER ROLE regress_test_role_super NOSUPERUSER;
! SET ROLE regress_test_role_super;
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! RESET ROLE;
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo        | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo RENAME TO foo1;
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo1       | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! ALTER FOREIGN DATA WRAPPER foo1 RENAME TO foo;
! -- DROP FOREIGN DATA WRAPPER
! DROP FOREIGN DATA WRAPPER nonexistent;                      -- ERROR
! ERROR:  foreign-data wrapper "nonexistent" does not exist
! DROP FOREIGN DATA WRAPPER IF EXISTS nonexistent;
! NOTICE:  foreign-data wrapper "nonexistent" does not exist, skipping
! \dew+
!                                                        List of foreign-data wrappers
!     Name    |          Owner          | Handler |        Validator         | Access privileges |         FDW Options          | Description 
! ------------+-------------------------+---------+--------------------------+-------------------+------------------------------+-------------
!  dummy      | foreign_data_user       | -       | -                        |                   |                              | useless
!  foo        | regress_test_role_super | -       | -                        |                   | (b '3', c '4', a '2', d '5') | 
!  postgresql | foreign_data_user       | -       | postgresql_fdw_validator |                   |                              | 
! (3 rows)
! 
! DROP ROLE regress_test_role_super;                          -- ERROR
! ERROR:  role "regress_test_role_super" cannot be dropped because some objects depend on it
! DETAIL:  owner of foreign-data wrapper foo
! SET ROLE regress_test_role_super;
! DROP FOREIGN DATA WRAPPER foo;
! RESET ROLE;
! DROP ROLE regress_test_role_super;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (2 rows)
! 
! CREATE FOREIGN DATA WRAPPER foo;
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
! COMMENT ON SERVER s1 IS 'foreign server';
! CREATE USER MAPPING FOR current_user SERVER s1;
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  foo        | foreign_data_user | -       | -                        |                   |             | 
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (3 rows)
! 
! \des+
!                                                List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges | Type | Version | FDW Options |  Description   
! ------+-------------------+----------------------+-------------------+------+---------+-------------+----------------
!  s1   | foreign_data_user | foo                  |                   |      |         |             | foreign server
! (1 row)
! 
! \deu+
!           List of user mappings
!  Server |     User name     | FDW Options 
! --------+-------------------+-------------
!  s1     | foreign_data_user | 
! (1 row)
! 
! DROP FOREIGN DATA WRAPPER foo;                              -- ERROR
! ERROR:  cannot drop foreign-data wrapper foo because other objects depend on it
! DETAIL:  server s1 depends on foreign-data wrapper foo
! user mapping for foreign_data_user depends on server s1
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! SET ROLE regress_test_role;
! DROP FOREIGN DATA WRAPPER foo CASCADE;                      -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! RESET ROLE;
! DROP FOREIGN DATA WRAPPER foo CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to server s1
! drop cascades to user mapping for foreign_data_user
! \dew+
!                                             List of foreign-data wrappers
!     Name    |       Owner       | Handler |        Validator         | Access privileges | FDW Options | Description 
! ------------+-------------------+---------+--------------------------+-------------------+-------------+-------------
!  dummy      | foreign_data_user | -       | -                        |                   |             | useless
!  postgresql | foreign_data_user | -       | postgresql_fdw_validator |                   |             | 
! (2 rows)
! 
! \des+
!                                        List of foreign servers
!  Name | Owner | Foreign-data wrapper | Access privileges | Type | Version | FDW Options | Description 
! ------+-------+----------------------+-------------------+------+---------+-------------+-------------
! (0 rows)
! 
! \deu+
!       List of user mappings
!  Server | User name | FDW Options 
! --------+-----------+-------------
! (0 rows)
! 
! -- exercise CREATE SERVER
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  foreign-data wrapper "foo" does not exist
! CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
! CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  server "s1" already exists
! CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s3 TYPE 'oracle' FOREIGN DATA WRAPPER foo;
! CREATE SERVER s4 TYPE 'oracle' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s5 VERSION '15.0' FOREIGN DATA WRAPPER foo;
! CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
! CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1'); -- ERROR
! ERROR:  invalid option "foo"
! HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
! CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
! (8 rows)
! 
! SET ROLE regress_test_role;
! CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDW
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! SET ROLE regress_test_role;
! CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
! RESET ROLE;
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                   |        |         |                                   | 
! (9 rows)
! 
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_test_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! GRANT regress_test_indirect TO regress_test_role;
! SET ROLE regress_test_role;
! CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
! \des+
!                                                          List of foreign servers
!  Name |       Owner       | Foreign-data wrapper | Access privileges |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  |                   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                   |        |         | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                   | oracle |         |                                   | 
!  s4   | foreign_data_user | foo                  |                   | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                   |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  |                   |        | 16.0    | (host 'a', dbname 'b')            | 
!  s7   | foreign_data_user | foo                  |                   | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                   |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                   |        |         |                                   | 
!  t2   | regress_test_role | foo                  |                   |        |         |                                   | 
! (10 rows)
! 
! RESET ROLE;
! REVOKE regress_test_indirect FROM regress_test_role;
! -- ALTER SERVER
! ALTER SERVER s0;                                            -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: ALTER SERVER s0;
!                        ^
! ALTER SERVER s0 OPTIONS (a '1');                            -- ERROR
! ERROR:  server "s0" does not exist
! ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
! ALTER SERVER s2 VERSION '1.1';
! ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
! GRANT USAGE ON FOREIGN SERVER s1 TO regress_test_role;
! GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role2 WITH GRANT OPTION;
! \des+
!                                                                     List of foreign servers
!  Name |       Owner       | Foreign-data wrapper |            Access privileges            |  Type  | Version |            FDW Options            | Description 
! ------+-------------------+----------------------+-----------------------------------------+--------+---------+-----------------------------------+-------------
!  s1   | foreign_data_user | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.0     | (servername 's1')                 | 
!       |                   |                      | regress_test_role=U/foreign_data_user   |        |         |                                   | 
!  s2   | foreign_data_user | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')            | 
!  s3   | foreign_data_user | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')  | 
!  s4   | foreign_data_user | foo                  |                                         | oracle |         | (host 'a', dbname 'b')            | 
!  s5   | foreign_data_user | foo                  |                                         |        | 15.0    |                                   | 
!  s6   | foreign_data_user | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')            | 
!       |                   |                      | regress_test_role2=U*/foreign_data_user |        |         |                                   | 
!  s7   | foreign_data_user | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')            | 
!  s8   | foreign_data_user | postgresql           |                                         |        |         | (host 'localhost', dbname 's8db') | 
!  t1   | regress_test_role | foo                  |                                         |        |         |                                   | 
!  t2   | regress_test_role | foo                  |                                         |        |         |                                   | 
! (10 rows)
! 
! SET ROLE regress_test_role;
! ALTER SERVER s1 VERSION '1.1';                              -- ERROR
! ERROR:  must be owner of foreign server s1
! ALTER SERVER s1 OWNER TO regress_test_role;                 -- ERROR
! ERROR:  must be owner of foreign server s1
! RESET ROLE;
! ALTER SERVER s1 OWNER TO regress_test_role;
! GRANT regress_test_role2 TO regress_test_role;
! SET ROLE regress_test_role;
! ALTER SERVER s1 VERSION '1.1';
! ALTER SERVER s1 OWNER TO regress_test_role2;                -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! RESET ROLE;
! ALTER SERVER s8 OPTIONS (foo '1');                          -- ERROR option validation
! ERROR:  invalid option "foo"
! HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
! ALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;             -- ERROR
! ERROR:  must be member of role "regress_test_indirect"
! RESET ROLE;
! GRANT regress_test_indirect TO regress_test_role;
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
! SET ROLE regress_test_role;
! ALTER SERVER s1 OWNER TO regress_test_indirect;
! RESET ROLE;
! DROP ROLE regress_test_indirect;                            -- ERROR
! ERROR:  role "regress_test_indirect" cannot be dropped because some objects depend on it
! DETAIL:  owner of server s1
! privileges for foreign-data wrapper foo
! \des+
!                                                                         List of foreign servers
!  Name |         Owner         | Foreign-data wrapper |            Access privileges            |  Type  | Version |             FDW Options              | Description 
! ------+-----------------------+----------------------+-----------------------------------------+--------+---------+--------------------------------------+-------------
!  s1   | regress_test_indirect | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.1     | (servername 's1')                    | 
!       |                       |                      | regress_test_role=U/foreign_data_user   |        |         |                                      | 
!  s2   | foreign_data_user     | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')               | 
!  s3   | foreign_data_user     | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')     | 
!  s4   | foreign_data_user     | foo                  |                                         | oracle |         | (host 'a', dbname 'b')               | 
!  s5   | foreign_data_user     | foo                  |                                         |        | 15.0    |                                      | 
!  s6   | foreign_data_user     | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')               | 
!       |                       |                      | regress_test_role2=U*/foreign_data_user |        |         |                                      | 
!  s7   | foreign_data_user     | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')               | 
!  s8   | foreign_data_user     | postgresql           |                                         |        |         | (dbname 'db1', connect_timeout '30') | 
!  t1   | regress_test_role     | foo                  |                                         |        |         |                                      | 
!  t2   | regress_test_role     | foo                  |                                         |        |         |                                      | 
! (10 rows)
! 
! ALTER SERVER s8 RENAME to s8new;
! \des+
!                                                                         List of foreign servers
!  Name  |         Owner         | Foreign-data wrapper |            Access privileges            |  Type  | Version |             FDW Options              | Description 
! -------+-----------------------+----------------------+-----------------------------------------+--------+---------+--------------------------------------+-------------
!  s1    | regress_test_indirect | foo                  | foreign_data_user=U/foreign_data_user  +|        | 1.1     | (servername 's1')                    | 
!        |                       |                      | regress_test_role=U/foreign_data_user   |        |         |                                      | 
!  s2    | foreign_data_user     | foo                  |                                         |        | 1.1     | (host 'a', dbname 'b')               | 
!  s3    | foreign_data_user     | foo                  |                                         | oracle |         | ("tns name" 'orcl', port '1521')     | 
!  s4    | foreign_data_user     | foo                  |                                         | oracle |         | (host 'a', dbname 'b')               | 
!  s5    | foreign_data_user     | foo                  |                                         |        | 15.0    |                                      | 
!  s6    | foreign_data_user     | foo                  | foreign_data_user=U/foreign_data_user  +|        | 16.0    | (host 'a', dbname 'b')               | 
!        |                       |                      | regress_test_role2=U*/foreign_data_user |        |         |                                      | 
!  s7    | foreign_data_user     | foo                  |                                         | oracle | 17.0    | (host 'a', dbname 'b')               | 
!  s8new | foreign_data_user     | postgresql           |                                         |        |         | (dbname 'db1', connect_timeout '30') | 
!  t1    | regress_test_role     | foo                  |                                         |        |         |                                      | 
!  t2    | regress_test_role     | foo                  |                                         |        |         |                                      | 
! (10 rows)
! 
! ALTER SERVER s8new RENAME to s8;
! -- DROP SERVER
! DROP SERVER nonexistent;                                    -- ERROR
! ERROR:  server "nonexistent" does not exist
! DROP SERVER IF EXISTS nonexistent;
! NOTICE:  server "nonexistent" does not exist, skipping
! \des
!                List of foreign servers
!  Name |         Owner         | Foreign-data wrapper 
! ------+-----------------------+----------------------
!  s1   | regress_test_indirect | foo
!  s2   | foreign_data_user     | foo
!  s3   | foreign_data_user     | foo
!  s4   | foreign_data_user     | foo
!  s5   | foreign_data_user     | foo
!  s6   | foreign_data_user     | foo
!  s7   | foreign_data_user     | foo
!  s8   | foreign_data_user     | postgresql
!  t1   | regress_test_role     | foo
!  t2   | regress_test_role     | foo
! (10 rows)
! 
! SET ROLE regress_test_role;
! DROP SERVER s2;                                             -- ERROR
! ERROR:  must be owner of foreign server s2
! DROP SERVER s1;
! RESET ROLE;
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s2   | foreign_data_user | foo
!  s3   | foreign_data_user | foo
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (9 rows)
! 
! ALTER SERVER s2 OWNER TO regress_test_role;
! SET ROLE regress_test_role;
! DROP SERVER s2;
! RESET ROLE;
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s3   | foreign_data_user | foo
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (8 rows)
! 
! CREATE USER MAPPING FOR current_user SERVER s3;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s3     | foreign_data_user
! (1 row)
! 
! DROP SERVER s3;                                             -- ERROR
! ERROR:  cannot drop server s3 because other objects depend on it
! DETAIL:  user mapping for foreign_data_user depends on server s3
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP SERVER s3 CASCADE;
! NOTICE:  drop cascades to user mapping for foreign_data_user
! \des
!              List of foreign servers
!  Name |       Owner       | Foreign-data wrapper 
! ------+-------------------+----------------------
!  s4   | foreign_data_user | foo
!  s5   | foreign_data_user | foo
!  s6   | foreign_data_user | foo
!  s7   | foreign_data_user | foo
!  s8   | foreign_data_user | postgresql
!  t1   | regress_test_role | foo
!  t2   | regress_test_role | foo
! (7 rows)
! 
! \deu
! List of user mappings
!  Server | User name 
! --------+-----------
! (0 rows)
! 
! -- CREATE USER MAPPING
! CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! CREATE USER MAPPING FOR current_user SERVER s1;             -- ERROR
! ERROR:  server "s1" does not exist
! CREATE USER MAPPING FOR current_user SERVER s4;
! CREATE USER MAPPING FOR user SERVER s4;                     -- ERROR duplicate
! ERROR:  user mapping "foreign_data_user" already exists for server s4
! CREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
! CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');    -- ERROR
! ERROR:  invalid option "username"
! HINT:  Valid options in this context are: user, password
! CREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
! ALTER SERVER s5 OWNER TO regress_test_role;
! ALTER SERVER s6 OWNER TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER s5;
! CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
! CREATE USER MAPPING FOR current_user SERVER s7;             -- ERROR
! ERROR:  permission denied for foreign server s7
! CREATE USER MAPPING FOR public SERVER s8;                   -- ERROR
! ERROR:  must be owner of foreign server s8
! RESET ROLE;
! ALTER SERVER t1 OWNER TO regress_test_indirect;
! SET ROLE regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER t1 OPTIONS (username 'bob', password 'boo');
! CREATE USER MAPPING FOR public SERVER t1;
! RESET ROLE;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s4     | foreign_data_user
!  s4     | public
!  s5     | regress_test_role
!  s6     | regress_test_role
!  s8     | foreign_data_user
!  t1     | public
!  t1     | regress_test_role
! (7 rows)
! 
! -- ALTER USER MAPPING
! ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  server "ss4" does not exist
! ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');            -- ERROR
! ERROR:  user mapping "public" does not exist for the server
! ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');    -- ERROR
! ERROR:  invalid option "username"
! HINT:  Valid options in this context are: user, password
! ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
! SET ROLE regress_test_role;
! ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
! ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1'); -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
! RESET ROLE;
! \deu+
!                      List of user mappings
!  Server |     User name     |           FDW Options            
! --------+-------------------+----------------------------------
!  s4     | foreign_data_user | 
!  s4     | public            | ("this mapping" 'is public')
!  s5     | regress_test_role | (modified '1')
!  s6     | regress_test_role | (username 'test')
!  s8     | foreign_data_user | (password 'public')
!  t1     | public            | (modified '1')
!  t1     | regress_test_role | (username 'bob', password 'boo')
! (7 rows)
! 
! -- DROP USER MAPPING
! DROP USER MAPPING FOR regress_test_missing_role SERVER s4;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
! DROP USER MAPPING FOR user SERVER ss4;
! ERROR:  server "ss4" does not exist
! DROP USER MAPPING FOR public SERVER s7;                     -- ERROR
! ERROR:  user mapping "public" does not exist for the server
! DROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
! NOTICE:  role "regress_test_missing_role" does not exist, skipping
! DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
! NOTICE:  server does not exist, skipping
! DROP USER MAPPING IF EXISTS FOR public SERVER s7;
! NOTICE:  user mapping "public" does not exist for the server, skipping
! CREATE USER MAPPING FOR public SERVER s8;
! SET ROLE regress_test_role;
! DROP USER MAPPING FOR public SERVER s8;                     -- ERROR
! ERROR:  must be owner of foreign server s8
! RESET ROLE;
! DROP SERVER s7;
! \deu
!    List of user mappings
!  Server |     User name     
! --------+-------------------
!  s4     | foreign_data_user
!  s4     | public
!  s5     | regress_test_role
!  s6     | regress_test_role
!  s8     | foreign_data_user
!  s8     | public
!  t1     | public
!  t1     | regress_test_role
! (8 rows)
! 
! -- CREATE FOREIGN TABLE
! CREATE SCHEMA foreign_schema;
! CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
! CREATE FOREIGN TABLE ft1 ();                                    -- ERROR
! ERROR:  syntax error at or near ";"
! LINE 1: CREATE FOREIGN TABLE ft1 ();
!                                    ^
! CREATE FOREIGN TABLE ft1 () SERVER no_server;                   -- ERROR
! ERROR:  server "no_server" does not exist
! CREATE FOREIGN TABLE ft1 () SERVER s0 WITH OIDS;                -- ERROR
! ERROR:  syntax error at or near "WITH OIDS"
! LINE 1: CREATE FOREIGN TABLE ft1 () SERVER s0 WITH OIDS;
!                                               ^
! CREATE FOREIGN TABLE ft1 (
! 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL,
! 	c2 text OPTIONS (param2 'val2', param3 'val3'),
! 	c3 date
! ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
! COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
! COMMENT ON COLUMN ft1.c1 IS 'ft1.c1';
! \d+ ft1
!                                       Foreign table "public.ft1"
!  Column |  Type   | Modifiers |          FDW Options           | Storage  | Stats target | Description 
! --------+---------+-----------+--------------------------------+----------+--------------+-------------
!  c1     | integer | not null  | ("param 1" 'val1')             | plain    |              | ft1.c1
!  c2     | text    |           | (param2 'val2', param3 'val3') | extended |              | 
!  c3     | date    |           |                                | plain    |              | 
! Server: s0
! FDW Options: (delimiter ',', quote '"', "be quoted" 'value')
! 
! \det+
!                                  List of foreign tables
!  Schema | Table | Server |                   FDW Options                   | Description 
! --------+-------+--------+-------------------------------------------------+-------------
!  public | ft1   | s0     | (delimiter ',', quote '"', "be quoted" 'value') | ft1
! (1 row)
! 
! CREATE INDEX id_ft1_c2 ON ft1 (c2);                             -- ERROR
! ERROR:  cannot create index on foreign table "ft1"
! SELECT * FROM ft1;                                              -- ERROR
! ERROR:  foreign-data wrapper "dummy" has no handler
! EXPLAIN SELECT * FROM ft1;                                      -- ERROR
! ERROR:  foreign-data wrapper "dummy" has no handler
! -- ALTER FOREIGN TABLE
! COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
! COMMENT ON FOREIGN TABLE ft1 IS NULL;
! COMMENT ON COLUMN ft1.c1 IS 'foreign column';
! COMMENT ON COLUMN ft1.c1 IS NULL;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
! ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0'; -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1'); -- ERROR
! ERROR:  cannot alter system column "xmin"
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
!                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
! \d+ ft1
!                                       Foreign table "public.ft1"
!  Column |  Type   | Modifiers |          FDW Options           | Storage  | Stats target | Description 
! --------+---------+-----------+--------------------------------+----------+--------------+-------------
!  c1     | integer | not null  | ("param 1" 'val1')             | plain    | 10000        | 
!  c2     | text    |           | (param2 'val2', param3 'val3') | extended |              | 
!  c3     | date    |           |                                | plain    |              | 
!  c4     | integer | default 0 |                                | plain    |              | 
!  c5     | integer |           |                                | plain    |              | 
!  c6     | integer | not null  |                                | plain    |              | 
!  c7     | integer |           | (p1 'v1', p2 'v2')             | plain    |              | 
!  c8     | text    |           | (p2 'V2')                      | extended |              | 
!  c9     | integer |           |                                | plain    |              | 
!  c10    | integer |           | (p1 'v1')                      | plain    |              | 
! Server: s0
! FDW Options: (delimiter ',', quote '"', "be quoted" 'value')
! 
! -- can't change the column type if it's used elsewhere
! CREATE TABLE use_ft1_column_type (x ft1);
! ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;	-- ERROR
! ERROR:  cannot alter foreign table "ft1" because column "use_ft1_column_type.x" uses its row type
! DROP TABLE use_ft1_column_type;
! ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0); -- ERROR
! ERROR:  constraints are not supported on foreign tables
! LINE 1: ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c...
!                                     ^
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;               -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c1_check;
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 SET WITH OIDS;                          -- ERROR
! ERROR:  "ft1" is not a table
! ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
! ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
! ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;                  -- ERROR
! ERROR:  column "no_column" of relation "ft1" does not exist
! ALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
! NOTICE:  column "no_column" of relation "ft1" does not exist, skipping
! ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
! ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
! ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;                      -- ERROR
! ERROR:  relation "ft1" does not exist
! ALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
! ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
! \d foreign_schema.foreign_table_1
!              Foreign table "foreign_schema.foreign_table_1"
!       Column      |  Type   | Modifiers |          FDW Options           
! ------------------+---------+-----------+--------------------------------
!  foreign_column_1 | integer | not null  | ("param 1" 'val1')
!  c2               | text    |           | (param2 'val2', param3 'val3')
!  c3               | date    |           | 
!  c4               | integer | default 0 | 
!  c5               | integer |           | 
!  c6               | integer | not null  | 
!  c7               | integer |           | (p1 'v1', p2 'v2')
!  c8               | text    |           | (p2 'V2')
!  c10              | integer |           | (p1 'v1')
! Server: s0
! FDW Options: (quote '~', "be quoted" 'value', escape '@')
! 
! -- alter noexisting table
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c4 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
!                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
! NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
! -- Information schema
! SELECT * FROM information_schema.foreign_data_wrappers ORDER BY 1, 2;
!  foreign_data_wrapper_catalog | foreign_data_wrapper_name | authorization_identifier | library_name | foreign_data_wrapper_language 
! ------------------------------+---------------------------+--------------------------+--------------+-------------------------------
!  regression                   | dummy                     | foreign_data_user        |              | c
!  regression                   | foo                       | foreign_data_user        |              | c
!  regression                   | postgresql                | foreign_data_user        |              | c
! (3 rows)
! 
! SELECT * FROM information_schema.foreign_data_wrapper_options ORDER BY 1, 2, 3;
!  foreign_data_wrapper_catalog | foreign_data_wrapper_name | option_name  | option_value 
! ------------------------------+---------------------------+--------------+--------------
!  regression                   | foo                       | test wrapper | true
! (1 row)
! 
! SELECT * FROM information_schema.foreign_servers ORDER BY 1, 2;
!  foreign_server_catalog | foreign_server_name | foreign_data_wrapper_catalog | foreign_data_wrapper_name | foreign_server_type | foreign_server_version | authorization_identifier 
! ------------------------+---------------------+------------------------------+---------------------------+---------------------+------------------------+--------------------------
!  regression             | s0                  | regression                   | dummy                     |                     |                        | foreign_data_user
!  regression             | s4                  | regression                   | foo                       | oracle              |                        | foreign_data_user
!  regression             | s5                  | regression                   | foo                       |                     | 15.0                   | regress_test_role
!  regression             | s6                  | regression                   | foo                       |                     | 16.0                   | regress_test_indirect
!  regression             | s8                  | regression                   | postgresql                |                     |                        | foreign_data_user
!  regression             | t1                  | regression                   | foo                       |                     |                        | regress_test_indirect
!  regression             | t2                  | regression                   | foo                       |                     |                        | regress_test_role
! (7 rows)
! 
! SELECT * FROM information_schema.foreign_server_options ORDER BY 1, 2, 3;
!  foreign_server_catalog | foreign_server_name |   option_name   | option_value 
! ------------------------+---------------------+-----------------+--------------
!  regression             | s4                  | dbname          | b
!  regression             | s4                  | host            | a
!  regression             | s6                  | dbname          | b
!  regression             | s6                  | host            | a
!  regression             | s8                  | connect_timeout | 30
!  regression             | s8                  | dbname          | db1
! (6 rows)
! 
! SELECT * FROM information_schema.user_mappings ORDER BY lower(authorization_identifier), 2, 3;
!  authorization_identifier | foreign_server_catalog | foreign_server_name 
! --------------------------+------------------------+---------------------
!  foreign_data_user        | regression             | s4
!  foreign_data_user        | regression             | s8
!  PUBLIC                   | regression             | s4
!  PUBLIC                   | regression             | s8
!  PUBLIC                   | regression             | t1
!  regress_test_role        | regression             | s5
!  regress_test_role        | regression             | s6
!  regress_test_role        | regression             | t1
! (8 rows)
! 
! SELECT * FROM information_schema.user_mapping_options ORDER BY lower(authorization_identifier), 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name  | option_value 
! --------------------------+------------------------+---------------------+--------------+--------------
!  foreign_data_user        | regression             | s8                  | password     | public
!  PUBLIC                   | regression             | s4                  | this mapping | is public
!  PUBLIC                   | regression             | t1                  | modified     | 1
!  regress_test_role        | regression             | s5                  | modified     | 1
!  regress_test_role        | regression             | s6                  | username     | test
!  regress_test_role        | regression             | t1                  | password     | boo
!  regress_test_role        | regression             | t1                  | username     | bob
! (7 rows)
! 
! SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | foreign_data_user     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
!  foreign_data_user | foreign_data_user     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (4 rows)
! 
! SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | foreign_data_user     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
!  foreign_data_user | foreign_data_user     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (4 rows)
! 
! SELECT * FROM information_schema.foreign_tables ORDER BY 1, 2, 3;
!  foreign_table_catalog | foreign_table_schema | foreign_table_name | foreign_server_catalog | foreign_server_name 
! -----------------------+----------------------+--------------------+------------------------+---------------------
!  regression            | foreign_schema       | foreign_table_1    | regression             | s0
! (1 row)
! 
! SELECT * FROM information_schema.foreign_table_options ORDER BY 1, 2, 3, 4;
!  foreign_table_catalog | foreign_table_schema | foreign_table_name | option_name | option_value 
! -----------------------+----------------------+--------------------+-------------+--------------
!  regression            | foreign_schema       | foreign_table_1    | be quoted   | value
!  regression            | foreign_schema       | foreign_table_1    | escape      | @
!  regression            | foreign_schema       | foreign_table_1    | quote       | ~
! (3 rows)
! 
! SET ROLE regress_test_role;
! SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
! --------------------------+------------------------+---------------------+-------------+--------------
!  PUBLIC                   | regression             | t1                  | modified    | 1
!  regress_test_role        | regression             | s5                  | modified    | 1
!  regress_test_role        | regression             | s6                  | username    | test
!  regress_test_role        | regression             | t1                  | password    | boo
!  regress_test_role        | regression             | t1                  | username    | bob
! (5 rows)
! 
! SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (2 rows)
! 
! SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
!       grantor      |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
! -------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
!  foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
!  foreign_data_user | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
! (2 rows)
! 
! DROP USER MAPPING FOR current_user SERVER t1;
! SET ROLE regress_test_role2;
! SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
!  authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
! --------------------------+------------------------+---------------------+-------------+--------------
!  regress_test_role        | regression             | s6                  | username    | 
! (1 row)
! 
! RESET ROLE;
! -- has_foreign_data_wrapper_privilege
! SELECT has_foreign_data_wrapper_privilege('regress_test_role',
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! SELECT has_foreign_data_wrapper_privilege('foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
!  has_foreign_data_wrapper_privilege 
! ------------------------------------
!  t
! (1 row)
! 
! -- has_server_privilege
! SELECT has_server_privilege('regress_test_role',
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! SELECT has_server_privilege(
!     (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  f
! (1 row)
! 
! SELECT has_server_privilege('s8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! GRANT USAGE ON FOREIGN SERVER s8 TO regress_test_role;
! SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
!  has_server_privilege 
! ----------------------
!  t
! (1 row)
! 
! REVOKE USAGE ON FOREIGN SERVER s8 FROM regress_test_role;
! GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
! DROP USER MAPPING FOR public SERVER s4;
! ALTER SERVER s6 OPTIONS (DROP host, DROP dbname);
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (DROP username);
! ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
! WARNING:  changing the foreign-data wrapper validator can cause the options for dependent objects to become invalid
! -- Privileges
! SET ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
! HINT:  Must be superuser to create a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OWNER TO unprivileged_role;      -- ERROR
! ERROR:  permission denied to change owner of foreign-data wrapper "foo"
! HINT:  Must be superuser to change owner of a foreign-data wrapper.
! DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! ALTER SERVER s4 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER SERVER s4 OWNER TO unprivileged_role;                     -- ERROR
! ERROR:  must be owner of foreign server s4
! DROP SERVER s4;                                                 -- ERROR
! ERROR:  must be owner of foreign server s4
! GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR
! ERROR:  permission denied for foreign server s4
! CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR
! ERROR:  must be owner of foreign server s4
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
! RESET ROLE;
! GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO unprivileged_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO unprivileged_role WITH GRANT OPTION;
! SET ROLE unprivileged_role;
! CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
! HINT:  Must be superuser to create a foreign-data wrapper.
! ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
! HINT:  Must be superuser to alter a foreign-data wrapper.
! DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
! ERROR:  must be owner of foreign-data wrapper foo
! GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role; -- WARNING
! WARNING:  no privileges were granted for "postgresql"
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
! CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
! ALTER SERVER s6 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP SERVER s6;                                                 -- ERROR
! ERROR:  must be owner of foreign server s6
! GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERROR
! ERROR:  permission denied for foreign server s6
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
! CREATE USER MAPPING FOR public SERVER s6;                       -- ERROR
! ERROR:  must be owner of foreign server s6
! CREATE USER MAPPING FOR public SERVER s9;
! ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
! DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
! RESET ROLE;
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM unprivileged_role; -- ERROR
! ERROR:  dependent privileges exist
! HINT:  Use CASCADE to revoke them too.
! REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM unprivileged_role CASCADE;
! SET ROLE unprivileged_role;
! GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! CREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
! ALTER SERVER s9 VERSION '1.1';
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
! CREATE USER MAPPING FOR current_user SERVER s9;
! DROP SERVER s9 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to user mapping for public
! drop cascades to user mapping for unprivileged_role
! RESET ROLE;
! CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
! GRANT USAGE ON FOREIGN SERVER s9 TO unprivileged_role;
! SET ROLE unprivileged_role;
! ALTER SERVER s9 VERSION '1.2';                                  -- ERROR
! ERROR:  must be owner of foreign server s9
! GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNING
! WARNING:  no privileges were granted for "s9"
! CREATE USER MAPPING FOR current_user SERVER s9;
! DROP SERVER s9 CASCADE;                                         -- ERROR
! ERROR:  must be owner of foreign server s9
! RESET ROLE;
! -- Triggers
! CREATE FUNCTION dummy_trigger() RETURNS TRIGGER AS $$
!   BEGIN
!     RETURN NULL;
!   END
! $$ language plpgsql;
! CREATE TRIGGER trigtest_before_stmt BEFORE INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH STATEMENT
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH STATEMENT
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
! ON foreign_schema.foreign_table_1
! FOR EACH ROW
! EXECUTE PROCEDURE dummy_trigger();
! ERROR:  "foreign_table_1" is a foreign table
! DETAIL:  Foreign tables cannot have constraint triggers.
! ALTER FOREIGN TABLE foreign_schema.foreign_table_1
! 	DISABLE TRIGGER trigtest_before_stmt;
! ALTER FOREIGN TABLE foreign_schema.foreign_table_1
! 	ENABLE TRIGGER trigtest_before_stmt;
! DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
! DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
! DROP FUNCTION dummy_trigger();
! -- IMPORT FOREIGN SCHEMA
! IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public; -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public; --ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public; -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! IMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO public
! OPTIONS (option1 'value1', option2 'value2'); -- ERROR
! ERROR:  foreign-data wrapper "foo" has no handler
! -- DROP FOREIGN TABLE
! DROP FOREIGN TABLE no_table;                                    -- ERROR
! ERROR:  foreign table "no_table" does not exist
! DROP FOREIGN TABLE IF EXISTS no_table;
! NOTICE:  foreign table "no_table" does not exist, skipping
! DROP FOREIGN TABLE foreign_schema.foreign_table_1;
! -- Cleanup
! DROP SCHEMA foreign_schema CASCADE;
! DROP ROLE regress_test_role;                                -- ERROR
! ERROR:  role "regress_test_role" cannot be dropped because some objects depend on it
! DETAIL:  privileges for server s4
! privileges for foreign-data wrapper foo
! owner of user mapping for regress_test_role
! owner of user mapping for regress_test_role
! owner of server s5
! owner of server t2
! DROP SERVER s5 CASCADE;
! NOTICE:  drop cascades to user mapping for regress_test_role
! DROP SERVER t1 CASCADE;
! NOTICE:  drop cascades to user mapping for public
! DROP SERVER t2;
! DROP USER MAPPING FOR regress_test_role SERVER s6;
! -- This test causes some order dependent cascade detail output,
! -- so switch to terse mode for it.
! \set VERBOSITY terse
! DROP FOREIGN DATA WRAPPER foo CASCADE;
! NOTICE:  drop cascades to 5 other objects
! \set VERBOSITY default
! DROP SERVER s8 CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to user mapping for foreign_data_user
! drop cascades to user mapping for public
! DROP ROLE regress_test_indirect;
! DROP ROLE regress_test_role;
! DROP ROLE unprivileged_role;                                -- ERROR
! ERROR:  role "unprivileged_role" cannot be dropped because some objects depend on it
! DETAIL:  privileges for foreign-data wrapper postgresql
! REVOKE ALL ON FOREIGN DATA WRAPPER postgresql FROM unprivileged_role;
! DROP ROLE unprivileged_role;
! DROP ROLE regress_test_role2;
! DROP FOREIGN DATA WRAPPER postgresql CASCADE;
! DROP FOREIGN DATA WRAPPER dummy CASCADE;
! NOTICE:  drop cascades to server s0
! \c
! DROP ROLE foreign_data_user;
! -- At this point we should have no wrappers, no servers, and no mappings.
! SELECT fdwname, fdwhandler, fdwvalidator, fdwoptions FROM pg_foreign_data_wrapper;
!  fdwname | fdwhandler | fdwvalidator | fdwoptions 
! ---------+------------+--------------+------------
! (0 rows)
! 
! SELECT srvname, srvoptions FROM pg_foreign_server;
!  srvname | srvoptions 
! ---------+------------
! (0 rows)
! 
! SELECT * FROM pg_user_mapping;
!  umuser | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/window.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/window.out	2015-01-26 12:33:25.959031415 +0300
***************
*** 1,1824 ****
! --
! -- WINDOW FUNCTIONS
! --
! CREATE TEMPORARY TABLE empsalary (
!     depname varchar,
!     empno bigint,
!     salary int,
!     enroll_date date
! );
! INSERT INTO empsalary VALUES
! ('develop', 10, 5200, '2007-08-01'),
! ('sales', 1, 5000, '2006-10-01'),
! ('personnel', 5, 3500, '2007-12-10'),
! ('sales', 4, 4800, '2007-08-08'),
! ('personnel', 2, 3900, '2006-12-23'),
! ('develop', 7, 4200, '2008-01-01'),
! ('develop', 9, 4500, '2008-01-01'),
! ('sales', 3, 4800, '2007-08-01'),
! ('develop', 8, 6000, '2006-10-01'),
! ('develop', 11, 5200, '2007-08-15');
! SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;
!   depname  | empno | salary |  sum  
! -----------+-------+--------+-------
!  develop   |     7 |   4200 | 25100
!  develop   |     9 |   4500 | 25100
!  develop   |    11 |   5200 | 25100
!  develop   |    10 |   5200 | 25100
!  develop   |     8 |   6000 | 25100
!  personnel |     5 |   3500 |  7400
!  personnel |     2 |   3900 |  7400
!  sales     |     3 |   4800 | 14600
!  sales     |     4 |   4800 | 14600
!  sales     |     1 |   5000 | 14600
! (10 rows)
! 
! SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;
!   depname  | empno | salary | rank 
! -----------+-------+--------+------
!  develop   |     7 |   4200 |    1
!  develop   |     9 |   4500 |    2
!  develop   |    11 |   5200 |    3
!  develop   |    10 |   5200 |    3
!  develop   |     8 |   6000 |    5
!  personnel |     5 |   3500 |    1
!  personnel |     2 |   3900 |    2
!  sales     |     3 |   4800 |    1
!  sales     |     4 |   4800 |    1
!  sales     |     1 |   5000 |    3
! (10 rows)
! 
! -- with GROUP BY
! SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1
! GROUP BY four, ten ORDER BY four, ten;
!  four | ten | sum  |          avg           
! ------+-----+------+------------------------
!     0 |   0 |    0 | 0.00000000000000000000
!     0 |   2 |    0 |     2.0000000000000000
!     0 |   4 |    0 |     4.0000000000000000
!     0 |   6 |    0 |     6.0000000000000000
!     0 |   8 |    0 |     8.0000000000000000
!     1 |   1 | 2500 | 1.00000000000000000000
!     1 |   3 | 2500 |     3.0000000000000000
!     1 |   5 | 2500 |     5.0000000000000000
!     1 |   7 | 2500 |     7.0000000000000000
!     1 |   9 | 2500 |     9.0000000000000000
!     2 |   0 | 5000 | 0.00000000000000000000
!     2 |   2 | 5000 |     2.0000000000000000
!     2 |   4 | 5000 |     4.0000000000000000
!     2 |   6 | 5000 |     6.0000000000000000
!     2 |   8 | 5000 |     8.0000000000000000
!     3 |   1 | 7500 | 1.00000000000000000000
!     3 |   3 | 7500 |     3.0000000000000000
!     3 |   5 | 7500 |     5.0000000000000000
!     3 |   7 | 7500 |     7.0000000000000000
!     3 |   9 | 7500 |     9.0000000000000000
! (20 rows)
! 
! SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);
!   depname  | empno | salary |  sum  
! -----------+-------+--------+-------
!  develop   |    11 |   5200 | 25100
!  develop   |     7 |   4200 | 25100
!  develop   |     9 |   4500 | 25100
!  develop   |     8 |   6000 | 25100
!  develop   |    10 |   5200 | 25100
!  personnel |     5 |   3500 |  7400
!  personnel |     2 |   3900 |  7400
!  sales     |     3 |   4800 | 14600
!  sales     |     1 |   5000 | 14600
!  sales     |     4 |   4800 | 14600
! (10 rows)
! 
! SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;
!   depname  | empno | salary | rank 
! -----------+-------+--------+------
!  develop   |     7 |   4200 |    1
!  personnel |     5 |   3500 |    1
!  sales     |     3 |   4800 |    1
!  sales     |     4 |   4800 |    1
!  personnel |     2 |   3900 |    2
!  develop   |     9 |   4500 |    2
!  sales     |     1 |   5000 |    3
!  develop   |    11 |   5200 |    3
!  develop   |    10 |   5200 |    3
!  develop   |     8 |   6000 |    5
! (10 rows)
! 
! -- empty window specification
! SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;
!  count 
! -------
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
! (10 rows)
! 
! SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();
!  count 
! -------
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
!     10
! (10 rows)
! 
! -- no window operation
! SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);
!  four 
! ------
! (0 rows)
! 
! -- cumulative aggregate
! SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;
!  sum_1 | ten | four 
! -------+-----+------
!      0 |   0 |    0
!      0 |   0 |    0
!      2 |   0 |    2
!      3 |   1 |    3
!      4 |   1 |    1
!      5 |   1 |    1
!      3 |   3 |    3
!      0 |   4 |    0
!      1 |   7 |    1
!      1 |   9 |    1
! (10 rows)
! 
! SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;
!  row_number 
! ------------
!           1
!           2
!           3
!           4
!           5
!           6
!           7
!           8
!           9
!          10
! (10 rows)
! 
! SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;
!  rank_1 | ten | four 
! --------+-----+------
!       1 |   0 |    0
!       1 |   0 |    0
!       3 |   4 |    0
!       1 |   1 |    1
!       1 |   1 |    1
!       3 |   7 |    1
!       4 |   9 |    1
!       1 |   0 |    2
!       1 |   1 |    3
!       2 |   3 |    3
! (10 rows)
! 
! SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  dense_rank | ten | four 
! ------------+-----+------
!           1 |   0 |    0
!           1 |   0 |    0
!           2 |   4 |    0
!           1 |   1 |    1
!           1 |   1 |    1
!           2 |   7 |    1
!           3 |   9 |    1
!           1 |   0 |    2
!           1 |   1 |    3
!           2 |   3 |    3
! (10 rows)
! 
! SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!    percent_rank    | ten | four 
! -------------------+-----+------
!                  0 |   0 |    0
!                  0 |   0 |    0
!                  1 |   4 |    0
!                  0 |   1 |    1
!                  0 |   1 |    1
!  0.666666666666667 |   7 |    1
!                  1 |   9 |    1
!                  0 |   0 |    2
!                  0 |   1 |    3
!                  1 |   3 |    3
! (10 rows)
! 
! SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!      cume_dist     | ten | four 
! -------------------+-----+------
!  0.666666666666667 |   0 |    0
!  0.666666666666667 |   0 |    0
!                  1 |   4 |    0
!                0.5 |   1 |    1
!                0.5 |   1 |    1
!               0.75 |   7 |    1
!                  1 |   9 |    1
!                  1 |   0 |    2
!                0.5 |   1 |    3
!                  1 |   3 |    3
! (10 rows)
! 
! SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;
!  ntile | ten | four 
! -------+-----+------
!      1 |   0 |    0
!      1 |   0 |    0
!      1 |   0 |    2
!      1 |   1 |    1
!      2 |   1 |    1
!      2 |   1 |    3
!      2 |   3 |    3
!      3 |   4 |    0
!      3 |   7 |    1
!      3 |   9 |    1
! (10 rows)
! 
! SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;
!  ntile | ten | four 
! -------+-----+------
!        |   0 |    0
!        |   0 |    0
! (2 rows)
! 
! SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!      |   0 |    0
!    0 |   0 |    0
!    0 |   4 |    0
!      |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!      |   0 |    2
!      |   1 |    3
!    1 |   3 |    3
! (10 rows)
! 
! SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!    0 |   0 |    0
!    0 |   0 |    0
!    4 |   4 |    0
!      |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!      |   0 |    2
!      |   1 |    3
!      |   3 |    3
! (10 rows)
! 
! SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lag | ten | four 
! -----+-----+------
!    0 |   0 |    0
!    0 |   0 |    0
!    4 |   4 |    0
!    0 |   1 |    1
!    1 |   1 |    1
!    1 |   7 |    1
!    7 |   9 |    1
!    0 |   0 |    2
!    0 |   1 |    3
!    0 |   3 |    3
! (10 rows)
! 
! SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     4 |   0 |    0
!       |   4 |    0
!     1 |   1 |    1
!     7 |   1 |    1
!     9 |   7 |    1
!       |   9 |    1
!       |   0 |    2
!     3 |   1 |    3
!       |   3 |    3
! (10 rows)
! 
! SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     8 |   0 |    0
!       |   4 |    0
!     2 |   1 |    1
!    14 |   1 |    1
!    18 |   7 |    1
!       |   9 |    1
!       |   0 |    2
!     6 |   1 |    3
!       |   3 |    3
! (10 rows)
! 
! SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  lead | ten | four 
! ------+-----+------
!     0 |   0 |    0
!     8 |   0 |    0
!    -1 |   4 |    0
!     2 |   1 |    1
!    14 |   1 |    1
!    18 |   7 |    1
!    -1 |   9 |    1
!    -1 |   0 |    2
!     6 |   1 |    3
!    -1 |   3 |    3
! (10 rows)
! 
! SELECT first_value(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  first_value | ten | four 
! -------------+-----+------
!            0 |   0 |    0
!            0 |   0 |    0
!            0 |   4 |    0
!            1 |   1 |    1
!            1 |   1 |    1
!            1 |   7 |    1
!            1 |   9 |    1
!            0 |   0 |    2
!            1 |   1 |    3
!            1 |   3 |    3
! (10 rows)
! 
! -- last_value returns the last row of the frame, which is CURRENT ROW in ORDER BY window.
! SELECT last_value(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;
!  last_value | ten | four 
! ------------+-----+------
!           0 |   0 |    0
!           0 |   0 |    2
!           0 |   0 |    0
!           1 |   1 |    1
!           1 |   1 |    3
!           1 |   1 |    1
!           3 |   3 |    3
!           0 |   4 |    0
!           1 |   7 |    1
!           1 |   9 |    1
! (10 rows)
! 
! SELECT last_value(ten) OVER (PARTITION BY four), ten, four FROM
! 	(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s
! 	ORDER BY four, ten;
!  last_value | ten | four 
! ------------+-----+------
!           4 |   0 |    0
!           4 |   0 |    0
!           4 |   4 |    0
!           9 |   1 |    1
!           9 |   1 |    1
!           9 |   7 |    1
!           9 |   9 |    1
!           0 |   0 |    2
!           3 |   1 |    3
!           3 |   3 |    3
! (10 rows)
! 
! SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four
! 	FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;
!  nth_value | ten | four 
! -----------+-----+------
!          0 |   0 |    0
!          0 |   0 |    0
!          0 |   4 |    0
!          1 |   1 |    1
!          1 |   1 |    1
!          1 |   7 |    1
!          1 |   9 |    1
!            |   0 |    2
!            |   1 |    3
!            |   3 |    3
! (10 rows)
! 
! SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum
! FROM tenk1 GROUP BY ten, two;
!  ten | two | gsum  |  wsum  
! -----+-----+-------+--------
!    0 |   0 | 45000 |  45000
!    2 |   0 | 47000 |  92000
!    4 |   0 | 49000 | 141000
!    6 |   0 | 51000 | 192000
!    8 |   0 | 53000 | 245000
!    1 |   1 | 46000 |  46000
!    3 |   1 | 48000 |  94000
!    5 |   1 | 50000 | 144000
!    7 |   1 | 52000 | 196000
!    9 |   1 | 54000 | 250000
! (10 rows)
! 
! SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;
!  count | four 
! -------+------
!      4 |    1
!      4 |    1
!      4 |    1
!      4 |    1
!      2 |    3
!      2 |    3
! (6 rows)
! 
! SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +
!   sum(hundred) OVER (PARTITION BY four ORDER BY ten))::varchar AS cntsum
!   FROM tenk1 WHERE unique2 < 10;
!  cntsum 
! --------
!  22
!  22
!  87
!  24
!  24
!  82
!  92
!  51
!  92
!  136
! (10 rows)
! 
! -- opexpr with different windows evaluation.
! SELECT * FROM(
!   SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +
!     sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,
!     count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,
!     sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum
!     FROM tenk1
! )sub
! WHERE total <> fourcount + twosum;
!  total | fourcount | twosum 
! -------+-----------+--------
! (0 rows)
! 
! SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;
!           avg           
! ------------------------
!  0.00000000000000000000
!  0.00000000000000000000
!  0.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!  1.00000000000000000000
!      2.0000000000000000
!      3.0000000000000000
!      3.0000000000000000
! (10 rows)
! 
! SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum
! FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);
!  ten | two | gsum  |  wsum  
! -----+-----+-------+--------
!    0 |   0 | 45000 |  45000
!    2 |   0 | 47000 |  92000
!    4 |   0 | 49000 | 141000
!    6 |   0 | 51000 | 192000
!    8 |   0 | 53000 | 245000
!    1 |   1 | 46000 |  46000
!    3 |   1 | 48000 |  94000
!    5 |   1 | 50000 | 144000
!    7 |   1 | 52000 | 196000
!    9 |   1 | 54000 | 250000
! (10 rows)
! 
! -- more than one window with GROUP BY
! SELECT sum(salary),
! 	row_number() OVER (ORDER BY depname),
! 	sum(sum(salary)) OVER (ORDER BY depname DESC)
! FROM empsalary GROUP BY depname;
!   sum  | row_number |  sum  
! -------+------------+-------
!  14600 |          3 | 14600
!   7400 |          2 | 22000
!  25100 |          1 | 47100
! (3 rows)
! 
! -- identical windows with different names
! SELECT sum(salary) OVER w1, count(*) OVER w2
! FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);
!   sum  | count 
! -------+-------
!   3500 |     1
!   7400 |     2
!  11600 |     3
!  16100 |     4
!  25700 |     6
!  25700 |     6
!  30700 |     7
!  41100 |     9
!  41100 |     9
!  47100 |    10
! (10 rows)
! 
! -- subplan
! SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)
! FROM tenk1 s WHERE unique2 < 10;
!  lead 
! ------
!     0
!     0
!     4
!     1
!     7
!     9
!      
!     0
!     3
!      
! (10 rows)
! 
! -- empty table
! SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;
!  count 
! -------
! (0 rows)
! 
! -- mixture of agg/wfunc in the same window
! SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
!   sum  | rank 
! -------+------
!   6000 |    1
!  16400 |    2
!  16400 |    2
!  20900 |    4
!  25100 |    5
!   3900 |    1
!   7400 |    2
!   5000 |    1
!  14600 |    2
!  14600 |    2
! (10 rows)
! 
! -- strict aggs
! SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(
! 	SELECT *,
! 		CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(YEAR FROM enroll_date) END * 500 AS bonus,
! 		CASE WHEN
! 			AVG(salary) OVER (PARTITION BY depname) < salary
! 		THEN 200 END AS depadj FROM empsalary
! )s;
!  empno |  depname  | salary | bonus | depadj | min  | max 
! -------+-----------+--------+-------+--------+------+-----
!      1 | sales     |   5000 |  1000 |    200 | 1000 | 200
!      2 | personnel |   3900 |  1000 |    200 | 1000 | 200
!      3 | sales     |   4800 |   500 |        |  500 | 200
!      4 | sales     |   4800 |   500 |        |  500 | 200
!      5 | personnel |   3500 |   500 |        |  500 | 200
!      7 | develop   |   4200 |       |        |  500 | 200
!      8 | develop   |   6000 |  1000 |    200 |  500 | 200
!      9 | develop   |   4500 |       |        |  500 | 200
!     10 | develop   |   5200 |   500 |    200 |  500 | 200
!     11 | develop   |   5200 |   500 |    200 |  500 | 200
! (10 rows)
! 
! -- window function over ungrouped agg over empty row set (bug before 9.1)
! SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;
!  sum 
! -----
!    0
! (1 row)
! 
! -- window function with ORDER BY an expression involving aggregates (9.1 bug)
! select ten,
!   sum(unique1) + sum(unique2) as res,
!   rank() over (order by sum(unique1) + sum(unique2)) as rank
! from tenk1
! group by ten order by ten;
!  ten |   res    | rank 
! -----+----------+------
!    0 |  9976146 |    4
!    1 | 10114187 |    9
!    2 | 10059554 |    8
!    3 |  9878541 |    1
!    4 |  9881005 |    2
!    5 |  9981670 |    5
!    6 |  9947099 |    3
!    7 | 10120309 |   10
!    8 |  9991305 |    6
!    9 | 10040184 |    7
! (10 rows)
! 
! -- window and aggregate with GROUP BY expression (9.2 bug)
! explain (costs off)
! select first_value(max(x)) over (), y
!   from (select unique1 as x, ten+four as y from tenk1) ss
!   group by y;
!                  QUERY PLAN                  
! ---------------------------------------------
!  WindowAgg
!    ->  HashAggregate
!          Group Key: (tenk1.ten + tenk1.four)
!          ->  Seq Scan on tenk1
! (4 rows)
! 
! -- test non-default frame specifications
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten),
! 	last_value(ten) over (partition by four order by ten)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   2 |   2 |          2
!     0 |   4 |   6 |          4
!     0 |   6 |  12 |          6
!     0 |   8 |  20 |          8
!     1 |   1 |   1 |          1
!     1 |   3 |   4 |          3
!     1 |   5 |   9 |          5
!     1 |   7 |  16 |          7
!     1 |   9 |  25 |          9
!     2 |   0 |   0 |          0
!     2 |   2 |   2 |          2
!     2 |   4 |   6 |          4
!     2 |   6 |  12 |          6
!     2 |   8 |  20 |          8
!     3 |   1 |   1 |          1
!     3 |   3 |   4 |          3
!     3 |   5 |   9 |          5
!     3 |   7 |  16 |          7
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten range between unbounded preceding and current row),
! 	last_value(ten) over (partition by four order by ten range between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   2 |   2 |          2
!     0 |   4 |   6 |          4
!     0 |   6 |  12 |          6
!     0 |   8 |  20 |          8
!     1 |   1 |   1 |          1
!     1 |   3 |   4 |          3
!     1 |   5 |   9 |          5
!     1 |   7 |  16 |          7
!     1 |   9 |  25 |          9
!     2 |   0 |   0 |          0
!     2 |   2 |   2 |          2
!     2 |   4 |   6 |          4
!     2 |   6 |  12 |          6
!     2 |   8 |  20 |          8
!     3 |   1 |   1 |          1
!     3 |   3 |   4 |          3
!     3 |   5 |   9 |          5
!     3 |   7 |  16 |          7
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten,
! 	sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),
! 	last_value(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)
! FROM (select distinct ten, four from tenk1) ss;
!  four | ten | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |  20 |          8
!     0 |   2 |  20 |          8
!     0 |   4 |  20 |          8
!     0 |   6 |  20 |          8
!     0 |   8 |  20 |          8
!     1 |   1 |  25 |          9
!     1 |   3 |  25 |          9
!     1 |   5 |  25 |          9
!     1 |   7 |  25 |          9
!     1 |   9 |  25 |          9
!     2 |   0 |  20 |          8
!     2 |   2 |  20 |          8
!     2 |   4 |  20 |          8
!     2 |   6 |  20 |          8
!     2 |   8 |  20 |          8
!     3 |   1 |  25 |          9
!     3 |   3 |  25 |          9
!     3 |   5 |  25 |          9
!     3 |   7 |  25 |          9
!     3 |   9 |  25 |          9
! (20 rows)
! 
! SELECT four, ten/4 as two,
! 	sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),
! 	last_value(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | two | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   0 |   0 |          0
!     0 |   1 |   2 |          1
!     0 |   1 |   2 |          1
!     0 |   2 |   4 |          2
!     1 |   0 |   0 |          0
!     1 |   0 |   0 |          0
!     1 |   1 |   2 |          1
!     1 |   1 |   2 |          1
!     1 |   2 |   4 |          2
!     2 |   0 |   0 |          0
!     2 |   0 |   0 |          0
!     2 |   1 |   2 |          1
!     2 |   1 |   2 |          1
!     2 |   2 |   4 |          2
!     3 |   0 |   0 |          0
!     3 |   0 |   0 |          0
!     3 |   1 |   2 |          1
!     3 |   1 |   2 |          1
!     3 |   2 |   4 |          2
! (20 rows)
! 
! SELECT four, ten/4 as two,
! 	sum(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row),
! 	last_value(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row)
! FROM (select distinct ten, four from tenk1) ss;
!  four | two | sum | last_value 
! ------+-----+-----+------------
!     0 |   0 |   0 |          0
!     0 |   0 |   0 |          0
!     0 |   1 |   1 |          1
!     0 |   1 |   2 |          1
!     0 |   2 |   4 |          2
!     1 |   0 |   0 |          0
!     1 |   0 |   0 |          0
!     1 |   1 |   1 |          1
!     1 |   1 |   2 |          1
!     1 |   2 |   4 |          2
!     2 |   0 |   0 |          0
!     2 |   0 |   0 |          0
!     2 |   1 |   1 |          1
!     2 |   1 |   2 |          1
!     2 |   2 |   4 |          2
!     3 |   0 |   0 |          0
!     3 |   0 |   0 |          0
!     3 |   1 |   1 |          1
!     3 |   1 |   2 |          1
!     3 |   2 |   4 |          2
! (20 rows)
! 
! SELECT sum(unique1) over (order by four range between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!   45 |       0 |    0
!   45 |       8 |    0
!   45 |       4 |    0
!   33 |       5 |    1
!   33 |       9 |    1
!   33 |       1 |    1
!   18 |       6 |    2
!   18 |       2 |    2
!   10 |       3 |    3
!   10 |       7 |    3
! (10 rows)
! 
! SELECT sum(unique1) over (rows between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!   45 |       4 |    0
!   41 |       2 |    2
!   39 |       1 |    1
!   38 |       6 |    2
!   32 |       9 |    1
!   23 |       8 |    0
!   15 |       5 |    1
!   10 |       3 |    3
!    7 |       7 |    3
!    0 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 2 preceding and 2 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    7 |       4 |    0
!   13 |       2 |    2
!   22 |       1 |    1
!   26 |       6 |    2
!   29 |       9 |    1
!   31 |       8 |    0
!   32 |       5 |    1
!   23 |       3 |    3
!   15 |       7 |    3
!   10 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 2 preceding and 1 preceding),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!      |       4 |    0
!    4 |       2 |    2
!    6 |       1 |    1
!    3 |       6 |    2
!    7 |       9 |    1
!   15 |       8 |    0
!   17 |       5 |    1
!   13 |       3 |    3
!    8 |       7 |    3
!   10 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between 1 following and 3 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    9 |       4 |    0
!   16 |       2 |    2
!   23 |       1 |    1
!   22 |       6 |    2
!   16 |       9 |    1
!   15 |       8 |    0
!   10 |       5 |    1
!    7 |       3 |    3
!    0 |       7 |    3
!      |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (rows between unbounded preceding and 1 following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 | four 
! -----+---------+------
!    6 |       4 |    0
!    7 |       2 |    2
!   13 |       1 |    1
!   22 |       6 |    2
!   30 |       9 |    1
!   35 |       8 |    0
!   38 |       5 |    1
!   45 |       3 |    3
!   45 |       7 |    3
!   45 |       0 |    0
! (10 rows)
! 
! SELECT sum(unique1) over (w range between current row and unbounded following),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
!  sum | unique1 | four 
! -----+---------+------
!   45 |       0 |    0
!   45 |       8 |    0
!   45 |       4 |    0
!   33 |       5 |    1
!   33 |       9 |    1
!   33 |       1 |    1
!   18 |       6 |    2
!   18 |       2 |    2
!   10 |       3 |    3
!   10 |       7 |    3
! (10 rows)
! 
! -- fail: not implemented yet
! SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding),
! 	unique1, four
! FROM tenk1 WHERE unique1 < 10;
! ERROR:  RANGE PRECEDING is only supported with UNBOUNDED
! LINE 1: SELECT sum(unique1) over (order by four range between 2::int...
!                                                 ^
! SELECT first_value(unique1) over w,
! 	nth_value(unique1, 2) over w AS nth_2,
! 	last_value(unique1) over w, unique1, four
! FROM tenk1 WHERE unique1 < 10
! WINDOW w AS (order by four range between current row and unbounded following);
!  first_value | nth_2 | last_value | unique1 | four 
! -------------+-------+------------+---------+------
!            0 |     8 |          7 |       0 |    0
!            0 |     8 |          7 |       8 |    0
!            0 |     8 |          7 |       4 |    0
!            5 |     9 |          7 |       5 |    1
!            5 |     9 |          7 |       9 |    1
!            5 |     9 |          7 |       1 |    1
!            6 |     2 |          7 |       6 |    2
!            6 |     2 |          7 |       2 |    2
!            3 |     7 |          7 |       3 |    3
!            3 |     7 |          7 |       7 |    3
! (10 rows)
! 
! SELECT sum(unique1) over
! 	(order by unique1
! 	 rows (SELECT unique1 FROM tenk1 ORDER BY unique1 LIMIT 1) + 1 PRECEDING),
! 	unique1
! FROM tenk1 WHERE unique1 < 10;
!  sum | unique1 
! -----+---------
!    0 |       0
!    1 |       1
!    3 |       2
!    5 |       3
!    7 |       4
!    9 |       5
!   11 |       6
!   13 |       7
!   15 |       8
!   17 |       9
! (10 rows)
! 
! CREATE TEMP VIEW v_window AS
! 	SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following) as sum_rows
! 	FROM generate_series(1, 10) i;
! SELECT * FROM v_window;
!  i  | sum_rows 
! ----+----------
!   1 |        3
!   2 |        6
!   3 |        9
!   4 |       12
!   5 |       15
!   6 |       18
!   7 |       21
!   8 |       24
!   9 |       27
!  10 |       19
! (10 rows)
! 
! SELECT pg_get_viewdef('v_window');
!                                     pg_get_viewdef                                     
! ---------------------------------------------------------------------------------------
!   SELECT i.i,                                                                         +
!      sum(i.i) OVER (ORDER BY i.i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS sum_rows+
!     FROM generate_series(1, 10) i(i);
! (1 row)
! 
! -- with UNION
! SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 UNION ALL SELECT * FROM tenk2)s LIMIT 0;
!  count 
! -------
! (0 rows)
! 
! -- ordering by a non-integer constant is allowed
! SELECT rank() OVER (ORDER BY length('abc'));
!  rank 
! ------
!     1
! (1 row)
! 
! -- can't order by another window function
! SELECT rank() OVER (ORDER BY rank() OVER (ORDER BY random()));
! ERROR:  window functions are not allowed in window definitions
! LINE 1: SELECT rank() OVER (ORDER BY rank() OVER (ORDER BY random())...
!                                      ^
! -- some other errors
! SELECT * FROM empsalary WHERE row_number() OVER (ORDER BY salary) < 10;
! ERROR:  window functions are not allowed in WHERE
! LINE 1: SELECT * FROM empsalary WHERE row_number() OVER (ORDER BY sa...
!                                       ^
! SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVER (ORDER BY salary) < 10;
! ERROR:  window functions are not allowed in JOIN conditions
! LINE 1: SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVE...
!                                                     ^
! SELECT rank() OVER (ORDER BY 1), count(*) FROM empsalary GROUP BY 1;
! ERROR:  window functions are not allowed in GROUP BY
! LINE 1: SELECT rank() OVER (ORDER BY 1), count(*) FROM empsalary GRO...
!                ^
! SELECT * FROM rank() OVER (ORDER BY random());
! ERROR:  syntax error at or near "ORDER"
! LINE 1: SELECT * FROM rank() OVER (ORDER BY random());
!                                    ^
! DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())) > 10;
! ERROR:  window functions are not allowed in WHERE
! LINE 1: DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())...
!                                      ^
! DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random());
! ERROR:  window functions are not allowed in RETURNING
! LINE 1: DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random...
!                                         ^
! SELECT count(*) OVER w FROM tenk1 WINDOW w AS (ORDER BY unique1), w AS (ORDER BY unique1);
! ERROR:  window "w" is already defined
! LINE 1: ...w FROM tenk1 WINDOW w AS (ORDER BY unique1), w AS (ORDER BY ...
!                                                              ^
! SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM tenk1;
! ERROR:  syntax error at or near "ORDER"
! LINE 1: SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM te...
!                                                ^
! SELECT count() OVER () FROM tenk1;
! ERROR:  count(*) must be used to call a parameterless aggregate function
! LINE 1: SELECT count() OVER () FROM tenk1;
!                ^
! SELECT generate_series(1, 100) OVER () FROM empsalary;
! ERROR:  OVER specified, but generate_series is not a window function nor an aggregate function
! LINE 1: SELECT generate_series(1, 100) OVER () FROM empsalary;
!                ^
! SELECT ntile(0) OVER (ORDER BY ten), ten, four FROM tenk1;
! ERROR:  argument of ntile must be greater than zero
! SELECT nth_value(four, 0) OVER (ORDER BY ten), ten, four FROM tenk1;
! ERROR:  argument of nth_value must be greater than zero
! -- filter
! SELECT sum(salary), row_number() OVER (ORDER BY depname), sum(
!     sum(salary) FILTER (WHERE enroll_date > '2007-01-01')
! ) FILTER (WHERE depname <> 'sales') OVER (ORDER BY depname DESC) AS "filtered_sum",
!     depname
! FROM empsalary GROUP BY depname;
!   sum  | row_number | filtered_sum |  depname  
! -------+------------+--------------+-----------
!  14600 |          3 |              | sales
!   7400 |          2 |         3500 | personnel
!  25100 |          1 |        22600 | develop
! (3 rows)
! 
! -- Test pushdown of quals into a subquery containing window functions
! -- pushdown is safe because all PARTITION BY clauses include depname:
! EXPLAIN (COSTS OFF)
! SELECT * FROM
!   (SELECT depname,
!           sum(salary) OVER (PARTITION BY depname) depsalary,
!           min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary
!    FROM empsalary) emp
! WHERE depname = 'sales';
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Subquery Scan on emp
!    ->  WindowAgg
!          ->  Sort
!                Sort Key: (((empsalary.depname)::text || 'A'::text))
!                ->  WindowAgg
!                      ->  Seq Scan on empsalary
!                            Filter: ((depname)::text = 'sales'::text)
! (7 rows)
! 
! -- pushdown is unsafe because there's a PARTITION BY clause without depname:
! EXPLAIN (COSTS OFF)
! SELECT * FROM
!   (SELECT depname,
!           sum(salary) OVER (PARTITION BY enroll_date) enroll_salary,
!           min(salary) OVER (PARTITION BY depname) depminsalary
!    FROM empsalary) emp
! WHERE depname = 'sales';
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Subquery Scan on emp
!    Filter: ((emp.depname)::text = 'sales'::text)
!    ->  WindowAgg
!          ->  Sort
!                Sort Key: empsalary.depname
!                ->  WindowAgg
!                      ->  Sort
!                            Sort Key: empsalary.enroll_date
!                            ->  Seq Scan on empsalary
! (9 rows)
! 
! -- cleanup
! DROP TABLE empsalary;
! -- test user-defined window function with named args and default args
! CREATE FUNCTION nth_value_def(val anyelement, n integer = 1) RETURNS anyelement
!   LANGUAGE internal WINDOW IMMUTABLE STRICT AS 'window_nth_value';
! SELECT nth_value_def(n := 2, val := ten) OVER (PARTITION BY four), ten, four
!   FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
!  nth_value_def | ten | four 
! ---------------+-----+------
!              0 |   0 |    0
!              0 |   0 |    0
!              0 |   4 |    0
!              1 |   1 |    1
!              1 |   1 |    1
!              1 |   7 |    1
!              1 |   9 |    1
!                |   0 |    2
!              3 |   1 |    3
!              3 |   3 |    3
! (10 rows)
! 
! SELECT nth_value_def(ten) OVER (PARTITION BY four), ten, four
!   FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
!  nth_value_def | ten | four 
! ---------------+-----+------
!              0 |   0 |    0
!              0 |   0 |    0
!              0 |   4 |    0
!              1 |   1 |    1
!              1 |   1 |    1
!              1 |   7 |    1
!              1 |   9 |    1
!              0 |   0 |    2
!              1 |   1 |    3
!              1 |   3 |    3
! (10 rows)
! 
! --
! -- Test the basic moving-aggregate machinery
! --
! -- create aggregates that record the series of transform calls (these are
! -- intentionally not true inverses)
! CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '-' || quote_nullable($2) $$
! LANGUAGE SQL IMMUTABLE;
! CREATE AGGREGATE logging_agg_nonstrict (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_nonstrict,
! 	mstype = text,
! 	msfunc = logging_msfunc_nonstrict,
! 	minvfunc = logging_minvfunc_nonstrict
! );
! CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_nonstrict,
! 	mstype = text,
! 	msfunc = logging_msfunc_nonstrict,
! 	minvfunc = logging_minvfunc_nonstrict,
! 	initcond = 'I',
! 	minitcond = 'MI'
! );
! CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '*' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '+' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS
! $$ SELECT $1 || '-' || quote_nullable($2) $$
! LANGUAGE SQL STRICT IMMUTABLE;
! CREATE AGGREGATE logging_agg_strict (text)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_strict,
! 	mstype = text,
! 	msfunc = logging_msfunc_strict,
! 	minvfunc = logging_minvfunc_strict
! );
! CREATE AGGREGATE logging_agg_strict_initcond (anyelement)
! (
! 	stype = text,
! 	sfunc = logging_sfunc_strict,
! 	mstype = text,
! 	msfunc = logging_msfunc_strict,
! 	minvfunc = logging_minvfunc_strict,
! 	initcond = 'I',
! 	minitcond = 'MI'
! );
! -- test strict and non-strict cases
! SELECT
! 	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row,
! 	logging_agg_nonstrict(v) over wnd as nstrict,
! 	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init,
! 	logging_agg_strict(v::text) over wnd as strict,
! 	logging_agg_strict_initcond(v) over wnd as strict_init
! FROM (VALUES
! 	(1, 1, NULL),
! 	(1, 2, 'a'),
! 	(1, 3, 'b'),
! 	(1, 4, NULL),
! 	(1, 5, NULL),
! 	(1, 6, 'c'),
! 	(2, 1, NULL),
! 	(2, 2, 'x'),
! 	(3, 1, 'z')
! ) AS t(p, i, v)
! WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY p, i;
!    row    |                    nstrict                    |                  nstrict_init                   |  strict   |  strict_init   
! ----------+-----------------------------------------------+-------------------------------------------------+-----------+----------------
!  1,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
!  1,2:a    | +NULL+'a'                                     | MI+NULL+'a'                                     | a         | MI+'a'
!  1,3:b    | +NULL+'a'-NULL+'b'                            | MI+NULL+'a'-NULL+'b'                            | a+'b'     | MI+'a'+'b'
!  1,4:NULL | +NULL+'a'-NULL+'b'-'a'+NULL                   | MI+NULL+'a'-NULL+'b'-'a'+NULL                   | a+'b'-'a' | MI+'a'+'b'-'a'
!  1,5:NULL | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          |           | MI
!  1,6:c    | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | c         | MI+'c'
!  2,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
!  2,2:x    | +NULL+'x'                                     | MI+NULL+'x'                                     | x         | MI+'x'
!  3,1:z    | +'z'                                          | MI+'z'                                          | z         | MI+'z'
! (9 rows)
! 
! -- and again, but with filter
! SELECT
! 	p::text || ',' || i::text || ':' ||
! 		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row,
! 	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt,
! 	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt,
! 	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt,
! 	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filt
! FROM (VALUES
! 	(1, 1, true,  NULL),
! 	(1, 2, false, 'a'),
! 	(1, 3, true,  'b'),
! 	(1, 4, false, NULL),
! 	(1, 5, false, NULL),
! 	(1, 6, false, 'c'),
! 	(2, 1, false, NULL),
! 	(2, 2, true,  'x'),
! 	(3, 1, true,  'z')
! ) AS t(p, i, f, v)
! WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY p, i;
!    row    | nstrict_filt | nstrict_init_filt | strict_filt | strict_init_filt 
! ----------+--------------+-------------------+-------------+------------------
!  1,1:NULL | +NULL        | MI+NULL           |             | MI
!  1,2:-    | +NULL        | MI+NULL           |             | MI
!  1,3:b    | +'b'         | MI+'b'            | b           | MI+'b'
!  1,4:-    | +'b'         | MI+'b'            | b           | MI+'b'
!  1,5:-    |              | MI                |             | MI
!  1,6:-    |              | MI                |             | MI
!  2,1:-    |              | MI                |             | MI
!  2,2:x    | +'x'         | MI+'x'            | x           | MI+'x'
!  3,1:z    | +'z'         | MI+'z'            | z           | MI+'z'
! (9 rows)
! 
! -- test that volatile arguments disable moving-aggregate mode
! SELECT
! 	i::text || ':' || COALESCE(v::text, 'NULL') as row,
! 	logging_agg_strict(v::text)
! 		over wnd as inverse,
! 	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END)
! 		over wnd as noinverse
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY i;
!  row |    inverse    | noinverse 
! -----+---------------+-----------
!  1:a | a             | a
!  2:b | a+'b'         | a*'b'
!  3:c | a+'b'-'a'+'c' | b*'c'
! (3 rows)
! 
! SELECT
! 	i::text || ':' || COALESCE(v::text, 'NULL') as row,
! 	logging_agg_strict(v::text) filter(where true)
! 		over wnd as inverse,
! 	logging_agg_strict(v::text) filter(where random() >= 0)
! 		over wnd as noinverse
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! ORDER BY i;
!  row |    inverse    | noinverse 
! -----+---------------+-----------
!  1:a | a             | a
!  2:b | a+'b'         | a*'b'
!  3:c | a+'b'-'a'+'c' | b*'c'
! (3 rows)
! 
! -- test that non-overlapping windows don't use inverse transitions
! SELECT
! 	logging_agg_strict(v::text) OVER wnd
! FROM (VALUES
! 	(1, 'a'),
! 	(2, 'b'),
! 	(3, 'c')
! ) AS t(i, v)
! WINDOW wnd AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
! ORDER BY i;
!  logging_agg_strict 
! --------------------
!  a
!  b
!  c
! (3 rows)
! 
! -- test that returning NULL from the inverse transition functions
! -- restarts the aggregation from scratch. The second aggregate is supposed
! -- to test cases where only some aggregates restart, the third one checks
! -- that one aggregate restarting doesn't cause others to restart.
! CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS
! $$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$
! LANGUAGE SQL STRICT;
! CREATE AGGREGATE sum_int_randomrestart (int4)
! (
! 	stype = int4,
! 	sfunc = int4pl,
! 	mstype = int4,
! 	msfunc = int4pl,
! 	minvfunc = sum_int_randrestart_minvfunc
! );
! WITH
! vs AS (
! 	SELECT i, (random() * 100)::int4 AS v
! 	FROM generate_series(1, 100) AS i
! ),
! sum_following AS (
! 	SELECT i, SUM(v) OVER
! 		(ORDER BY i DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s
! 	FROM vs
! )
! SELECT DISTINCT
! 	sum_following.s = sum_int_randomrestart(v) OVER fwd AS eq1,
! 	-sum_following.s = sum_int_randomrestart(-v) OVER fwd AS eq2,
! 	100*3+(vs.i-1)*3 = length(logging_agg_nonstrict(''::text) OVER fwd) AS eq3
! FROM vs
! JOIN sum_following ON sum_following.i = vs.i
! WINDOW fwd AS (
! 	ORDER BY vs.i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
! );
!  eq1 | eq2 | eq3 
! -----+-----+-----
!  t   | t   | t
! (1 row)
! 
! --
! -- Test various built-in aggregates that have moving-aggregate support
! --
! -- test inverse transition functions handle NULLs properly
! SELECT i,AVG(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 1.5000000000000000
!  2 | 2.0000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.5),(2,2.5),(3,NULL),(4,NULL)) t(i,v);
!  i |        avg         
! ---+--------------------
!  1 | 2.0000000000000000
!  2 | 2.5000000000000000
!  3 |                   
!  4 |                   
! (4 rows)
! 
! SELECT i,AVG(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
!  i |    avg     
! ---+------------
!  1 | @ 1.5 secs
!  2 | @ 2 secs
!  3 | 
!  4 | 
! (4 rows)
! 
! SELECT i,SUM(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::money) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1.10'),(2,'2.20'),(3,NULL),(4,NULL)) t(i,v);
!  i |  sum  
! ---+-------
!  1 | $3.30
!  2 | $2.20
!  3 |      
!  4 |      
! (4 rows)
! 
! SELECT i,SUM(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
!  i |   sum    
! ---+----------
!  1 | @ 3 secs
!  2 | @ 2 secs
!  3 | 
!  4 | 
! (4 rows)
! 
! SELECT i,SUM(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.1),(2,2.2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 | 3.3
!  2 | 2.2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT SUM(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1.01),(2,2),(3,3)) v(i,n);
!  sum  
! ------
!  6.01
!     5
!     3
! (3 rows)
! 
! SELECT i,COUNT(v) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | count 
! ---+-------
!  1 |     2
!  2 |     1
!  3 |     0
!  4 |     0
! (4 rows)
! 
! SELECT i,COUNT(*) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | count 
! ---+-------
!  1 |     4
!  2 |     3
!  3 |     2
!  4 |     1
! (4 rows)
! 
! SELECT VAR_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!         var_pop        
! -----------------------
!     21704.000000000000
!     13868.750000000000
!     11266.666666666667
!  4225.0000000000000000
!                      0
! (5 rows)
! 
! SELECT VAR_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VAR_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        var_samp        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT VARIANCE(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        variance        
! -----------------------
!     27130.000000000000
!     18491.666666666667
!     16900.000000000000
!  8450.0000000000000000
!                       
! (5 rows)
! 
! SELECT STDDEV_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_pop      
! ---------------------
!     147.322774885623
!     147.322774885623
!     117.765657133139
!     106.144555520604
!  65.0000000000000000
!                    0
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
!      stddev_samp     
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! SELECT STDDEV(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
!   FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
!        stddev        
! ---------------------
!     164.711869639076
!     164.711869639076
!     135.984067694222
!     130.000000000000
!  91.9238815542511782
!                     
! (6 rows)
! 
! -- test that inverse transition functions work with various frame options
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   1
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   2
!  3 |    
!  4 |    
! (4 rows)
! 
! SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
!   FROM (VALUES(1,1),(2,2),(3,3),(4,4)) t(i,v);
!  i | sum 
! ---+-----
!  1 |   3
!  2 |   6
!  3 |   9
!  4 |   7
! (4 rows)
! 
! -- ensure aggregate over numeric properly recovers from NaN values
! SELECT a, b,
!        SUM(b) OVER(ORDER BY A ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
! FROM (VALUES(1,1::numeric),(2,2),(3,'NaN'),(4,3),(5,4)) t(a,b);
!  a |  b  | sum 
! ---+-----+-----
!  1 |   1 |   1
!  2 |   2 |   3
!  3 | NaN | NaN
!  4 |   3 | NaN
!  5 |   4 |   7
! (5 rows)
! 
! -- It might be tempting for someone to add an inverse trans function for
! -- float and double precision. This should not be done as it can give incorrect
! -- results. This test should fail if anyone ever does this without thinking too
! -- hard about it.
! SELECT to_char(SUM(n::float8) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING),'999999999999999999999D9')
!   FROM (VALUES(1,1e20),(2,1)) n(i,n);
!          to_char          
! --------------------------
!   100000000000000000000
!                       1.0
! (2 rows)
! 
! SELECT i, b, bool_and(b) OVER w, bool_or(b) OVER w
!   FROM (VALUES (1,true), (2,true), (3,false), (4,false), (5,true)) v(i,b)
!   WINDOW w AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING);
!  i | b | bool_and | bool_or 
! ---+---+----------+---------
!  1 | t | t        | t
!  2 | t | f        | t
!  3 | f | f        | f
!  4 | f | f        | t
!  5 | t | t        | t
! (5 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/xmlmap_1.out	2014-11-21 01:48:04.367437000 +0300
--- /home/orion/postgres/src/test/regress/results/xmlmap.out	2015-01-26 12:33:25.927031413 +0300
***************
*** 1,125 ****
! CREATE SCHEMA testxmlschema;
! CREATE TABLE testxmlschema.test1 (a int, b text);
! INSERT INTO testxmlschema.test1 VALUES (1, 'one'), (2, 'two'), (-1, null);
! CREATE DOMAIN testxmldomain AS varchar;
! CREATE TABLE testxmlschema.test2 (z int, y varchar(500), x char(6), w numeric(9,2), v smallint, u bigint, t real, s time, r timestamp, q date, p xml, o testxmldomain, n bool, m bytea, aaa text);
! ALTER TABLE testxmlschema.test2 DROP COLUMN aaa;
! INSERT INTO testxmlschema.test2 VALUES (55, 'abc', 'def', 98.6, 2, 999, 0, '21:07', '2009-06-08 21:07:30', '2009-06-08', NULL, 'ABC', true, 'XYZ');
! SELECT table_to_xml('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', true, false, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test2', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', false, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xmlschema('testxmlschema.test2', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xml('SELECT * FROM testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xmlschema('SELECT * FROM testxmlschema.test1', false, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT query_to_xml_and_xmlschema('SELECT * FROM testxmlschema.test1', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
! SELECT cursor_to_xml('xc'::refcursor, 5, false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! MOVE FIRST IN xc;
! SELECT cursor_to_xml('xc'::refcursor, 5, true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT cursor_to_xmlschema('xc'::refcursor, true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml('testxmlschema', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml('testxmlschema', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xmlschema('testxmlschema', false, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xmlschema('testxmlschema', true, false, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT schema_to_xml_and_xmlschema('testxmlschema', true, true, 'foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- test that domains are transformed like their base types
! CREATE DOMAIN testboolxmldomain AS bool;
! CREATE DOMAIN testdatexmldomain AS date;
! CREATE TABLE testxmlschema.test3
!     AS SELECT true c1,
!               true::testboolxmldomain c2,
!               '2013-02-21'::date c3,
!               '2013-02-21'::testdatexmldomain c4;
! SELECT xmlforest(c1, c2, c3, c4) FROM testxmlschema.test3;
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_to_xml('testxmlschema.test3', true, true, '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/functional_deps.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/functional_deps.out	2015-01-26 12:33:25.939031414 +0300
***************
*** 1,232 ****
! -- from http://www.depesz.com/index.php/2010/04/19/getting-unique-elements/
! CREATE TEMP TABLE articles (
!     id int CONSTRAINT articles_pkey PRIMARY KEY,
!     keywords text,
!     title text UNIQUE NOT NULL,
!     body text UNIQUE,
!     created date
! );
! CREATE TEMP TABLE articles_in_category (
!     article_id int,
!     category_id int,
!     changed date,
!     PRIMARY KEY (article_id, category_id)
! );
! -- test functional dependencies based on primary keys/unique constraints
! -- base tables
! -- group by primary key (OK)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by unique not null (fail/todo)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY title;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- group by unique nullable (fail)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY body;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- group by something else (fail)
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY keywords;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT id, keywords, title, body, created
!                ^
! -- multiple tables
! -- group by primary key (OK)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a, articles_in_category AS aic
! WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
! GROUP BY a.id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by something else (fail)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a, articles_in_category AS aic
! WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id, aic.category_id;
! ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
!                ^
! -- JOIN syntax
! -- group by left table's primary key (OK)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY a.id;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! -- group by something else (fail)
! SELECT a.id, a.keywords, a.title, a.body, a.created
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id, aic.category_id;
! ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
!                ^
! -- group by right table's (composite) primary key (OK)
! SELECT aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.category_id, aic.article_id;
!  changed 
! ---------
! (0 rows)
! 
! -- group by right table's partial primary key (fail)
! SELECT aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY aic.article_id;
! ERROR:  column "aic.changed" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT aic.changed
!                ^
! -- example from documentation
! CREATE TEMP TABLE products (product_id int, name text, price numeric);
! CREATE TEMP TABLE sales (product_id int, units int);
! -- OK
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id, p.name, p.price;
!  product_id | name | sales 
! ------------+------+-------
! (0 rows)
! 
! -- fail
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id;
! ERROR:  column "p.name" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!                            ^
! ALTER TABLE products ADD PRIMARY KEY (product_id);
! -- OK now
! SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
!     FROM products p LEFT JOIN sales s USING (product_id)
!     GROUP BY product_id;
!  product_id | name | sales 
! ------------+------+-------
! (0 rows)
! 
! -- Drupal example, http://drupal.org/node/555530
! CREATE TEMP TABLE node (
!     nid SERIAL,
!     vid integer NOT NULL default '0',
!     type varchar(32) NOT NULL default '',
!     title varchar(128) NOT NULL default '',
!     uid integer NOT NULL default '0',
!     status integer NOT NULL default '1',
!     created integer NOT NULL default '0',
!     -- snip
!     PRIMARY KEY (nid, vid)
! );
! CREATE TEMP TABLE users (
!     uid integer NOT NULL default '0',
!     name varchar(60) NOT NULL default '',
!     pass varchar(32) NOT NULL default '',
!     -- snip
!     PRIMARY KEY (uid),
!     UNIQUE (name)
! );
! -- OK
! SELECT u.uid, u.name FROM node n
! INNER JOIN users u ON u.uid = n.uid
! WHERE n.type = 'blog' AND n.status = 1
! GROUP BY u.uid, u.name;
!  uid | name 
! -----+------
! (0 rows)
! 
! -- OK
! SELECT u.uid, u.name FROM node n
! INNER JOIN users u ON u.uid = n.uid
! WHERE n.type = 'blog' AND n.status = 1
! GROUP BY u.uid;
!  uid | name 
! -----+------
! (0 rows)
! 
! -- Check views and dependencies
! -- fail
! CREATE TEMP VIEW fdv1 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY body;
! ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 2: SELECT id, keywords, title, body, created
!                ^
! -- OK
! CREATE TEMP VIEW fdv1 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
! -- fail
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv1 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv1;
! -- multiple dependencies
! CREATE TEMP VIEW fdv2 AS
! SELECT a.id, a.keywords, a.title, aic.category_id, aic.changed
! FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
! WHERE aic.category_id in (14,62,70,53,138)
! GROUP BY a.id, aic.category_id, aic.article_id;
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv2 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! ALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT; --fail
! ERROR:  cannot drop constraint articles_in_category_pkey on table articles_in_category because other objects depend on it
! DETAIL:  view fdv2 depends on constraint articles_in_category_pkey on table articles_in_category
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv2;
! -- nested queries
! CREATE TEMP VIEW fdv3 AS
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id
! UNION
! SELECT id, keywords, title, body, created
! FROM articles
! GROUP BY id;
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv3 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv3;
! CREATE TEMP VIEW fdv4 AS
! SELECT * FROM articles WHERE title IN (SELECT title FROM articles GROUP BY id);
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
! ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
! DETAIL:  view fdv4 depends on constraint articles_pkey on table articles
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP VIEW fdv4;
! -- prepared query plans: this results in failure on reuse
! PREPARE foo AS
!   SELECT id, keywords, title, body, created
!   FROM articles
!   GROUP BY id;
! EXECUTE foo;
!  id | keywords | title | body | created 
! ----+----------+-------+------+---------
! (0 rows)
! 
! ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
! EXECUTE foo;  -- fail
! ERROR:  column "articles.keywords" must appear in the GROUP BY clause or be used in an aggregate function
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/advisory_lock.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/advisory_lock.out	2015-01-26 12:33:25.931031413 +0300
***************
*** 1,275 ****
! --
! -- ADVISORY LOCKS
! --
! BEGIN;
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- pg_advisory_unlock_all() shouldn't release xact locks
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      4
! (1 row)
! 
! -- can't unlock xact locks
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock_shared(2, 2);
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
!  pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock_shared 
! --------------------+---------------------------+--------------------+---------------------------
!  f                  | f                         | f                  | f
! (1 row)
! 
! -- automatically release xact locks at commit
! COMMIT;
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- holding both session and xact locks on the same objects, xact first
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock_shared 
! ------------------+-------------------------+------------------+-------------------------
!                   |                         |                  | 
! (1 row)
! 
! ROLLBACK;
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- unlocking session locks
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock(1),
! 	pg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),
! 	pg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
! WARNING:  you don't own a lock of type ExclusiveLock
! WARNING:  you don't own a lock of type ShareLock
!  pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared 
! --------------------+--------------------+---------------------------+---------------------------+--------------------+--------------------+---------------------------+---------------------------
!  t                  | f                  | t                         | f                         | t                  | f                  | t                         | f
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- holding both session and xact locks on the same objects, session first
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock_shared 
! ------------------+-------------------------+------------------+-------------------------
!                   |                         |                  | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock_shared 
! -----------------------+------------------------------+-----------------------+------------------------------
!                        |                              |                       | 
! (1 row)
! 
! ROLLBACK;
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! -- releasing all session locks
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! BEGIN;
! -- grabbing txn locks multiple times
! SELECT
! 	pg_advisory_xact_lock(1), pg_advisory_xact_lock(1),
! 	pg_advisory_xact_lock_shared(2), pg_advisory_xact_lock_shared(2),
! 	pg_advisory_xact_lock(1, 1), pg_advisory_xact_lock(1, 1),
! 	pg_advisory_xact_lock_shared(2, 2), pg_advisory_xact_lock_shared(2, 2);
!  pg_advisory_xact_lock | pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock_shared | pg_advisory_xact_lock | pg_advisory_xact_lock | pg_advisory_xact_lock_shared | pg_advisory_xact_lock_shared 
! -----------------------+-----------------------+------------------------------+------------------------------+-----------------------+-----------------------+------------------------------+------------------------------
!                        |                       |                              |                              |                       |                       |                              | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! COMMIT;
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! -- grabbing session locks multiple times
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock(1),
! 	pg_advisory_lock_shared(2), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock(1, 1),
! 	pg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared 
! ------------------+------------------+-------------------------+-------------------------+------------------+------------------+-------------------------+-------------------------
!                   |                  |                         |                         |                  |                  |                         | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT
! 	pg_advisory_unlock(1), pg_advisory_unlock(1),
! 	pg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),
! 	pg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),
! 	pg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);
!  pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared | pg_advisory_unlock | pg_advisory_unlock | pg_advisory_unlock_shared | pg_advisory_unlock_shared 
! --------------------+--------------------+---------------------------+---------------------------+--------------------+--------------------+---------------------------+---------------------------
!  t                  | t                  | t                         | t                         | t                  | t                  | t                         | t
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
! -- .. and releasing them all at once
! SELECT
! 	pg_advisory_lock(1), pg_advisory_lock(1),
! 	pg_advisory_lock_shared(2), pg_advisory_lock_shared(2),
! 	pg_advisory_lock(1, 1), pg_advisory_lock(1, 1),
! 	pg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);
!  pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared | pg_advisory_lock | pg_advisory_lock | pg_advisory_lock_shared | pg_advisory_lock_shared 
! ------------------+------------------+-------------------------+-------------------------+------------------+------------------+-------------------------+-------------------------
!                   |                  |                         |                         |                  |                  |                         | 
! (1 row)
! 
! SELECT locktype, classid, objid, objsubid, mode, granted
! 	FROM pg_locks WHERE locktype = 'advisory'
! 	ORDER BY classid, objid, objsubid;
!  locktype | classid | objid | objsubid |     mode      | granted 
! ----------+---------+-------+----------+---------------+---------
!  advisory |       0 |     1 |        1 | ExclusiveLock | t
!  advisory |       0 |     2 |        1 | ShareLock     | t
!  advisory |       1 |     1 |        2 | ExclusiveLock | t
!  advisory |       2 |     2 |        2 | ShareLock     | t
! (4 rows)
! 
! SELECT pg_advisory_unlock_all();
!  pg_advisory_unlock_all 
! ------------------------
!  
! (1 row)
! 
! SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
!  count 
! -------
!      0
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/json_1.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/json.out	2015-01-26 12:33:25.955031415 +0300
***************
*** 1,1584 ****
! -- Strings.
! SELECT '""'::json;				-- OK.
!  json 
! ------
!  ""
! (1 row)
! 
! SELECT $$''$$::json;			-- ERROR, single quotes are not allowed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT $$''$$::json;
!                ^
! DETAIL:  Token "'" is invalid.
! CONTEXT:  JSON data, line 1: '...
! SELECT '"abc"'::json;			-- OK
!  json  
! -------
!  "abc"
! (1 row)
! 
! SELECT '"abc'::json;			-- ERROR, quotes not closed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc'::json;
!                ^
! DETAIL:  Token ""abc" is invalid.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"abc
! def"'::json;					-- ERROR, unescaped newline in string constant
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc
!                ^
! DETAIL:  Character with value 0x0a must be escaped.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"\n\"\\"'::json;		-- OK, legal escapes
!    json   
! ----------
!  "\n\"\\"
! (1 row)
! 
! SELECT '"\v"'::json;			-- ERROR, not a valid JSON escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\v"'::json;
!                ^
! DETAIL:  Escape sequence "\v" is invalid.
! CONTEXT:  JSON data, line 1: "\v...
! SELECT '"\u"'::json;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u"
! SELECT '"\u00"'::json;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u00"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u00"
! SELECT '"\u000g"'::json;		-- ERROR, g is not a hex digit
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u000g"'::json;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u000g...
! SELECT '"\u0000"'::json;		-- OK, legal escape
!    json   
! ----------
!  "\u0000"
! (1 row)
! 
! SELECT '"\uaBcD"'::json;		-- OK, uppercase and lower case both OK
!    json   
! ----------
!  "\uaBcD"
! (1 row)
! 
! -- Numbers.
! SELECT '1'::json;				-- OK
!  json 
! ------
!  1
! (1 row)
! 
! SELECT '0'::json;				-- OK
!  json 
! ------
!  0
! (1 row)
! 
! SELECT '01'::json;				-- ERROR, not valid according to JSON spec
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '01'::json;
!                ^
! DETAIL:  Token "01" is invalid.
! CONTEXT:  JSON data, line 1: 01
! SELECT '0.1'::json;				-- OK
!  json 
! ------
!  0.1
! (1 row)
! 
! SELECT '9223372036854775808'::json;	-- OK, even though it's too large for int8
!         json         
! ---------------------
!  9223372036854775808
! (1 row)
! 
! SELECT '1e100'::json;			-- OK
!  json  
! -------
!  1e100
! (1 row)
! 
! SELECT '1.3e100'::json;			-- OK
!   json   
! ---------
!  1.3e100
! (1 row)
! 
! SELECT '1f2'::json;				-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1f2'::json;
!                ^
! DETAIL:  Token "1f2" is invalid.
! CONTEXT:  JSON data, line 1: 1f2
! SELECT '0.x1'::json;			-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '0.x1'::json;
!                ^
! DETAIL:  Token "0.x1" is invalid.
! CONTEXT:  JSON data, line 1: 0.x1
! SELECT '1.3ex100'::json;		-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1.3ex100'::json;
!                ^
! DETAIL:  Token "1.3ex100" is invalid.
! CONTEXT:  JSON data, line 1: 1.3ex100
! -- Arrays.
! SELECT '[]'::json;				-- OK
!  json 
! ------
!  []
! (1 row)
! 
! SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::json;  -- OK
!                                                                                                    json                                                                                                   
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
! (1 row)
! 
! SELECT '[1,2]'::json;			-- OK
!  json  
! -------
!  [1,2]
! (1 row)
! 
! SELECT '[1,2,]'::json;			-- ERROR, trailing comma
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2,]'::json;
!                ^
! DETAIL:  Expected JSON value, but found "]".
! CONTEXT:  JSON data, line 1: [1,2,]
! SELECT '[1,2'::json;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2'::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,2
! SELECT '[1,[2]'::json;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,[2]'::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,[2]
! -- Objects.
! SELECT '{}'::json;				-- OK
!  json 
! ------
!  {}
! (1 row)
! 
! SELECT '{"abc"}'::json;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"}'::json;
!                ^
! DETAIL:  Expected ":", but found "}".
! CONTEXT:  JSON data, line 1: {"abc"}
! SELECT '{"abc":1}'::json;		-- OK
!    json    
! -----------
!  {"abc":1}
! (1 row)
! 
! SELECT '{1:"abc"}'::json;		-- ERROR, keys must be strings
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{1:"abc"}'::json;
!                ^
! DETAIL:  Expected string or "}", but found "1".
! CONTEXT:  JSON data, line 1: {1...
! SELECT '{"abc",1}'::json;		-- ERROR, wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc",1}'::json;
!                ^
! DETAIL:  Expected ":", but found ",".
! CONTEXT:  JSON data, line 1: {"abc",...
! SELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"=1}'::json;
!                ^
! DETAIL:  Token "=" is invalid.
! CONTEXT:  JSON data, line 1: {"abc"=...
! SELECT '{"abc"::1}'::json;		-- ERROR, another wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"::1}'::json;
!                ^
! DETAIL:  Expected JSON value, but found ":".
! CONTEXT:  JSON data, line 1: {"abc"::...
! SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::json; -- OK
!                           json                           
! ---------------------------------------------------------
!  {"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}
! (1 row)
! 
! SELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spot
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1:2}'::json;
!                ^
! DETAIL:  Expected "," or "}", but found ":".
! CONTEXT:  JSON data, line 1: {"abc":1:...
! SELECT '{"abc":1,3}'::json;		-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1,3}'::json;
!                ^
! DETAIL:  Expected string, but found "3".
! CONTEXT:  JSON data, line 1: {"abc":1,3...
! -- Miscellaneous stuff.
! SELECT 'true'::json;			-- OK
!  json 
! ------
!  true
! (1 row)
! 
! SELECT 'false'::json;			-- OK
!  json  
! -------
!  false
! (1 row)
! 
! SELECT 'null'::json;			-- OK
!  json 
! ------
!  null
! (1 row)
! 
! SELECT ' true '::json;			-- OK, even with extra whitespace
!   json  
! --------
!   true 
! (1 row)
! 
! SELECT 'true false'::json;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true false'::json;
!                ^
! DETAIL:  Expected end of input, but found "false".
! CONTEXT:  JSON data, line 1: true false
! SELECT 'true, false'::json;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true, false'::json;
!                ^
! DETAIL:  Expected end of input, but found ",".
! CONTEXT:  JSON data, line 1: true,...
! SELECT 'truf'::json;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'truf'::json;
!                ^
! DETAIL:  Token "truf" is invalid.
! CONTEXT:  JSON data, line 1: truf
! SELECT 'trues'::json;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'trues'::json;
!                ^
! DETAIL:  Token "trues" is invalid.
! CONTEXT:  JSON data, line 1: trues
! SELECT ''::json;				-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT ''::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: 
! SELECT '    '::json;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '    '::json;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1:     
! --constructors
! -- array_to_json
! SELECT array_to_json(array(select 1 as a));
!  array_to_json 
! ---------------
!  [1]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
!                 array_to_json                
! ---------------------------------------------
!  [{"b":1,"c":2},{"b":2,"c":4},{"b":3,"c":6}]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
!   array_to_json  
! -----------------
!  [{"b":1,"c":2},+
!   {"b":2,"c":4},+
!   {"b":3,"c":6}]
! (1 row)
! 
! SELECT array_to_json(array_agg(q),false)
!   FROM ( SELECT $$a$$ || x AS b, y AS c,
!                ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!          FROM generate_series(1,2) x,
!               generate_series(4,5) y) q;
!                                                                                                                                  array_to_json                                                                                                                                 
! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [{"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]},{"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]},{"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]},{"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}]
! (1 row)
! 
! SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
!  array_to_json  
! ----------------
!  [5,6,7,8,9,10]
! (1 row)
! 
! SELECT array_to_json('{{1,5},{99,100}}'::int[]);
!   array_to_json   
! ------------------
!  [[1,5],[99,100]]
! (1 row)
! 
! -- row_to_json
! SELECT row_to_json(row(1,'foo'));
!      row_to_json     
! ---------------------
!  {"f1":1,"f2":"foo"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT $$a$$ || x AS b,
!          y AS c,
!          ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!       FROM generate_series(1,2) x,
!            generate_series(4,5) y) q;
!                             row_to_json                             
! --------------------------------------------------------------------
!  {"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
!  {"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
! (4 rows)
! 
! SELECT row_to_json(q,true)
! FROM (SELECT $$a$$ || x AS b,
!          y AS c,
!          ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!       FROM generate_series(1,2) x,
!            generate_series(4,5) y) q;
!                      row_to_json                     
! -----------------------------------------------------
!  {"b":"a1",                                         +
!   "c":4,                                            +
!   "z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a1",                                         +
!   "c":5,                                            +
!   "z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
!  {"b":"a2",                                         +
!   "c":4,                                            +
!   "z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}
!  {"b":"a2",                                         +
!   "c":5,                                            +
!   "z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}
! (4 rows)
! 
! CREATE TEMP TABLE rows AS
! SELECT x, 'txt' || x as y
! FROM generate_series(1,3) AS x;
! SELECT row_to_json(q,true)
! FROM rows q;
!  row_to_json  
! --------------
!  {"x":1,     +
!   "y":"txt1"}
!  {"x":2,     +
!   "y":"txt2"}
!  {"x":3,     +
!   "y":"txt3"}
! (3 rows)
! 
! SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
!       row_to_json      
! -----------------------
!  {"f1":[5,6,7,8,9,10]}
! (1 row)
! 
! -- to_json, timestamps
! select to_json(timestamp '2014-05-28 12:22:35.614298');
!            to_json            
! ------------------------------
!  "2014-05-28T12:22:35.614298"
! (1 row)
! 
! BEGIN;
! SET LOCAL TIME ZONE 10.5;
! select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
!               to_json               
! ------------------------------------
!  "2014-05-29T02:52:35.614298+10:30"
! (1 row)
! 
! SET LOCAL TIME ZONE -8;
! select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
!               to_json               
! ------------------------------------
!  "2014-05-28T08:22:35.614298-08:00"
! (1 row)
! 
! COMMIT;
! -- unicode escape - backslash is not escaped
! select to_json(text '\uabcd');
!  to_json  
! ----------
!  "\uabcd"
! (1 row)
! 
! -- any other backslash is escaped
! select to_json(text '\abcd');
!  to_json  
! ----------
!  "\\abcd"
! (1 row)
! 
! --json_agg
! SELECT json_agg(q)
!   FROM ( SELECT $$a$$ || x AS b, y AS c,
!                ARRAY[ROW(x.*,ARRAY[1,2,3]),
!                ROW(y.*,ARRAY[4,5,6])] AS z
!          FROM generate_series(1,2) x,
!               generate_series(4,5) y) q;
!                                json_agg                                
! -----------------------------------------------------------------------
!  [{"b":"a1","c":4,"z":[{"f1":1,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}, +
!   {"b":"a1","c":5,"z":[{"f1":1,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}, +
!   {"b":"a2","c":4,"z":[{"f1":2,"f2":[1,2,3]},{"f1":4,"f2":[4,5,6]}]}, +
!   {"b":"a2","c":5,"z":[{"f1":2,"f2":[1,2,3]},{"f1":5,"f2":[4,5,6]}]}]
! (1 row)
! 
! SELECT json_agg(q)
!   FROM rows q;
!        json_agg        
! -----------------------
!  [{"x":1,"y":"txt1"}, +
!   {"x":2,"y":"txt2"}, +
!   {"x":3,"y":"txt3"}]
! (1 row)
! 
! -- non-numeric output
! SELECT row_to_json(q)
! FROM (SELECT 'NaN'::float8 AS "float8field") q;
!       row_to_json      
! -----------------------
!  {"float8field":"NaN"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT 'Infinity'::float8 AS "float8field") q;
!         row_to_json         
! ----------------------------
!  {"float8field":"Infinity"}
! (1 row)
! 
! SELECT row_to_json(q)
! FROM (SELECT '-Infinity'::float8 AS "float8field") q;
!          row_to_json         
! -----------------------------
!  {"float8field":"-Infinity"}
! (1 row)
! 
! -- json input
! SELECT row_to_json(q)
! FROM (SELECT '{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}'::json AS "jsonfield") q;
!                            row_to_json                            
! ------------------------------------------------------------------
!  {"jsonfield":{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}}
! (1 row)
! 
! -- json extraction functions
! CREATE TEMP TABLE test_json (
!        json_type text,
!        test_json json
! );
! INSERT INTO test_json VALUES
! ('scalar','"a scalar"'),
! ('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
! ('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json->'field2'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  "val2"
! (1 row)
! 
! SELECT test_json->>'field2'
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  val2
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  "two"
! (1 row)
! 
! SELECT test_json -> 2
! FROM test_json
! WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json->>2
! FROM test_json
! WHERE json_type = 'array';
!  ?column? 
! ----------
!  two
! (1 row)
! 
! SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
!  ?column? 
! ----------
!  {"f1":9}
! (1 row)
! 
! SELECT test_json ->> 'field4' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  4
! (1 row)
! 
! SELECT test_json ->> 'field5' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! SELECT test_json ->> 'field6' FROM test_json WHERE json_type = 'object';
!  ?column? 
! ----------
!  {"f1":9}
! (1 row)
! 
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'scalar';
! ERROR:  cannot call json_object_keys on a scalar
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'array';
! ERROR:  cannot call json_object_keys on an array
! SELECT json_object_keys(test_json)
! FROM test_json
! WHERE json_type = 'object';
!  json_object_keys 
! ------------------
!  field1
!  field2
!  field3
!  field4
!  field5
!  field6
! (6 rows)
! 
! -- test extending object_keys resultset - initial resultset size is 256
! select count(*) from
!     (select json_object_keys(json_object(array_agg(g)))
!      from (select unnest(array['f'||n,n::text])as g
!            from generate_series(1,300) as n) x ) y;
!  count 
! -------
!    300
! (1 row)
! 
! -- nulls
! select (test_json->'field3') is null as expect_false
! from test_json
! where json_type = 'object';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select (test_json->>'field3') is null as expect_true
! from test_json
! where json_type = 'object';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! select (test_json->3) is null as expect_false
! from test_json
! where json_type = 'array';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select (test_json->>3) is null as expect_true
! from test_json
! where json_type = 'array';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- corner cases
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::json -> 'b';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::json -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::json ->> 'b';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array length
! SELECT json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
!  json_array_length 
! -------------------
!                  5
! (1 row)
! 
! SELECT json_array_length('[]');
!  json_array_length 
! -------------------
!                  0
! (1 row)
! 
! SELECT json_array_length('{"f1":1,"f2":[5,6]}');
! ERROR:  cannot get array length of a non-array
! SELECT json_array_length('4');
! ERROR:  cannot get array length of a scalar
! -- each
! select json_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
!      json_each     
! -------------------
!  (f1,"[1,2,3]")
!  (f2,"{""f3"":1}")
!  (f4,null)
! (3 rows)
! 
! select * from json_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1,2,3]
!  f2  | {"f3":1}
!  f4  | null
!  f5  | 99
!  f6  | "stringy"
! (5 rows)
! 
! select json_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
!   json_each_text   
! -------------------
!  (f1,"[1,2,3]")
!  (f2,"{""f3"":1}")
!  (f4,)
!  (f5,null)
! (4 rows)
! 
! select * from json_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |  value   
! -----+----------
!  f1  | [1,2,3]
!  f2  | {"f3":1}
!  f4  | 
!  f5  | 99
!  f6  | stringy
! (5 rows)
! 
! -- extract_path, extract_path_as_text
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  json_extract_path 
! -------------------
!  "stringy"
! (1 row)
! 
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  json_extract_path 
! -------------------
!  {"f3":1}
! (1 row)
! 
! select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  json_extract_path 
! -------------------
!  "f3"
! (1 row)
! 
! select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  json_extract_path 
! -------------------
!  1
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  json_extract_path_text 
! ------------------------
!  stringy
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  json_extract_path_text 
! ------------------------
!  {"f3":1}
! (1 row)
! 
! select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  json_extract_path_text 
! ------------------------
!  f3
! (1 row)
! 
! select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  json_extract_path_text 
! ------------------------
!  1
! (1 row)
! 
! -- extract_path nulls
! select json_extract_path('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') is null as expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') is null as expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! select json_extract_path('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') is null as expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! select json_extract_path_text('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') is null as expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- extract_path operators
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f4','f6'];
!  ?column?  
! -----------
!  "stringy"
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2'];
!  ?column? 
! ----------
!  {"f3":1}
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','0'];
!  ?column? 
! ----------
!  "f3"
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f4','f6'];
!  ?column? 
! ----------
!  stringy
! (1 row)
! 
! select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2'];
!  ?column? 
! ----------
!  {"f3":1}
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','0'];
!  ?column? 
! ----------
!  f3
! (1 row)
! 
! select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! -- corner cases for same
! select '{"a": {"b":{"c": "foo"}}}'::json #> '{}';
!          ?column?          
! ---------------------------
!  {"a": {"b":{"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::json #> '{}';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! select '"foo"'::json #> '{}';
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '42'::json #> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::json #> '{}';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a'];
!       ?column?      
! --------------------
!  {"b":{"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c'];
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #> array['1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::json #> array['1','b'];
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::json #> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> '{}';
!          ?column?          
! ---------------------------
!  {"a": {"b":{"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::json #>> '{}';
!  ?column? 
! ----------
!  [1,2,3]
! (1 row)
! 
! select '"foo"'::json #>> '{}';
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '42'::json #>> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::json #>> '{}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a'];
!       ?column?      
! --------------------
!  {"b":{"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c'];
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::json #>> array['1','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::json #>> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #>> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::json #>> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array_elements
! select json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!   json_array_elements  
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  null
!  {"f1":1,"f2":[7,8,9]}
!  false
!  "stringy"
! (7 rows)
! 
! select * from json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!          value         
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  null
!  {"f1":1,"f2":[7,8,9]}
!  false
!  "stringy"
! (7 rows)
! 
! select json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!  json_array_elements_text 
! --------------------------
!  1
!  true
!  [1,[2,3]]
!  
!  {"f1":1,"f2":[7,8,9]}
!  false
!  stringy
! (7 rows)
! 
! select * from json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!          value         
! -----------------------
!  1
!  true
!  [1,[2,3]]
!  
!  {"f1":1,"f2":[7,8,9]}
!  false
!  stringy
! (7 rows)
! 
! -- populate_record
! create type jpop as (a text, b int, c timestamp);
! select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(null::jpop,'{"a":[100,200,false],"x":43.2}') q;
!         a        | b | c 
! -----------------+---+---
!  [100,200,false] |   | 
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":[100,200,false],"x":43.2}') q;
!         a        | b |            c             
! -----------------+---+--------------------------
!  [100,200,false] | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"c":[100,200,false],"x":43.2}') q;
! ERROR:  invalid input syntax for type timestamp: "[100,200,false]"
! -- populate_recordset
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!        a       | b  |            c             
! ---------------+----+--------------------------
!  [100,200,300] | 99 | 
!  {"z":true}    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
! ERROR:  invalid input syntax for type timestamp: "[100,200,300]"
! create type jpop2 as (a int, b json, c int, d int);
! select * from json_populate_recordset(null::jpop2, '[{"a":2,"c":3,"b":{"z":4},"d":6}]') q;
!  a |    b    | c | d 
! ---+---------+---+---
!  2 | {"z":4} | 3 | 6
! (1 row)
! 
! select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!        a       | b  |            c             
! ---------------+----+--------------------------
!  [100,200,300] | 99 | 
!  {"z":true}    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! -- handling of unicode surrogate pairs
! select json '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a' as correct_in_utf8;
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a row
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode high surrogate must not follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong order
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogate
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogate
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! --handling of simple unicode escapes
! select json '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' as correct_in_utf8;
! ERROR:  invalid input syntax for type json
! DETAIL:  Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.
! CONTEXT:  JSON data, line 1: { "a":...
! select json '{ "a":  "dollar \u0024 character" }' ->> 'a' as correct_everywhere;
!  correct_everywhere 
! --------------------
!  dollar $ character
! (1 row)
! 
! select json '{ "a":  "null \u0000 escape" }' ->> 'a' as not_unescaped;
!    not_unescaped    
! --------------------
!  null \u0000 escape
! (1 row)
! 
! --json_typeof() function
! select value, json_typeof(value)
!   from (values (json '123.4'),
!                (json '-1'),
!                (json '"foo"'),
!                (json 'true'),
!                (json 'false'),
!                (json 'null'),
!                (json '[1, 2, 3]'),
!                (json '[]'),
!                (json '{"x":"foo", "y":123}'),
!                (json '{}'),
!                (NULL::json))
!       as data(value);
!         value         | json_typeof 
! ----------------------+-------------
!  123.4                | number
!  -1                   | number
!  "foo"                | string
!  true                 | boolean
!  false                | boolean
!  null                 | null
!  [1, 2, 3]            | array
!  []                   | array
!  {"x":"foo", "y":123} | object
!  {}                   | object
!                       | 
! (11 rows)
! 
! -- json_build_array, json_build_object, json_object_agg
! SELECT json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
!                            json_build_array                            
! -----------------------------------------------------------------------
!  ["a", 1, "b", 1.2, "c", true, "d", null, "e", {"x": 3, "y": [1,2,3]}]
! (1 row)
! 
! SELECT json_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
!                              json_build_object                              
! ----------------------------------------------------------------------------
!  {"a" : 1, "b" : 1.2, "c" : true, "d" : null, "e" : {"x": 3, "y": [1,2,3]}}
! (1 row)
! 
! SELECT json_build_object(
!        'a', json_build_object('b',false,'c',99),
!        'd', json_build_object('e',array[9,8,7]::int[],
!            'f', (select row_to_json(r) from ( select relkind, oid::regclass as name from pg_class where relname = 'pg_class') r)));
!                                         json_build_object                                        
! -------------------------------------------------------------------------------------------------
!  {"a" : {"b" : false, "c" : 99}, "d" : {"e" : [9,8,7], "f" : {"relkind":"r","name":"pg_class"}}}
! (1 row)
! 
! -- empty objects/arrays
! SELECT json_build_array();
!  json_build_array 
! ------------------
!  []
! (1 row)
! 
! SELECT json_build_object();
!  json_build_object 
! -------------------
!  {}
! (1 row)
! 
! -- make sure keys are quoted
! SELECT json_build_object(1,2);
!  json_build_object 
! -------------------
!  {"1" : 2}
! (1 row)
! 
! -- keys must be scalar and not null
! SELECT json_build_object(null,2);
! ERROR:  argument 1 cannot be null
! HINT:  Object keys should be text.
! SELECT json_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
! ERROR:  key value must be scalar, not array, composite, or json
! SELECT json_build_object(json '{"a":1,"b":2}', 3);
! ERROR:  key value must be scalar, not array, composite, or json
! SELECT json_build_object('{1,2,3}'::int[], 3);
! ERROR:  key value must be scalar, not array, composite, or json
! CREATE TEMP TABLE foo (serial_num int, name text, type text);
! INSERT INTO foo VALUES (847001,'t15','GE1043');
! INSERT INTO foo VALUES (847002,'t16','GE1043');
! INSERT INTO foo VALUES (847003,'sub-alpha','GESS90');
! SELECT json_build_object('turbines',json_object_agg(serial_num,json_build_object('name',name,'type',type)))
! FROM foo;
!                                                                             json_build_object                                                                            
! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  {"turbines" : { "847001" : {"name" : "t15", "type" : "GE1043"}, "847002" : {"name" : "t16", "type" : "GE1043"}, "847003" : {"name" : "sub-alpha", "type" : "GESS90"} }}
! (1 row)
! 
! -- json_object
! -- one dimension
! SELECT json_object('{a,1,b,2,3,NULL,"d e f","a b c"}');
!                       json_object                      
! -------------------------------------------------------
!  {"a" : "1", "b" : "2", "3" : null, "d e f" : "a b c"}
! (1 row)
! 
! -- same but with two dimensions
! SELECT json_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
!                       json_object                      
! -------------------------------------------------------
!  {"a" : "1", "b" : "2", "3" : null, "d e f" : "a b c"}
! (1 row)
! 
! -- odd number error
! SELECT json_object('{a,b,c}');
! ERROR:  array must have even number of elements
! -- one column error
! SELECT json_object('{{a},{b}}');
! ERROR:  array must have two columns
! -- too many columns error
! SELECT json_object('{{a,b,c},{b,c,d}}');
! ERROR:  array must have two columns
! -- too many dimensions error
! SELECT json_object('{{{a,b},{c,d}},{{b,c},{d,e}}}');
! ERROR:  wrong number of array subscripts
! --two argument form of json_object
! select json_object('{a,b,c,"d e f"}','{1,2,3,"a b c"}');
!                      json_object                      
! ------------------------------------------------------
!  {"a" : "1", "b" : "2", "c" : "3", "d e f" : "a b c"}
! (1 row)
! 
! -- too many dimensions
! SELECT json_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
! ERROR:  wrong number of array subscripts
! -- mismatched dimensions
! select json_object('{a,b,c,"d e f",g}','{1,2,3,"a b c"}');
! ERROR:  mismatched array dimensions
! select json_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
! ERROR:  mismatched array dimensions
! -- null key error
! select json_object('{a,b,NULL,"d e f"}','{1,2,3,"a b c"}');
! ERROR:  null value not allowed for object key
! -- empty key is allowed
! select json_object('{a,b,"","d e f"}','{1,2,3,"a b c"}');
!                      json_object                     
! -----------------------------------------------------
!  {"a" : "1", "b" : "2", "" : "3", "d e f" : "a b c"}
! (1 row)
! 
! -- json_to_record and json_to_recordset
! select * from json_to_record('{"a":1,"b":"foo","c":"bar"}')
!     as x(a int, b text, d text);
!  a |  b  | d 
! ---+-----+---
!  1 | foo | 
! (1 row)
! 
! select * from json_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
!     as x(a int, b text, c boolean);
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 
!  2 | bar | t
! (2 rows)
! 
! select * from json_to_recordset('[{"a":1,"b":{"d":"foo"},"c":true},{"a":2,"c":false,"b":{"d":"bar"}}]')
!     as x(a int, b json, c boolean);
!  a |      b      | c 
! ---+-------------+---
!  1 | {"d":"foo"} | t
!  2 | {"d":"bar"} | f
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/jsonb.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/jsonb.out	2015-01-26 12:33:25.931031413 +0300
***************
*** 1,2474 ****
! -- Strings.
! SELECT '""'::jsonb;				-- OK.
!  jsonb 
! -------
!  ""
! (1 row)
! 
! SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT $$''$$::jsonb;
!                ^
! DETAIL:  Token "'" is invalid.
! CONTEXT:  JSON data, line 1: '...
! SELECT '"abc"'::jsonb;			-- OK
!  jsonb 
! -------
!  "abc"
! (1 row)
! 
! SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc'::jsonb;
!                ^
! DETAIL:  Token ""abc" is invalid.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"abc
! def"'::jsonb;					-- ERROR, unescaped newline in string constant
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"abc
!                ^
! DETAIL:  Character with value 0x0a must be escaped.
! CONTEXT:  JSON data, line 1: "abc
! SELECT '"\n\"\\"'::jsonb;		-- OK, legal escapes
!   jsonb   
! ----------
!  "\n\"\\"
! (1 row)
! 
! SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\v"'::jsonb;
!                ^
! DETAIL:  Escape sequence "\v" is invalid.
! CONTEXT:  JSON data, line 1: "\v...
! SELECT '"\u"'::jsonb;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u"
! SELECT '"\u00"'::jsonb;			-- ERROR, incomplete escape
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u00"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u00"
! SELECT '"\u000g"'::jsonb;		-- ERROR, g is not a hex digit
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '"\u000g"'::jsonb;
!                ^
! DETAIL:  "\u" must be followed by four hexadecimal digits.
! CONTEXT:  JSON data, line 1: "\u000g...
! SELECT '"\u0000"'::jsonb;		-- OK, legal escape
!   jsonb   
! ----------
!  "\u0000"
! (1 row)
! 
! -- use octet_length here so we don't get an odd unicode char in the
! -- output
! SELECT octet_length('"\uaBcD"'::jsonb::text); -- OK, uppercase and lower case both OK
!  octet_length 
! --------------
!             5
! (1 row)
! 
! -- Numbers.
! SELECT '1'::jsonb;				-- OK
!  jsonb 
! -------
!  1
! (1 row)
! 
! SELECT '0'::jsonb;				-- OK
!  jsonb 
! -------
!  0
! (1 row)
! 
! SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '01'::jsonb;
!                ^
! DETAIL:  Token "01" is invalid.
! CONTEXT:  JSON data, line 1: 01
! SELECT '0.1'::jsonb;				-- OK
!  jsonb 
! -------
!  0.1
! (1 row)
! 
! SELECT '9223372036854775808'::jsonb;	-- OK, even though it's too large for int8
!         jsonb        
! ---------------------
!  9223372036854775808
! (1 row)
! 
! SELECT '1e100'::jsonb;			-- OK
!                                                  jsonb                                                 
! -------------------------------------------------------------------------------------------------------
!  10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
! (1 row)
! 
! SELECT '1.3e100'::jsonb;			-- OK
!                                                  jsonb                                                 
! -------------------------------------------------------------------------------------------------------
!  13000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
! (1 row)
! 
! SELECT '1f2'::jsonb;				-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1f2'::jsonb;
!                ^
! DETAIL:  Token "1f2" is invalid.
! CONTEXT:  JSON data, line 1: 1f2
! SELECT '0.x1'::jsonb;			-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '0.x1'::jsonb;
!                ^
! DETAIL:  Token "0.x1" is invalid.
! CONTEXT:  JSON data, line 1: 0.x1
! SELECT '1.3ex100'::jsonb;		-- ERROR
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '1.3ex100'::jsonb;
!                ^
! DETAIL:  Token "1.3ex100" is invalid.
! CONTEXT:  JSON data, line 1: 1.3ex100
! -- Arrays.
! SELECT '[]'::jsonb;				-- OK
!  jsonb 
! -------
!  []
! (1 row)
! 
! SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::jsonb;  -- OK
!                                                                                                   jsonb                                                                                                   
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
! (1 row)
! 
! SELECT '[1,2]'::jsonb;			-- OK
!  jsonb  
! --------
!  [1, 2]
! (1 row)
! 
! SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2,]'::jsonb;
!                ^
! DETAIL:  Expected JSON value, but found "]".
! CONTEXT:  JSON data, line 1: [1,2,]
! SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,2'::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,2
! SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '[1,[2]'::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: [1,[2]
! -- Objects.
! SELECT '{}'::jsonb;				-- OK
!  jsonb 
! -------
!  {}
! (1 row)
! 
! SELECT '{"abc"}'::jsonb;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"}'::jsonb;
!                ^
! DETAIL:  Expected ":", but found "}".
! CONTEXT:  JSON data, line 1: {"abc"}
! SELECT '{"abc":1}'::jsonb;		-- OK
!    jsonb    
! ------------
!  {"abc": 1}
! (1 row)
! 
! SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{1:"abc"}'::jsonb;
!                ^
! DETAIL:  Expected string or "}", but found "1".
! CONTEXT:  JSON data, line 1: {1...
! SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc",1}'::jsonb;
!                ^
! DETAIL:  Expected ":", but found ",".
! CONTEXT:  JSON data, line 1: {"abc",...
! SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"=1}'::jsonb;
!                ^
! DETAIL:  Token "=" is invalid.
! CONTEXT:  JSON data, line 1: {"abc"=...
! SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc"::1}'::jsonb;
!                ^
! DETAIL:  Expected JSON value, but found ":".
! CONTEXT:  JSON data, line 1: {"abc"::...
! SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::jsonb; -- OK
!                                jsonb                                
! --------------------------------------------------------------------
!  {"abc": 1, "def": 2, "ghi": [3, 4], "hij": {"klm": 5, "nop": [6]}}
! (1 row)
! 
! SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1:2}'::jsonb;
!                ^
! DETAIL:  Expected "," or "}", but found ":".
! CONTEXT:  JSON data, line 1: {"abc":1:...
! SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '{"abc":1,3}'::jsonb;
!                ^
! DETAIL:  Expected string, but found "3".
! CONTEXT:  JSON data, line 1: {"abc":1,3...
! -- Miscellaneous stuff.
! SELECT 'true'::jsonb;			-- OK
!  jsonb 
! -------
!  true
! (1 row)
! 
! SELECT 'false'::jsonb;			-- OK
!  jsonb 
! -------
!  false
! (1 row)
! 
! SELECT 'null'::jsonb;			-- OK
!  jsonb 
! -------
!  null
! (1 row)
! 
! SELECT ' true '::jsonb;			-- OK, even with extra whitespace
!  jsonb 
! -------
!  true
! (1 row)
! 
! SELECT 'true false'::jsonb;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true false'::jsonb;
!                ^
! DETAIL:  Expected end of input, but found "false".
! CONTEXT:  JSON data, line 1: true false
! SELECT 'true, false'::jsonb;		-- ERROR, too many values
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'true, false'::jsonb;
!                ^
! DETAIL:  Expected end of input, but found ",".
! CONTEXT:  JSON data, line 1: true,...
! SELECT 'truf'::jsonb;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'truf'::jsonb;
!                ^
! DETAIL:  Token "truf" is invalid.
! CONTEXT:  JSON data, line 1: truf
! SELECT 'trues'::jsonb;			-- ERROR, not a keyword
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT 'trues'::jsonb;
!                ^
! DETAIL:  Token "trues" is invalid.
! CONTEXT:  JSON data, line 1: trues
! SELECT ''::jsonb;				-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT ''::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1: 
! SELECT '    '::jsonb;			-- ERROR, no value
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT '    '::jsonb;
!                ^
! DETAIL:  The input string ended unexpectedly.
! CONTEXT:  JSON data, line 1:     
! -- make sure jsonb is passed through json generators without being escaped
! SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
!       array_to_json       
! --------------------------
!  [{"a": 1},{"b": [2, 3]}]
! (1 row)
! 
! -- jsonb extraction functions
! CREATE TEMP TABLE test_jsonb (
!        json_type text,
!        test_json jsonb
! );
! INSERT INTO test_jsonb VALUES
! ('scalar','"a scalar"'),
! ('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
! ('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 'field2' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  "val2"
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  val2
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  "two"
! (1 row)
! 
! SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
!  ?column?  
! -----------
!  {"f1": 9}
! (1 row)
! 
! SELECT test_json ->> 'field4' FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  4
! (1 row)
! 
! SELECT test_json ->> 'field5' FROM test_jsonb WHERE json_type = 'object';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT test_json ->> 'field6' FROM test_jsonb WHERE json_type = 'object';
!  ?column?  
! -----------
!  {"f1": 9}
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'scalar';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
!  ?column? 
! ----------
!  two
! (1 row)
! 
! SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'object';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
! ERROR:  cannot call jsonb_object_keys on a scalar
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
! ERROR:  cannot call jsonb_object_keys on an array
! SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
!  jsonb_object_keys 
! -------------------
!  field1
!  field2
!  field3
!  field4
!  field5
!  field6
! (6 rows)
! 
! -- nulls
! SELECT (test_json->'field3') IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'object';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT (test_json->>'field3') IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'object';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- corner cases
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::jsonb -> 'b';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::jsonb -> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb -> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::text;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::int;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> '';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 1;
!   ?column?   
! -------------
!  {"b": "cc"}
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 3;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": "c", "b": null}'::jsonb ->> 'b';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb ->> 1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb ->> 'z';
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- equality and inequality
! SELECT '{"x":"y"}'::jsonb = '{"x":"y"}'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb = '{"x":"z"}'::jsonb;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb <> '{"x":"y"}'::jsonb;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"x":"y"}'::jsonb <> '{"x":"z"}'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- containment
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":null}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "g":null}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"g":null}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"c"}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
!  jsonb_contains 
! ----------------
!  t
! (1 row)
! 
! SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":"q"}');
!  jsonb_contains 
! ----------------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "g":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"g":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"c"}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":"q"}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '[1,2]'::jsonb @> '[1,2,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,1,2]'::jsonb @> '[1,2,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[[1,2]]'::jsonb @> '[[1,2,2]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,2,2]'::jsonb <@ '[1,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[1,2,2]'::jsonb <@ '[1,1,2]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[[1,2,2]]'::jsonb <@ '[[1,2]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "c":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "g":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"g":null}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"a":"c"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  t
! (1 row)
! 
! SELECT jsonb_contained('{"a":"b", "c":"q"}', '{"a":"b", "b":1, "c":null}');
!  jsonb_contained 
! -----------------
!  f
! (1 row)
! 
! SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "c":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"c"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":"b", "c":"q"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- Raw scalar may contain another raw scalar, array may contain a raw scalar
! SELECT '[5]'::jsonb @> '[5]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '5'::jsonb @> '5';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '[5]'::jsonb @> '5';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- But a raw scalar cannot contain an array
! SELECT '5'::jsonb @> '[5]';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- In general, one thing should always contain itself. Test array containment:
! SELECT '["9", ["7", "3"], 1]'::jsonb @> '["9", ["7", "3"], 1]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["9", ["7", "3"], ["1"]]'::jsonb @> '["9", ["7", "3"], ["1"]]'::jsonb;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- array containment string matching confusion bug
! SELECT '{ "name": "Bob", "tags": [ "enim", "qui"]}'::jsonb @> '{"tags":["qu"]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- array length
! SELECT jsonb_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
!  jsonb_array_length 
! --------------------
!                   5
! (1 row)
! 
! SELECT jsonb_array_length('[]');
!  jsonb_array_length 
! --------------------
!                   0
! (1 row)
! 
! SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
! ERROR:  cannot get array length of a non-array
! SELECT jsonb_array_length('4');
! ERROR:  cannot get array length of a scalar
! -- each
! SELECT jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
!      jsonb_each     
! --------------------
!  (f1,"[1, 2, 3]")
!  (f2,"{""f3"": 1}")
!  (f4,null)
! (3 rows)
! 
! SELECT jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!                           q                           
! ------------------------------------------------------
!  (1,"""first""")
!  (a,"{""1"": ""first"", ""b"": ""c"", ""c"": ""b""}")
!  (b,"[1, 2]")
!  (c,"""cc""")
!  (n,null)
! (5 rows)
! 
! SELECT * FROM jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1, 2, 3]
!  f2  | {"f3": 1}
!  f4  | null
!  f5  | 99
!  f6  | "stringy"
! (5 rows)
! 
! SELECT * FROM jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!  key |               value                
! -----+------------------------------------
!  1   | "first"
!  a   | {"1": "first", "b": "c", "c": "b"}
!  b   | [1, 2]
!  c   | "cc"
!  n   | null
! (5 rows)
! 
! SELECT jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
!   jsonb_each_text   
! --------------------
!  (f1,"[1, 2, 3]")
!  (f2,"{""f3"": 1}")
!  (f4,)
!  (f5,null)
! (4 rows)
! 
! SELECT jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!                           q                           
! ------------------------------------------------------
!  (1,first)
!  (a,"{""1"": ""first"", ""b"": ""c"", ""c"": ""b""}")
!  (b,"[1, 2]")
!  (c,cc)
!  (n,)
! (5 rows)
! 
! SELECT * FROM jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
!  key |   value   
! -----+-----------
!  f1  | [1, 2, 3]
!  f2  | {"f3": 1}
!  f4  | 
!  f5  | 99
!  f6  | stringy
! (5 rows)
! 
! SELECT * FROM jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
!  key |               value                
! -----+------------------------------------
!  1   | first
!  a   | {"1": "first", "b": "c", "c": "b"}
!  b   | [1, 2]
!  c   | cc
!  n   | 
! (5 rows)
! 
! -- exists
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'a');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'b');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb_exists('{"a":null, "b":"qq"}', 'c');
!  jsonb_exists 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_exists('{"a":"null", "b":"qq"}', 'a');
!  jsonb_exists 
! --------------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'b';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ? 'c';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":"null", "b":"qq"}' ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- array exists - array elements should behave as keys
! SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
! -- type sensitive array exists - should return no rows (since "exists" only
! -- matches strings that are either object keys or array elements)
! SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
! -- However, a raw scalar is *contained* within the array
! SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['a','b']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['b','a']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','a']);
!  jsonb_exists_any 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','d']);
!  jsonb_exists_any 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_any('{"a":null, "b":"qq"}', '{}'::text[]);
!  jsonb_exists_any 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['a','b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['b','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','d'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?| '{}'::text[];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['a','b']);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['b','a']);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','a']);
!  jsonb_exists_all 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','d']);
!  jsonb_exists_all 
! ------------------
!  f
! (1 row)
! 
! SELECT jsonb_exists_all('{"a":null, "b":"qq"}', '{}'::text[]);
!  jsonb_exists_all 
! ------------------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['b','a'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','a'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','d'];
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','a', 'b', 'b', 'b'];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT jsonb '{"a":null, "b":"qq"}' ?& '{}'::text[];
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- typeof
! SELECT jsonb_typeof('{}') AS object;
!  object 
! --------
!  object
! (1 row)
! 
! SELECT jsonb_typeof('{"c":3,"p":"o"}') AS object;
!  object 
! --------
!  object
! (1 row)
! 
! SELECT jsonb_typeof('[]') AS array;
!  array 
! -------
!  array
! (1 row)
! 
! SELECT jsonb_typeof('["a", 1]') AS array;
!  array 
! -------
!  array
! (1 row)
! 
! SELECT jsonb_typeof('null') AS "null";
!  null 
! ------
!  null
! (1 row)
! 
! SELECT jsonb_typeof('1') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('-1') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('1.0') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('1e2') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('-1.0') AS number;
!  number 
! --------
!  number
! (1 row)
! 
! SELECT jsonb_typeof('true') AS boolean;
!  boolean 
! ---------
!  boolean
! (1 row)
! 
! SELECT jsonb_typeof('false') AS boolean;
!  boolean 
! ---------
!  boolean
! (1 row)
! 
! SELECT jsonb_typeof('"hello"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! SELECT jsonb_typeof('"true"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! SELECT jsonb_typeof('"1.0"') AS string;
!  string 
! --------
!  string
! (1 row)
! 
! -- extract_path, extract_path_as_text
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  jsonb_extract_path 
! --------------------
!  "stringy"
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  jsonb_extract_path 
! --------------------
!  {"f3": 1}
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  jsonb_extract_path 
! --------------------
!  "f3"
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  jsonb_extract_path 
! --------------------
!  1
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
!  jsonb_extract_path_text 
! -------------------------
!  stringy
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
!  jsonb_extract_path_text 
! -------------------------
!  {"f3": 1}
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
!  jsonb_extract_path_text 
! -------------------------
!  f3
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
!  jsonb_extract_path_text 
! -------------------------
!  1
! (1 row)
! 
! -- extract_path nulls
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_false;
!  expect_false 
! --------------
!  f
! (1 row)
! 
! SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_true;
!  expect_true 
! -------------
!  t
! (1 row)
! 
! -- extract_path operators
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
!  ?column?  
! -----------
!  "stringy"
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
!  ?column?  
! -----------
!  {"f3": 1}
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
!  ?column? 
! ----------
!  "f3"
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
!  ?column? 
! ----------
!  stringy
! (1 row)
! 
! SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
!  ?column?  
! -----------
!  {"f3": 1}
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
!  ?column? 
! ----------
!  f3
! (1 row)
! 
! SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
!  ?column? 
! ----------
!  1
! (1 row)
! 
! -- corner cases for same
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
!           ?column?          
! ----------------------------
!  {"a": {"b": {"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::jsonb #> '{}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! select '"foo"'::jsonb #> '{}';
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '42'::jsonb #> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::jsonb #> '{}';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
!       ?column?       
! ---------------------
!  {"b": {"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
!  ?column? 
! ----------
!  "foo"
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
!  ?column? 
! ----------
!  "cc"
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
!  ?column? 
! ----------
!  null
! (1 row)
! 
! select '"foo"'::jsonb #> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
!           ?column?          
! ----------------------------
!  {"a": {"b": {"c": "foo"}}}
! (1 row)
! 
! select '[1,2,3]'::jsonb #>> '{}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! select '"foo"'::jsonb #>> '{}';
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '42'::jsonb #>> '{}';
!  ?column? 
! ----------
!  42
! (1 row)
! 
! select 'null'::jsonb #>> '{}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
!       ?column?       
! ---------------------
!  {"b": {"c": "foo"}}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
!    ?column?   
! --------------
!  {"c": "foo"}
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
!  ?column? 
! ----------
!  foo
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
!  ?column? 
! ----------
!  cc
! (1 row)
! 
! select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '"foo"'::jsonb #>> array['z'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #>> array['f2'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! select '42'::jsonb #>> array['0'];
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- array_elements
! SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
!     jsonb_array_elements    
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  null
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
! (6 rows)
! 
! SELECT * FROM jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]') q;
!            value            
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  null
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
! (6 rows)
! 
! SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
!  jsonb_array_elements_text  
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
!  stringy
! (7 rows)
! 
! SELECT * FROM jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
!            value            
! ----------------------------
!  1
!  true
!  [1, [2, 3]]
!  
!  {"f1": 1, "f2": [7, 8, 9]}
!  false
!  stringy
! (7 rows)
! 
! -- populate_record
! CREATE TYPE jbpop AS (a text, b int, c timestamp);
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b | c 
! --------+---+---
!  blurfl |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":[100,200,false],"x":43.2}') q;
!          a         | b | c 
! -------------------+---+---
!  [100, 200, false] |   | 
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":[100,200,false],"x":43.2}') q;
!          a         | b |            c             
! -------------------+---+--------------------------
!  [100, 200, false] | 3 | Mon Dec 31 15:30:56 2012
! (1 row)
! 
! SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
! ERROR:  invalid input syntax for type timestamp: "[100, 200, false]"
! -- populate_recordset
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!         a        | b  |            c             
! -----------------+----+--------------------------
!  [100, 200, 300] | 99 | 
!  {"z": true}     |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
! ERROR:  invalid input syntax for type timestamp: "[100, 200, 300]"
! SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b |            c             
! --------+---+--------------------------
!  blurfl |   | 
!         | 3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
!    a    | b  |            c             
! --------+----+--------------------------
!  blurfl | 99 | 
!  def    |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
!         a        | b  |            c             
! -----------------+----+--------------------------
!  [100, 200, 300] | 99 | 
!  {"z": true}     |  3 | Fri Jan 20 10:42:53 2012
! (2 rows)
! 
! -- handling of unicode surrogate pairs
! SELECT octet_length((jsonb '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a')::text) AS correct_in_utf8;
!  correct_in_utf8 
! -----------------
!               10
! (1 row)
! 
! SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a row
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a';
!                      ^
! DETAIL:  Unicode high surrogate must not follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong order
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogate
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ud83dX" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! SELECT jsonb '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogate
! ERROR:  invalid input syntax for type json
! LINE 1: SELECT jsonb '{ "a":  "\ude04X" }' -> 'a';
!                      ^
! DETAIL:  Unicode low surrogate must follow a high surrogate.
! CONTEXT:  JSON data, line 1: { "a":...
! -- handling of simple unicode escapes
! SELECT jsonb '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' AS correct_in_utf8;
!    correct_in_utf8    
! ----------------------
!  the Copyright © sign
! (1 row)
! 
! SELECT jsonb '{ "a":  "dollar \u0024 character" }' ->> 'a' AS correct_everyWHERE;
!  correct_everywhere 
! --------------------
!  dollar $ character
! (1 row)
! 
! SELECT jsonb '{ "a":  "null \u0000 escape" }' ->> 'a' AS not_unescaped;
!    not_unescaped    
! --------------------
!  null \u0000 escape
! (1 row)
! 
! -- jsonb_to_record and jsonb_to_recordset
! select * from jsonb_to_record('{"a":1,"b":"foo","c":"bar"}')
!     as x(a int, b text, d text);
!  a |  b  | d 
! ---+-----+---
!  1 | foo | 
! (1 row)
! 
! select * from jsonb_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
!     as x(a int, b text, c boolean);
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 
!  2 | bar | t
! (2 rows)
! 
! -- indexing
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
! CREATE INDEX jidx ON testjsonb USING gin (j);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
!  count 
! -------
!      3
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
!  count 
! -------
!      3
! (1 row)
! 
! -- excercise GIN_SEARCH_MODE_ALL
! SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
! -- array exists - array elements should behave as keys (for GIN index scans too)
! CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
! SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
! -- type sensitive array exists - should return no rows (since "exists" only
! -- matches strings that are either object keys or array elements)
! SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
! -- However, a raw scalar is *contained* within the array
! SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
! RESET enable_seqscan;
! SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
!  count 
! -------
!   4791
! (1 row)
! 
! SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
!     key    | count 
! -----------+-------
!  line      |   884
!  query     |   207
!  pos       |   203
!  node      |   202
!  space     |   197
!  status    |   195
!  public    |   194
!  title     |   190
!  wait      |   190
!  org       |   189
!  user      |   189
!  coauthors |   188
!  disabled  |   185
!  indexed   |   184
!  cleaned   |   180
!  bad       |   179
!  date      |   179
!  world     |   176
!  state     |   172
!  subtitle  |   169
!  auth      |   168
!  abstract  |   161
!  array     |     5
!  age       |     2
!  foo       |     2
!  fool      |     1
! (26 rows)
! 
! -- sort/hash
! SELECT count(distinct j) FROM testjsonb;
!  count 
! -------
!    894
! (1 row)
! 
! SET enable_hashagg = off;
! SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
! SET enable_hashagg = on;
! SET enable_sort = off;
! SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
! SELECT distinct * FROM (values (jsonb '{}' || ''),('{}')) v(j);
!  j  
! ----
!  {}
! (1 row)
! 
! SET enable_sort = on;
! RESET enable_hashagg;
! RESET enable_sort;
! DROP INDEX jidx;
! DROP INDEX jidx_array;
! -- btree
! CREATE INDEX jidx ON testjsonb USING btree (j);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
!  count 
! -------
!    884
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
!  count 
! -------
!      1
! (1 row)
! 
! --gin path opclass
! DROP INDEX jidx;
! CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
! SET enable_seqscan = off;
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
! -- excercise GIN_SEARCH_MODE_ALL
! SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
! RESET enable_seqscan;
! DROP INDEX jidx;
! -- nested tests
! SELECT '{"ff":{"a":12,"b":16}}'::jsonb;
!            jsonb            
! ----------------------------
!  {"ff": {"a": 12, "b": 16}}
! (1 row)
! 
! SELECT '{"ff":{"a":12,"b":16},"qq":123}'::jsonb;
!                  jsonb                 
! ---------------------------------------
!  {"ff": {"a": 12, "b": 16}, "qq": 123}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":12,"b":16,"c":["c1","c2"],"d":{"d1":"d1","d2":"d2","d1":"d3"}}}'::jsonb;
!                                               jsonb                                               
! --------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": 12, "b": 16, "c": ["c1", "c2"], "d": {"d1": "d3", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2"],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
!                                                 jsonb                                                 
! ------------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": "12", "b": "16", "c": ["c1", "c2"], "d": {"d1": "d1", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2",["c3"],{"c4":4}],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
!                                                           jsonb                                                          
! -------------------------------------------------------------------------------------------------------------------------
!  {"aa": ["a", "aaa"], "qq": {"a": "12", "b": "16", "c": ["c1", "c2", ["c3"], {"c4": 4}], "d": {"d1": "d1", "d2": "d2"}}}
! (1 row)
! 
! SELECT '{"ff":["a","aaa"]}'::jsonb;
!         jsonb         
! ----------------------
!  {"ff": ["a", "aaa"]}
! (1 row)
! 
! SELECT
!   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'ff',
!   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'qq',
!   ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'Y') IS NULL AS f,
!   ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb ->> 'Y') IS NULL AS t,
!    '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'x';
!       ?column?      | ?column? | f | t | ?column? 
! --------------------+----------+---+---+----------
!  {"a": 12, "b": 16} | 123      | f | t | [1, 2]
! (1 row)
! 
! -- nested containment
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[2,1],"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":[1,2]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '["a","b"]'::jsonb @> '["a","b","c","b"]';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '["a","b","c","b"]'::jsonb @> '["a","b"]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["a","b","c",[1,2]]'::jsonb @> '["a",[1,2]]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '["a","b","c",[1,2]]'::jsonb @> '["b",[1,2]]';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[2]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[3]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"c":3}]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4}]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},3]}';
!  ?column? 
! ----------
!  f
! (1 row)
! 
! SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},1]}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- nested object field / array index lookup
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'n';
!  ?column? 
! ----------
!  null
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'a';
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'b';
!  ?column? 
! ----------
!  [1, 2]
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'c';
!  ?column? 
! ----------
!  {"1": 2}
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd';
!    ?column?    
! ---------------
!  {"1": [2, 3]}
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd' -> '1';
!  ?column? 
! ----------
!  [2, 3]
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'e';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 0; --expecting error
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 0;
!  ?column? 
! ----------
!  "a"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 1;
!  ?column? 
! ----------
!  "b"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 2;
!  ?column? 
! ----------
!  "c"
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 3;
!  ?column? 
! ----------
!  [1, 2]
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 3 -> 1;
!  ?column? 
! ----------
!  2
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 4;
!  ?column? 
! ----------
!  null
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> 5;
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '["a","b","c",[1,2],null]'::jsonb -> -1;
!  ?column? 
! ----------
!  
! (1 row)
! 
! --nested path extraction
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
!  ?column? 
! ----------
!  "b"
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
!  ?column?  
! -----------
!  [1, 2, 3]
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
!  ?column? 
! ----------
!  1
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
!  ?column? 
! ----------
!  2
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
!  ?column? 
! ----------
!  3
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
!  ?column? 
! ----------
!  
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
!  ?column? 
! ----------
!  0
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
!  ?column? 
! ----------
!  [3, 4]
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
!    ?column?    
! ---------------
!  {"5": "five"}
! (1 row)
! 
! SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
!  ?column? 
! ----------
!  "five"
! (1 row)
! 
! --nested exists
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'n';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'a';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'b';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'c';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'd';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'e';
!  ?column? 
! ----------
!  f
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/indirect_toast.out	2014-11-21 01:48:04.323416000 +0300
--- /home/orion/postgres/src/test/regress/results/indirect_toast.out	2015-01-26 12:33:25.955031415 +0300
***************
*** 1,151 ****
! CREATE TABLE toasttest(descr text, cnt int DEFAULT 0, f1 text, f2 text);
! INSERT INTO toasttest(descr, f1, f2) VALUES('two-compressed', repeat('1234567890',1000), repeat('1234567890',1000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('two-toasted', repeat('1234567890',30000), repeat('1234567890',50000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-compressed,one-null', NULL, repeat('1234567890',1000));
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-toasted,one-null', NULL, repeat('1234567890',50000));
! -- check whether indirect tuples works on the most basic level
! SELECT descr, substring(make_tuple_indirect(toasttest)::text, 1, 200) FROM toasttest;
!           descr          |                                                                                                substring                                                                                                 
! -------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  two-compressed          | (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  two-toasted             | (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  one-compressed,one-null | ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  one-toasted,one-null    | ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without changing varlenas
! UPDATE toasttest SET cnt = cnt +1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without modifying asigned value
! UPDATE toasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification modifying, but effectively not changing
! UPDATE toasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
!  (two-toasted,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
!  ("one-compressed,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! UPDATE toasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- check we didn't screw with main/toast tuple visiblity
! VACUUM FREEZE toasttest;
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- now create a trigger that forces all Datums to be indirect ones
! CREATE FUNCTION update_using_indirect()
!         RETURNS trigger
!         LANGUAGE plpgsql AS $$
! BEGIN
!     NEW := make_tuple_indirect(NEW);
!     RETURN NEW;
! END$$;
! CREATE TRIGGER toasttest_update_indirect
!         BEFORE INSERT OR UPDATE
!         ON toasttest
!         FOR EACH ROW
!         EXECUTE PROCEDURE update_using_indirect();
! -- modification without changing varlenas
! UPDATE toasttest SET cnt = cnt +1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification without modifying asigned value
! UPDATE toasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! -- modification modifying, but effectively not changing
! UPDATE toasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
!  (two-toasted,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
!  ("one-compressed,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! UPDATE toasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(toasttest::text, 1, 200);
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
! (4 rows)
! 
! INSERT INTO toasttest(descr, f1, f2) VALUES('one-toasted,one-null, via indirect', repeat('1234567890',30000), NULL);
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
! (5 rows)
! 
! -- check we didn't screw with main/toast tuple visiblity
! VACUUM FREEZE toasttest;
! SELECT substring(toasttest::text, 1, 200) FROM toasttest;
!                                                                                                 substring                                                                                                 
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
!  ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
!  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
! (5 rows)
! 
! DROP TABLE toasttest;
! DROP FUNCTION update_using_indirect();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/equivclass.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/equivclass.out	2015-01-26 12:33:25.951031414 +0300
***************
*** 1,383 ****
! --
! -- Tests for the planner's "equivalence class" mechanism
! --
! -- One thing that's not tested well during normal querying is the logic
! -- for handling "broken" ECs.  This is because an EC can only become broken
! -- if its underlying btree operator family doesn't include a complete set
! -- of cross-type equality operators.  There are not (and should not be)
! -- any such families built into Postgres; so we have to hack things up
! -- to create one.  We do this by making two alias types that are really
! -- int8 (so we need no new C code) and adding only some operators for them
! -- into the standard integer_ops opfamily.
! create type int8alias1;
! create function int8alias1in(cstring) returns int8alias1
!   strict immutable language internal as 'int8in';
! NOTICE:  return type int8alias1 is only a shell
! create function int8alias1out(int8alias1) returns cstring
!   strict immutable language internal as 'int8out';
! NOTICE:  argument type int8alias1 is only a shell
! create type int8alias1 (
!     input = int8alias1in,
!     output = int8alias1out,
!     like = int8
! );
! create type int8alias2;
! create function int8alias2in(cstring) returns int8alias2
!   strict immutable language internal as 'int8in';
! NOTICE:  return type int8alias2 is only a shell
! create function int8alias2out(int8alias2) returns cstring
!   strict immutable language internal as 'int8out';
! NOTICE:  argument type int8alias2 is only a shell
! create type int8alias2 (
!     input = int8alias2in,
!     output = int8alias2out,
!     like = int8
! );
! create cast (int8 as int8alias1) without function;
! create cast (int8 as int8alias2) without function;
! create cast (int8alias1 as int8) without function;
! create cast (int8alias2 as int8) without function;
! create function int8alias1eq(int8alias1, int8alias1) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8alias1, rightarg = int8alias1,
!     commutator = =,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias1, int8alias1);
! create function int8alias2eq(int8alias2, int8alias2) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias2eq,
!     leftarg = int8alias2, rightarg = int8alias2,
!     commutator = =,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias2, int8alias2);
! create function int8alias1eq(int8, int8alias1) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8, rightarg = int8alias1,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8, int8alias1);
! create function int8alias1eq(int8alias1, int8alias2) returns bool
!   strict immutable language internal as 'int8eq';
! create operator = (
!     procedure = int8alias1eq,
!     leftarg = int8alias1, rightarg = int8alias2,
!     restrict = eqsel, join = eqjoinsel,
!     merges
! );
! alter operator family integer_ops using btree add
!   operator 3 = (int8alias1, int8alias2);
! create function int8alias1lt(int8alias1, int8alias1) returns bool
!   strict immutable language internal as 'int8lt';
! create operator < (
!     procedure = int8alias1lt,
!     leftarg = int8alias1, rightarg = int8alias1
! );
! alter operator family integer_ops using btree add
!   operator 1 < (int8alias1, int8alias1);
! create function int8alias1cmp(int8, int8alias1) returns int
!   strict immutable language internal as 'btint8cmp';
! alter operator family integer_ops using btree add
!   function 1 int8alias1cmp (int8, int8alias1);
! create table ec0 (ff int8 primary key, f1 int8, f2 int8);
! create table ec1 (ff int8 primary key, f1 int8alias1, f2 int8alias2);
! create table ec2 (xf int8 primary key, x1 int8alias1, x2 int8alias2);
! -- for the moment we only want to look at nestloop plans
! set enable_hashjoin = off;
! set enable_mergejoin = off;
! --
! -- Note that for cases where there's a missing operator, we don't care so
! -- much whether the plan is ideal as that we don't fail or generate an
! -- outright incorrect plan.
! --
! explain (costs off)
!   select * from ec0 where ff = f1 and f1 = '42'::int8;
!             QUERY PLAN            
! ----------------------------------
!  Index Scan using ec0_pkey on ec0
!    Index Cond: (ff = 42::bigint)
!    Filter: (f1 = 42::bigint)
! (3 rows)
! 
! explain (costs off)
!   select * from ec0 where ff = f1 and f1 = '42'::int8alias1;
!               QUERY PLAN               
! ---------------------------------------
!  Index Scan using ec0_pkey on ec0
!    Index Cond: (ff = '42'::int8alias1)
!    Filter: (f1 = '42'::int8alias1)
! (3 rows)
! 
! explain (costs off)
!   select * from ec1 where ff = f1 and f1 = '42'::int8alias1;
!               QUERY PLAN               
! ---------------------------------------
!  Index Scan using ec1_pkey on ec1
!    Index Cond: (ff = '42'::int8alias1)
!    Filter: (f1 = '42'::int8alias1)
! (3 rows)
! 
! explain (costs off)
!   select * from ec1 where ff = f1 and f1 = '42'::int8alias2;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Seq Scan on ec1
!    Filter: ((ff = f1) AND (f1 = '42'::int8alias2))
! (2 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and ff = '42'::int8;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Nested Loop
!    Join Filter: (ec1.ff = ec2.x1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: ((ff = 42::bigint) AND (ff = 42::bigint))
!    ->  Seq Scan on ec2
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and ff = '42'::int8alias1;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = '42'::int8alias1)
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias1)
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and '42'::int8 = x1;
!                QUERY PLAN               
! ----------------------------------------
!  Nested Loop
!    Join Filter: (ec1.ff = ec2.x1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Seq Scan on ec2
!          Filter: (42::bigint = x1)
! (6 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias1;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = '42'::int8alias1)
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias1)
! (5 rows)
! 
! explain (costs off)
!   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias2;
!                QUERY PLAN                
! -----------------------------------------
!  Nested Loop
!    ->  Seq Scan on ec2
!          Filter: (x1 = '42'::int8alias2)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = ec2.x1)
! (5 rows)
! 
! create unique index ec1_expr1 on ec1((ff + 1));
! create unique index ec1_expr2 on ec1((ff + 2 + 1));
! create unique index ec1_expr3 on ec1((ff + 3 + 1));
! create unique index ec1_expr4 on ec1((ff + 4));
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                Index Cond: (((ff + 3) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = ec1.f1)
! (10 rows)
! 
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8 and ec1.ff = ec1.f1;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Nested Loop
!    Join Filter: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: ((ff = 42::bigint) AND (ff = 42::bigint))
!          Filter: (ff = f1)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = 42::bigint)
!          ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                Index Cond: (((ff + 3) + 1) = 42::bigint)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = 42::bigint)
! (12 rows)
! 
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss2
!   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Nested Loop
!    ->  Nested Loop
!          ->  Index Scan using ec1_pkey on ec1
!                Index Cond: (ff = 42::bigint)
!          ->  Append
!                ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                      Index Cond: (((ff + 2) + 1) = ec1.f1)
!                ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                      Index Cond: (((ff + 3) + 1) = ec1.f1)
!                ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                      Index Cond: ((ff + 4) = ec1.f1)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_4
!                Index Cond: (((ff + 2) + 1) = (((ec1_1.ff + 2) + 1)))
!          ->  Index Scan using ec1_expr3 on ec1 ec1_5
!                Index Cond: (((ff + 3) + 1) = (((ec1_1.ff + 2) + 1)))
!          ->  Index Scan using ec1_expr4 on ec1 ec1_6
!                Index Cond: ((ff + 4) = (((ec1_1.ff + 2) + 1)))
! (18 rows)
! 
! -- let's try that as a mergejoin
! set enable_mergejoin = on;
! set enable_nestloop = off;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss2
!   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Merge Join
!    Merge Cond: ((((ec1_4.ff + 2) + 1)) = (((ec1_1.ff + 2) + 1)))
!    ->  Merge Append
!          Sort Key: (((ec1_4.ff + 2) + 1))
!          ->  Index Scan using ec1_expr2 on ec1 ec1_4
!          ->  Index Scan using ec1_expr3 on ec1 ec1_5
!          ->  Index Scan using ec1_expr4 on ec1 ec1_6
!    ->  Materialize
!          ->  Merge Join
!                Merge Cond: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!                ->  Merge Append
!                      Sort Key: (((ec1_1.ff + 2) + 1))
!                      ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                      ->  Index Scan using ec1_expr3 on ec1 ec1_2
!                      ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                ->  Materialize
!                      ->  Sort
!                            Sort Key: ec1.f1
!                            ->  Index Scan using ec1_pkey on ec1
!                                  Index Cond: (ff = 42::bigint)
! (20 rows)
! 
! -- check partially indexed scan
! set enable_nestloop = on;
! set enable_mergejoin = off;
! drop index ec1_expr3;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec1_pkey on ec1
!          Index Cond: (ff = 42::bigint)
!    ->  Append
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!                Index Cond: (((ff + 2) + 1) = ec1.f1)
!          ->  Seq Scan on ec1 ec1_2
!                Filter: (((ff + 3) + 1) = ec1.f1)
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!                Index Cond: ((ff + 4) = ec1.f1)
! (10 rows)
! 
! -- let's try that as a mergejoin
! set enable_mergejoin = on;
! set enable_nestloop = off;
! explain (costs off)
!   select * from ec1,
!     (select ff + 1 as x from
!        (select ff + 2 as ff from ec1
!         union all
!         select ff + 3 as ff from ec1) ss0
!      union all
!      select ff + 4 as x from ec1) as ss1
!   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Merge Join
!    Merge Cond: ((((ec1_1.ff + 2) + 1)) = ec1.f1)
!    ->  Merge Append
!          Sort Key: (((ec1_1.ff + 2) + 1))
!          ->  Index Scan using ec1_expr2 on ec1 ec1_1
!          ->  Sort
!                Sort Key: (((ec1_2.ff + 3) + 1))
!                ->  Seq Scan on ec1 ec1_2
!          ->  Index Scan using ec1_expr4 on ec1 ec1_3
!    ->  Materialize
!          ->  Sort
!                Sort Key: ec1.f1
!                ->  Index Scan using ec1_pkey on ec1
!                      Index Cond: (ff = 42::bigint)
! (14 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/plancache.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/plancache.out	2015-01-26 12:33:26.287031432 +0300
***************
*** 1,258 ****
! --
! -- Tests to exercise the plan caching/invalidation mechanism
! --
! CREATE TEMP TABLE pcachetest AS SELECT * FROM int8_tbl;
! -- create and use a cached plan
! PREPARE prepstmt AS SELECT * FROM pcachetest;
! EXECUTE prepstmt;
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! -- and one with parameters
! PREPARE prepstmt2(bigint) AS SELECT * FROM pcachetest WHERE q1 = $1;
! EXECUTE prepstmt2(123);
!  q1  |        q2        
! -----+------------------
!  123 |              456
!  123 | 4567890123456789
! (2 rows)
! 
! -- invalidate the plans and see what happens
! DROP TABLE pcachetest;
! EXECUTE prepstmt;
! ERROR:  relation "pcachetest" does not exist
! EXECUTE prepstmt2(123);
! ERROR:  relation "pcachetest" does not exist
! -- recreate the temp table (this demonstrates that the raw plan is
! -- purely textual and doesn't depend on OIDs, for instance)
! CREATE TEMP TABLE pcachetest AS SELECT * FROM int8_tbl ORDER BY 2;
! EXECUTE prepstmt;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!  4567890123456789 |               123
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |  4567890123456789
! (5 rows)
! 
! EXECUTE prepstmt2(123);
!  q1  |        q2        
! -----+------------------
!  123 |              456
!  123 | 4567890123456789
! (2 rows)
! 
! -- prepared statements should prevent change in output tupdesc,
! -- since clients probably aren't expecting that to change on the fly
! ALTER TABLE pcachetest ADD COLUMN q3 bigint;
! EXECUTE prepstmt;
! ERROR:  cached plan must not change result type
! EXECUTE prepstmt2(123);
! ERROR:  cached plan must not change result type
! -- but we're nice guys and will let you undo your mistake
! ALTER TABLE pcachetest DROP COLUMN q3;
! EXECUTE prepstmt;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!  4567890123456789 |               123
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |  4567890123456789
! (5 rows)
! 
! EXECUTE prepstmt2(123);
!  q1  |        q2        
! -----+------------------
!  123 |              456
!  123 | 4567890123456789
! (2 rows)
! 
! -- Try it with a view, which isn't directly used in the resulting plan
! -- but should trigger invalidation anyway
! CREATE TEMP VIEW pcacheview AS
!   SELECT * FROM pcachetest;
! PREPARE vprep AS SELECT * FROM pcacheview;
! EXECUTE vprep;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!  4567890123456789 |               123
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |  4567890123456789
! (5 rows)
! 
! CREATE OR REPLACE TEMP VIEW pcacheview AS
!   SELECT q1, q2/2 AS q2 FROM pcachetest;
! EXECUTE vprep;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -2283945061728394
!  4567890123456789 |                61
!               123 |               228
!               123 |  2283945061728394
!  4567890123456789 |  2283945061728394
! (5 rows)
! 
! -- Check basic SPI plan invalidation
! create function cache_test(int) returns int as $$
! declare total int;
! begin
! 	create temp table t1(f1 int);
! 	insert into t1 values($1);
! 	insert into t1 values(11);
! 	insert into t1 values(12);
! 	insert into t1 values(13);
! 	select sum(f1) into total from t1;
! 	drop table t1;
! 	return total;
! end
! $$ language plpgsql;
! select cache_test(1);
!  cache_test 
! ------------
!          37
! (1 row)
! 
! select cache_test(2);
!  cache_test 
! ------------
!          38
! (1 row)
! 
! select cache_test(3);
!  cache_test 
! ------------
!          39
! (1 row)
! 
! -- Check invalidation of plpgsql "simple expression"
! create temp view v1 as
!   select 2+2 as f1;
! create function cache_test_2() returns int as $$
! begin
! 	return f1 from v1;
! end$$ language plpgsql;
! select cache_test_2();
!  cache_test_2 
! --------------
!             4
! (1 row)
! 
! create or replace temp view v1 as
!   select 2+2+4 as f1;
! select cache_test_2();
!  cache_test_2 
! --------------
!             8
! (1 row)
! 
! create or replace temp view v1 as
!   select 2+2+4+(select max(unique1) from tenk1) as f1;
! select cache_test_2();
!  cache_test_2 
! --------------
!         10007
! (1 row)
! 
! --- Check that change of search_path is honored when re-using cached plan
! create schema s1
!   create table abc (f1 int);
! create schema s2
!   create table abc (f1 int);
! insert into s1.abc values(123);
! insert into s2.abc values(456);
! set search_path = s1;
! prepare p1 as select f1 from abc;
! execute p1;
!  f1  
! -----
!  123
! (1 row)
! 
! set search_path = s2;
! select f1 from abc;
!  f1  
! -----
!  456
! (1 row)
! 
! execute p1;
!  f1  
! -----
!  456
! (1 row)
! 
! alter table s1.abc add column f2 float8;   -- force replan
! execute p1;
!  f1  
! -----
!  456
! (1 row)
! 
! drop schema s1 cascade;
! NOTICE:  drop cascades to table s1.abc
! drop schema s2 cascade;
! NOTICE:  drop cascades to table abc
! reset search_path;
! -- Check that invalidation deals with regclass constants
! create temp sequence seq;
! prepare p2 as select nextval('seq');
! execute p2;
!  nextval 
! ---------
!        1
! (1 row)
! 
! drop sequence seq;
! create temp sequence seq;
! execute p2;
!  nextval 
! ---------
!        1
! (1 row)
! 
! -- Check DDL via SPI, immediately followed by SPI plan re-use
! -- (bug in original coding)
! create function cachebug() returns void as $$
! declare r int;
! begin
!   drop table if exists temptable cascade;
!   create temp table temptable as select * from generate_series(1,3) as f1;
!   create temp view vv as select * from temptable;
!   for r in select * from vv loop
!     raise notice '%', r;
!   end loop;
! end$$ language plpgsql;
! select cachebug();
! NOTICE:  table "temptable" does not exist, skipping
! CONTEXT:  SQL statement "drop table if exists temptable cascade"
! PL/pgSQL function cachebug() line 4 at SQL statement
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
!  cachebug 
! ----------
!  
! (1 row)
! 
! select cachebug();
! NOTICE:  drop cascades to view vv
! CONTEXT:  SQL statement "drop table if exists temptable cascade"
! PL/pgSQL function cachebug() line 4 at SQL statement
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
!  cachebug 
! ----------
!  
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/limit.out	2014-11-21 01:48:04.327418000 +0300
--- /home/orion/postgres/src/test/regress/results/limit.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,131 ****
! --
! -- LIMIT
! -- Check the LIMIT/OFFSET feature of SELECT
! --
! SELECT ''::text AS two, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 > 50
! 		ORDER BY unique1 LIMIT 2;
!  two | unique1 | unique2 | stringu1 
! -----+---------+---------+----------
!      |      51 |      76 | ZBAAAA
!      |      52 |     985 | ACAAAA
! (2 rows)
! 
! SELECT ''::text AS five, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 > 60
! 		ORDER BY unique1 LIMIT 5;
!  five | unique1 | unique2 | stringu1 
! ------+---------+---------+----------
!       |      61 |     560 | JCAAAA
!       |      62 |     633 | KCAAAA
!       |      63 |     296 | LCAAAA
!       |      64 |     479 | MCAAAA
!       |      65 |      64 | NCAAAA
! (5 rows)
! 
! SELECT ''::text AS two, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 > 60 AND unique1 < 63
! 		ORDER BY unique1 LIMIT 5;
!  two | unique1 | unique2 | stringu1 
! -----+---------+---------+----------
!      |      61 |     560 | JCAAAA
!      |      62 |     633 | KCAAAA
! (2 rows)
! 
! SELECT ''::text AS three, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 > 100
! 		ORDER BY unique1 LIMIT 3 OFFSET 20;
!  three | unique1 | unique2 | stringu1 
! -------+---------+---------+----------
!        |     121 |     700 | REAAAA
!        |     122 |     519 | SEAAAA
!        |     123 |     777 | TEAAAA
! (3 rows)
! 
! SELECT ''::text AS zero, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 < 50
! 		ORDER BY unique1 DESC LIMIT 8 OFFSET 99;
!  zero | unique1 | unique2 | stringu1 
! ------+---------+---------+----------
! (0 rows)
! 
! SELECT ''::text AS eleven, unique1, unique2, stringu1
! 		FROM onek WHERE unique1 < 50
! 		ORDER BY unique1 DESC LIMIT 20 OFFSET 39;
!  eleven | unique1 | unique2 | stringu1 
! --------+---------+---------+----------
!         |      10 |     520 | KAAAAA
!         |       9 |      49 | JAAAAA
!         |       8 |     653 | IAAAAA
!         |       7 |     647 | HAAAAA
!         |       6 |     978 | GAAAAA
!         |       5 |     541 | FAAAAA
!         |       4 |     833 | EAAAAA
!         |       3 |     431 | DAAAAA
!         |       2 |     326 | CAAAAA
!         |       1 |     214 | BAAAAA
!         |       0 |     998 | AAAAAA
! (11 rows)
! 
! SELECT ''::text AS ten, unique1, unique2, stringu1
! 		FROM onek
! 		ORDER BY unique1 OFFSET 990;
!  ten | unique1 | unique2 | stringu1 
! -----+---------+---------+----------
!      |     990 |     369 | CMAAAA
!      |     991 |     426 | DMAAAA
!      |     992 |     363 | EMAAAA
!      |     993 |     661 | FMAAAA
!      |     994 |     695 | GMAAAA
!      |     995 |     144 | HMAAAA
!      |     996 |     258 | IMAAAA
!      |     997 |      21 | JMAAAA
!      |     998 |     549 | KMAAAA
!      |     999 |     152 | LMAAAA
! (10 rows)
! 
! SELECT ''::text AS five, unique1, unique2, stringu1
! 		FROM onek
! 		ORDER BY unique1 OFFSET 990 LIMIT 5;
!  five | unique1 | unique2 | stringu1 
! ------+---------+---------+----------
!       |     990 |     369 | CMAAAA
!       |     991 |     426 | DMAAAA
!       |     992 |     363 | EMAAAA
!       |     993 |     661 | FMAAAA
!       |     994 |     695 | GMAAAA
! (5 rows)
! 
! SELECT ''::text AS five, unique1, unique2, stringu1
! 		FROM onek
! 		ORDER BY unique1 LIMIT 5 OFFSET 900;
!  five | unique1 | unique2 | stringu1 
! ------+---------+---------+----------
!       |     900 |     913 | QIAAAA
!       |     901 |     931 | RIAAAA
!       |     902 |     702 | SIAAAA
!       |     903 |     641 | TIAAAA
!       |     904 |     793 | UIAAAA
! (5 rows)
! 
! -- Stress test for variable LIMIT in conjunction with bounded-heap sorting
! SELECT
!   (SELECT n
!      FROM (VALUES (1)) AS x,
!           (SELECT n FROM generate_series(1,10) AS n
!              ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z
!   FROM generate_series(1,10) AS s;
!  z  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (10 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/plpgsql.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/plpgsql.out	2015-01-26 12:33:26.347031435 +0300
***************
*** 1,5353 ****
! --
! -- PLPGSQL
! --
! -- Scenario:
! --
! --     A building with a modern TP cable installation where any
! --     of the wall connectors can be used to plug in phones,
! --     ethernet interfaces or local office hubs. The backside
! --     of the wall connectors is wired to one of several patch-
! --     fields in the building.
! --
! --     In the patchfields, there are hubs and all the slots
! --     representing the wall connectors. In addition there are
! --     slots that can represent a phone line from the central
! --     phone system.
! --
! --     Triggers ensure consistency of the patching information.
! --
! --     Functions are used to build up powerful views that let
! --     you look behind the wall when looking at a patchfield
! --     or into a room.
! --
! create table Room (
!     roomno	char(8),
!     comment	text
! );
! create unique index Room_rno on Room using btree (roomno bpchar_ops);
! create table WSlot (
!     slotname	char(20),
!     roomno	char(8),
!     slotlink	char(20),
!     backlink	char(20)
! );
! create unique index WSlot_name on WSlot using btree (slotname bpchar_ops);
! create table PField (
!     name	text,
!     comment	text
! );
! create unique index PField_name on PField using btree (name text_ops);
! create table PSlot (
!     slotname	char(20),
!     pfname	text,
!     slotlink	char(20),
!     backlink	char(20)
! );
! create unique index PSlot_name on PSlot using btree (slotname bpchar_ops);
! create table PLine (
!     slotname	char(20),
!     phonenumber	char(20),
!     comment	text,
!     backlink	char(20)
! );
! create unique index PLine_name on PLine using btree (slotname bpchar_ops);
! create table Hub (
!     name	char(14),
!     comment	text,
!     nslots	integer
! );
! create unique index Hub_name on Hub using btree (name bpchar_ops);
! create table HSlot (
!     slotname	char(20),
!     hubname	char(14),
!     slotno	integer,
!     slotlink	char(20)
! );
! create unique index HSlot_name on HSlot using btree (slotname bpchar_ops);
! create index HSlot_hubname on HSlot using btree (hubname bpchar_ops);
! create table System (
!     name	text,
!     comment	text
! );
! create unique index System_name on System using btree (name text_ops);
! create table IFace (
!     slotname	char(20),
!     sysname	text,
!     ifname	text,
!     slotlink	char(20)
! );
! create unique index IFace_name on IFace using btree (slotname bpchar_ops);
! create table PHone (
!     slotname	char(20),
!     comment	text,
!     slotlink	char(20)
! );
! create unique index PHone_name on PHone using btree (slotname bpchar_ops);
! -- ************************************************************
! -- *
! -- * Trigger procedures and functions for the patchfield
! -- * test of PL/pgSQL
! -- *
! -- ************************************************************
! -- ************************************************************
! -- * AFTER UPDATE on Room
! -- *	- If room no changes let wall slots follow
! -- ************************************************************
! create function tg_room_au() returns trigger as '
! begin
!     if new.roomno != old.roomno then
!         update WSlot set roomno = new.roomno where roomno = old.roomno;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_room_au after update
!     on Room for each row execute procedure tg_room_au();
! -- ************************************************************
! -- * AFTER DELETE on Room
! -- *	- delete wall slots in this room
! -- ************************************************************
! create function tg_room_ad() returns trigger as '
! begin
!     delete from WSlot where roomno = old.roomno;
!     return old;
! end;
! ' language plpgsql;
! create trigger tg_room_ad after delete
!     on Room for each row execute procedure tg_room_ad();
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on WSlot
! -- *	- Check that room exists
! -- ************************************************************
! create function tg_wslot_biu() returns trigger as $$
! begin
!     if count(*) = 0 from Room where roomno = new.roomno then
!         raise exception 'Room % does not exist', new.roomno;
!     end if;
!     return new;
! end;
! $$ language plpgsql;
! create trigger tg_wslot_biu before insert or update
!     on WSlot for each row execute procedure tg_wslot_biu();
! -- ************************************************************
! -- * AFTER UPDATE on PField
! -- *	- Let PSlots of this field follow
! -- ************************************************************
! create function tg_pfield_au() returns trigger as '
! begin
!     if new.name != old.name then
!         update PSlot set pfname = new.name where pfname = old.name;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_pfield_au after update
!     on PField for each row execute procedure tg_pfield_au();
! -- ************************************************************
! -- * AFTER DELETE on PField
! -- *	- Remove all slots of this patchfield
! -- ************************************************************
! create function tg_pfield_ad() returns trigger as '
! begin
!     delete from PSlot where pfname = old.name;
!     return old;
! end;
! ' language plpgsql;
! create trigger tg_pfield_ad after delete
!     on PField for each row execute procedure tg_pfield_ad();
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on PSlot
! -- *	- Ensure that our patchfield does exist
! -- ************************************************************
! create function tg_pslot_biu() returns trigger as $proc$
! declare
!     pfrec	record;
!     ps          alias for new;
! begin
!     select into pfrec * from PField where name = ps.pfname;
!     if not found then
!         raise exception $$Patchfield "%" does not exist$$, ps.pfname;
!     end if;
!     return ps;
! end;
! $proc$ language plpgsql;
! create trigger tg_pslot_biu before insert or update
!     on PSlot for each row execute procedure tg_pslot_biu();
! -- ************************************************************
! -- * AFTER UPDATE on System
! -- *	- If system name changes let interfaces follow
! -- ************************************************************
! create function tg_system_au() returns trigger as '
! begin
!     if new.name != old.name then
!         update IFace set sysname = new.name where sysname = old.name;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_system_au after update
!     on System for each row execute procedure tg_system_au();
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on IFace
! -- *	- set the slotname to IF.sysname.ifname
! -- ************************************************************
! create function tg_iface_biu() returns trigger as $$
! declare
!     sname	text;
!     sysrec	record;
! begin
!     select into sysrec * from system where name = new.sysname;
!     if not found then
!         raise exception $q$system "%" does not exist$q$, new.sysname;
!     end if;
!     sname := 'IF.' || new.sysname;
!     sname := sname || '.';
!     sname := sname || new.ifname;
!     if length(sname) > 20 then
!         raise exception 'IFace slotname "%" too long (20 char max)', sname;
!     end if;
!     new.slotname := sname;
!     return new;
! end;
! $$ language plpgsql;
! create trigger tg_iface_biu before insert or update
!     on IFace for each row execute procedure tg_iface_biu();
! -- ************************************************************
! -- * AFTER INSERT or UPDATE or DELETE on Hub
! -- *	- insert/delete/rename slots as required
! -- ************************************************************
! create function tg_hub_a() returns trigger as '
! declare
!     hname	text;
!     dummy	integer;
! begin
!     if tg_op = ''INSERT'' then
! 	dummy := tg_hub_adjustslots(new.name, 0, new.nslots);
! 	return new;
!     end if;
!     if tg_op = ''UPDATE'' then
! 	if new.name != old.name then
! 	    update HSlot set hubname = new.name where hubname = old.name;
! 	end if;
! 	dummy := tg_hub_adjustslots(new.name, old.nslots, new.nslots);
! 	return new;
!     end if;
!     if tg_op = ''DELETE'' then
! 	dummy := tg_hub_adjustslots(old.name, old.nslots, 0);
! 	return old;
!     end if;
! end;
! ' language plpgsql;
! create trigger tg_hub_a after insert or update or delete
!     on Hub for each row execute procedure tg_hub_a();
! -- ************************************************************
! -- * Support function to add/remove slots of Hub
! -- ************************************************************
! create function tg_hub_adjustslots(hname bpchar,
!                                    oldnslots integer,
!                                    newnslots integer)
! returns integer as '
! begin
!     if newnslots = oldnslots then
!         return 0;
!     end if;
!     if newnslots < oldnslots then
!         delete from HSlot where hubname = hname and slotno > newnslots;
! 	return 0;
!     end if;
!     for i in oldnslots + 1 .. newnslots loop
!         insert into HSlot (slotname, hubname, slotno, slotlink)
! 		values (''HS.dummy'', hname, i, '''');
!     end loop;
!     return 0;
! end
! ' language plpgsql;
! -- Test comments
! COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
! ERROR:  function tg_hub_adjustslots_wrong(character, integer, integer) does not exist
! COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS 'function with args';
! COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS NULL;
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on HSlot
! -- *	- prevent from manual manipulation
! -- *	- set the slotname to HS.hubname.slotno
! -- ************************************************************
! create function tg_hslot_biu() returns trigger as '
! declare
!     sname	text;
!     xname	HSlot.slotname%TYPE;
!     hubrec	record;
! begin
!     select into hubrec * from Hub where name = new.hubname;
!     if not found then
!         raise exception ''no manual manipulation of HSlot'';
!     end if;
!     if new.slotno < 1 or new.slotno > hubrec.nslots then
!         raise exception ''no manual manipulation of HSlot'';
!     end if;
!     if tg_op = ''UPDATE'' and new.hubname != old.hubname then
! 	if count(*) > 0 from Hub where name = old.hubname then
! 	    raise exception ''no manual manipulation of HSlot'';
! 	end if;
!     end if;
!     sname := ''HS.'' || trim(new.hubname);
!     sname := sname || ''.'';
!     sname := sname || new.slotno::text;
!     if length(sname) > 20 then
!         raise exception ''HSlot slotname "%" too long (20 char max)'', sname;
!     end if;
!     new.slotname := sname;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_hslot_biu before insert or update
!     on HSlot for each row execute procedure tg_hslot_biu();
! -- ************************************************************
! -- * BEFORE DELETE on HSlot
! -- *	- prevent from manual manipulation
! -- ************************************************************
! create function tg_hslot_bd() returns trigger as '
! declare
!     hubrec	record;
! begin
!     select into hubrec * from Hub where name = old.hubname;
!     if not found then
!         return old;
!     end if;
!     if old.slotno > hubrec.nslots then
!         return old;
!     end if;
!     raise exception ''no manual manipulation of HSlot'';
! end;
! ' language plpgsql;
! create trigger tg_hslot_bd before delete
!     on HSlot for each row execute procedure tg_hslot_bd();
! -- ************************************************************
! -- * BEFORE INSERT on all slots
! -- *	- Check name prefix
! -- ************************************************************
! create function tg_chkslotname() returns trigger as '
! begin
!     if substr(new.slotname, 1, 2) != tg_argv[0] then
!         raise exception ''slotname must begin with %'', tg_argv[0];
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_chkslotname before insert
!     on PSlot for each row execute procedure tg_chkslotname('PS');
! create trigger tg_chkslotname before insert
!     on WSlot for each row execute procedure tg_chkslotname('WS');
! create trigger tg_chkslotname before insert
!     on PLine for each row execute procedure tg_chkslotname('PL');
! create trigger tg_chkslotname before insert
!     on IFace for each row execute procedure tg_chkslotname('IF');
! create trigger tg_chkslotname before insert
!     on PHone for each row execute procedure tg_chkslotname('PH');
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on all slots with slotlink
! -- *	- Set slotlink to empty string if NULL value given
! -- ************************************************************
! create function tg_chkslotlink() returns trigger as '
! begin
!     if new.slotlink isnull then
!         new.slotlink := '''';
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_chkslotlink before insert or update
!     on PSlot for each row execute procedure tg_chkslotlink();
! create trigger tg_chkslotlink before insert or update
!     on WSlot for each row execute procedure tg_chkslotlink();
! create trigger tg_chkslotlink before insert or update
!     on IFace for each row execute procedure tg_chkslotlink();
! create trigger tg_chkslotlink before insert or update
!     on HSlot for each row execute procedure tg_chkslotlink();
! create trigger tg_chkslotlink before insert or update
!     on PHone for each row execute procedure tg_chkslotlink();
! -- ************************************************************
! -- * BEFORE INSERT or UPDATE on all slots with backlink
! -- *	- Set backlink to empty string if NULL value given
! -- ************************************************************
! create function tg_chkbacklink() returns trigger as '
! begin
!     if new.backlink isnull then
!         new.backlink := '''';
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_chkbacklink before insert or update
!     on PSlot for each row execute procedure tg_chkbacklink();
! create trigger tg_chkbacklink before insert or update
!     on WSlot for each row execute procedure tg_chkbacklink();
! create trigger tg_chkbacklink before insert or update
!     on PLine for each row execute procedure tg_chkbacklink();
! -- ************************************************************
! -- * BEFORE UPDATE on PSlot
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_pslot_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname then
!         delete from PSlot where slotname = old.slotname;
! 	insert into PSlot (
! 		    slotname,
! 		    pfname,
! 		    slotlink,
! 		    backlink
! 		) values (
! 		    new.slotname,
! 		    new.pfname,
! 		    new.slotlink,
! 		    new.backlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_pslot_bu before update
!     on PSlot for each row execute procedure tg_pslot_bu();
! -- ************************************************************
! -- * BEFORE UPDATE on WSlot
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_wslot_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname then
!         delete from WSlot where slotname = old.slotname;
! 	insert into WSlot (
! 		    slotname,
! 		    roomno,
! 		    slotlink,
! 		    backlink
! 		) values (
! 		    new.slotname,
! 		    new.roomno,
! 		    new.slotlink,
! 		    new.backlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_wslot_bu before update
!     on WSlot for each row execute procedure tg_Wslot_bu();
! -- ************************************************************
! -- * BEFORE UPDATE on PLine
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_pline_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname then
!         delete from PLine where slotname = old.slotname;
! 	insert into PLine (
! 		    slotname,
! 		    phonenumber,
! 		    comment,
! 		    backlink
! 		) values (
! 		    new.slotname,
! 		    new.phonenumber,
! 		    new.comment,
! 		    new.backlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_pline_bu before update
!     on PLine for each row execute procedure tg_pline_bu();
! -- ************************************************************
! -- * BEFORE UPDATE on IFace
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_iface_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname then
!         delete from IFace where slotname = old.slotname;
! 	insert into IFace (
! 		    slotname,
! 		    sysname,
! 		    ifname,
! 		    slotlink
! 		) values (
! 		    new.slotname,
! 		    new.sysname,
! 		    new.ifname,
! 		    new.slotlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_iface_bu before update
!     on IFace for each row execute procedure tg_iface_bu();
! -- ************************************************************
! -- * BEFORE UPDATE on HSlot
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_hslot_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname or new.hubname != old.hubname then
!         delete from HSlot where slotname = old.slotname;
! 	insert into HSlot (
! 		    slotname,
! 		    hubname,
! 		    slotno,
! 		    slotlink
! 		) values (
! 		    new.slotname,
! 		    new.hubname,
! 		    new.slotno,
! 		    new.slotlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_hslot_bu before update
!     on HSlot for each row execute procedure tg_hslot_bu();
! -- ************************************************************
! -- * BEFORE UPDATE on PHone
! -- *	- do delete/insert instead of update if name changes
! -- ************************************************************
! create function tg_phone_bu() returns trigger as '
! begin
!     if new.slotname != old.slotname then
!         delete from PHone where slotname = old.slotname;
! 	insert into PHone (
! 		    slotname,
! 		    comment,
! 		    slotlink
! 		) values (
! 		    new.slotname,
! 		    new.comment,
! 		    new.slotlink
! 		);
!         return null;
!     end if;
!     return new;
! end;
! ' language plpgsql;
! create trigger tg_phone_bu before update
!     on PHone for each row execute procedure tg_phone_bu();
! -- ************************************************************
! -- * AFTER INSERT or UPDATE or DELETE on slot with backlink
! -- *	- Ensure that the opponent correctly points back to us
! -- ************************************************************
! create function tg_backlink_a() returns trigger as '
! declare
!     dummy	integer;
! begin
!     if tg_op = ''INSERT'' then
!         if new.backlink != '''' then
! 	    dummy := tg_backlink_set(new.backlink, new.slotname);
! 	end if;
! 	return new;
!     end if;
!     if tg_op = ''UPDATE'' then
!         if new.backlink != old.backlink then
! 	    if old.backlink != '''' then
! 	        dummy := tg_backlink_unset(old.backlink, old.slotname);
! 	    end if;
! 	    if new.backlink != '''' then
! 	        dummy := tg_backlink_set(new.backlink, new.slotname);
! 	    end if;
! 	else
! 	    if new.slotname != old.slotname and new.backlink != '''' then
! 	        dummy := tg_slotlink_set(new.backlink, new.slotname);
! 	    end if;
! 	end if;
! 	return new;
!     end if;
!     if tg_op = ''DELETE'' then
!         if old.backlink != '''' then
! 	    dummy := tg_backlink_unset(old.backlink, old.slotname);
! 	end if;
! 	return old;
!     end if;
! end;
! ' language plpgsql;
! create trigger tg_backlink_a after insert or update or delete
!     on PSlot for each row execute procedure tg_backlink_a('PS');
! create trigger tg_backlink_a after insert or update or delete
!     on WSlot for each row execute procedure tg_backlink_a('WS');
! create trigger tg_backlink_a after insert or update or delete
!     on PLine for each row execute procedure tg_backlink_a('PL');
! -- ************************************************************
! -- * Support function to set the opponents backlink field
! -- * if it does not already point to the requested slot
! -- ************************************************************
! create function tg_backlink_set(myname bpchar, blname bpchar)
! returns integer as '
! declare
!     mytype	char(2);
!     link	char(4);
!     rec		record;
! begin
!     mytype := substr(myname, 1, 2);
!     link := mytype || substr(blname, 1, 2);
!     if link = ''PLPL'' then
!         raise exception
! 		''backlink between two phone lines does not make sense'';
!     end if;
!     if link in (''PLWS'', ''WSPL'') then
!         raise exception
! 		''direct link of phone line to wall slot not permitted'';
!     end if;
!     if mytype = ''PS'' then
!         select into rec * from PSlot where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.backlink != blname then
! 	    update PSlot set backlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''WS'' then
!         select into rec * from WSlot where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.backlink != blname then
! 	    update WSlot set backlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''PL'' then
!         select into rec * from PLine where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.backlink != blname then
! 	    update PLine set backlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     raise exception ''illegal backlink beginning with %'', mytype;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * Support function to clear out the backlink field if
! -- * it still points to specific slot
! -- ************************************************************
! create function tg_backlink_unset(bpchar, bpchar)
! returns integer as '
! declare
!     myname	alias for $1;
!     blname	alias for $2;
!     mytype	char(2);
!     rec		record;
! begin
!     mytype := substr(myname, 1, 2);
!     if mytype = ''PS'' then
!         select into rec * from PSlot where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.backlink = blname then
! 	    update PSlot set backlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''WS'' then
!         select into rec * from WSlot where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.backlink = blname then
! 	    update WSlot set backlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''PL'' then
!         select into rec * from PLine where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.backlink = blname then
! 	    update PLine set backlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
! end
! ' language plpgsql;
! -- ************************************************************
! -- * AFTER INSERT or UPDATE or DELETE on slot with slotlink
! -- *	- Ensure that the opponent correctly points back to us
! -- ************************************************************
! create function tg_slotlink_a() returns trigger as '
! declare
!     dummy	integer;
! begin
!     if tg_op = ''INSERT'' then
!         if new.slotlink != '''' then
! 	    dummy := tg_slotlink_set(new.slotlink, new.slotname);
! 	end if;
! 	return new;
!     end if;
!     if tg_op = ''UPDATE'' then
!         if new.slotlink != old.slotlink then
! 	    if old.slotlink != '''' then
! 	        dummy := tg_slotlink_unset(old.slotlink, old.slotname);
! 	    end if;
! 	    if new.slotlink != '''' then
! 	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
! 	    end if;
! 	else
! 	    if new.slotname != old.slotname and new.slotlink != '''' then
! 	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
! 	    end if;
! 	end if;
! 	return new;
!     end if;
!     if tg_op = ''DELETE'' then
!         if old.slotlink != '''' then
! 	    dummy := tg_slotlink_unset(old.slotlink, old.slotname);
! 	end if;
! 	return old;
!     end if;
! end;
! ' language plpgsql;
! create trigger tg_slotlink_a after insert or update or delete
!     on PSlot for each row execute procedure tg_slotlink_a('PS');
! create trigger tg_slotlink_a after insert or update or delete
!     on WSlot for each row execute procedure tg_slotlink_a('WS');
! create trigger tg_slotlink_a after insert or update or delete
!     on IFace for each row execute procedure tg_slotlink_a('IF');
! create trigger tg_slotlink_a after insert or update or delete
!     on HSlot for each row execute procedure tg_slotlink_a('HS');
! create trigger tg_slotlink_a after insert or update or delete
!     on PHone for each row execute procedure tg_slotlink_a('PH');
! -- ************************************************************
! -- * Support function to set the opponents slotlink field
! -- * if it does not already point to the requested slot
! -- ************************************************************
! create function tg_slotlink_set(bpchar, bpchar)
! returns integer as '
! declare
!     myname	alias for $1;
!     blname	alias for $2;
!     mytype	char(2);
!     link	char(4);
!     rec		record;
! begin
!     mytype := substr(myname, 1, 2);
!     link := mytype || substr(blname, 1, 2);
!     if link = ''PHPH'' then
!         raise exception
! 		''slotlink between two phones does not make sense'';
!     end if;
!     if link in (''PHHS'', ''HSPH'') then
!         raise exception
! 		''link of phone to hub does not make sense'';
!     end if;
!     if link in (''PHIF'', ''IFPH'') then
!         raise exception
! 		''link of phone to hub does not make sense'';
!     end if;
!     if link in (''PSWS'', ''WSPS'') then
!         raise exception
! 		''slotlink from patchslot to wallslot not permitted'';
!     end if;
!     if mytype = ''PS'' then
!         select into rec * from PSlot where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.slotlink != blname then
! 	    update PSlot set slotlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''WS'' then
!         select into rec * from WSlot where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.slotlink != blname then
! 	    update WSlot set slotlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''IF'' then
!         select into rec * from IFace where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.slotlink != blname then
! 	    update IFace set slotlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''HS'' then
!         select into rec * from HSlot where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.slotlink != blname then
! 	    update HSlot set slotlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''PH'' then
!         select into rec * from PHone where slotname = myname;
! 	if not found then
! 	    raise exception ''% does not exist'', myname;
! 	end if;
! 	if rec.slotlink != blname then
! 	    update PHone set slotlink = blname where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     raise exception ''illegal slotlink beginning with %'', mytype;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * Support function to clear out the slotlink field if
! -- * it still points to specific slot
! -- ************************************************************
! create function tg_slotlink_unset(bpchar, bpchar)
! returns integer as '
! declare
!     myname	alias for $1;
!     blname	alias for $2;
!     mytype	char(2);
!     rec		record;
! begin
!     mytype := substr(myname, 1, 2);
!     if mytype = ''PS'' then
!         select into rec * from PSlot where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.slotlink = blname then
! 	    update PSlot set slotlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''WS'' then
!         select into rec * from WSlot where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.slotlink = blname then
! 	    update WSlot set slotlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''IF'' then
!         select into rec * from IFace where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.slotlink = blname then
! 	    update IFace set slotlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''HS'' then
!         select into rec * from HSlot where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.slotlink = blname then
! 	    update HSlot set slotlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
!     if mytype = ''PH'' then
!         select into rec * from PHone where slotname = myname;
! 	if not found then
! 	    return 0;
! 	end if;
! 	if rec.slotlink = blname then
! 	    update PHone set slotlink = '''' where slotname = myname;
! 	end if;
! 	return 0;
!     end if;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * Describe the backside of a patchfield slot
! -- ************************************************************
! create function pslot_backlink_view(bpchar)
! returns text as '
! <<outer>>
! declare
!     rec		record;
!     bltype	char(2);
!     retval	text;
! begin
!     select into rec * from PSlot where slotname = $1;
!     if not found then
!         return '''';
!     end if;
!     if rec.backlink = '''' then
!         return ''-'';
!     end if;
!     bltype := substr(rec.backlink, 1, 2);
!     if bltype = ''PL'' then
!         declare
! 	    rec		record;
! 	begin
! 	    select into rec * from PLine where slotname = "outer".rec.backlink;
! 	    retval := ''Phone line '' || trim(rec.phonenumber);
! 	    if rec.comment != '''' then
! 	        retval := retval || '' ('';
! 		retval := retval || rec.comment;
! 		retval := retval || '')'';
! 	    end if;
! 	    return retval;
! 	end;
!     end if;
!     if bltype = ''WS'' then
!         select into rec * from WSlot where slotname = rec.backlink;
! 	retval := trim(rec.slotname) || '' in room '';
! 	retval := retval || trim(rec.roomno);
! 	retval := retval || '' -> '';
! 	return retval || wslot_slotlink_view(rec.slotname);
!     end if;
!     return rec.backlink;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * Describe the front of a patchfield slot
! -- ************************************************************
! create function pslot_slotlink_view(bpchar)
! returns text as '
! declare
!     psrec	record;
!     sltype	char(2);
!     retval	text;
! begin
!     select into psrec * from PSlot where slotname = $1;
!     if not found then
!         return '''';
!     end if;
!     if psrec.slotlink = '''' then
!         return ''-'';
!     end if;
!     sltype := substr(psrec.slotlink, 1, 2);
!     if sltype = ''PS'' then
! 	retval := trim(psrec.slotlink) || '' -> '';
! 	return retval || pslot_backlink_view(psrec.slotlink);
!     end if;
!     if sltype = ''HS'' then
!         retval := comment from Hub H, HSlot HS
! 			where HS.slotname = psrec.slotlink
! 			  and H.name = HS.hubname;
!         retval := retval || '' slot '';
! 	retval := retval || slotno::text from HSlot
! 			where slotname = psrec.slotlink;
! 	return retval;
!     end if;
!     return psrec.slotlink;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * Describe the front of a wall connector slot
! -- ************************************************************
! create function wslot_slotlink_view(bpchar)
! returns text as '
! declare
!     rec		record;
!     sltype	char(2);
!     retval	text;
! begin
!     select into rec * from WSlot where slotname = $1;
!     if not found then
!         return '''';
!     end if;
!     if rec.slotlink = '''' then
!         return ''-'';
!     end if;
!     sltype := substr(rec.slotlink, 1, 2);
!     if sltype = ''PH'' then
!         select into rec * from PHone where slotname = rec.slotlink;
! 	retval := ''Phone '' || trim(rec.slotname);
! 	if rec.comment != '''' then
! 	    retval := retval || '' ('';
! 	    retval := retval || rec.comment;
! 	    retval := retval || '')'';
! 	end if;
! 	return retval;
!     end if;
!     if sltype = ''IF'' then
! 	declare
! 	    syrow	System%RowType;
! 	    ifrow	IFace%ROWTYPE;
!         begin
! 	    select into ifrow * from IFace where slotname = rec.slotlink;
! 	    select into syrow * from System where name = ifrow.sysname;
! 	    retval := syrow.name || '' IF '';
! 	    retval := retval || ifrow.ifname;
! 	    if syrow.comment != '''' then
! 	        retval := retval || '' ('';
! 		retval := retval || syrow.comment;
! 		retval := retval || '')'';
! 	    end if;
! 	    return retval;
! 	end;
!     end if;
!     return rec.slotlink;
! end;
! ' language plpgsql;
! -- ************************************************************
! -- * View of a patchfield describing backside and patches
! -- ************************************************************
! create view Pfield_v1 as select PF.pfname, PF.slotname,
! 	pslot_backlink_view(PF.slotname) as backside,
! 	pslot_slotlink_view(PF.slotname) as patch
!     from PSlot PF;
! --
! -- First we build the house - so we create the rooms
! --
! insert into Room values ('001', 'Entrance');
! insert into Room values ('002', 'Office');
! insert into Room values ('003', 'Office');
! insert into Room values ('004', 'Technical');
! insert into Room values ('101', 'Office');
! insert into Room values ('102', 'Conference');
! insert into Room values ('103', 'Restroom');
! insert into Room values ('104', 'Technical');
! insert into Room values ('105', 'Office');
! insert into Room values ('106', 'Office');
! --
! -- Second we install the wall connectors
! --
! insert into WSlot values ('WS.001.1a', '001', '', '');
! insert into WSlot values ('WS.001.1b', '001', '', '');
! insert into WSlot values ('WS.001.2a', '001', '', '');
! insert into WSlot values ('WS.001.2b', '001', '', '');
! insert into WSlot values ('WS.001.3a', '001', '', '');
! insert into WSlot values ('WS.001.3b', '001', '', '');
! insert into WSlot values ('WS.002.1a', '002', '', '');
! insert into WSlot values ('WS.002.1b', '002', '', '');
! insert into WSlot values ('WS.002.2a', '002', '', '');
! insert into WSlot values ('WS.002.2b', '002', '', '');
! insert into WSlot values ('WS.002.3a', '002', '', '');
! insert into WSlot values ('WS.002.3b', '002', '', '');
! insert into WSlot values ('WS.003.1a', '003', '', '');
! insert into WSlot values ('WS.003.1b', '003', '', '');
! insert into WSlot values ('WS.003.2a', '003', '', '');
! insert into WSlot values ('WS.003.2b', '003', '', '');
! insert into WSlot values ('WS.003.3a', '003', '', '');
! insert into WSlot values ('WS.003.3b', '003', '', '');
! insert into WSlot values ('WS.101.1a', '101', '', '');
! insert into WSlot values ('WS.101.1b', '101', '', '');
! insert into WSlot values ('WS.101.2a', '101', '', '');
! insert into WSlot values ('WS.101.2b', '101', '', '');
! insert into WSlot values ('WS.101.3a', '101', '', '');
! insert into WSlot values ('WS.101.3b', '101', '', '');
! insert into WSlot values ('WS.102.1a', '102', '', '');
! insert into WSlot values ('WS.102.1b', '102', '', '');
! insert into WSlot values ('WS.102.2a', '102', '', '');
! insert into WSlot values ('WS.102.2b', '102', '', '');
! insert into WSlot values ('WS.102.3a', '102', '', '');
! insert into WSlot values ('WS.102.3b', '102', '', '');
! insert into WSlot values ('WS.105.1a', '105', '', '');
! insert into WSlot values ('WS.105.1b', '105', '', '');
! insert into WSlot values ('WS.105.2a', '105', '', '');
! insert into WSlot values ('WS.105.2b', '105', '', '');
! insert into WSlot values ('WS.105.3a', '105', '', '');
! insert into WSlot values ('WS.105.3b', '105', '', '');
! insert into WSlot values ('WS.106.1a', '106', '', '');
! insert into WSlot values ('WS.106.1b', '106', '', '');
! insert into WSlot values ('WS.106.2a', '106', '', '');
! insert into WSlot values ('WS.106.2b', '106', '', '');
! insert into WSlot values ('WS.106.3a', '106', '', '');
! insert into WSlot values ('WS.106.3b', '106', '', '');
! --
! -- Now create the patch fields and their slots
! --
! insert into PField values ('PF0_1', 'Wallslots basement');
! --
! -- The cables for these will be made later, so they are unconnected for now
! --
! insert into PSlot values ('PS.base.a1', 'PF0_1', '', '');
! insert into PSlot values ('PS.base.a2', 'PF0_1', '', '');
! insert into PSlot values ('PS.base.a3', 'PF0_1', '', '');
! insert into PSlot values ('PS.base.a4', 'PF0_1', '', '');
! insert into PSlot values ('PS.base.a5', 'PF0_1', '', '');
! insert into PSlot values ('PS.base.a6', 'PF0_1', '', '');
! --
! -- These are already wired to the wall connectors
! --
! insert into PSlot values ('PS.base.b1', 'PF0_1', '', 'WS.002.1a');
! insert into PSlot values ('PS.base.b2', 'PF0_1', '', 'WS.002.1b');
! insert into PSlot values ('PS.base.b3', 'PF0_1', '', 'WS.002.2a');
! insert into PSlot values ('PS.base.b4', 'PF0_1', '', 'WS.002.2b');
! insert into PSlot values ('PS.base.b5', 'PF0_1', '', 'WS.002.3a');
! insert into PSlot values ('PS.base.b6', 'PF0_1', '', 'WS.002.3b');
! insert into PSlot values ('PS.base.c1', 'PF0_1', '', 'WS.003.1a');
! insert into PSlot values ('PS.base.c2', 'PF0_1', '', 'WS.003.1b');
! insert into PSlot values ('PS.base.c3', 'PF0_1', '', 'WS.003.2a');
! insert into PSlot values ('PS.base.c4', 'PF0_1', '', 'WS.003.2b');
! insert into PSlot values ('PS.base.c5', 'PF0_1', '', 'WS.003.3a');
! insert into PSlot values ('PS.base.c6', 'PF0_1', '', 'WS.003.3b');
! --
! -- This patchfield will be renamed later into PF0_2 - so its
! -- slots references in pfname should follow
! --
! insert into PField values ('PF0_X', 'Phonelines basement');
! insert into PSlot values ('PS.base.ta1', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.ta2', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.ta3', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.ta4', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.ta5', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.ta6', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb1', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb2', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb3', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb4', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb5', 'PF0_X', '', '');
! insert into PSlot values ('PS.base.tb6', 'PF0_X', '', '');
! insert into PField values ('PF1_1', 'Wallslots first floor');
! insert into PSlot values ('PS.first.a1', 'PF1_1', '', 'WS.101.1a');
! insert into PSlot values ('PS.first.a2', 'PF1_1', '', 'WS.101.1b');
! insert into PSlot values ('PS.first.a3', 'PF1_1', '', 'WS.101.2a');
! insert into PSlot values ('PS.first.a4', 'PF1_1', '', 'WS.101.2b');
! insert into PSlot values ('PS.first.a5', 'PF1_1', '', 'WS.101.3a');
! insert into PSlot values ('PS.first.a6', 'PF1_1', '', 'WS.101.3b');
! insert into PSlot values ('PS.first.b1', 'PF1_1', '', 'WS.102.1a');
! insert into PSlot values ('PS.first.b2', 'PF1_1', '', 'WS.102.1b');
! insert into PSlot values ('PS.first.b3', 'PF1_1', '', 'WS.102.2a');
! insert into PSlot values ('PS.first.b4', 'PF1_1', '', 'WS.102.2b');
! insert into PSlot values ('PS.first.b5', 'PF1_1', '', 'WS.102.3a');
! insert into PSlot values ('PS.first.b6', 'PF1_1', '', 'WS.102.3b');
! insert into PSlot values ('PS.first.c1', 'PF1_1', '', 'WS.105.1a');
! insert into PSlot values ('PS.first.c2', 'PF1_1', '', 'WS.105.1b');
! insert into PSlot values ('PS.first.c3', 'PF1_1', '', 'WS.105.2a');
! insert into PSlot values ('PS.first.c4', 'PF1_1', '', 'WS.105.2b');
! insert into PSlot values ('PS.first.c5', 'PF1_1', '', 'WS.105.3a');
! insert into PSlot values ('PS.first.c6', 'PF1_1', '', 'WS.105.3b');
! insert into PSlot values ('PS.first.d1', 'PF1_1', '', 'WS.106.1a');
! insert into PSlot values ('PS.first.d2', 'PF1_1', '', 'WS.106.1b');
! insert into PSlot values ('PS.first.d3', 'PF1_1', '', 'WS.106.2a');
! insert into PSlot values ('PS.first.d4', 'PF1_1', '', 'WS.106.2b');
! insert into PSlot values ('PS.first.d5', 'PF1_1', '', 'WS.106.3a');
! insert into PSlot values ('PS.first.d6', 'PF1_1', '', 'WS.106.3b');
! --
! -- Now we wire the wall connectors 1a-2a in room 001 to the
! -- patchfield. In the second update we make an error, and
! -- correct it after
! --
! update PSlot set backlink = 'WS.001.1a' where slotname = 'PS.base.a1';
! update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a3';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a3          
!  WS.001.2a            | 001      |                      |                     
!  WS.001.2b            | 001      |                      |                     
!  WS.001.3a            | 001      |                      |                     
!  WS.001.3b            | 001      |                      |                     
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      |                     
!  PS.base.a3           | PF0_1  |                      | WS.001.1b           
!  PS.base.a4           | PF0_1  |                      |                     
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
! (6 rows)
! 
! update PSlot set backlink = 'WS.001.2a' where slotname = 'PS.base.a3';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      |                     
!  WS.001.3a            | 001      |                      |                     
!  WS.001.3b            | 001      |                      |                     
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      |                     
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
! (6 rows)
! 
! update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a2';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      |                     
!  WS.001.3a            | 001      |                      |                     
!  WS.001.3b            | 001      |                      |                     
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      | WS.001.1b           
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
! (6 rows)
! 
! --
! -- Same procedure for 2b-3b but this time updating the WSlot instead
! -- of the PSlot. Due to the triggers the result is the same:
! -- WSlot and corresponding PSlot point to each other.
! --
! update WSlot set backlink = 'PS.base.a4' where slotname = 'WS.001.2b';
! update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3a';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      | PS.base.a6          
!  WS.001.3b            | 001      |                      |                     
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      | WS.001.1b           
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      | WS.001.3a           
! (6 rows)
! 
! update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      |                     
!  WS.001.3b            | 001      |                      | PS.base.a6          
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      | WS.001.1b           
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
! (6 rows)
! 
! update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
! select * from WSlot where roomno = '001' order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      | PS.base.a5          
!  WS.001.3b            | 001      |                      | PS.base.a6          
! (6 rows)
! 
! select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      | WS.001.1b           
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      | WS.001.3a           
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
! (6 rows)
! 
! insert into PField values ('PF1_2', 'Phonelines first floor');
! insert into PSlot values ('PS.first.ta1', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.ta2', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.ta3', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.ta4', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.ta5', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.ta6', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb1', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb2', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb3', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb4', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb5', 'PF1_2', '', '');
! insert into PSlot values ('PS.first.tb6', 'PF1_2', '', '');
! --
! -- Fix the wrong name for patchfield PF0_2
! --
! update PField set name = 'PF0_2' where name = 'PF0_X';
! select * from PSlot order by slotname;
!        slotname       | pfname |       slotlink       |       backlink       
! ----------------------+--------+----------------------+----------------------
!  PS.base.a1           | PF0_1  |                      | WS.001.1a           
!  PS.base.a2           | PF0_1  |                      | WS.001.1b           
!  PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      | WS.001.3a           
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
!  PS.base.b1           | PF0_1  |                      | WS.002.1a           
!  PS.base.b2           | PF0_1  |                      | WS.002.1b           
!  PS.base.b3           | PF0_1  |                      | WS.002.2a           
!  PS.base.b4           | PF0_1  |                      | WS.002.2b           
!  PS.base.b5           | PF0_1  |                      | WS.002.3a           
!  PS.base.b6           | PF0_1  |                      | WS.002.3b           
!  PS.base.c1           | PF0_1  |                      | WS.003.1a           
!  PS.base.c2           | PF0_1  |                      | WS.003.1b           
!  PS.base.c3           | PF0_1  |                      | WS.003.2a           
!  PS.base.c4           | PF0_1  |                      | WS.003.2b           
!  PS.base.c5           | PF0_1  |                      | WS.003.3a           
!  PS.base.c6           | PF0_1  |                      | WS.003.3b           
!  PS.base.ta1          | PF0_2  |                      |                     
!  PS.base.ta2          | PF0_2  |                      |                     
!  PS.base.ta3          | PF0_2  |                      |                     
!  PS.base.ta4          | PF0_2  |                      |                     
!  PS.base.ta5          | PF0_2  |                      |                     
!  PS.base.ta6          | PF0_2  |                      |                     
!  PS.base.tb1          | PF0_2  |                      |                     
!  PS.base.tb2          | PF0_2  |                      |                     
!  PS.base.tb3          | PF0_2  |                      |                     
!  PS.base.tb4          | PF0_2  |                      |                     
!  PS.base.tb5          | PF0_2  |                      |                     
!  PS.base.tb6          | PF0_2  |                      |                     
!  PS.first.a1          | PF1_1  |                      | WS.101.1a           
!  PS.first.a2          | PF1_1  |                      | WS.101.1b           
!  PS.first.a3          | PF1_1  |                      | WS.101.2a           
!  PS.first.a4          | PF1_1  |                      | WS.101.2b           
!  PS.first.a5          | PF1_1  |                      | WS.101.3a           
!  PS.first.a6          | PF1_1  |                      | WS.101.3b           
!  PS.first.b1          | PF1_1  |                      | WS.102.1a           
!  PS.first.b2          | PF1_1  |                      | WS.102.1b           
!  PS.first.b3          | PF1_1  |                      | WS.102.2a           
!  PS.first.b4          | PF1_1  |                      | WS.102.2b           
!  PS.first.b5          | PF1_1  |                      | WS.102.3a           
!  PS.first.b6          | PF1_1  |                      | WS.102.3b           
!  PS.first.c1          | PF1_1  |                      | WS.105.1a           
!  PS.first.c2          | PF1_1  |                      | WS.105.1b           
!  PS.first.c3          | PF1_1  |                      | WS.105.2a           
!  PS.first.c4          | PF1_1  |                      | WS.105.2b           
!  PS.first.c5          | PF1_1  |                      | WS.105.3a           
!  PS.first.c6          | PF1_1  |                      | WS.105.3b           
!  PS.first.d1          | PF1_1  |                      | WS.106.1a           
!  PS.first.d2          | PF1_1  |                      | WS.106.1b           
!  PS.first.d3          | PF1_1  |                      | WS.106.2a           
!  PS.first.d4          | PF1_1  |                      | WS.106.2b           
!  PS.first.d5          | PF1_1  |                      | WS.106.3a           
!  PS.first.d6          | PF1_1  |                      | WS.106.3b           
!  PS.first.ta1         | PF1_2  |                      |                     
!  PS.first.ta2         | PF1_2  |                      |                     
!  PS.first.ta3         | PF1_2  |                      |                     
!  PS.first.ta4         | PF1_2  |                      |                     
!  PS.first.ta5         | PF1_2  |                      |                     
!  PS.first.ta6         | PF1_2  |                      |                     
!  PS.first.tb1         | PF1_2  |                      |                     
!  PS.first.tb2         | PF1_2  |                      |                     
!  PS.first.tb3         | PF1_2  |                      |                     
!  PS.first.tb4         | PF1_2  |                      |                     
!  PS.first.tb5         | PF1_2  |                      |                     
!  PS.first.tb6         | PF1_2  |                      |                     
! (66 rows)
! 
! select * from WSlot order by slotname;
!        slotname       |  roomno  |       slotlink       |       backlink       
! ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
!  WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      | PS.base.a5          
!  WS.001.3b            | 001      |                      | PS.base.a6          
!  WS.002.1a            | 002      |                      | PS.base.b1          
!  WS.002.1b            | 002      |                      | PS.base.b2          
!  WS.002.2a            | 002      |                      | PS.base.b3          
!  WS.002.2b            | 002      |                      | PS.base.b4          
!  WS.002.3a            | 002      |                      | PS.base.b5          
!  WS.002.3b            | 002      |                      | PS.base.b6          
!  WS.003.1a            | 003      |                      | PS.base.c1          
!  WS.003.1b            | 003      |                      | PS.base.c2          
!  WS.003.2a            | 003      |                      | PS.base.c3          
!  WS.003.2b            | 003      |                      | PS.base.c4          
!  WS.003.3a            | 003      |                      | PS.base.c5          
!  WS.003.3b            | 003      |                      | PS.base.c6          
!  WS.101.1a            | 101      |                      | PS.first.a1         
!  WS.101.1b            | 101      |                      | PS.first.a2         
!  WS.101.2a            | 101      |                      | PS.first.a3         
!  WS.101.2b            | 101      |                      | PS.first.a4         
!  WS.101.3a            | 101      |                      | PS.first.a5         
!  WS.101.3b            | 101      |                      | PS.first.a6         
!  WS.102.1a            | 102      |                      | PS.first.b1         
!  WS.102.1b            | 102      |                      | PS.first.b2         
!  WS.102.2a            | 102      |                      | PS.first.b3         
!  WS.102.2b            | 102      |                      | PS.first.b4         
!  WS.102.3a            | 102      |                      | PS.first.b5         
!  WS.102.3b            | 102      |                      | PS.first.b6         
!  WS.105.1a            | 105      |                      | PS.first.c1         
!  WS.105.1b            | 105      |                      | PS.first.c2         
!  WS.105.2a            | 105      |                      | PS.first.c3         
!  WS.105.2b            | 105      |                      | PS.first.c4         
!  WS.105.3a            | 105      |                      | PS.first.c5         
!  WS.105.3b            | 105      |                      | PS.first.c6         
!  WS.106.1a            | 106      |                      | PS.first.d1         
!  WS.106.1b            | 106      |                      | PS.first.d2         
!  WS.106.2a            | 106      |                      | PS.first.d3         
!  WS.106.2b            | 106      |                      | PS.first.d4         
!  WS.106.3a            | 106      |                      | PS.first.d5         
!  WS.106.3b            | 106      |                      | PS.first.d6         
! (42 rows)
! 
! --
! -- Install the central phone system and create the phone numbers.
! -- They are weired on insert to the patchfields. Again the
! -- triggers automatically tell the PSlots to update their
! -- backlink field.
! --
! insert into PLine values ('PL.001', '-0', 'Central call', 'PS.base.ta1');
! insert into PLine values ('PL.002', '-101', '', 'PS.base.ta2');
! insert into PLine values ('PL.003', '-102', '', 'PS.base.ta3');
! insert into PLine values ('PL.004', '-103', '', 'PS.base.ta5');
! insert into PLine values ('PL.005', '-104', '', 'PS.base.ta6');
! insert into PLine values ('PL.006', '-106', '', 'PS.base.tb2');
! insert into PLine values ('PL.007', '-108', '', 'PS.base.tb3');
! insert into PLine values ('PL.008', '-109', '', 'PS.base.tb4');
! insert into PLine values ('PL.009', '-121', '', 'PS.base.tb5');
! insert into PLine values ('PL.010', '-122', '', 'PS.base.tb6');
! insert into PLine values ('PL.015', '-134', '', 'PS.first.ta1');
! insert into PLine values ('PL.016', '-137', '', 'PS.first.ta3');
! insert into PLine values ('PL.017', '-139', '', 'PS.first.ta4');
! insert into PLine values ('PL.018', '-362', '', 'PS.first.tb1');
! insert into PLine values ('PL.019', '-363', '', 'PS.first.tb2');
! insert into PLine values ('PL.020', '-364', '', 'PS.first.tb3');
! insert into PLine values ('PL.021', '-365', '', 'PS.first.tb5');
! insert into PLine values ('PL.022', '-367', '', 'PS.first.tb6');
! insert into PLine values ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
! insert into PLine values ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
! --
! -- Buy some phones, plug them into the wall and patch the
! -- phone lines to the corresponding patchfield slots.
! --
! insert into PHone values ('PH.hc001', 'Hicom standard', 'WS.001.1a');
! update PSlot set slotlink = 'PS.base.ta1' where slotname = 'PS.base.a1';
! insert into PHone values ('PH.hc002', 'Hicom standard', 'WS.002.1a');
! update PSlot set slotlink = 'PS.base.ta5' where slotname = 'PS.base.b1';
! insert into PHone values ('PH.hc003', 'Hicom standard', 'WS.002.2a');
! update PSlot set slotlink = 'PS.base.tb2' where slotname = 'PS.base.b3';
! insert into PHone values ('PH.fax001', 'Canon fax', 'WS.001.2a');
! update PSlot set slotlink = 'PS.base.ta2' where slotname = 'PS.base.a3';
! --
! -- Install a hub at one of the patchfields, plug a computers
! -- ethernet interface into the wall and patch it to the hub.
! --
! insert into Hub values ('base.hub1', 'Patchfield PF0_1 hub', 16);
! insert into System values ('orion', 'PC');
! insert into IFace values ('IF', 'orion', 'eth0', 'WS.002.1b');
! update PSlot set slotlink = 'HS.base.hub1.1' where slotname = 'PS.base.b2';
! --
! -- Now we take a look at the patchfield
! --
! select * from PField_v1 where pfname = 'PF0_1' order by slotname;
!  pfname |       slotname       |                         backside                         |                     patch                     
! --------+----------------------+----------------------------------------------------------+-----------------------------------------------
!  PF0_1  | PS.base.a1           | WS.001.1a in room 001 -> Phone PH.hc001 (Hicom standard) | PS.base.ta1 -> Phone line -0 (Central call)
!  PF0_1  | PS.base.a2           | WS.001.1b in room 001 -> -                               | -
!  PF0_1  | PS.base.a3           | WS.001.2a in room 001 -> Phone PH.fax001 (Canon fax)     | PS.base.ta2 -> Phone line -501 (Fax entrance)
!  PF0_1  | PS.base.a4           | WS.001.2b in room 001 -> -                               | -
!  PF0_1  | PS.base.a5           | WS.001.3a in room 001 -> -                               | -
!  PF0_1  | PS.base.a6           | WS.001.3b in room 001 -> -                               | -
!  PF0_1  | PS.base.b1           | WS.002.1a in room 002 -> Phone PH.hc002 (Hicom standard) | PS.base.ta5 -> Phone line -103
!  PF0_1  | PS.base.b2           | WS.002.1b in room 002 -> orion IF eth0 (PC)              | Patchfield PF0_1 hub slot 1
!  PF0_1  | PS.base.b3           | WS.002.2a in room 002 -> Phone PH.hc003 (Hicom standard) | PS.base.tb2 -> Phone line -106
!  PF0_1  | PS.base.b4           | WS.002.2b in room 002 -> -                               | -
!  PF0_1  | PS.base.b5           | WS.002.3a in room 002 -> -                               | -
!  PF0_1  | PS.base.b6           | WS.002.3b in room 002 -> -                               | -
!  PF0_1  | PS.base.c1           | WS.003.1a in room 003 -> -                               | -
!  PF0_1  | PS.base.c2           | WS.003.1b in room 003 -> -                               | -
!  PF0_1  | PS.base.c3           | WS.003.2a in room 003 -> -                               | -
!  PF0_1  | PS.base.c4           | WS.003.2b in room 003 -> -                               | -
!  PF0_1  | PS.base.c5           | WS.003.3a in room 003 -> -                               | -
!  PF0_1  | PS.base.c6           | WS.003.3b in room 003 -> -                               | -
! (18 rows)
! 
! select * from PField_v1 where pfname = 'PF0_2' order by slotname;
!  pfname |       slotname       |            backside            |                                 patch                                  
! --------+----------------------+--------------------------------+------------------------------------------------------------------------
!  PF0_2  | PS.base.ta1          | Phone line -0 (Central call)   | PS.base.a1 -> WS.001.1a in room 001 -> Phone PH.hc001 (Hicom standard)
!  PF0_2  | PS.base.ta2          | Phone line -501 (Fax entrance) | PS.base.a3 -> WS.001.2a in room 001 -> Phone PH.fax001 (Canon fax)
!  PF0_2  | PS.base.ta3          | Phone line -102                | -
!  PF0_2  | PS.base.ta4          | -                              | -
!  PF0_2  | PS.base.ta5          | Phone line -103                | PS.base.b1 -> WS.002.1a in room 002 -> Phone PH.hc002 (Hicom standard)
!  PF0_2  | PS.base.ta6          | Phone line -104                | -
!  PF0_2  | PS.base.tb1          | -                              | -
!  PF0_2  | PS.base.tb2          | Phone line -106                | PS.base.b3 -> WS.002.2a in room 002 -> Phone PH.hc003 (Hicom standard)
!  PF0_2  | PS.base.tb3          | Phone line -108                | -
!  PF0_2  | PS.base.tb4          | Phone line -109                | -
!  PF0_2  | PS.base.tb5          | Phone line -121                | -
!  PF0_2  | PS.base.tb6          | Phone line -122                | -
! (12 rows)
! 
! --
! -- Finally we want errors
! --
! insert into PField values ('PF1_1', 'should fail due to unique index');
! ERROR:  duplicate key value violates unique constraint "pfield_name"
! DETAIL:  Key (name)=(PF1_1) already exists.
! update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
! ERROR:  WS.not.there         does not exist
! CONTEXT:  PL/pgSQL function tg_backlink_a() line 17 at assignment
! update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
! ERROR:  illegal backlink beginning with XX
! CONTEXT:  PL/pgSQL function tg_backlink_a() line 17 at assignment
! update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
! ERROR:  PS.not.there         does not exist
! CONTEXT:  PL/pgSQL function tg_slotlink_a() line 17 at assignment
! update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
! ERROR:  illegal slotlink beginning with XX
! CONTEXT:  PL/pgSQL function tg_slotlink_a() line 17 at assignment
! insert into HSlot values ('HS', 'base.hub1', 1, '');
! ERROR:  duplicate key value violates unique constraint "hslot_name"
! DETAIL:  Key (slotname)=(HS.base.hub1.1      ) already exists.
! insert into HSlot values ('HS', 'base.hub1', 20, '');
! ERROR:  no manual manipulation of HSlot
! delete from HSlot;
! ERROR:  no manual manipulation of HSlot
! insert into IFace values ('IF', 'notthere', 'eth0', '');
! ERROR:  system "notthere" does not exist
! insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
! ERROR:  IFace slotname "IF.orion.ethernet_interface_name_too_long" too long (20 char max)
! --
! -- The following tests are unrelated to the scenario outlined above;
! -- they merely exercise specific parts of PL/pgSQL
! --
! --
! -- Test recursion, per bug report 7-Sep-01
! --
! CREATE FUNCTION recursion_test(int,int) RETURNS text AS '
! DECLARE rslt text;
! BEGIN
!     IF $1 <= 0 THEN
!         rslt = CAST($2 AS TEXT);
!     ELSE
!         rslt = CAST($1 AS TEXT) || '','' || recursion_test($1 - 1, $2);
!     END IF;
!     RETURN rslt;
! END;' LANGUAGE plpgsql;
! SELECT recursion_test(4,3);
!  recursion_test 
! ----------------
!  4,3,2,1,3
! (1 row)
! 
! --
! -- Test the FOUND magic variable
! --
! CREATE TABLE found_test_tbl (a int);
! create function test_found()
!   returns boolean as '
!   declare
!   begin
!   insert into found_test_tbl values (1);
!   if FOUND then
!      insert into found_test_tbl values (2);
!   end if;
! 
!   update found_test_tbl set a = 100 where a = 1;
!   if FOUND then
!     insert into found_test_tbl values (3);
!   end if;
! 
!   delete from found_test_tbl where a = 9999; -- matches no rows
!   if not FOUND then
!     insert into found_test_tbl values (4);
!   end if;
! 
!   for i in 1 .. 10 loop
!     -- no need to do anything
!   end loop;
!   if FOUND then
!     insert into found_test_tbl values (5);
!   end if;
! 
!   -- never executes the loop
!   for i in 2 .. 1 loop
!     -- no need to do anything
!   end loop;
!   if not FOUND then
!     insert into found_test_tbl values (6);
!   end if;
!   return true;
!   end;' language plpgsql;
! select test_found();
!  test_found 
! ------------
!  t
! (1 row)
! 
! select * from found_test_tbl;
!   a  
! -----
!    2
!  100
!    3
!    4
!    5
!    6
! (6 rows)
! 
! --
! -- Test set-returning functions for PL/pgSQL
! --
! create function test_table_func_rec() returns setof found_test_tbl as '
! DECLARE
! 	rec RECORD;
! BEGIN
! 	FOR rec IN select * from found_test_tbl LOOP
! 		RETURN NEXT rec;
! 	END LOOP;
! 	RETURN;
! END;' language plpgsql;
! select * from test_table_func_rec();
!   a  
! -----
!    2
!  100
!    3
!    4
!    5
!    6
! (6 rows)
! 
! create function test_table_func_row() returns setof found_test_tbl as '
! DECLARE
! 	row found_test_tbl%ROWTYPE;
! BEGIN
! 	FOR row IN select * from found_test_tbl LOOP
! 		RETURN NEXT row;
! 	END LOOP;
! 	RETURN;
! END;' language plpgsql;
! select * from test_table_func_row();
!   a  
! -----
!    2
!  100
!    3
!    4
!    5
!    6
! (6 rows)
! 
! create function test_ret_set_scalar(int,int) returns setof int as '
! DECLARE
! 	i int;
! BEGIN
! 	FOR i IN $1 .. $2 LOOP
! 		RETURN NEXT i + 1;
! 	END LOOP;
! 	RETURN;
! END;' language plpgsql;
! select * from test_ret_set_scalar(1,10);
!  test_ret_set_scalar 
! ---------------------
!                    2
!                    3
!                    4
!                    5
!                    6
!                    7
!                    8
!                    9
!                   10
!                   11
! (10 rows)
! 
! create function test_ret_set_rec_dyn(int) returns setof record as '
! DECLARE
! 	retval RECORD;
! BEGIN
! 	IF $1 > 10 THEN
! 		SELECT INTO retval 5, 10, 15;
! 		RETURN NEXT retval;
! 		RETURN NEXT retval;
! 	ELSE
! 		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
! 		RETURN NEXT retval;
! 		RETURN NEXT retval;
! 	END IF;
! 	RETURN;
! END;' language plpgsql;
! SELECT * FROM test_ret_set_rec_dyn(1500) AS (a int, b int, c int);
!  a | b  | c  
! ---+----+----
!  5 | 10 | 15
!  5 | 10 | 15
! (2 rows)
! 
! SELECT * FROM test_ret_set_rec_dyn(5) AS (a int, b numeric, c text);
!  a  | b |  c  
! ----+---+-----
!  50 | 5 | xxx
!  50 | 5 | xxx
! (2 rows)
! 
! create function test_ret_rec_dyn(int) returns record as '
! DECLARE
! 	retval RECORD;
! BEGIN
! 	IF $1 > 10 THEN
! 		SELECT INTO retval 5, 10, 15;
! 		RETURN retval;
! 	ELSE
! 		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
! 		RETURN retval;
! 	END IF;
! END;' language plpgsql;
! SELECT * FROM test_ret_rec_dyn(1500) AS (a int, b int, c int);
!  a | b  | c  
! ---+----+----
!  5 | 10 | 15
! (1 row)
! 
! SELECT * FROM test_ret_rec_dyn(5) AS (a int, b numeric, c text);
!  a  | b |  c  
! ----+---+-----
!  50 | 5 | xxx
! (1 row)
! 
! --
! -- Test handling of OUT parameters, including polymorphic cases.
! -- Note that RETURN is optional with OUT params; we try both ways.
! --
! -- wrong way to do it:
! create function f1(in i int, out j int) returns int as $$
! begin
!   return i+1;
! end$$ language plpgsql;
! ERROR:  RETURN cannot have a parameter in function with OUT parameters
! LINE 3:   return i+1;
!                  ^
! create function f1(in i int, out j int) as $$
! begin
!   j := i+1;
!   return;
! end$$ language plpgsql;
! select f1(42);
!  f1 
! ----
!  43
! (1 row)
! 
! select * from f1(42);
!  j  
! ----
!  43
! (1 row)
! 
! create or replace function f1(inout i int) as $$
! begin
!   i := i+1;
! end$$ language plpgsql;
! select f1(42);
!  f1 
! ----
!  43
! (1 row)
! 
! select * from f1(42);
!  i  
! ----
!  43
! (1 row)
! 
! drop function f1(int);
! create function f1(in i int, out j int) returns setof int as $$
! begin
!   j := i+1;
!   return next;
!   j := i+2;
!   return next;
!   return;
! end$$ language plpgsql;
! select * from f1(42);
!  j  
! ----
!  43
!  44
! (2 rows)
! 
! drop function f1(int);
! create function f1(in i int, out j int, out k text) as $$
! begin
!   j := i;
!   j := j+1;
!   k := 'foo';
! end$$ language plpgsql;
! select f1(42);
!     f1    
! ----------
!  (43,foo)
! (1 row)
! 
! select * from f1(42);
!  j  |  k  
! ----+-----
!  43 | foo
! (1 row)
! 
! drop function f1(int);
! create function f1(in i int, out j int, out k text) returns setof record as $$
! begin
!   j := i+1;
!   k := 'foo';
!   return next;
!   j := j+1;
!   k := 'foot';
!   return next;
! end$$ language plpgsql;
! select * from f1(42);
!  j  |  k   
! ----+------
!  43 | foo
!  44 | foot
! (2 rows)
! 
! drop function f1(int);
! create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$
! begin
!   j := i;
!   k := array[j,j];
!   return;
! end$$ language plpgsql;
! select * from duplic(42);
!  j  |    k    
! ----+---------
!  42 | {42,42}
! (1 row)
! 
! select * from duplic('foo'::text);
!   j  |     k     
! -----+-----------
!  foo | {foo,foo}
! (1 row)
! 
! drop function duplic(anyelement);
! --
! -- test PERFORM
! --
! create table perform_test (
! 	a	INT,
! 	b	INT
! );
! create function simple_func(int) returns boolean as '
! BEGIN
! 	IF $1 < 20 THEN
! 		INSERT INTO perform_test VALUES ($1, $1 + 10);
! 		RETURN TRUE;
! 	ELSE
! 		RETURN FALSE;
! 	END IF;
! END;' language plpgsql;
! create function perform_test_func() returns void as '
! BEGIN
! 	IF FOUND then
! 		INSERT INTO perform_test VALUES (100, 100);
! 	END IF;
! 
! 	PERFORM simple_func(5);
! 
! 	IF FOUND then
! 		INSERT INTO perform_test VALUES (100, 100);
! 	END IF;
! 
! 	PERFORM simple_func(50);
! 
! 	IF FOUND then
! 		INSERT INTO perform_test VALUES (100, 100);
! 	END IF;
! 
! 	RETURN;
! END;' language plpgsql;
! SELECT perform_test_func();
!  perform_test_func 
! -------------------
!  
! (1 row)
! 
! SELECT * FROM perform_test;
!   a  |  b  
! -----+-----
!    5 |  15
!  100 | 100
!  100 | 100
! (3 rows)
! 
! drop table perform_test;
! --
! -- Test error trapping
! --
! create function trap_zero_divide(int) returns int as $$
! declare x int;
! 	sx smallint;
! begin
! 	begin	-- start a subtransaction
! 		raise notice 'should see this';
! 		x := 100 / $1;
! 		raise notice 'should see this only if % <> 0', $1;
! 		sx := $1;
! 		raise notice 'should see this only if % fits in smallint', $1;
! 		if $1 < 0 then
! 			raise exception '% is less than zero', $1;
! 		end if;
! 	exception
! 		when division_by_zero then
! 			raise notice 'caught division_by_zero';
! 			x := -1;
! 		when NUMERIC_VALUE_OUT_OF_RANGE then
! 			raise notice 'caught numeric_value_out_of_range';
! 			x := -2;
! 	end;
! 	return x;
! end$$ language plpgsql;
! select trap_zero_divide(50);
! NOTICE:  should see this
! NOTICE:  should see this only if 50 <> 0
! NOTICE:  should see this only if 50 fits in smallint
!  trap_zero_divide 
! ------------------
!                 2
! (1 row)
! 
! select trap_zero_divide(0);
! NOTICE:  should see this
! NOTICE:  caught division_by_zero
!  trap_zero_divide 
! ------------------
!                -1
! (1 row)
! 
! select trap_zero_divide(100000);
! NOTICE:  should see this
! NOTICE:  should see this only if 100000 <> 0
! NOTICE:  caught numeric_value_out_of_range
!  trap_zero_divide 
! ------------------
!                -2
! (1 row)
! 
! select trap_zero_divide(-100);
! NOTICE:  should see this
! NOTICE:  should see this only if -100 <> 0
! NOTICE:  should see this only if -100 fits in smallint
! ERROR:  -100 is less than zero
! create function trap_matching_test(int) returns int as $$
! declare x int;
! 	sx smallint;
! 	y int;
! begin
! 	begin	-- start a subtransaction
! 		x := 100 / $1;
! 		sx := $1;
! 		select into y unique1 from tenk1 where unique2 =
! 			(select unique2 from tenk1 b where ten = $1);
! 	exception
! 		when data_exception then  -- category match
! 			raise notice 'caught data_exception';
! 			x := -1;
! 		when NUMERIC_VALUE_OUT_OF_RANGE OR CARDINALITY_VIOLATION then
! 			raise notice 'caught numeric_value_out_of_range or cardinality_violation';
! 			x := -2;
! 	end;
! 	return x;
! end$$ language plpgsql;
! select trap_matching_test(50);
!  trap_matching_test 
! --------------------
!                   2
! (1 row)
! 
! select trap_matching_test(0);
! NOTICE:  caught data_exception
!  trap_matching_test 
! --------------------
!                  -1
! (1 row)
! 
! select trap_matching_test(100000);
! NOTICE:  caught data_exception
!  trap_matching_test 
! --------------------
!                  -1
! (1 row)
! 
! select trap_matching_test(1);
! NOTICE:  caught numeric_value_out_of_range or cardinality_violation
!  trap_matching_test 
! --------------------
!                  -2
! (1 row)
! 
! create temp table foo (f1 int);
! create function blockme() returns int as $$
! declare x int;
! begin
!   x := 1;
!   insert into foo values(x);
!   begin
!     x := x + 1;
!     insert into foo values(x);
!     -- we assume this will take longer than 2 seconds:
!     select count(*) into x from tenk1 a, tenk1 b, tenk1 c;
!   exception
!     when others then
!       raise notice 'caught others?';
!       return -1;
!     when query_canceled then
!       raise notice 'nyeah nyeah, can''t stop me';
!       x := x * 10;
!   end;
!   insert into foo values(x);
!   return x;
! end$$ language plpgsql;
! set statement_timeout to 2000;
! select blockme();
! NOTICE:  nyeah nyeah, can't stop me
!  blockme 
! ---------
!       20
! (1 row)
! 
! reset statement_timeout;
! select * from foo;
!  f1 
! ----
!   1
!  20
! (2 rows)
! 
! drop table foo;
! -- Test for pass-by-ref values being stored in proper context
! create function test_variable_storage() returns text as $$
! declare x text;
! begin
!   x := '1234';
!   begin
!     x := x || '5678';
!     -- force error inside subtransaction SPI context
!     perform trap_zero_divide(-100);
!   exception
!     when others then
!       x := x || '9012';
!   end;
!   return x;
! end$$ language plpgsql;
! select test_variable_storage();
! NOTICE:  should see this
! CONTEXT:  SQL statement "SELECT trap_zero_divide(-100)"
! PL/pgSQL function test_variable_storage() line 8 at PERFORM
! NOTICE:  should see this only if -100 <> 0
! CONTEXT:  SQL statement "SELECT trap_zero_divide(-100)"
! PL/pgSQL function test_variable_storage() line 8 at PERFORM
! NOTICE:  should see this only if -100 fits in smallint
! CONTEXT:  SQL statement "SELECT trap_zero_divide(-100)"
! PL/pgSQL function test_variable_storage() line 8 at PERFORM
!  test_variable_storage 
! -----------------------
!  123456789012
! (1 row)
! 
! --
! -- test foreign key error trapping
! --
! create temp table master(f1 int primary key);
! create temp table slave(f1 int references master deferrable);
! insert into master values(1);
! insert into slave values(1);
! insert into slave values(2);	-- fails
! ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
! DETAIL:  Key (f1)=(2) is not present in table "master".
! create function trap_foreign_key(int) returns int as $$
! begin
! 	begin	-- start a subtransaction
! 		insert into slave values($1);
! 	exception
! 		when foreign_key_violation then
! 			raise notice 'caught foreign_key_violation';
! 			return 0;
! 	end;
! 	return 1;
! end$$ language plpgsql;
! create function trap_foreign_key_2() returns int as $$
! begin
! 	begin	-- start a subtransaction
! 		set constraints all immediate;
! 	exception
! 		when foreign_key_violation then
! 			raise notice 'caught foreign_key_violation';
! 			return 0;
! 	end;
! 	return 1;
! end$$ language plpgsql;
! select trap_foreign_key(1);
!  trap_foreign_key 
! ------------------
!                 1
! (1 row)
! 
! select trap_foreign_key(2);	-- detects FK violation
! NOTICE:  caught foreign_key_violation
!  trap_foreign_key 
! ------------------
!                 0
! (1 row)
! 
! begin;
!   set constraints all deferred;
!   select trap_foreign_key(2);	-- should not detect FK violation
!  trap_foreign_key 
! ------------------
!                 1
! (1 row)
! 
!   savepoint x;
!     set constraints all immediate; -- fails
! ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
! DETAIL:  Key (f1)=(2) is not present in table "master".
!   rollback to x;
!   select trap_foreign_key_2();  -- detects FK violation
! NOTICE:  caught foreign_key_violation
!  trap_foreign_key_2 
! --------------------
!                   0
! (1 row)
! 
! commit;				-- still fails
! ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
! DETAIL:  Key (f1)=(2) is not present in table "master".
! drop function trap_foreign_key(int);
! drop function trap_foreign_key_2();
! --
! -- Test proper snapshot handling in simple expressions
! --
! create temp table users(login text, id serial);
! create function sp_id_user(a_login text) returns int as $$
! declare x int;
! begin
!   select into x id from users where login = a_login;
!   if found then return x; end if;
!   return 0;
! end$$ language plpgsql stable;
! insert into users values('user1');
! select sp_id_user('user1');
!  sp_id_user 
! ------------
!           1
! (1 row)
! 
! select sp_id_user('userx');
!  sp_id_user 
! ------------
!           0
! (1 row)
! 
! create function sp_add_user(a_login text) returns int as $$
! declare my_id_user int;
! begin
!   my_id_user = sp_id_user( a_login );
!   IF  my_id_user > 0 THEN
!     RETURN -1;  -- error code for existing user
!   END IF;
!   INSERT INTO users ( login ) VALUES ( a_login );
!   my_id_user = sp_id_user( a_login );
!   IF  my_id_user = 0 THEN
!     RETURN -2;  -- error code for insertion failure
!   END IF;
!   RETURN my_id_user;
! end$$ language plpgsql;
! select sp_add_user('user1');
!  sp_add_user 
! -------------
!           -1
! (1 row)
! 
! select sp_add_user('user2');
!  sp_add_user 
! -------------
!            2
! (1 row)
! 
! select sp_add_user('user2');
!  sp_add_user 
! -------------
!           -1
! (1 row)
! 
! select sp_add_user('user3');
!  sp_add_user 
! -------------
!            3
! (1 row)
! 
! select sp_add_user('user3');
!  sp_add_user 
! -------------
!           -1
! (1 row)
! 
! drop function sp_add_user(text);
! drop function sp_id_user(text);
! --
! -- tests for refcursors
! --
! create table rc_test (a int, b int);
! copy rc_test from stdin;
! create function return_refcursor(rc refcursor) returns refcursor as $$
! begin
!     open rc for select a from rc_test;
!     return rc;
! end
! $$ language plpgsql;
! create function refcursor_test1(refcursor) returns refcursor as $$
! begin
!     perform return_refcursor($1);
!     return $1;
! end
! $$ language plpgsql;
! begin;
! select refcursor_test1('test1');
!  refcursor_test1 
! -----------------
!  test1
! (1 row)
! 
! fetch next in test1;
!  a 
! ---
!  5
! (1 row)
! 
! select refcursor_test1('test2');
!  refcursor_test1 
! -----------------
!  test2
! (1 row)
! 
! fetch all from test2;
!   a  
! -----
!    5
!   50
!  500
! (3 rows)
! 
! commit;
! -- should fail
! fetch next from test1;
! ERROR:  cursor "test1" does not exist
! create function refcursor_test2(int, int) returns boolean as $$
! declare
!     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
!     nonsense record;
! begin
!     open c1($1, $2);
!     fetch c1 into nonsense;
!     close c1;
!     if found then
!         return true;
!     else
!         return false;
!     end if;
! end
! $$ language plpgsql;
! select refcursor_test2(20000, 20000) as "Should be false",
!        refcursor_test2(20, 20) as "Should be true";
!  Should be false | Should be true 
! -----------------+----------------
!  f               | t
! (1 row)
! 
! --
! -- tests for cursors with named parameter arguments
! --
! create function namedparmcursor_test1(int, int) returns boolean as $$
! declare
!     c1 cursor (param1 int, param12 int) for select * from rc_test where a > param1 and b > param12;
!     nonsense record;
! begin
!     open c1(param12 := $2, param1 := $1);
!     fetch c1 into nonsense;
!     close c1;
!     if found then
!         return true;
!     else
!         return false;
!     end if;
! end
! $$ language plpgsql;
! select namedparmcursor_test1(20000, 20000) as "Should be false",
!        namedparmcursor_test1(20, 20) as "Should be true";
!  Should be false | Should be true 
! -----------------+----------------
!  f               | t
! (1 row)
! 
! -- mixing named and positional argument notations
! create function namedparmcursor_test2(int, int) returns boolean as $$
! declare
!     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
!     nonsense record;
! begin
!     open c1(param1 := $1, $2);
!     fetch c1 into nonsense;
!     close c1;
!     if found then
!         return true;
!     else
!         return false;
!     end if;
! end
! $$ language plpgsql;
! select namedparmcursor_test2(20, 20);
!  namedparmcursor_test2 
! -----------------------
!  t
! (1 row)
! 
! -- mixing named and positional: param2 is given twice, once in named notation
! -- and second time in positional notation. Should throw an error at parse time
! create function namedparmcursor_test3() returns void as $$
! declare
!     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
! begin
!     open c1(param2 := 20, 21);
! end
! $$ language plpgsql;
! ERROR:  value for parameter "param2" of cursor "c1" specified more than once
! LINE 5:     open c1(param2 := 20, 21);
!                                   ^
! -- mixing named and positional: same as previous test, but param1 is duplicated
! create function namedparmcursor_test4() returns void as $$
! declare
!     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
! begin
!     open c1(20, param1 := 21);
! end
! $$ language plpgsql;
! ERROR:  value for parameter "param1" of cursor "c1" specified more than once
! LINE 5:     open c1(20, param1 := 21);
!                         ^
! -- duplicate named parameter, should throw an error at parse time
! create function namedparmcursor_test5() returns void as $$
! declare
!   c1 cursor (p1 int, p2 int) for
!     select * from tenk1 where thousand = p1 and tenthous = p2;
! begin
!   open c1 (p2 := 77, p2 := 42);
! end
! $$ language plpgsql;
! ERROR:  value for parameter "p2" of cursor "c1" specified more than once
! LINE 6:   open c1 (p2 := 77, p2 := 42);
!                              ^
! -- not enough parameters, should throw an error at parse time
! create function namedparmcursor_test6() returns void as $$
! declare
!   c1 cursor (p1 int, p2 int) for
!     select * from tenk1 where thousand = p1 and tenthous = p2;
! begin
!   open c1 (p2 := 77);
! end
! $$ language plpgsql;
! ERROR:  not enough arguments for cursor "c1"
! LINE 6:   open c1 (p2 := 77);
!                            ^
! -- division by zero runtime error, the context given in the error message
! -- should be sensible
! create function namedparmcursor_test7() returns void as $$
! declare
!   c1 cursor (p1 int, p2 int) for
!     select * from tenk1 where thousand = p1 and tenthous = p2;
! begin
!   open c1 (p2 := 77, p1 := 42/0);
! end $$ language plpgsql;
! select namedparmcursor_test7();
! ERROR:  division by zero
! CONTEXT:  SQL statement "SELECT 42/0 AS p1, 77 AS p2;"
! PL/pgSQL function namedparmcursor_test7() line 6 at OPEN
! -- check that line comments work correctly within the argument list (there
! -- is some special handling of this case in the code: the newline after the
! -- comment must be preserved when the argument-evaluating query is
! -- constructed, otherwise the comment effectively comments out the next
! -- argument, too)
! create function namedparmcursor_test8() returns int4 as $$
! declare
!   c1 cursor (p1 int, p2 int) for
!     select count(*) from tenk1 where thousand = p1 and tenthous = p2;
!   n int4;
! begin
!   open c1 (77 -- test
!   , 42);
!   fetch c1 into n;
!   return n;
! end $$ language plpgsql;
! select namedparmcursor_test8();
!  namedparmcursor_test8 
! -----------------------
!                      0
! (1 row)
! 
! -- cursor parameter name can match plpgsql variable or unreserved keyword
! create function namedparmcursor_test9(p1 int) returns int4 as $$
! declare
!   c1 cursor (p1 int, p2 int, debug int) for
!     select count(*) from tenk1 where thousand = p1 and tenthous = p2
!       and four = debug;
!   p2 int4 := 1006;
!   n int4;
! begin
!   open c1 (p1 := p1, p2 := p2, debug := 2);
!   fetch c1 into n;
!   return n;
! end $$ language plpgsql;
! select namedparmcursor_test9(6);
!  namedparmcursor_test9 
! -----------------------
!                      1
! (1 row)
! 
! --
! -- tests for "raise" processing
! --
! create function raise_test1(int) returns int as $$
! begin
!     raise notice 'This message has too many parameters!', $1;
!     return $1;
! end;
! $$ language plpgsql;
! ERROR:  too many parameters specified for RAISE
! CONTEXT:  compilation of PL/pgSQL function "raise_test1" near line 3
! create function raise_test2(int) returns int as $$
! begin
!     raise notice 'This message has too few parameters: %, %, %', $1, $1;
!     return $1;
! end;
! $$ language plpgsql;
! ERROR:  too few parameters specified for RAISE
! CONTEXT:  compilation of PL/pgSQL function "raise_test2" near line 3
! create function raise_test3(int) returns int as $$
! begin
!     raise notice 'This message has no parameters (despite having %% signs in it)!';
!     return $1;
! end;
! $$ language plpgsql;
! select raise_test3(1);
! NOTICE:  This message has no parameters (despite having % signs in it)!
!  raise_test3 
! -------------
!            1
! (1 row)
! 
! -- Test re-RAISE inside a nested exception block.  This case is allowed
! -- by Oracle's PL/SQL but was handled differently by PG before 9.1.
! CREATE FUNCTION reraise_test() RETURNS void AS $$
! BEGIN
!    BEGIN
!        RAISE syntax_error;
!    EXCEPTION
!        WHEN syntax_error THEN
!            BEGIN
!                raise notice 'exception % thrown in inner block, reraising', sqlerrm;
!                RAISE;
!            EXCEPTION
!                WHEN OTHERS THEN
!                    raise notice 'RIGHT - exception % caught in inner block', sqlerrm;
!            END;
!    END;
! EXCEPTION
!    WHEN OTHERS THEN
!        raise notice 'WRONG - exception % caught in outer block', sqlerrm;
! END;
! $$ LANGUAGE plpgsql;
! SELECT reraise_test();
! NOTICE:  exception syntax_error thrown in inner block, reraising
! NOTICE:  RIGHT - exception syntax_error caught in inner block
!  reraise_test 
! --------------
!  
! (1 row)
! 
! --
! -- reject function definitions that contain malformed SQL queries at
! -- compile-time, where possible
! --
! create function bad_sql1() returns int as $$
! declare a int;
! begin
!     a := 5;
!     Johnny Yuma;
!     a := 10;
!     return a;
! end$$ language plpgsql;
! ERROR:  syntax error at or near "Johnny"
! LINE 5:     Johnny Yuma;
!             ^
! create function bad_sql2() returns int as $$
! declare r record;
! begin
!     for r in select I fought the law, the law won LOOP
!         raise notice 'in loop';
!     end loop;
!     return 5;
! end;$$ language plpgsql;
! ERROR:  syntax error at or near "the"
! LINE 4:     for r in select I fought the law, the law won LOOP
!                                      ^
! -- a RETURN expression is mandatory, except for void-returning
! -- functions, where it is not allowed
! create function missing_return_expr() returns int as $$
! begin
!     return ;
! end;$$ language plpgsql;
! ERROR:  missing expression at or near ";"
! LINE 3:     return ;
!                    ^
! create function void_return_expr() returns void as $$
! begin
!     return 5;
! end;$$ language plpgsql;
! ERROR:  RETURN cannot have a parameter in function returning void
! LINE 3:     return 5;
!                    ^
! -- VOID functions are allowed to omit RETURN
! create function void_return_expr() returns void as $$
! begin
!     perform 2+2;
! end;$$ language plpgsql;
! select void_return_expr();
!  void_return_expr 
! ------------------
!  
! (1 row)
! 
! -- but ordinary functions are not
! create function missing_return_expr() returns int as $$
! begin
!     perform 2+2;
! end;$$ language plpgsql;
! select missing_return_expr();
! ERROR:  control reached end of function without RETURN
! CONTEXT:  PL/pgSQL function missing_return_expr()
! drop function void_return_expr();
! drop function missing_return_expr();
! --
! -- EXECUTE ... INTO test
! --
! create table eifoo (i integer, y integer);
! create type eitype as (i integer, y integer);
! create or replace function execute_into_test(varchar) returns record as $$
! declare
!     _r record;
!     _rt eifoo%rowtype;
!     _v eitype;
!     i int;
!     j int;
!     k int;
! begin
!     execute 'insert into '||$1||' values(10,15)';
!     execute 'select (row).* from (select row(10,1)::eifoo) s' into _r;
!     raise notice '% %', _r.i, _r.y;
!     execute 'select * from '||$1||' limit 1' into _rt;
!     raise notice '% %', _rt.i, _rt.y;
!     execute 'select *, 20 from '||$1||' limit 1' into i, j, k;
!     raise notice '% % %', i, j, k;
!     execute 'select 1,2' into _v;
!     return _v;
! end; $$ language plpgsql;
! select execute_into_test('eifoo');
! NOTICE:  10 1
! NOTICE:  10 15
! NOTICE:  10 15 20
!  execute_into_test 
! -------------------
!  (1,2)
! (1 row)
! 
! drop table eifoo cascade;
! drop type eitype cascade;
! --
! -- SQLSTATE and SQLERRM test
! --
! create function excpt_test1() returns void as $$
! begin
!     raise notice '% %', sqlstate, sqlerrm;
! end; $$ language plpgsql;
! -- should fail: SQLSTATE and SQLERRM are only in defined EXCEPTION
! -- blocks
! select excpt_test1();
! ERROR:  column "sqlstate" does not exist
! LINE 1: SELECT sqlstate
!                ^
! QUERY:  SELECT sqlstate
! CONTEXT:  PL/pgSQL function excpt_test1() line 3 at RAISE
! create function excpt_test2() returns void as $$
! begin
!     begin
!         begin
!             raise notice '% %', sqlstate, sqlerrm;
!         end;
!     end;
! end; $$ language plpgsql;
! -- should fail
! select excpt_test2();
! ERROR:  column "sqlstate" does not exist
! LINE 1: SELECT sqlstate
!                ^
! QUERY:  SELECT sqlstate
! CONTEXT:  PL/pgSQL function excpt_test2() line 5 at RAISE
! create function excpt_test3() returns void as $$
! begin
!     begin
!         raise exception 'user exception';
!     exception when others then
! 	    raise notice 'caught exception % %', sqlstate, sqlerrm;
! 	    begin
! 	        raise notice '% %', sqlstate, sqlerrm;
! 	        perform 10/0;
!         exception
!             when substring_error then
!                 -- this exception handler shouldn't be invoked
!                 raise notice 'unexpected exception: % %', sqlstate, sqlerrm;
! 	        when division_by_zero then
! 	            raise notice 'caught exception % %', sqlstate, sqlerrm;
! 	    end;
! 	    raise notice '% %', sqlstate, sqlerrm;
!     end;
! end; $$ language plpgsql;
! select excpt_test3();
! NOTICE:  caught exception P0001 user exception
! NOTICE:  P0001 user exception
! NOTICE:  caught exception 22012 division by zero
! NOTICE:  P0001 user exception
!  excpt_test3 
! -------------
!  
! (1 row)
! 
! drop function excpt_test1();
! drop function excpt_test2();
! drop function excpt_test3();
! -- parameters of raise stmt can be expressions
! create function raise_exprs() returns void as $$
! declare
!     a integer[] = '{10,20,30}';
!     c varchar = 'xyz';
!     i integer;
! begin
!     i := 2;
!     raise notice '%; %; %; %; %; %', a, a[i], c, (select c || 'abc'), row(10,'aaa',NULL,30), NULL;
! end;$$ language plpgsql;
! select raise_exprs();
! NOTICE:  {10,20,30}; 20; xyz; xyzabc; (10,aaa,,30); <NULL>
!  raise_exprs 
! -------------
!  
! (1 row)
! 
! drop function raise_exprs();
! -- continue statement
! create table conttesttbl(idx serial, v integer);
! insert into conttesttbl(v) values(10);
! insert into conttesttbl(v) values(20);
! insert into conttesttbl(v) values(30);
! insert into conttesttbl(v) values(40);
! create function continue_test1() returns void as $$
! declare _i integer = 0; _r record;
! begin
!   raise notice '---1---';
!   loop
!     _i := _i + 1;
!     raise notice '%', _i;
!     continue when _i < 10;
!     exit;
!   end loop;
! 
!   raise notice '---2---';
!   <<lbl>>
!   loop
!     _i := _i - 1;
!     loop
!       raise notice '%', _i;
!       continue lbl when _i > 0;
!       exit lbl;
!     end loop;
!   end loop;
! 
!   raise notice '---3---';
!   <<the_loop>>
!   while _i < 10 loop
!     _i := _i + 1;
!     continue the_loop when _i % 2 = 0;
!     raise notice '%', _i;
!   end loop;
! 
!   raise notice '---4---';
!   for _i in 1..10 loop
!     begin
!       -- applies to outer loop, not the nested begin block
!       continue when _i < 5;
!       raise notice '%', _i;
!     end;
!   end loop;
! 
!   raise notice '---5---';
!   for _r in select * from conttesttbl loop
!     continue when _r.v <= 20;
!     raise notice '%', _r.v;
!   end loop;
! 
!   raise notice '---6---';
!   for _r in execute 'select * from conttesttbl' loop
!     continue when _r.v <= 20;
!     raise notice '%', _r.v;
!   end loop;
! 
!   raise notice '---7---';
!   for _i in 1..3 loop
!     raise notice '%', _i;
!     continue when _i = 3;
!   end loop;
! 
!   raise notice '---8---';
!   _i := 1;
!   while _i <= 3 loop
!     raise notice '%', _i;
!     _i := _i + 1;
!     continue when _i = 3;
!   end loop;
! 
!   raise notice '---9---';
!   for _r in select * from conttesttbl order by v limit 1 loop
!     raise notice '%', _r.v;
!     continue;
!   end loop;
! 
!   raise notice '---10---';
!   for _r in execute 'select * from conttesttbl order by v limit 1' loop
!     raise notice '%', _r.v;
!     continue;
!   end loop;
! end; $$ language plpgsql;
! select continue_test1();
! NOTICE:  ---1---
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
! NOTICE:  5
! NOTICE:  6
! NOTICE:  7
! NOTICE:  8
! NOTICE:  9
! NOTICE:  10
! NOTICE:  ---2---
! NOTICE:  9
! NOTICE:  8
! NOTICE:  7
! NOTICE:  6
! NOTICE:  5
! NOTICE:  4
! NOTICE:  3
! NOTICE:  2
! NOTICE:  1
! NOTICE:  0
! NOTICE:  ---3---
! NOTICE:  1
! NOTICE:  3
! NOTICE:  5
! NOTICE:  7
! NOTICE:  9
! NOTICE:  ---4---
! NOTICE:  5
! NOTICE:  6
! NOTICE:  7
! NOTICE:  8
! NOTICE:  9
! NOTICE:  10
! NOTICE:  ---5---
! NOTICE:  30
! NOTICE:  40
! NOTICE:  ---6---
! NOTICE:  30
! NOTICE:  40
! NOTICE:  ---7---
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  ---8---
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  ---9---
! NOTICE:  10
! NOTICE:  ---10---
! NOTICE:  10
!  continue_test1 
! ----------------
!  
! (1 row)
! 
! -- CONTINUE is only legal inside a loop
! create function continue_test2() returns void as $$
! begin
!     begin
!         continue;
!     end;
!     return;
! end;
! $$ language plpgsql;
! -- should fail
! select continue_test2();
! ERROR:  CONTINUE cannot be used outside a loop
! CONTEXT:  PL/pgSQL function continue_test2()
! -- CONTINUE can't reference the label of a named block
! create function continue_test3() returns void as $$
! begin
!     <<begin_block1>>
!     begin
!         loop
!             continue begin_block1;
!         end loop;
!     end;
! end;
! $$ language plpgsql;
! -- should fail
! select continue_test3();
! ERROR:  CONTINUE cannot be used outside a loop
! CONTEXT:  PL/pgSQL function continue_test3()
! drop function continue_test1();
! drop function continue_test2();
! drop function continue_test3();
! drop table conttesttbl;
! -- verbose end block and end loop
! create function end_label1() returns void as $$
! <<blbl>>
! begin
!   <<flbl1>>
!   for _i in 1 .. 10 loop
!     exit flbl1;
!   end loop flbl1;
!   <<flbl2>>
!   for _i in 1 .. 10 loop
!     exit flbl2;
!   end loop;
! end blbl;
! $$ language plpgsql;
! select end_label1();
!  end_label1 
! ------------
!  
! (1 row)
! 
! drop function end_label1();
! -- should fail: undefined end label
! create function end_label2() returns void as $$
! begin
!   for _i in 1 .. 10 loop
!     exit;
!   end loop flbl1;
! end;
! $$ language plpgsql;
! ERROR:  label does not exist at or near "flbl1"
! LINE 5:   end loop flbl1;
!                    ^
! -- should fail: end label does not match start label
! create function end_label3() returns void as $$
! <<outer_label>>
! begin
!   <<inner_label>>
!   for _i in 1 .. 10 loop
!     exit;
!   end loop outer_label;
! end;
! $$ language plpgsql;
! ERROR:  end label "outer_label" differs from block's label "inner_label"
! LINE 7:   end loop outer_label;
!                    ^
! -- should fail: end label on a block without a start label
! create function end_label4() returns void as $$
! <<outer_label>>
! begin
!   for _i in 1 .. 10 loop
!     exit;
!   end loop outer_label;
! end;
! $$ language plpgsql;
! ERROR:  end label "outer_label" specified for unlabelled block
! LINE 6:   end loop outer_label;
!                    ^
! -- using list of scalars in fori and fore stmts
! create function for_vect() returns void as $proc$
! <<lbl>>declare a integer; b varchar; c varchar; r record;
! begin
!   -- fori
!   for i in 1 .. 3 loop
!     raise notice '%', i;
!   end loop;
!   -- fore with record var
!   for r in select gs as aa, 'BB' as bb, 'CC' as cc from generate_series(1,4) gs loop
!     raise notice '% % %', r.aa, r.bb, r.cc;
!   end loop;
!   -- fore with single scalar
!   for a in select gs from generate_series(1,4) gs loop
!     raise notice '%', a;
!   end loop;
!   -- fore with multiple scalars
!   for a,b,c in select gs, 'BB','CC' from generate_series(1,4) gs loop
!     raise notice '% % %', a, b, c;
!   end loop;
!   -- using qualified names in fors, fore is enabled, disabled only for fori
!   for lbl.a, lbl.b, lbl.c in execute $$select gs, 'bb','cc' from generate_series(1,4) gs$$ loop
!     raise notice '% % %', a, b, c;
!   end loop;
! end;
! $proc$ language plpgsql;
! select for_vect();
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  1 BB CC
! NOTICE:  2 BB CC
! NOTICE:  3 BB CC
! NOTICE:  4 BB CC
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
! NOTICE:  1 BB CC
! NOTICE:  2 BB CC
! NOTICE:  3 BB CC
! NOTICE:  4 BB CC
! NOTICE:  1 bb cc
! NOTICE:  2 bb cc
! NOTICE:  3 bb cc
! NOTICE:  4 bb cc
!  for_vect 
! ----------
!  
! (1 row)
! 
! -- regression test: verify that multiple uses of same plpgsql datum within
! -- a SQL command all get mapped to the same $n parameter.  The return value
! -- of the SELECT is not important, we only care that it doesn't fail with
! -- a complaint about an ungrouped column reference.
! create function multi_datum_use(p1 int) returns bool as $$
! declare
!   x int;
!   y int;
! begin
!   select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;
!   return x = y;
! end$$ language plpgsql;
! select multi_datum_use(42);
!  multi_datum_use 
! -----------------
!  t
! (1 row)
! 
! --
! -- Test STRICT limiter in both planned and EXECUTE invocations.
! -- Note that a data-modifying query is quasi strict (disallow multi rows)
! -- by default in the planned case, but not in EXECUTE.
! --
! create temp table foo (f1 int, f2 int);
! insert into foo values (1,2), (3,4);
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should work
!   insert into foo values(5,6) returning * into x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! NOTICE:  x.f1 = 5, x.f2 = 6
!  footest 
! ---------
!  
! (1 row)
! 
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should fail due to implicit strict
!   insert into foo values(7,8),(9,10) returning * into x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 5 at SQL statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should work
!   execute 'insert into foo values(5,6) returning *' into x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! NOTICE:  x.f1 = 5, x.f2 = 6
!  footest 
! ---------
!  
! (1 row)
! 
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- this should work since EXECUTE isn't as picky
!   execute 'insert into foo values(7,8),(9,10) returning *' into x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! NOTICE:  x.f1 = 7, x.f2 = 8
!  footest 
! ---------
!  
! (1 row)
! 
! select * from foo;
!  f1 | f2 
! ----+----
!   1 |  2
!   3 |  4
!   5 |  6
!   5 |  6
!   7 |  8
!   9 | 10
! (6 rows)
! 
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should work
!   select * from foo where f1 = 3 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! NOTICE:  x.f1 = 3, x.f2 = 4
!  footest 
! ---------
!  
! (1 row)
! 
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should fail, no rows
!   select * from foo where f1 = 0 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned no rows
! CONTEXT:  PL/pgSQL function footest() line 5 at SQL statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should fail, too many rows
!   select * from foo where f1 > 3 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 5 at SQL statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should work
!   execute 'select * from foo where f1 = 3' into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! NOTICE:  x.f1 = 3, x.f2 = 4
!  footest 
! ---------
!  
! (1 row)
! 
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should fail, no rows
!   execute 'select * from foo where f1 = 0' into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned no rows
! CONTEXT:  PL/pgSQL function footest() line 5 at EXECUTE statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- should fail, too many rows
!   execute 'select * from foo where f1 > 3' into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 5 at EXECUTE statement
! drop function footest();
! -- test printing parameters after failure due to STRICT
! set plpgsql.print_strict_params to true;
! create or replace function footest() returns void as $$
! declare
! x record;
! p1 int := 2;
! p3 text := 'foo';
! begin
!   -- no rows
!   select * from foo where f1 = p1 and f1::text = p3 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned no rows
! DETAIL:  parameters: p1 = '2', p3 = 'foo'
! CONTEXT:  PL/pgSQL function footest() line 8 at SQL statement
! create or replace function footest() returns void as $$
! declare
! x record;
! p1 int := 2;
! p3 text := 'foo';
! begin
!   -- too many rows
!   select * from foo where f1 > p1 or f1::text = p3  into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! DETAIL:  parameters: p1 = '2', p3 = 'foo'
! CONTEXT:  PL/pgSQL function footest() line 8 at SQL statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- too many rows, no params
!   select * from foo where f1 > 3 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 5 at SQL statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- no rows
!   execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned no rows
! DETAIL:  parameters: $1 = '0', $2 = 'foo'
! CONTEXT:  PL/pgSQL function footest() line 5 at EXECUTE statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- too many rows
!   execute 'select * from foo where f1 > $1' using 1 into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! DETAIL:  parameters: $1 = '1'
! CONTEXT:  PL/pgSQL function footest() line 5 at EXECUTE statement
! create or replace function footest() returns void as $$
! declare x record;
! begin
!   -- too many rows, no parameters
!   execute 'select * from foo where f1 > 3' into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 5 at EXECUTE statement
! create or replace function footest() returns void as $$
! -- override the global
! #print_strict_params off
! declare
! x record;
! p1 int := 2;
! p3 text := 'foo';
! begin
!   -- too many rows
!   select * from foo where f1 > p1 or f1::text = p3  into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! CONTEXT:  PL/pgSQL function footest() line 10 at SQL statement
! reset plpgsql.print_strict_params;
! create or replace function footest() returns void as $$
! -- override the global
! #print_strict_params on
! declare
! x record;
! p1 int := 2;
! p3 text := 'foo';
! begin
!   -- too many rows
!   select * from foo where f1 > p1 or f1::text = p3  into strict x;
!   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
! end$$ language plpgsql;
! select footest();
! ERROR:  query returned more than one row
! DETAIL:  parameters: p1 = '2', p3 = 'foo'
! CONTEXT:  PL/pgSQL function footest() line 10 at SQL statement
! -- test warnings and errors
! set plpgsql.extra_warnings to 'all';
! set plpgsql.extra_warnings to 'none';
! set plpgsql.extra_errors to 'all';
! set plpgsql.extra_errors to 'none';
! -- test warnings when shadowing a variable
! set plpgsql.extra_warnings to 'shadowed_variables';
! -- simple shadowing of input and output parameters
! create or replace function shadowtest(in1 int)
! 	returns table (out1 int) as $$
! declare
! in1 int;
! out1 int;
! begin
! end
! $$ language plpgsql;
! WARNING:  variable "in1" shadows a previously defined variable
! LINE 4: in1 int;
!         ^
! WARNING:  variable "out1" shadows a previously defined variable
! LINE 5: out1 int;
!         ^
! select shadowtest(1);
!  shadowtest 
! ------------
! (0 rows)
! 
! set plpgsql.extra_warnings to 'shadowed_variables';
! select shadowtest(1);
!  shadowtest 
! ------------
! (0 rows)
! 
! create or replace function shadowtest(in1 int)
! 	returns table (out1 int) as $$
! declare
! in1 int;
! out1 int;
! begin
! end
! $$ language plpgsql;
! WARNING:  variable "in1" shadows a previously defined variable
! LINE 4: in1 int;
!         ^
! WARNING:  variable "out1" shadows a previously defined variable
! LINE 5: out1 int;
!         ^
! select shadowtest(1);
!  shadowtest 
! ------------
! (0 rows)
! 
! drop function shadowtest(int);
! -- shadowing in a second DECLARE block
! create or replace function shadowtest()
! 	returns void as $$
! declare
! f1 int;
! begin
! 	declare
! 	f1 int;
! 	begin
! 	end;
! end$$ language plpgsql;
! WARNING:  variable "f1" shadows a previously defined variable
! LINE 7:  f1 int;
!          ^
! drop function shadowtest();
! -- several levels of shadowing
! create or replace function shadowtest(in1 int)
! 	returns void as $$
! declare
! in1 int;
! begin
! 	declare
! 	in1 int;
! 	begin
! 	end;
! end$$ language plpgsql;
! WARNING:  variable "in1" shadows a previously defined variable
! LINE 4: in1 int;
!         ^
! WARNING:  variable "in1" shadows a previously defined variable
! LINE 7:  in1 int;
!          ^
! drop function shadowtest(int);
! -- shadowing in cursor definitions
! create or replace function shadowtest()
! 	returns void as $$
! declare
! f1 int;
! c1 cursor (f1 int) for select 1;
! begin
! end$$ language plpgsql;
! WARNING:  variable "f1" shadows a previously defined variable
! LINE 5: c1 cursor (f1 int) for select 1;
!                    ^
! drop function shadowtest();
! -- test errors when shadowing a variable
! set plpgsql.extra_errors to 'shadowed_variables';
! create or replace function shadowtest(f1 int)
! 	returns boolean as $$
! declare f1 int; begin return 1; end $$ language plpgsql;
! ERROR:  variable "f1" shadows a previously defined variable
! LINE 3: declare f1 int; begin return 1; end $$ language plpgsql;
!                 ^
! select shadowtest(1);
! ERROR:  function shadowtest(integer) does not exist
! LINE 1: select shadowtest(1);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! reset plpgsql.extra_errors;
! reset plpgsql.extra_warnings;
! create or replace function shadowtest(f1 int)
! 	returns boolean as $$
! declare f1 int; begin return 1; end $$ language plpgsql;
! select shadowtest(1);
!  shadowtest 
! ------------
!  t
! (1 row)
! 
! -- test scrollable cursor support
! create function sc_test() returns setof integer as $$
! declare
!   c scroll cursor for select f1 from int4_tbl;
!   x integer;
! begin
!   open c;
!   fetch last from c into x;
!   while found loop
!     return next x;
!     fetch prior from c into x;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!    sc_test   
! -------------
!  -2147483647
!   2147483647
!      -123456
!       123456
!            0
! (5 rows)
! 
! create or replace function sc_test() returns setof integer as $$
! declare
!   c no scroll cursor for select f1 from int4_tbl;
!   x integer;
! begin
!   open c;
!   fetch last from c into x;
!   while found loop
!     return next x;
!     fetch prior from c into x;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();  -- fails because of NO SCROLL specification
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! CONTEXT:  PL/pgSQL function sc_test() line 7 at FETCH
! create or replace function sc_test() returns setof integer as $$
! declare
!   c refcursor;
!   x integer;
! begin
!   open c scroll for select f1 from int4_tbl;
!   fetch last from c into x;
!   while found loop
!     return next x;
!     fetch prior from c into x;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!    sc_test   
! -------------
!  -2147483647
!   2147483647
!      -123456
!       123456
!            0
! (5 rows)
! 
! create or replace function sc_test() returns setof integer as $$
! declare
!   c refcursor;
!   x integer;
! begin
!   open c scroll for execute 'select f1 from int4_tbl';
!   fetch last from c into x;
!   while found loop
!     return next x;
!     fetch relative -2 from c into x;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!    sc_test   
! -------------
!  -2147483647
!      -123456
!            0
! (3 rows)
! 
! create or replace function sc_test() returns setof integer as $$
! declare
!   c refcursor;
!   x integer;
! begin
!   open c scroll for execute 'select f1 from int4_tbl';
!   fetch last from c into x;
!   while found loop
!     return next x;
!     move backward 2 from c;
!     fetch relative -1 from c into x;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!    sc_test   
! -------------
!  -2147483647
!       123456
! (2 rows)
! 
! create or replace function sc_test() returns setof integer as $$
! declare
!   c cursor for select * from generate_series(1, 10);
!   x integer;
! begin
!   open c;
!   loop
!       move relative 2 in c;
!       if not found then
!           exit;
!       end if;
!       fetch next from c into x;
!       if found then
!           return next x;
!       end if;
!   end loop;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!  sc_test 
! ---------
!        3
!        6
!        9
! (3 rows)
! 
! create or replace function sc_test() returns setof integer as $$
! declare
!   c cursor for select * from generate_series(1, 10);
!   x integer;
! begin
!   open c;
!   move forward all in c;
!   fetch backward from c into x;
!   if found then
!     return next x;
!   end if;
!   close c;
! end;
! $$ language plpgsql;
! select * from sc_test();
!  sc_test 
! ---------
!       10
! (1 row)
! 
! drop function sc_test();
! -- test qualified variable names
! create function pl_qual_names (param1 int) returns void as $$
! <<outerblock>>
! declare
!   param1 int := 1;
! begin
!   <<innerblock>>
!   declare
!     param1 int := 2;
!   begin
!     raise notice 'param1 = %', param1;
!     raise notice 'pl_qual_names.param1 = %', pl_qual_names.param1;
!     raise notice 'outerblock.param1 = %', outerblock.param1;
!     raise notice 'innerblock.param1 = %', innerblock.param1;
!   end;
! end;
! $$ language plpgsql;
! select pl_qual_names(42);
! NOTICE:  param1 = 2
! NOTICE:  pl_qual_names.param1 = 42
! NOTICE:  outerblock.param1 = 1
! NOTICE:  innerblock.param1 = 2
!  pl_qual_names 
! ---------------
!  
! (1 row)
! 
! drop function pl_qual_names(int);
! -- tests for RETURN QUERY
! create function ret_query1(out int, out int) returns setof record as $$
! begin
!     $1 := -1;
!     $2 := -2;
!     return next;
!     return query select x + 1, x * 10 from generate_series(0, 10) s (x);
!     return next;
! end;
! $$ language plpgsql;
! select * from ret_query1();
!  column1 | column2 
! ---------+---------
!       -1 |      -2
!        1 |       0
!        2 |      10
!        3 |      20
!        4 |      30
!        5 |      40
!        6 |      50
!        7 |      60
!        8 |      70
!        9 |      80
!       10 |      90
!       11 |     100
!       -1 |      -2
! (13 rows)
! 
! create type record_type as (x text, y int, z boolean);
! create or replace function ret_query2(lim int) returns setof record_type as $$
! begin
!     return query select md5(s.x::text), s.x, s.x > 0
!                  from generate_series(-8, lim) s (x) where s.x % 2 = 0;
! end;
! $$ language plpgsql;
! select * from ret_query2(8);
!                 x                 | y  | z 
! ----------------------------------+----+---
!  a8d2ec85eaf98407310b72eb73dda247 | -8 | f
!  596a3d04481816330f07e4f97510c28f | -6 | f
!  0267aaf632e87a63288a08331f22c7c3 | -4 | f
!  5d7b9adcbe1c629ec722529dd12e5129 | -2 | f
!  cfcd208495d565ef66e7dff9f98764da |  0 | f
!  c81e728d9d4c2f636f067f89cc14862c |  2 | t
!  a87ff679a2f3e71d9181a67b7542122c |  4 | t
!  1679091c5a880faf6fb5e6087eb1b2dc |  6 | t
!  c9f0f895fb98ab9159f51fd0297e236d |  8 | t
! (9 rows)
! 
! -- test EXECUTE USING
! create function exc_using(int, text) returns int as $$
! declare i int;
! begin
!   for i in execute 'select * from generate_series(1,$1)' using $1+1 loop
!     raise notice '%', i;
!   end loop;
!   execute 'select $2 + $2*3 + length($1)' into i using $2,$1;
!   return i;
! end
! $$ language plpgsql;
! select exc_using(5, 'foobar');
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
! NOTICE:  5
! NOTICE:  6
!  exc_using 
! -----------
!         26
! (1 row)
! 
! drop function exc_using(int, text);
! create or replace function exc_using(int) returns void as $$
! declare
!   c refcursor;
!   i int;
! begin
!   open c for execute 'select * from generate_series(1,$1)' using $1+1;
!   loop
!     fetch c into i;
!     exit when not found;
!     raise notice '%', i;
!   end loop;
!   close c;
!   return;
! end;
! $$ language plpgsql;
! select exc_using(5);
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
! NOTICE:  5
! NOTICE:  6
!  exc_using 
! -----------
!  
! (1 row)
! 
! drop function exc_using(int);
! -- test FOR-over-cursor
! create or replace function forc01() returns void as $$
! declare
!   c cursor(r1 integer, r2 integer)
!        for select * from generate_series(r1,r2) i;
!   c2 cursor
!        for select * from generate_series(41,43) i;
! begin
!   for r in c(5,7) loop
!     raise notice '% from %', r.i, c;
!   end loop;
!   -- again, to test if cursor was closed properly
!   for r in c(9,10) loop
!     raise notice '% from %', r.i, c;
!   end loop;
!   -- and test a parameterless cursor
!   for r in c2 loop
!     raise notice '% from %', r.i, c2;
!   end loop;
!   -- and try it with a hand-assigned name
!   raise notice 'after loop, c2 = %', c2;
!   c2 := 'special_name';
!   for r in c2 loop
!     raise notice '% from %', r.i, c2;
!   end loop;
!   raise notice 'after loop, c2 = %', c2;
!   -- and try it with a generated name
!   -- (which we can't show in the output because it's variable)
!   c2 := null;
!   for r in c2 loop
!     raise notice '%', r.i;
!   end loop;
!   raise notice 'after loop, c2 = %', c2;
!   return;
! end;
! $$ language plpgsql;
! select forc01();
! NOTICE:  5 from c
! NOTICE:  6 from c
! NOTICE:  7 from c
! NOTICE:  9 from c
! NOTICE:  10 from c
! NOTICE:  41 from c2
! NOTICE:  42 from c2
! NOTICE:  43 from c2
! NOTICE:  after loop, c2 = c2
! NOTICE:  41 from special_name
! NOTICE:  42 from special_name
! NOTICE:  43 from special_name
! NOTICE:  after loop, c2 = special_name
! NOTICE:  41
! NOTICE:  42
! NOTICE:  43
! NOTICE:  after loop, c2 = <NULL>
!  forc01 
! --------
!  
! (1 row)
! 
! -- try updating the cursor's current row
! create temp table forc_test as
!   select n as i, n as j from generate_series(1,10) n;
! create or replace function forc01() returns void as $$
! declare
!   c cursor for select * from forc_test;
! begin
!   for r in c loop
!     raise notice '%, %', r.i, r.j;
!     update forc_test set i = i * 100, j = r.j * 2 where current of c;
!   end loop;
! end;
! $$ language plpgsql;
! select forc01();
! NOTICE:  1, 1
! NOTICE:  2, 2
! NOTICE:  3, 3
! NOTICE:  4, 4
! NOTICE:  5, 5
! NOTICE:  6, 6
! NOTICE:  7, 7
! NOTICE:  8, 8
! NOTICE:  9, 9
! NOTICE:  10, 10
!  forc01 
! --------
!  
! (1 row)
! 
! select * from forc_test;
!   i   | j  
! ------+----
!   100 |  2
!   200 |  4
!   300 |  6
!   400 |  8
!   500 | 10
!   600 | 12
!   700 | 14
!   800 | 16
!   900 | 18
!  1000 | 20
! (10 rows)
! 
! -- same, with a cursor whose portal name doesn't match variable name
! create or replace function forc01() returns void as $$
! declare
!   c refcursor := 'fooled_ya';
!   r record;
! begin
!   open c for select * from forc_test;
!   loop
!     fetch c into r;
!     exit when not found;
!     raise notice '%, %', r.i, r.j;
!     update forc_test set i = i * 100, j = r.j * 2 where current of c;
!   end loop;
! end;
! $$ language plpgsql;
! select forc01();
! NOTICE:  100, 2
! NOTICE:  200, 4
! NOTICE:  300, 6
! NOTICE:  400, 8
! NOTICE:  500, 10
! NOTICE:  600, 12
! NOTICE:  700, 14
! NOTICE:  800, 16
! NOTICE:  900, 18
! NOTICE:  1000, 20
!  forc01 
! --------
!  
! (1 row)
! 
! select * from forc_test;
!    i    | j  
! --------+----
!   10000 |  4
!   20000 |  8
!   30000 | 12
!   40000 | 16
!   50000 | 20
!   60000 | 24
!   70000 | 28
!   80000 | 32
!   90000 | 36
!  100000 | 40
! (10 rows)
! 
! drop function forc01();
! -- fail because cursor has no query bound to it
! create or replace function forc_bad() returns void as $$
! declare
!   c refcursor;
! begin
!   for r in c loop
!     raise notice '%', r.i;
!   end loop;
! end;
! $$ language plpgsql;
! ERROR:  cursor FOR loop must use a bound cursor variable
! LINE 5:   for r in c loop
!                    ^
! -- test RETURN QUERY EXECUTE
! create or replace function return_dquery()
! returns setof int as $$
! begin
!   return query execute 'select * from (values(10),(20)) f';
!   return query execute 'select * from (values($1),($2)) f' using 40,50;
! end;
! $$ language plpgsql;
! select * from return_dquery();
!  return_dquery 
! ---------------
!             10
!             20
!             40
!             50
! (4 rows)
! 
! drop function return_dquery();
! -- test RETURN QUERY with dropped columns
! create table tabwithcols(a int, b int, c int, d int);
! insert into tabwithcols values(10,20,30,40),(50,60,70,80);
! create or replace function returnqueryf()
! returns setof tabwithcols as $$
! begin
!   return query select * from tabwithcols;
!   return query execute 'select * from tabwithcols';
! end;
! $$ language plpgsql;
! select * from returnqueryf();
!  a  | b  | c  | d  
! ----+----+----+----
!  10 | 20 | 30 | 40
!  50 | 60 | 70 | 80
!  10 | 20 | 30 | 40
!  50 | 60 | 70 | 80
! (4 rows)
! 
! alter table tabwithcols drop column b;
! select * from returnqueryf();
!  a  | c  | d  
! ----+----+----
!  10 | 30 | 40
!  50 | 70 | 80
!  10 | 30 | 40
!  50 | 70 | 80
! (4 rows)
! 
! alter table tabwithcols drop column d;
! select * from returnqueryf();
!  a  | c  
! ----+----
!  10 | 30
!  50 | 70
!  10 | 30
!  50 | 70
! (4 rows)
! 
! alter table tabwithcols add column d int;
! select * from returnqueryf();
!  a  | c  | d 
! ----+----+---
!  10 | 30 |  
!  50 | 70 |  
!  10 | 30 |  
!  50 | 70 |  
! (4 rows)
! 
! drop function returnqueryf();
! drop table tabwithcols;
! --
! -- Tests for composite-type results
! --
! create type compostype as (x int, y varchar);
! -- test: use of variable of composite type in return statement
! create or replace function compos() returns compostype as $$
! declare
!   v compostype;
! begin
!   v := (1, 'hello');
!   return v;
! end;
! $$ language plpgsql;
! select compos();
!   compos   
! -----------
!  (1,hello)
! (1 row)
! 
! -- test: use of variable of record type in return statement
! create or replace function compos() returns compostype as $$
! declare
!   v record;
! begin
!   v := (1, 'hello'::varchar);
!   return v;
! end;
! $$ language plpgsql;
! select compos();
!   compos   
! -----------
!  (1,hello)
! (1 row)
! 
! -- test: use of row expr in return statement
! create or replace function compos() returns compostype as $$
! begin
!   return (1, 'hello'::varchar);
! end;
! $$ language plpgsql;
! select compos();
!   compos   
! -----------
!  (1,hello)
! (1 row)
! 
! -- this does not work currently (no implicit casting)
! create or replace function compos() returns compostype as $$
! begin
!   return (1, 'hello');
! end;
! $$ language plpgsql;
! select compos();
! ERROR:  returned record type does not match expected record type
! DETAIL:  Returned type unknown does not match expected type character varying in column 2.
! CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
! -- ... but this does
! create or replace function compos() returns compostype as $$
! begin
!   return (1, 'hello')::compostype;
! end;
! $$ language plpgsql;
! select compos();
!   compos   
! -----------
!  (1,hello)
! (1 row)
! 
! drop function compos();
! -- test: return a row expr as record.
! create or replace function composrec() returns record as $$
! declare
!   v record;
! begin
!   v := (1, 'hello');
!   return v;
! end;
! $$ language plpgsql;
! select composrec();
!  composrec 
! -----------
!  (1,hello)
! (1 row)
! 
! -- test: return row expr in return statement.
! create or replace function composrec() returns record as $$
! begin
!   return (1, 'hello');
! end;
! $$ language plpgsql;
! select composrec();
!  composrec 
! -----------
!  (1,hello)
! (1 row)
! 
! drop function composrec();
! -- test: row expr in RETURN NEXT statement.
! create or replace function compos() returns setof compostype as $$
! begin
!   for i in 1..3
!   loop
!     return next (1, 'hello'::varchar);
!   end loop;
!   return next null::compostype;
!   return next (2, 'goodbye')::compostype;
! end;
! $$ language plpgsql;
! select * from compos();
!  x |    y    
! ---+---------
!  1 | hello
!  1 | hello
!  1 | hello
!    | 
!  2 | goodbye
! (5 rows)
! 
! drop function compos();
! -- test: use invalid expr in return statement.
! create or replace function compos() returns compostype as $$
! begin
!   return 1 + 1;
! end;
! $$ language plpgsql;
! select compos();
! ERROR:  cannot return non-composite value from function returning composite type
! CONTEXT:  PL/pgSQL function compos() line 3 at RETURN
! drop function compos();
! drop type compostype;
! --
! -- Tests for 8.4's new RAISE features
! --
! create or replace function raise_test() returns void as $$
! begin
!   raise notice '% % %', 1, 2, 3
!      using errcode = '55001', detail = 'some detail info', hint = 'some hint';
!   raise '% % %', 1, 2, 3
!      using errcode = 'division_by_zero', detail = 'some detail info';
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  1 2 3
! DETAIL:  some detail info
! HINT:  some hint
! ERROR:  1 2 3
! DETAIL:  some detail info
! -- Since we can't actually see the thrown SQLSTATE in default psql output,
! -- test it like this; this also tests re-RAISE
! create or replace function raise_test() returns void as $$
! begin
!   raise 'check me'
!      using errcode = 'division_by_zero', detail = 'some detail info';
!   exception
!     when others then
!       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
!       raise;
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  SQLSTATE: 22012 SQLERRM: check me
! ERROR:  check me
! DETAIL:  some detail info
! create or replace function raise_test() returns void as $$
! begin
!   raise 'check me'
!      using errcode = '1234F', detail = 'some detail info';
!   exception
!     when others then
!       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
!       raise;
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  SQLSTATE: 1234F SQLERRM: check me
! ERROR:  check me
! DETAIL:  some detail info
! -- SQLSTATE specification in WHEN
! create or replace function raise_test() returns void as $$
! begin
!   raise 'check me'
!      using errcode = '1234F', detail = 'some detail info';
!   exception
!     when sqlstate '1234F' then
!       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
!       raise;
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  SQLSTATE: 1234F SQLERRM: check me
! ERROR:  check me
! DETAIL:  some detail info
! create or replace function raise_test() returns void as $$
! begin
!   raise division_by_zero using detail = 'some detail info';
!   exception
!     when others then
!       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
!       raise;
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  SQLSTATE: 22012 SQLERRM: division_by_zero
! ERROR:  division_by_zero
! DETAIL:  some detail info
! create or replace function raise_test() returns void as $$
! begin
!   raise division_by_zero;
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  division_by_zero
! create or replace function raise_test() returns void as $$
! begin
!   raise sqlstate '1234F';
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  1234F
! create or replace function raise_test() returns void as $$
! begin
!   raise division_by_zero using message = 'custom' || ' message';
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  custom message
! create or replace function raise_test() returns void as $$
! begin
!   raise using message = 'custom' || ' message', errcode = '22012';
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  custom message
! -- conflict on message
! create or replace function raise_test() returns void as $$
! begin
!   raise notice 'some message' using message = 'custom' || ' message', errcode = '22012';
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  RAISE option already specified: MESSAGE
! CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
! -- conflict on errcode
! create or replace function raise_test() returns void as $$
! begin
!   raise division_by_zero using message = 'custom' || ' message', errcode = '22012';
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  RAISE option already specified: ERRCODE
! CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
! -- nothing to re-RAISE
! create or replace function raise_test() returns void as $$
! begin
!   raise;
! end;
! $$ language plpgsql;
! select raise_test();
! ERROR:  RAISE without parameters cannot be used outside an exception handler
! CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
! -- test access to exception data
! create function zero_divide() returns int as $$
! declare v int := 0;
! begin
!   return 10 / v;
! end;
! $$ language plpgsql;
! create or replace function raise_test() returns void as $$
! begin
!   raise exception 'custom exception'
!      using detail = 'some detail of custom exception',
!            hint = 'some hint related to custom exception';
! end;
! $$ language plpgsql;
! create function stacked_diagnostics_test() returns void as $$
! declare _sqlstate text;
!         _message text;
!         _context text;
! begin
!   perform zero_divide();
! exception when others then
!   get stacked diagnostics
!         _sqlstate = returned_sqlstate,
!         _message = message_text,
!         _context = pg_exception_context;
!   raise notice 'sqlstate: %, message: %, context: [%]',
!     _sqlstate, _message, replace(_context, E'\n', ' <- ');
! end;
! $$ language plpgsql;
! select stacked_diagnostics_test();
! NOTICE:  sqlstate: 22012, message: division by zero, context: [PL/pgSQL function zero_divide() line 4 at RETURN <- SQL statement "SELECT zero_divide()" <- PL/pgSQL function stacked_diagnostics_test() line 6 at PERFORM]
!  stacked_diagnostics_test 
! --------------------------
!  
! (1 row)
! 
! create or replace function stacked_diagnostics_test() returns void as $$
! declare _detail text;
!         _hint text;
!         _message text;
! begin
!   perform raise_test();
! exception when others then
!   get stacked diagnostics
!         _message = message_text,
!         _detail = pg_exception_detail,
!         _hint = pg_exception_hint;
!   raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
! end;
! $$ language plpgsql;
! select stacked_diagnostics_test();
! NOTICE:  message: custom exception, detail: some detail of custom exception, hint: some hint related to custom exception
!  stacked_diagnostics_test 
! --------------------------
!  
! (1 row)
! 
! -- fail, cannot use stacked diagnostics statement outside handler
! create or replace function stacked_diagnostics_test() returns void as $$
! declare _detail text;
!         _hint text;
!         _message text;
! begin
!   get stacked diagnostics
!         _message = message_text,
!         _detail = pg_exception_detail,
!         _hint = pg_exception_hint;
!   raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
! end;
! $$ language plpgsql;
! select stacked_diagnostics_test();
! ERROR:  GET STACKED DIAGNOSTICS cannot be used outside an exception handler
! CONTEXT:  PL/pgSQL function stacked_diagnostics_test() line 6 at GET DIAGNOSTICS
! drop function zero_divide();
! drop function stacked_diagnostics_test();
! -- check cases where implicit SQLSTATE variable could be confused with
! -- SQLSTATE as a keyword, cf bug #5524
! create or replace function raise_test() returns void as $$
! begin
!   perform 1/0;
! exception
!   when sqlstate '22012' then
!     raise notice using message = sqlstate;
!     raise sqlstate '22012' using message = 'substitute message';
! end;
! $$ language plpgsql;
! select raise_test();
! NOTICE:  22012
! ERROR:  substitute message
! drop function raise_test();
! -- test passing column_name, constraint_name, datatype_name, table_name
! -- and schema_name error fields
! create or replace function stacked_diagnostics_test() returns void as $$
! declare _column_name text;
!         _constraint_name text;
!         _datatype_name text;
!         _table_name text;
!         _schema_name text;
! begin
!   raise exception using
!     column = '>>some column name<<',
!     constraint = '>>some constraint name<<',
!     datatype = '>>some datatype name<<',
!     table = '>>some table name<<',
!     schema = '>>some schema name<<';
! exception when others then
!   get stacked diagnostics
!         _column_name = column_name,
!         _constraint_name = constraint_name,
!         _datatype_name = pg_datatype_name,
!         _table_name = table_name,
!         _schema_name = schema_name;
!   raise notice 'column %, constraint %, type %, table %, schema %',
!     _column_name, _constraint_name, _datatype_name, _table_name, _schema_name;
! end;
! $$ language plpgsql;
! select stacked_diagnostics_test();
! NOTICE:  column >>some column name<<, constraint >>some constraint name<<, type >>some datatype name<<, table >>some table name<<, schema >>some schema name<<
!  stacked_diagnostics_test 
! --------------------------
!  
! (1 row)
! 
! drop function stacked_diagnostics_test();
! -- test CASE statement
! create or replace function case_test(bigint) returns text as $$
! declare a int = 10;
!         b int = 1;
! begin
!   case $1
!     when 1 then
!       return 'one';
!     when 2 then
!       return 'two';
!     when 3,4,3+5 then
!       return 'three, four or eight';
!     when a then
!       return 'ten';
!     when a+b, a+b+1 then
!       return 'eleven, twelve';
!   end case;
! end;
! $$ language plpgsql immutable;
! select case_test(1);
!  case_test 
! -----------
!  one
! (1 row)
! 
! select case_test(2);
!  case_test 
! -----------
!  two
! (1 row)
! 
! select case_test(3);
!       case_test       
! ----------------------
!  three, four or eight
! (1 row)
! 
! select case_test(4);
!       case_test       
! ----------------------
!  three, four or eight
! (1 row)
! 
! select case_test(5); -- fails
! ERROR:  case not found
! HINT:  CASE statement is missing ELSE part.
! CONTEXT:  PL/pgSQL function case_test(bigint) line 5 at CASE
! select case_test(8);
!       case_test       
! ----------------------
!  three, four or eight
! (1 row)
! 
! select case_test(10);
!  case_test 
! -----------
!  ten
! (1 row)
! 
! select case_test(11);
!    case_test    
! ----------------
!  eleven, twelve
! (1 row)
! 
! select case_test(12);
!    case_test    
! ----------------
!  eleven, twelve
! (1 row)
! 
! select case_test(13); -- fails
! ERROR:  case not found
! HINT:  CASE statement is missing ELSE part.
! CONTEXT:  PL/pgSQL function case_test(bigint) line 5 at CASE
! create or replace function catch() returns void as $$
! begin
!   raise notice '%', case_test(6);
! exception
!   when case_not_found then
!     raise notice 'caught case_not_found % %', SQLSTATE, SQLERRM;
! end
! $$ language plpgsql;
! select catch();
! NOTICE:  caught case_not_found 20000 case not found
!  catch 
! -------
!  
! (1 row)
! 
! -- test the searched variant too, as well as ELSE
! create or replace function case_test(bigint) returns text as $$
! declare a int = 10;
! begin
!   case
!     when $1 = 1 then
!       return 'one';
!     when $1 = a + 2 then
!       return 'twelve';
!     else
!       return 'other';
!   end case;
! end;
! $$ language plpgsql immutable;
! select case_test(1);
!  case_test 
! -----------
!  one
! (1 row)
! 
! select case_test(2);
!  case_test 
! -----------
!  other
! (1 row)
! 
! select case_test(12);
!  case_test 
! -----------
!  twelve
! (1 row)
! 
! select case_test(13);
!  case_test 
! -----------
!  other
! (1 row)
! 
! drop function catch();
! drop function case_test(bigint);
! -- test variadic functions
! create or replace function vari(variadic int[])
! returns void as $$
! begin
!   for i in array_lower($1,1)..array_upper($1,1) loop
!     raise notice '%', $1[i];
!   end loop; end;
! $$ language plpgsql;
! select vari(1,2,3,4,5);
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
! NOTICE:  5
!  vari 
! ------
!  
! (1 row)
! 
! select vari(3,4,5);
! NOTICE:  3
! NOTICE:  4
! NOTICE:  5
!  vari 
! ------
!  
! (1 row)
! 
! select vari(variadic array[5,6,7]);
! NOTICE:  5
! NOTICE:  6
! NOTICE:  7
!  vari 
! ------
!  
! (1 row)
! 
! drop function vari(int[]);
! -- coercion test
! create or replace function pleast(variadic numeric[])
! returns numeric as $$
! declare aux numeric = $1[array_lower($1,1)];
! begin
!   for i in array_lower($1,1)+1..array_upper($1,1) loop
!     if $1[i] < aux then aux := $1[i]; end if;
!   end loop;
!   return aux;
! end;
! $$ language plpgsql immutable strict;
! select pleast(10,1,2,3,-16);
!  pleast 
! --------
!     -16
! (1 row)
! 
! select pleast(10.2,2.2,-1.1);
!  pleast 
! --------
!    -1.1
! (1 row)
! 
! select pleast(10.2,10, -20);
!  pleast 
! --------
!     -20
! (1 row)
! 
! select pleast(10,20, -1.0);
!  pleast 
! --------
!    -1.0
! (1 row)
! 
! -- in case of conflict, non-variadic version is preferred
! create or replace function pleast(numeric)
! returns numeric as $$
! begin
!   raise notice 'non-variadic function called';
!   return $1;
! end;
! $$ language plpgsql immutable strict;
! select pleast(10);
! NOTICE:  non-variadic function called
!  pleast 
! --------
!      10
! (1 row)
! 
! drop function pleast(numeric[]);
! drop function pleast(numeric);
! -- test table functions
! create function tftest(int) returns table(a int, b int) as $$
! begin
!   return query select $1, $1+i from generate_series(1,5) g(i);
! end;
! $$ language plpgsql immutable strict;
! select * from tftest(10);
!  a  | b  
! ----+----
!  10 | 11
!  10 | 12
!  10 | 13
!  10 | 14
!  10 | 15
! (5 rows)
! 
! create or replace function tftest(a1 int) returns table(a int, b int) as $$
! begin
!   a := a1; b := a1 + 1;
!   return next;
!   a := a1 * 10; b := a1 * 10 + 1;
!   return next;
! end;
! $$ language plpgsql immutable strict;
! select * from tftest(10);
!   a  |  b  
! -----+-----
!   10 |  11
!  100 | 101
! (2 rows)
! 
! drop function tftest(int);
! create or replace function rttest()
! returns setof int as $$
! declare rc int;
! begin
!   return query values(10),(20);
!   get diagnostics rc = row_count;
!   raise notice '% %', found, rc;
!   return query select * from (values(10),(20)) f(a) where false;
!   get diagnostics rc = row_count;
!   raise notice '% %', found, rc;
!   return query execute 'values(10),(20)';
!   get diagnostics rc = row_count;
!   raise notice '% %', found, rc;
!   return query execute 'select * from (values(10),(20)) f(a) where false';
!   get diagnostics rc = row_count;
!   raise notice '% %', found, rc;
! end;
! $$ language plpgsql;
! select * from rttest();
! NOTICE:  t 2
! NOTICE:  f 0
! NOTICE:  t 2
! NOTICE:  f 0
!  rttest 
! --------
!      10
!      20
!      10
!      20
! (4 rows)
! 
! drop function rttest();
! -- Test for proper cleanup at subtransaction exit.  This example
! -- exposed a bug in PG 8.2.
! CREATE FUNCTION leaker_1(fail BOOL) RETURNS INTEGER AS $$
! DECLARE
!   v_var INTEGER;
! BEGIN
!   BEGIN
!     v_var := (leaker_2(fail)).error_code;
!   EXCEPTION
!     WHEN others THEN RETURN 0;
!   END;
!   RETURN 1;
! END;
! $$ LANGUAGE plpgsql;
! CREATE FUNCTION leaker_2(fail BOOL, OUT error_code INTEGER, OUT new_id INTEGER)
!   RETURNS RECORD AS $$
! BEGIN
!   IF fail THEN
!     RAISE EXCEPTION 'fail ...';
!   END IF;
!   error_code := 1;
!   new_id := 1;
!   RETURN;
! END;
! $$ LANGUAGE plpgsql;
! SELECT * FROM leaker_1(false);
!  leaker_1 
! ----------
!         1
! (1 row)
! 
! SELECT * FROM leaker_1(true);
!  leaker_1 
! ----------
!         0
! (1 row)
! 
! DROP FUNCTION leaker_1(bool);
! DROP FUNCTION leaker_2(bool);
! -- Test for appropriate cleanup of non-simple expression evaluations
! -- (bug in all versions prior to August 2010)
! CREATE FUNCTION nonsimple_expr_test() RETURNS text[] AS $$
! DECLARE
!   arr text[];
!   lr text;
!   i integer;
! BEGIN
!   arr := array[array['foo','bar'], array['baz', 'quux']];
!   lr := 'fool';
!   i := 1;
!   -- use sub-SELECTs to make expressions non-simple
!   arr[(SELECT i)][(SELECT i+1)] := (SELECT lr);
!   RETURN arr;
! END;
! $$ LANGUAGE plpgsql;
! SELECT nonsimple_expr_test();
!    nonsimple_expr_test   
! -------------------------
!  {{foo,fool},{baz,quux}}
! (1 row)
! 
! DROP FUNCTION nonsimple_expr_test();
! CREATE FUNCTION nonsimple_expr_test() RETURNS integer AS $$
! declare
!    i integer NOT NULL := 0;
! begin
!   begin
!     i := (SELECT NULL::integer);  -- should throw error
!   exception
!     WHEN OTHERS THEN
!       i := (SELECT 1::integer);
!   end;
!   return i;
! end;
! $$ LANGUAGE plpgsql;
! SELECT nonsimple_expr_test();
!  nonsimple_expr_test 
! ---------------------
!                    1
! (1 row)
! 
! DROP FUNCTION nonsimple_expr_test();
! --
! -- Test cases involving recursion and error recovery in simple expressions
! -- (bugs in all versions before October 2010).  The problems are most
! -- easily exposed by mutual recursion between plpgsql and sql functions.
! --
! create function recurse(float8) returns float8 as
! $$
! begin
!   if ($1 > 0) then
!     return sql_recurse($1 - 1);
!   else
!     return $1;
!   end if;
! end;
! $$ language plpgsql;
! -- "limit" is to prevent this from being inlined
! create function sql_recurse(float8) returns float8 as
! $$ select recurse($1) limit 1; $$ language sql;
! select recurse(10);
!  recurse 
! ---------
!        0
! (1 row)
! 
! create function error1(text) returns text language sql as
! $$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
! create function error2(p_name_table text) returns text language plpgsql as $$
! begin
!   return error1(p_name_table);
! end$$;
! BEGIN;
! create table public.stuffs (stuff text);
! SAVEPOINT a;
! select error2('nonexistent.stuffs');
! ERROR:  schema "nonexistent" does not exist
! CONTEXT:  SQL function "error1" statement 1
! PL/pgSQL function error2(text) line 3 at RETURN
! ROLLBACK TO a;
! select error2('public.stuffs');
!  error2 
! --------
!  stuffs
! (1 row)
! 
! rollback;
! drop function error2(p_name_table text);
! drop function error1(text);
! -- Test for consistent reporting of error context
! create function fail() returns int language plpgsql as $$
! begin
!   return 1/0;
! end
! $$;
! select fail();
! ERROR:  division by zero
! CONTEXT:  SQL statement "SELECT 1/0"
! PL/pgSQL function fail() line 3 at RETURN
! select fail();
! ERROR:  division by zero
! CONTEXT:  SQL statement "SELECT 1/0"
! PL/pgSQL function fail() line 3 at RETURN
! drop function fail();
! -- Test handling of string literals.
! set standard_conforming_strings = off;
! create or replace function strtest() returns text as $$
! begin
!   raise notice 'foo\\bar\041baz';
!   return 'foo\\bar\041baz';
! end
! $$ language plpgsql;
! WARNING:  nonstandard use of \\ in a string literal
! LINE 3:   raise notice 'foo\\bar\041baz';
!                        ^
! HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
! WARNING:  nonstandard use of \\ in a string literal
! LINE 4:   return 'foo\\bar\041baz';
!                  ^
! HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
! WARNING:  nonstandard use of \\ in a string literal
! LINE 4:   return 'foo\\bar\041baz';
!                  ^
! HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
! select strtest();
! NOTICE:  foo\bar!baz
! WARNING:  nonstandard use of \\ in a string literal
! LINE 1: SELECT 'foo\\bar\041baz'
!                ^
! HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
! QUERY:  SELECT 'foo\\bar\041baz'
! CONTEXT:  PL/pgSQL function strtest() line 4 at RETURN
!    strtest   
! -------------
!  foo\bar!baz
! (1 row)
! 
! create or replace function strtest() returns text as $$
! begin
!   raise notice E'foo\\bar\041baz';
!   return E'foo\\bar\041baz';
! end
! $$ language plpgsql;
! select strtest();
! NOTICE:  foo\bar!baz
!    strtest   
! -------------
!  foo\bar!baz
! (1 row)
! 
! set standard_conforming_strings = on;
! create or replace function strtest() returns text as $$
! begin
!   raise notice 'foo\\bar\041baz\';
!   return 'foo\\bar\041baz\';
! end
! $$ language plpgsql;
! select strtest();
! NOTICE:  foo\\bar\041baz\
!      strtest      
! ------------------
!  foo\\bar\041baz\
! (1 row)
! 
! create or replace function strtest() returns text as $$
! begin
!   raise notice E'foo\\bar\041baz';
!   return E'foo\\bar\041baz';
! end
! $$ language plpgsql;
! select strtest();
! NOTICE:  foo\bar!baz
!    strtest   
! -------------
!  foo\bar!baz
! (1 row)
! 
! drop function strtest();
! -- Test anonymous code blocks.
! DO $$
! DECLARE r record;
! BEGIN
!     FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno
!     LOOP
!         RAISE NOTICE '%, %', r.roomno, r.comment;
!     END LOOP;
! END$$;
! NOTICE:  001, Entrance
! NOTICE:  002, Office
! NOTICE:  003, Office
! NOTICE:  004, Technical
! NOTICE:  101, Office
! NOTICE:  102, Conference
! NOTICE:  103, Restroom
! NOTICE:  104, Technical
! NOTICE:  105, Office
! NOTICE:  106, Office
! -- these are to check syntax error reporting
! DO LANGUAGE plpgsql $$begin return 1; end$$;
! ERROR:  RETURN cannot have a parameter in function returning void
! LINE 1: DO LANGUAGE plpgsql $$begin return 1; end$$;
!                                            ^
! DO $$
! DECLARE r record;
! BEGIN
!     FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
!     LOOP
!         RAISE NOTICE '%, %', r.roomno, r.comment;
!     END LOOP;
! END$$;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomn...
!                                         ^
! QUERY:  SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
! CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows
! -- Check handling of errors thrown from/into anonymous code blocks.
! do $outer$
! begin
!   for i in 1..10 loop
!    begin
!     execute $ex$
!       do $$
!       declare x int = 0;
!       begin
!         x := 1 / x;
!       end;
!       $$;
!     $ex$;
!   exception when division_by_zero then
!     raise notice 'caught division by zero';
!   end;
!   end loop;
! end;
! $outer$;
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! NOTICE:  caught division by zero
! -- Check variable scoping -- a var is not available in its own or prior
! -- default expressions.
! create function scope_test() returns int as $$
! declare x int := 42;
! begin
!   declare y int := x + 1;
!           x int := x + 2;
!   begin
!     return x * 100 + y;
!   end;
! end;
! $$ language plpgsql;
! select scope_test();
!  scope_test 
! ------------
!        4443
! (1 row)
! 
! drop function scope_test();
! -- Check handling of conflicts between plpgsql vars and table columns.
! set plpgsql.variable_conflict = error;
! create function conflict_test() returns setof int8_tbl as $$
! declare r record;
!   q1 bigint := 42;
! begin
!   for r in select q1,q2 from int8_tbl loop
!     return next r;
!   end loop;
! end;
! $$ language plpgsql;
! select * from conflict_test();
! ERROR:  column reference "q1" is ambiguous
! LINE 1: select q1,q2 from int8_tbl
!                ^
! DETAIL:  It could refer to either a PL/pgSQL variable or a table column.
! QUERY:  select q1,q2 from int8_tbl
! CONTEXT:  PL/pgSQL function conflict_test() line 5 at FOR over SELECT rows
! create or replace function conflict_test() returns setof int8_tbl as $$
! #variable_conflict use_variable
! declare r record;
!   q1 bigint := 42;
! begin
!   for r in select q1,q2 from int8_tbl loop
!     return next r;
!   end loop;
! end;
! $$ language plpgsql;
! select * from conflict_test();
!  q1 |        q2         
! ----+-------------------
!  42 |               456
!  42 |  4567890123456789
!  42 |               123
!  42 |  4567890123456789
!  42 | -4567890123456789
! (5 rows)
! 
! create or replace function conflict_test() returns setof int8_tbl as $$
! #variable_conflict use_column
! declare r record;
!   q1 bigint := 42;
! begin
!   for r in select q1,q2 from int8_tbl loop
!     return next r;
!   end loop;
! end;
! $$ language plpgsql;
! select * from conflict_test();
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (5 rows)
! 
! drop function conflict_test();
! -- Check that an unreserved keyword can be used as a variable name
! create function unreserved_test() returns int as $$
! declare
!   forward int := 21;
! begin
!   forward := forward * 2;
!   return forward;
! end
! $$ language plpgsql;
! select unreserved_test();
!  unreserved_test 
! -----------------
!               42
! (1 row)
! 
! drop function unreserved_test();
! --
! -- Test FOREACH over arrays
! --
! create function foreach_test(anyarray)
! returns void as $$
! declare x int;
! begin
!   foreach x in array $1
!   loop
!     raise notice '%', x;
!   end loop;
!   end;
! $$ language plpgsql;
! select foreach_test(ARRAY[1,2,3,4]);
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[1,2],[3,4]]);
! NOTICE:  1
! NOTICE:  2
! NOTICE:  3
! NOTICE:  4
!  foreach_test 
! --------------
!  
! (1 row)
! 
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare x int;
! begin
!   foreach x slice 1 in array $1
!   loop
!     raise notice '%', x;
!   end loop;
!   end;
! $$ language plpgsql;
! -- should fail
! select foreach_test(ARRAY[1,2,3,4]);
! ERROR:  FOREACH ... SLICE loop variable must be of an array type
! CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
! select foreach_test(ARRAY[[1,2],[3,4]]);
! ERROR:  FOREACH ... SLICE loop variable must be of an array type
! CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare x int[];
! begin
!   foreach x slice 1 in array $1
!   loop
!     raise notice '%', x;
!   end loop;
!   end;
! $$ language plpgsql;
! select foreach_test(ARRAY[1,2,3,4]);
! NOTICE:  {1,2,3,4}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[1,2],[3,4]]);
! NOTICE:  {1,2}
! NOTICE:  {3,4}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! -- higher level of slicing
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare x int[];
! begin
!   foreach x slice 2 in array $1
!   loop
!     raise notice '%', x;
!   end loop;
!   end;
! $$ language plpgsql;
! -- should fail
! select foreach_test(ARRAY[1,2,3,4]);
! ERROR:  slice dimension (2) is out of the valid range 0..1
! CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
! -- ok
! select foreach_test(ARRAY[[1,2],[3,4]]);
! NOTICE:  {{1,2},{3,4}}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[[1,2]],[[3,4]]]);
! NOTICE:  {{1,2}}
! NOTICE:  {{3,4}}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! create type xy_tuple AS (x int, y int);
! -- iteration over array of records
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare r record;
! begin
!   foreach r in array $1
!   loop
!     raise notice '%', r;
!   end loop;
!   end;
! $$ language plpgsql;
! select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
! NOTICE:  (10,20)
! NOTICE:  (40,69)
! NOTICE:  (35,78)
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
! NOTICE:  (10,20)
! NOTICE:  (40,69)
! NOTICE:  (35,78)
! NOTICE:  (88,76)
!  foreach_test 
! --------------
!  
! (1 row)
! 
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare x int; y int;
! begin
!   foreach x, y in array $1
!   loop
!     raise notice 'x = %, y = %', x, y;
!   end loop;
!   end;
! $$ language plpgsql;
! select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
! NOTICE:  x = 10, y = 20
! NOTICE:  x = 40, y = 69
! NOTICE:  x = 35, y = 78
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
! NOTICE:  x = 10, y = 20
! NOTICE:  x = 40, y = 69
! NOTICE:  x = 35, y = 78
! NOTICE:  x = 88, y = 76
!  foreach_test 
! --------------
!  
! (1 row)
! 
! -- slicing over array of composite types
! create or replace function foreach_test(anyarray)
! returns void as $$
! declare x xy_tuple[];
! begin
!   foreach x slice 1 in array $1
!   loop
!     raise notice '%', x;
!   end loop;
!   end;
! $$ language plpgsql;
! select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
! NOTICE:  {"(10,20)","(40,69)","(35,78)"}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
! NOTICE:  {"(10,20)","(40,69)"}
! NOTICE:  {"(35,78)","(88,76)"}
!  foreach_test 
! --------------
!  
! (1 row)
! 
! drop function foreach_test(anyarray);
! drop type xy_tuple;
! --
! -- Assorted tests for array subscript assignment
! --
! create temp table rtype (id int, ar text[]);
! create function arrayassign1() returns text[] language plpgsql as $$
! declare
!  r record;
! begin
!   r := row(12, '{foo,bar,baz}')::rtype;
!   r.ar[2] := 'replace';
!   return r.ar;
! end$$;
! select arrayassign1();
!    arrayassign1    
! -------------------
!  {foo,replace,baz}
! (1 row)
! 
! select arrayassign1(); -- try again to exercise internal caching
!    arrayassign1    
! -------------------
!  {foo,replace,baz}
! (1 row)
! 
! create domain orderedarray as int[2]
!   constraint sorted check (value[1] < value[2]);
! select '{1,2}'::orderedarray;
!  orderedarray 
! --------------
!  {1,2}
! (1 row)
! 
! select '{2,1}'::orderedarray;  -- fail
! ERROR:  value for domain orderedarray violates check constraint "sorted"
! create function testoa(x1 int, x2 int, x3 int) returns orderedarray
! language plpgsql as $$
! declare res orderedarray;
! begin
!   res := array[x1, x2];
!   res[2] := x3;
!   return res;
! end$$;
! select testoa(1,2,3);
!  testoa 
! --------
!  {1,3}
! (1 row)
! 
! select testoa(1,2,3); -- try again to exercise internal caching
!  testoa 
! --------
!  {1,3}
! (1 row)
! 
! select testoa(2,1,3); -- fail at initial assign
! ERROR:  value for domain orderedarray violates check constraint "sorted"
! CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 4 at assignment
! select testoa(1,2,1); -- fail at update
! ERROR:  value for domain orderedarray violates check constraint "sorted"
! CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 5 at assignment
! drop function arrayassign1();
! drop function testoa(x1 int, x2 int, x3 int);
! -- access to call stack
! create function inner_func(int)
! returns int as $$
! declare _context text;
! begin
!   get diagnostics _context = pg_context;
!   raise notice '***%***', _context;
!   -- lets do it again, just for fun..
!   get diagnostics _context = pg_context;
!   raise notice '***%***', _context;
!   raise notice 'lets make sure we didnt break anything';
!   return 2 * $1;
! end;
! $$ language plpgsql;
! create or replace function outer_func(int)
! returns int as $$
! declare
!   myresult int;
! begin
!   raise notice 'calling down into inner_func()';
!   myresult := inner_func($1);
!   raise notice 'inner_func() done';
!   return myresult;
! end;
! $$ language plpgsql;
! create or replace function outer_outer_func(int)
! returns int as $$
! declare
!   myresult int;
! begin
!   raise notice 'calling down into outer_func()';
!   myresult := outer_func($1);
!   raise notice 'outer_func() done';
!   return myresult;
! end;
! $$ language plpgsql;
! select outer_outer_func(10);
! NOTICE:  calling down into outer_func()
! NOTICE:  calling down into inner_func()
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 4 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 7 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  lets make sure we didnt break anything
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  inner_func() done
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  outer_func() done
!  outer_outer_func 
! ------------------
!                20
! (1 row)
! 
! -- repeated call should to work
! select outer_outer_func(20);
! NOTICE:  calling down into outer_func()
! NOTICE:  calling down into inner_func()
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 4 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 7 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  lets make sure we didnt break anything
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  inner_func() done
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  outer_func() done
!  outer_outer_func 
! ------------------
!                40
! (1 row)
! 
! drop function outer_outer_func(int);
! drop function outer_func(int);
! drop function inner_func(int);
! -- access to call stack from exception
! create function inner_func(int)
! returns int as $$
! declare
!   _context text;
!   sx int := 5;
! begin
!   begin
!     perform sx / 0;
!   exception
!     when division_by_zero then
!       get diagnostics _context = pg_context;
!       raise notice '***%***', _context;
!   end;
! 
!   -- lets do it again, just for fun..
!   get diagnostics _context = pg_context;
!   raise notice '***%***', _context;
!   raise notice 'lets make sure we didnt break anything';
!   return 2 * $1;
! end;
! $$ language plpgsql;
! create or replace function outer_func(int)
! returns int as $$
! declare
!   myresult int;
! begin
!   raise notice 'calling down into inner_func()';
!   myresult := inner_func($1);
!   raise notice 'inner_func() done';
!   return myresult;
! end;
! $$ language plpgsql;
! create or replace function outer_outer_func(int)
! returns int as $$
! declare
!   myresult int;
! begin
!   raise notice 'calling down into outer_func()';
!   myresult := outer_func($1);
!   raise notice 'outer_func() done';
!   return myresult;
! end;
! $$ language plpgsql;
! select outer_outer_func(10);
! NOTICE:  calling down into outer_func()
! NOTICE:  calling down into inner_func()
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 10 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 15 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  lets make sure we didnt break anything
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  inner_func() done
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  outer_func() done
!  outer_outer_func 
! ------------------
!                20
! (1 row)
! 
! -- repeated call should to work
! select outer_outer_func(20);
! NOTICE:  calling down into outer_func()
! NOTICE:  calling down into inner_func()
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 10 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  ***PL/pgSQL function inner_func(integer) line 15 at GET DIAGNOSTICS
! PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  lets make sure we didnt break anything
! CONTEXT:  PL/pgSQL function outer_func(integer) line 6 at assignment
! PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  inner_func() done
! CONTEXT:  PL/pgSQL function outer_outer_func(integer) line 6 at assignment
! NOTICE:  outer_func() done
!  outer_outer_func 
! ------------------
!                40
! (1 row)
! 
! drop function outer_outer_func(int);
! drop function outer_func(int);
! drop function inner_func(int);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/copy2.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/copy2.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,437 ****
! CREATE TEMP TABLE x (
! 	a serial,
! 	b int,
! 	c text not null default 'stuff',
! 	d text,
! 	e text
! ) WITH OIDS;
! CREATE FUNCTION fn_x_before () RETURNS TRIGGER AS '
!   BEGIN
! 		NEW.e := ''before trigger fired''::text;
! 		return NEW;
! 	END;
! ' LANGUAGE plpgsql;
! CREATE FUNCTION fn_x_after () RETURNS TRIGGER AS '
!   BEGIN
! 		UPDATE x set e=''after trigger fired'' where c=''stuff'';
! 		return NULL;
! 	END;
! ' LANGUAGE plpgsql;
! CREATE TRIGGER trg_x_after AFTER INSERT ON x
! FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
! CREATE TRIGGER trg_x_before BEFORE INSERT ON x
! FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
! COPY x (a, b, c, d, e) from stdin;
! COPY x (b, d) from stdin;
! COPY x (b, d) from stdin;
! COPY x (a, b, c, d, e) from stdin;
! -- non-existent column in column list: should fail
! COPY x (xyz) from stdin;
! ERROR:  column "xyz" of relation "x" does not exist
! -- too many columns in column list: should fail
! COPY x (a, b, c, d, e, d, c) from stdin;
! ERROR:  column "d" specified more than once
! -- missing data: should fail
! COPY x from stdin;
! ERROR:  invalid input syntax for integer: ""
! CONTEXT:  COPY x, line 1, column a: ""
! COPY x from stdin;
! ERROR:  missing data for column "e"
! CONTEXT:  COPY x, line 1: "2000	230	23	23"
! COPY x from stdin;
! ERROR:  missing data for column "e"
! CONTEXT:  COPY x, line 1: "2001	231	\N	\N"
! -- extra data: should fail
! COPY x from stdin;
! ERROR:  extra data after last expected column
! CONTEXT:  COPY x, line 1: "2002	232	40	50	60	70	80"
! -- various COPY options: delimiters, oids, NULL string, encoding
! COPY x (b, c, d, e) from stdin with oids delimiter ',' null 'x';
! COPY x from stdin WITH DELIMITER AS ';' NULL AS '';
! COPY x from stdin WITH DELIMITER AS ':' NULL AS E'\\X' ENCODING 'sql_ascii';
! -- check results of copy in
! SELECT * FROM x;
!    a   | b  |     c      |   d    |          e           
! -------+----+------------+--------+----------------------
!   9999 |    | \N         | NN     | before trigger fired
!  10000 | 21 | 31         | 41     | before trigger fired
!  10001 | 22 | 32         | 42     | before trigger fired
!  10002 | 23 | 33         | 43     | before trigger fired
!  10003 | 24 | 34         | 44     | before trigger fired
!  10004 | 25 | 35         | 45     | before trigger fired
!  10005 | 26 | 36         | 46     | before trigger fired
!      6 |    | 45         | 80     | before trigger fired
!      7 |    | x          | \x     | before trigger fired
!      8 |    | ,          | \,     | before trigger fired
!   3000 |    | c          |        | before trigger fired
!   4000 |    | C          |        | before trigger fired
!   4001 |  1 | empty      |        | before trigger fired
!   4002 |  2 | null       |        | before trigger fired
!   4003 |  3 | Backslash  | \      | before trigger fired
!   4004 |  4 | BackslashX | \X     | before trigger fired
!   4005 |  5 | N          | N      | before trigger fired
!   4006 |  6 | BackslashN | \N     | before trigger fired
!   4007 |  7 | XX         | XX     | before trigger fired
!   4008 |  8 | Delimiter  | :      | before trigger fired
!      1 |  1 | stuff      | test_1 | after trigger fired
!      2 |  2 | stuff      | test_2 | after trigger fired
!      3 |  3 | stuff      | test_3 | after trigger fired
!      4 |  4 | stuff      | test_4 | after trigger fired
!      5 |  5 | stuff      | test_5 | after trigger fired
! (25 rows)
! 
! -- COPY w/ oids on a table w/o oids should fail
! CREATE TABLE no_oids (
! 	a	int,
! 	b	int
! ) WITHOUT OIDS;
! INSERT INTO no_oids (a, b) VALUES (5, 10);
! INSERT INTO no_oids (a, b) VALUES (20, 30);
! -- should fail
! COPY no_oids FROM stdin WITH OIDS;
! ERROR:  table "no_oids" does not have OIDs
! COPY no_oids TO stdout WITH OIDS;
! ERROR:  table "no_oids" does not have OIDs
! -- check copy out
! COPY x TO stdout;
! 9999	\N	\\N	NN	before trigger fired
! 10000	21	31	41	before trigger fired
! 10001	22	32	42	before trigger fired
! 10002	23	33	43	before trigger fired
! 10003	24	34	44	before trigger fired
! 10004	25	35	45	before trigger fired
! 10005	26	36	46	before trigger fired
! 6	\N	45	80	before trigger fired
! 7	\N	x	\\x	before trigger fired
! 8	\N	,	\\,	before trigger fired
! 3000	\N	c	\N	before trigger fired
! 4000	\N	C	\N	before trigger fired
! 4001	1	empty		before trigger fired
! 4002	2	null	\N	before trigger fired
! 4003	3	Backslash	\\	before trigger fired
! 4004	4	BackslashX	\\X	before trigger fired
! 4005	5	N	N	before trigger fired
! 4006	6	BackslashN	\\N	before trigger fired
! 4007	7	XX	XX	before trigger fired
! 4008	8	Delimiter	:	before trigger fired
! 1	1	stuff	test_1	after trigger fired
! 2	2	stuff	test_2	after trigger fired
! 3	3	stuff	test_3	after trigger fired
! 4	4	stuff	test_4	after trigger fired
! 5	5	stuff	test_5	after trigger fired
! COPY x (c, e) TO stdout;
! \\N	before trigger fired
! 31	before trigger fired
! 32	before trigger fired
! 33	before trigger fired
! 34	before trigger fired
! 35	before trigger fired
! 36	before trigger fired
! 45	before trigger fired
! x	before trigger fired
! ,	before trigger fired
! c	before trigger fired
! C	before trigger fired
! empty	before trigger fired
! null	before trigger fired
! Backslash	before trigger fired
! BackslashX	before trigger fired
! N	before trigger fired
! BackslashN	before trigger fired
! XX	before trigger fired
! Delimiter	before trigger fired
! stuff	after trigger fired
! stuff	after trigger fired
! stuff	after trigger fired
! stuff	after trigger fired
! stuff	after trigger fired
! COPY x (b, e) TO stdout WITH NULL 'I''m null';
! I'm null	before trigger fired
! 21	before trigger fired
! 22	before trigger fired
! 23	before trigger fired
! 24	before trigger fired
! 25	before trigger fired
! 26	before trigger fired
! I'm null	before trigger fired
! I'm null	before trigger fired
! I'm null	before trigger fired
! I'm null	before trigger fired
! I'm null	before trigger fired
! 1	before trigger fired
! 2	before trigger fired
! 3	before trigger fired
! 4	before trigger fired
! 5	before trigger fired
! 6	before trigger fired
! 7	before trigger fired
! 8	before trigger fired
! 1	after trigger fired
! 2	after trigger fired
! 3	after trigger fired
! 4	after trigger fired
! 5	after trigger fired
! CREATE TEMP TABLE y (
! 	col1 text,
! 	col2 text
! );
! INSERT INTO y VALUES ('Jackson, Sam', E'\\h');
! INSERT INTO y VALUES ('It is "perfect".',E'\t');
! INSERT INTO y VALUES ('', NULL);
! COPY y TO stdout WITH CSV;
! "Jackson, Sam",\h
! "It is ""perfect"".",	
! "",
! COPY y TO stdout WITH CSV QUOTE '''' DELIMITER '|';
! Jackson, Sam|\h
! It is "perfect".|	
! ''|
! COPY y TO stdout WITH CSV FORCE QUOTE col2 ESCAPE E'\\' ENCODING 'sql_ascii';
! "Jackson, Sam","\\h"
! "It is \"perfect\".","	"
! "",
! COPY y TO stdout WITH CSV FORCE QUOTE *;
! "Jackson, Sam","\h"
! "It is ""perfect"".","	"
! "",
! -- Repeat above tests with new 9.0 option syntax
! COPY y TO stdout (FORMAT CSV);
! "Jackson, Sam",\h
! "It is ""perfect"".",	
! "",
! COPY y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|');
! Jackson, Sam|\h
! It is "perfect".|	
! ''|
! COPY y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\');
! "Jackson, Sam","\\h"
! "It is \"perfect\".","	"
! "",
! COPY y TO stdout (FORMAT CSV, FORCE_QUOTE *);
! "Jackson, Sam","\h"
! "It is ""perfect"".","	"
! "",
! \copy y TO stdout (FORMAT CSV)
! "Jackson, Sam",\h
! "It is ""perfect"".",	
! "",
! \copy y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|')
! Jackson, Sam|\h
! It is "perfect".|	
! ''|
! \copy y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\')
! "Jackson, Sam","\\h"
! "It is \"perfect\".","	"
! "",
! \copy y TO stdout (FORMAT CSV, FORCE_QUOTE *)
! "Jackson, Sam","\h"
! "It is ""perfect"".","	"
! "",
! --test that we read consecutive LFs properly
! CREATE TEMP TABLE testnl (a int, b text, c int);
! COPY testnl FROM stdin CSV;
! -- test end of copy marker
! CREATE TEMP TABLE testeoc (a text);
! COPY testeoc FROM stdin CSV;
! COPY testeoc TO stdout CSV;
! a\.
! \.b
! c\.d
! "\."
! -- test handling of nonstandard null marker that violates escaping rules
! CREATE TEMP TABLE testnull(a int, b text);
! INSERT INTO testnull VALUES (1, E'\\0'), (NULL, NULL);
! COPY testnull TO stdout WITH NULL AS E'\\0';
! 1	\\0
! \0	\0
! COPY testnull FROM stdin WITH NULL AS E'\\0';
! SELECT * FROM testnull;
!  a  | b  
! ----+----
!   1 | \0
!     | 
!  42 | \0
!     | 
! (4 rows)
! 
! BEGIN;
! CREATE TABLE vistest (LIKE testeoc);
! COPY vistest FROM stdin CSV;
! COMMIT;
! SELECT * FROM vistest;
!  a  
! ----
!  a0
!  b
! (2 rows)
! 
! BEGIN;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV;
! SELECT * FROM vistest;
!  a  
! ----
!  a1
!  b
! (2 rows)
! 
! SAVEPOINT s1;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV;
! SELECT * FROM vistest;
!  a  
! ----
!  d1
!  e
! (2 rows)
! 
! COMMIT;
! SELECT * FROM vistest;
!  a  
! ----
!  d1
!  e
! (2 rows)
! 
! BEGIN;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV FREEZE;
! SELECT * FROM vistest;
!  a  
! ----
!  a2
!  b
! (2 rows)
! 
! SAVEPOINT s1;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV FREEZE;
! SELECT * FROM vistest;
!  a  
! ----
!  d2
!  e
! (2 rows)
! 
! COMMIT;
! SELECT * FROM vistest;
!  a  
! ----
!  d2
!  e
! (2 rows)
! 
! BEGIN;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV FREEZE;
! SELECT * FROM vistest;
!  a 
! ---
!  x
!  y
! (2 rows)
! 
! COMMIT;
! TRUNCATE vistest;
! COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
! BEGIN;
! TRUNCATE vistest;
! SAVEPOINT s1;
! COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
! COMMIT;
! BEGIN;
! INSERT INTO vistest VALUES ('z');
! SAVEPOINT s1;
! TRUNCATE vistest;
! ROLLBACK TO SAVEPOINT s1;
! COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
! COMMIT;
! CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS
! $$
! BEGIN
! 	TRUNCATE vistest;
! EXCEPTION
!   WHEN OTHERS THEN
! 	INSERT INTO vistest VALUES ('subxact failure');
! END;
! $$ language plpgsql;
! BEGIN;
! INSERT INTO vistest VALUES ('z');
! SELECT truncate_in_subxact();
!  truncate_in_subxact 
! ---------------------
!  
! (1 row)
! 
! COPY vistest FROM stdin CSV FREEZE;
! SELECT * FROM vistest;
!  a  
! ----
!  d4
!  e
! (2 rows)
! 
! COMMIT;
! SELECT * FROM vistest;
!  a  
! ----
!  d4
!  e
! (2 rows)
! 
! -- Test FORCE_NOT_NULL and FORCE_NULL options
! CREATE TEMP TABLE forcetest (
!     a INT NOT NULL,
!     b TEXT NOT NULL,
!     c TEXT,
!     d TEXT,
!     e TEXT
! );
! \pset null NULL
! -- should succeed with no effect ("b" remains an empty string, "c" remains NULL)
! BEGIN;
! COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b), FORCE_NULL(c));
! COMMIT;
! SELECT b, c FROM forcetest WHERE a = 1;
!  b |  c   
! ---+------
!    | NULL
! (1 row)
! 
! -- should succeed, FORCE_NULL and FORCE_NOT_NULL can be both specified
! BEGIN;
! COPY forcetest (a, b, c, d) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(c,d), FORCE_NULL(c,d));
! COMMIT;
! SELECT c, d FROM forcetest WHERE a = 2;
!  c |  d   
! ---+------
!    | NULL
! (1 row)
! 
! -- should fail with not-null constraint violation
! BEGIN;
! COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
! ERROR:  null value in column "b" violates not-null constraint
! DETAIL:  Failing row contains (3, null, , null, null).
! CONTEXT:  COPY forcetest, line 1: "3,,"""
! ROLLBACK;
! -- should fail with "not referenced by COPY" error
! BEGIN;
! COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b));
! ERROR:  FORCE NOT NULL column "b" not referenced by COPY
! ROLLBACK;
! -- should fail with "not referenced by COPY" error
! BEGIN;
! COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b));
! ERROR:  FORCE NULL column "b" not referenced by COPY
! ROLLBACK;
! \pset null ''
! DROP TABLE forcetest;
! DROP TABLE vistest;
! DROP FUNCTION truncate_in_subxact();
! DROP TABLE x, y;
! DROP FUNCTION fn_x_before();
! DROP FUNCTION fn_x_after();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/temp.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/temp.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,201 ****
! --
! -- TEMP
! -- Test temp relations and indexes
! --
! -- test temp table/index masking
! CREATE TABLE temptest(col int);
! CREATE INDEX i_temptest ON temptest(col);
! CREATE TEMP TABLE temptest(tcol int);
! CREATE INDEX i_temptest ON temptest(tcol);
! SELECT * FROM temptest;
!  tcol 
! ------
! (0 rows)
! 
! DROP INDEX i_temptest;
! DROP TABLE temptest;
! SELECT * FROM temptest;
!  col 
! -----
! (0 rows)
! 
! DROP INDEX i_temptest;
! DROP TABLE temptest;
! -- test temp table selects
! CREATE TABLE temptest(col int);
! INSERT INTO temptest VALUES (1);
! CREATE TEMP TABLE temptest(tcol float);
! INSERT INTO temptest VALUES (2.1);
! SELECT * FROM temptest;
!  tcol 
! ------
!   2.1
! (1 row)
! 
! DROP TABLE temptest;
! SELECT * FROM temptest;
!  col 
! -----
!    1
! (1 row)
! 
! DROP TABLE temptest;
! -- test temp table deletion
! CREATE TEMP TABLE temptest(col int);
! \c
! SELECT * FROM temptest;
! ERROR:  relation "temptest" does not exist
! LINE 1: SELECT * FROM temptest;
!                       ^
! -- Test ON COMMIT DELETE ROWS
! CREATE TEMP TABLE temptest(col int) ON COMMIT DELETE ROWS;
! BEGIN;
! INSERT INTO temptest VALUES (1);
! INSERT INTO temptest VALUES (2);
! SELECT * FROM temptest;
!  col 
! -----
!    1
!    2
! (2 rows)
! 
! COMMIT;
! SELECT * FROM temptest;
!  col 
! -----
! (0 rows)
! 
! DROP TABLE temptest;
! BEGIN;
! CREATE TEMP TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
! SELECT * FROM temptest;
!  col 
! -----
!    1
! (1 row)
! 
! COMMIT;
! SELECT * FROM temptest;
!  col 
! -----
! (0 rows)
! 
! DROP TABLE temptest;
! -- Test ON COMMIT DROP
! BEGIN;
! CREATE TEMP TABLE temptest(col int) ON COMMIT DROP;
! INSERT INTO temptest VALUES (1);
! INSERT INTO temptest VALUES (2);
! SELECT * FROM temptest;
!  col 
! -----
!    1
!    2
! (2 rows)
! 
! COMMIT;
! SELECT * FROM temptest;
! ERROR:  relation "temptest" does not exist
! LINE 1: SELECT * FROM temptest;
!                       ^
! BEGIN;
! CREATE TEMP TABLE temptest(col) ON COMMIT DROP AS SELECT 1;
! SELECT * FROM temptest;
!  col 
! -----
!    1
! (1 row)
! 
! COMMIT;
! SELECT * FROM temptest;
! ERROR:  relation "temptest" does not exist
! LINE 1: SELECT * FROM temptest;
!                       ^
! -- ON COMMIT is only allowed for TEMP
! CREATE TABLE temptest(col int) ON COMMIT DELETE ROWS;
! ERROR:  ON COMMIT can only be used on temporary tables
! CREATE TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
! ERROR:  ON COMMIT can only be used on temporary tables
! -- Test foreign keys
! BEGIN;
! CREATE TEMP TABLE temptest1(col int PRIMARY KEY);
! CREATE TEMP TABLE temptest2(col int REFERENCES temptest1)
!   ON COMMIT DELETE ROWS;
! INSERT INTO temptest1 VALUES (1);
! INSERT INTO temptest2 VALUES (1);
! COMMIT;
! SELECT * FROM temptest1;
!  col 
! -----
!    1
! (1 row)
! 
! SELECT * FROM temptest2;
!  col 
! -----
! (0 rows)
! 
! BEGIN;
! CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
! CREATE TEMP TABLE temptest4(col int REFERENCES temptest3);
! COMMIT;
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
! -- Test manipulation of temp schema's placement in search path
! create table public.whereami (f1 text);
! insert into public.whereami values ('public');
! create temp table whereami (f1 text);
! insert into whereami values ('temp');
! create function public.whoami() returns text
!   as $$select 'public'::text$$ language sql;
! create function pg_temp.whoami() returns text
!   as $$select 'temp'::text$$ language sql;
! -- default should have pg_temp implicitly first, but only for tables
! select * from whereami;
!   f1  
! ------
!  temp
! (1 row)
! 
! select whoami();
!  whoami 
! --------
!  public
! (1 row)
! 
! -- can list temp first explicitly, but it still doesn't affect functions
! set search_path = pg_temp, public;
! select * from whereami;
!   f1  
! ------
!  temp
! (1 row)
! 
! select whoami();
!  whoami 
! --------
!  public
! (1 row)
! 
! -- or put it last for security
! set search_path = public, pg_temp;
! select * from whereami;
!    f1   
! --------
!  public
! (1 row)
! 
! select whoami();
!  whoami 
! --------
!  public
! (1 row)
! 
! -- you can invoke a temp function explicitly, though
! select pg_temp.whoami();
!  whoami 
! --------
!  temp
! (1 row)
! 
! drop table public.whereami;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/domain.out	2014-11-21 01:48:04.319414000 +0300
--- /home/orion/postgres/src/test/regress/results/domain.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,667 ****
! --
! -- Test domains.
! --
! -- Test Comment / Drop
! create domain domaindroptest int4;
! comment on domain domaindroptest is 'About to drop this..';
! create domain dependenttypetest domaindroptest;
! -- fail because of dependent type
! drop domain domaindroptest;
! ERROR:  cannot drop type domaindroptest because other objects depend on it
! DETAIL:  type dependenttypetest depends on type domaindroptest
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! drop domain domaindroptest cascade;
! NOTICE:  drop cascades to type dependenttypetest
! -- this should fail because already gone
! drop domain domaindroptest cascade;
! ERROR:  type "domaindroptest" does not exist
! -- Test domain input.
! -- Note: the point of checking both INSERT and COPY FROM is that INSERT
! -- exercises CoerceToDomain while COPY exercises domain_in.
! create domain domainvarchar varchar(5);
! create domain domainnumeric numeric(8,2);
! create domain domainint4 int4;
! create domain domaintext text;
! -- Test explicit coercions --- these should succeed (and truncate)
! SELECT cast('123456' as domainvarchar);
!  domainvarchar 
! ---------------
!  12345
! (1 row)
! 
! SELECT cast('12345' as domainvarchar);
!  domainvarchar 
! ---------------
!  12345
! (1 row)
! 
! -- Test tables using domains
! create table basictest
!            ( testint4 domainint4
!            , testtext domaintext
!            , testvarchar domainvarchar
!            , testnumeric domainnumeric
!            );
! INSERT INTO basictest values ('88', 'haha', 'short', '123.12');      -- Good
! INSERT INTO basictest values ('88', 'haha', 'short text', '123.12'); -- Bad varchar
! ERROR:  value too long for type character varying(5)
! INSERT INTO basictest values ('88', 'haha', 'short', '123.1212');    -- Truncate numeric
! -- Test copy
! COPY basictest (testvarchar) FROM stdin; -- fail
! ERROR:  value too long for type character varying(5)
! CONTEXT:  COPY basictest, line 1, column testvarchar: "notsoshorttext"
! COPY basictest (testvarchar) FROM stdin;
! select * from basictest;
!  testint4 | testtext | testvarchar | testnumeric 
! ----------+----------+-------------+-------------
!        88 | haha     | short       |      123.12
!        88 | haha     | short       |      123.12
!           |          | short       |            
! (3 rows)
! 
! -- check that domains inherit operations from base types
! select testtext || testvarchar as concat, testnumeric + 42 as sum
! from basictest;
!   concat   |  sum   
! -----------+--------
!  hahashort | 165.12
!  hahashort | 165.12
!            |       
! (3 rows)
! 
! -- check that union/case/coalesce type resolution handles domains properly
! select coalesce(4::domainint4, 7) is of (int4) as t;
!  t 
! ---
!  t
! (1 row)
! 
! select coalesce(4::domainint4, 7) is of (domainint4) as f;
!  f 
! ---
!  f
! (1 row)
! 
! select coalesce(4::domainint4, 7::domainint4) is of (domainint4) as t;
!  t 
! ---
!  t
! (1 row)
! 
! drop table basictest;
! drop domain domainvarchar restrict;
! drop domain domainnumeric restrict;
! drop domain domainint4 restrict;
! drop domain domaintext;
! -- Test domains over array types
! create domain domainint4arr int4[1];
! create domain domainchar4arr varchar(4)[2][3];
! create table domarrtest
!            ( testint4arr domainint4arr
!            , testchar4arr domainchar4arr
!             );
! INSERT INTO domarrtest values ('{2,2}', '{{"a","b"},{"c","d"}}');
! INSERT INTO domarrtest values ('{{2,2},{2,2}}', '{{"a","b"}}');
! INSERT INTO domarrtest values ('{2,2}', '{{"a","b"},{"c","d"},{"e","f"}}');
! INSERT INTO domarrtest values ('{2,2}', '{{"a"},{"c"}}');
! INSERT INTO domarrtest values (NULL, '{{"a","b","c"},{"d","e","f"}}');
! INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
! ERROR:  value too long for type character varying(4)
! select * from domarrtest;
!   testint4arr  |    testchar4arr     
! ---------------+---------------------
!  {2,2}         | {{a,b},{c,d}}
!  {{2,2},{2,2}} | {{a,b}}
!  {2,2}         | {{a,b},{c,d},{e,f}}
!  {2,2}         | {{a},{c}}
!                | {{a,b,c},{d,e,f}}
! (5 rows)
! 
! select testint4arr[1], testchar4arr[2:2] from domarrtest;
!  testint4arr | testchar4arr 
! -------------+--------------
!            2 | {{c,d}}
!              | {}
!            2 | {{c,d}}
!            2 | {{c}}
!              | {{d,e,f}}
! (5 rows)
! 
! select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest;
!  array_dims | array_dims 
! ------------+------------
!  [1:2]      | [1:2][1:2]
!  [1:2][1:2] | [1:1][1:2]
!  [1:2]      | [1:3][1:2]
!  [1:2]      | [1:2][1:1]
!             | [1:2][1:3]
! (5 rows)
! 
! COPY domarrtest FROM stdin;
! COPY domarrtest FROM stdin;	-- fail
! ERROR:  value too long for type character varying(4)
! CONTEXT:  COPY domarrtest, line 1, column testchar4arr: "{qwerty,w,e}"
! select * from domarrtest;
!   testint4arr  |    testchar4arr     
! ---------------+---------------------
!  {2,2}         | {{a,b},{c,d}}
!  {{2,2},{2,2}} | {{a,b}}
!  {2,2}         | {{a,b},{c,d},{e,f}}
!  {2,2}         | {{a},{c}}
!                | {{a,b,c},{d,e,f}}
!  {3,4}         | {q,w,e}
!                | 
! (7 rows)
! 
! drop table domarrtest;
! drop domain domainint4arr restrict;
! drop domain domainchar4arr restrict;
! create domain dia as int[];
! select '{1,2,3}'::dia;
!    dia   
! ---------
!  {1,2,3}
! (1 row)
! 
! select array_dims('{1,2,3}'::dia);
!  array_dims 
! ------------
!  [1:3]
! (1 row)
! 
! select pg_typeof('{1,2,3}'::dia);
!  pg_typeof 
! -----------
!  dia
! (1 row)
! 
! select pg_typeof('{1,2,3}'::dia || 42); -- should be int[] not dia
!  pg_typeof 
! -----------
!  integer[]
! (1 row)
! 
! drop domain dia;
! create domain dnotnull varchar(15) NOT NULL;
! create domain dnull    varchar(15);
! create domain dcheck   varchar(15) NOT NULL CHECK (VALUE = 'a' OR VALUE = 'c' OR VALUE = 'd');
! create table nulltest
!            ( col1 dnotnull
!            , col2 dnotnull NULL  -- NOT NULL in the domain cannot be overridden
!            , col3 dnull    NOT NULL
!            , col4 dnull
!            , col5 dcheck CHECK (col5 IN ('c', 'd'))
!            );
! INSERT INTO nulltest DEFAULT VALUES;
! ERROR:  domain dnotnull does not allow null values
! INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c');  -- Good
! insert into nulltest values ('a', 'b', 'c', 'd', NULL);
! ERROR:  domain dcheck does not allow null values
! insert into nulltest values ('a', 'b', 'c', 'd', 'a');
! ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
! DETAIL:  Failing row contains (a, b, c, d, a).
! INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
! ERROR:  domain dnotnull does not allow null values
! INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
! ERROR:  domain dnotnull does not allow null values
! INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
! ERROR:  null value in column "col3" violates not-null constraint
! DETAIL:  Failing row contains (a, b, null, d, c).
! INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd'); -- Good
! -- Test copy
! COPY nulltest FROM stdin; --fail
! ERROR:  null value in column "col3" violates not-null constraint
! DETAIL:  Failing row contains (a, b, null, d, d).
! CONTEXT:  COPY nulltest, line 1: "a	b	\N	d	d"
! COPY nulltest FROM stdin; --fail
! ERROR:  domain dcheck does not allow null values
! CONTEXT:  COPY nulltest, line 1, column col5: null input
! -- Last row is bad
! COPY nulltest FROM stdin;
! ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
! DETAIL:  Failing row contains (a, b, c, null, a).
! CONTEXT:  COPY nulltest, line 3: "a	b	c	\N	a"
! select * from nulltest;
!  col1 | col2 | col3 | col4 | col5 
! ------+------+------+------+------
!  a    | b    | c    | d    | c
!  a    | b    | c    |      | d
! (2 rows)
! 
! -- Test out coerced (casted) constraints
! SELECT cast('1' as dnotnull);
!  dnotnull 
! ----------
!  1
! (1 row)
! 
! SELECT cast(NULL as dnotnull); -- fail
! ERROR:  domain dnotnull does not allow null values
! SELECT cast(cast(NULL as dnull) as dnotnull); -- fail
! ERROR:  domain dnotnull does not allow null values
! SELECT cast(col4 as dnotnull) from nulltest; -- fail
! ERROR:  domain dnotnull does not allow null values
! -- cleanup
! drop table nulltest;
! drop domain dnotnull restrict;
! drop domain dnull restrict;
! drop domain dcheck restrict;
! create domain ddef1 int4 DEFAULT 3;
! create domain ddef2 oid DEFAULT '12';
! -- Type mixing, function returns int8
! create domain ddef3 text DEFAULT 5;
! create sequence ddef4_seq;
! create domain ddef4 int4 DEFAULT nextval('ddef4_seq');
! create domain ddef5 numeric(8,2) NOT NULL DEFAULT '12.12';
! create table defaulttest
!             ( col1 ddef1
!             , col2 ddef2
!             , col3 ddef3
!             , col4 ddef4 PRIMARY KEY
!             , col5 ddef1 NOT NULL DEFAULT NULL
!             , col6 ddef2 DEFAULT '88'
!             , col7 ddef4 DEFAULT 8000
!             , col8 ddef5
!             );
! insert into defaulttest(col4) values(0); -- fails, col5 defaults to null
! ERROR:  null value in column "col5" violates not-null constraint
! DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
! alter table defaulttest alter column col5 drop default;
! insert into defaulttest default values; -- succeeds, inserts domain default
! -- We used to treat SET DEFAULT NULL as equivalent to DROP DEFAULT; wrong
! alter table defaulttest alter column col5 set default null;
! insert into defaulttest(col4) values(0); -- fails
! ERROR:  null value in column "col5" violates not-null constraint
! DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
! alter table defaulttest alter column col5 drop default;
! insert into defaulttest default values;
! insert into defaulttest default values;
! -- Test defaults with copy
! COPY defaulttest(col5) FROM stdin;
! select * from defaulttest;
!  col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8  
! ------+------+------+------+------+------+------+-------
!     3 |   12 | 5    |    1 |    3 |   88 | 8000 | 12.12
!     3 |   12 | 5    |    2 |    3 |   88 | 8000 | 12.12
!     3 |   12 | 5    |    3 |    3 |   88 | 8000 | 12.12
!     3 |   12 | 5    |    4 |   42 |   88 | 8000 | 12.12
! (4 rows)
! 
! drop table defaulttest cascade;
! -- Test ALTER DOMAIN .. NOT NULL
! create domain dnotnulltest integer;
! create table domnotnull
! ( col1 dnotnulltest
! , col2 dnotnulltest
! );
! insert into domnotnull default values;
! alter domain dnotnulltest set not null; -- fails
! ERROR:  column "col1" of table "domnotnull" contains null values
! update domnotnull set col1 = 5;
! alter domain dnotnulltest set not null; -- fails
! ERROR:  column "col2" of table "domnotnull" contains null values
! update domnotnull set col2 = 6;
! alter domain dnotnulltest set not null;
! update domnotnull set col1 = null; -- fails
! ERROR:  domain dnotnulltest does not allow null values
! alter domain dnotnulltest drop not null;
! update domnotnull set col1 = null;
! drop domain dnotnulltest cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table domnotnull column col1
! drop cascades to table domnotnull column col2
! -- Test ALTER DOMAIN .. DEFAULT ..
! create table domdeftest (col1 ddef1);
! insert into domdeftest default values;
! select * from domdeftest;
!  col1 
! ------
!     3
! (1 row)
! 
! alter domain ddef1 set default '42';
! insert into domdeftest default values;
! select * from domdeftest;
!  col1 
! ------
!     3
!    42
! (2 rows)
! 
! alter domain ddef1 drop default;
! insert into domdeftest default values;
! select * from domdeftest;
!  col1 
! ------
!     3
!    42
!      
! (3 rows)
! 
! drop table domdeftest;
! -- Test ALTER DOMAIN .. CONSTRAINT ..
! create domain con as integer;
! create table domcontest (col1 con);
! insert into domcontest values (1);
! insert into domcontest values (2);
! alter domain con add constraint t check (VALUE < 1); -- fails
! ERROR:  column "col1" of table "domcontest" contains values that violate the new constraint
! alter domain con add constraint t check (VALUE < 34);
! alter domain con add check (VALUE > 0);
! insert into domcontest values (-5); -- fails
! ERROR:  value for domain con violates check constraint "con_check"
! insert into domcontest values (42); -- fails
! ERROR:  value for domain con violates check constraint "t"
! insert into domcontest values (5);
! alter domain con drop constraint t;
! insert into domcontest values (-5); --fails
! ERROR:  value for domain con violates check constraint "con_check"
! insert into domcontest values (42);
! alter domain con drop constraint nonexistent;
! ERROR:  constraint "nonexistent" of domain "con" does not exist
! alter domain con drop constraint if exists nonexistent;
! NOTICE:  constraint "nonexistent" of domain "con" does not exist, skipping
! -- Test ALTER DOMAIN .. CONSTRAINT .. NOT VALID
! create domain things AS INT;
! CREATE TABLE thethings (stuff things);
! INSERT INTO thethings (stuff) VALUES (55);
! ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
! ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
! ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
! ALTER DOMAIN things VALIDATE CONSTRAINT meow;
! ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
! UPDATE thethings SET stuff = 10;
! ALTER DOMAIN things VALIDATE CONSTRAINT meow;
! -- Confirm ALTER DOMAIN with RULES.
! create table domtab (col1 integer);
! create domain dom as integer;
! create view domview as select cast(col1 as dom) from domtab;
! insert into domtab (col1) values (null);
! insert into domtab (col1) values (5);
! select * from domview;
!  col1 
! ------
!      
!     5
! (2 rows)
! 
! alter domain dom set not null;
! select * from domview; -- fail
! ERROR:  domain dom does not allow null values
! alter domain dom drop not null;
! select * from domview;
!  col1 
! ------
!      
!     5
! (2 rows)
! 
! alter domain dom add constraint domchkgt6 check(value > 6);
! select * from domview; --fail
! ERROR:  value for domain dom violates check constraint "domchkgt6"
! alter domain dom drop constraint domchkgt6 restrict;
! select * from domview;
!  col1 
! ------
!      
!     5
! (2 rows)
! 
! -- cleanup
! drop domain ddef1 restrict;
! drop domain ddef2 restrict;
! drop domain ddef3 restrict;
! drop domain ddef4 restrict;
! drop domain ddef5 restrict;
! drop sequence ddef4_seq;
! -- Test domains over domains
! create domain vchar4 varchar(4);
! create domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x');
! create domain dtop dinter check (substring(VALUE, 2, 1) = '1');
! select 'x123'::dtop;
!  dtop 
! ------
!  x123
! (1 row)
! 
! select 'x1234'::dtop; -- explicit coercion should truncate
!  dtop 
! ------
!  x123
! (1 row)
! 
! select 'y1234'::dtop; -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
! select 'y123'::dtop; -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
! select 'yz23'::dtop; -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
! select 'xz23'::dtop; -- fail
! ERROR:  value for domain dtop violates check constraint "dtop_check"
! create temp table dtest(f1 dtop);
! insert into dtest values('x123');
! insert into dtest values('x1234'); -- fail, implicit coercion
! ERROR:  value too long for type character varying(4)
! insert into dtest values('y1234'); -- fail, implicit coercion
! ERROR:  value too long for type character varying(4)
! insert into dtest values('y123'); -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
! insert into dtest values('yz23'); -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
! insert into dtest values('xz23'); -- fail
! ERROR:  value for domain dtop violates check constraint "dtop_check"
! drop table dtest;
! drop domain vchar4 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to type dinter
! drop cascades to type dtop
! -- Make sure that constraints of newly-added domain columns are
! -- enforced correctly, even if there's no default value for the new
! -- column. Per bug #1433
! create domain str_domain as text not null;
! create table domain_test (a int, b int);
! insert into domain_test values (1, 2);
! insert into domain_test values (1, 2);
! -- should fail
! alter table domain_test add column c str_domain;
! ERROR:  domain str_domain does not allow null values
! create domain str_domain2 as text check (value <> 'foo') default 'foo';
! -- should fail
! alter table domain_test add column d str_domain2;
! ERROR:  value for domain str_domain2 violates check constraint "str_domain2_check"
! -- Check that domain constraints on prepared statement parameters of
! -- unknown type are enforced correctly.
! create domain pos_int as int4 check (value > 0) not null;
! prepare s1 as select $1::pos_int = 10 as "is_ten";
! execute s1(10);
!  is_ten 
! --------
!  t
! (1 row)
! 
! execute s1(0); -- should fail
! ERROR:  value for domain pos_int violates check constraint "pos_int_check"
! execute s1(NULL); -- should fail
! ERROR:  domain pos_int does not allow null values
! -- Check that domain constraints on plpgsql function parameters, results,
! -- and local variables are enforced correctly.
! create function doubledecrement(p1 pos_int) returns pos_int as $$
! declare v pos_int;
! begin
!     return p1;
! end$$ language plpgsql;
! select doubledecrement(3); -- fail because of implicit null assignment
! ERROR:  domain pos_int does not allow null values
! CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
! create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
! declare v pos_int := 0;
! begin
!     return p1;
! end$$ language plpgsql;
! select doubledecrement(3); -- fail at initialization assignment
! ERROR:  value for domain pos_int violates check constraint "pos_int_check"
! CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
! create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
! declare v pos_int := 1;
! begin
!     v := p1 - 1;
!     return v - 1;
! end$$ language plpgsql;
! select doubledecrement(null); -- fail before call
! ERROR:  domain pos_int does not allow null values
! select doubledecrement(0); -- fail before call
! ERROR:  value for domain pos_int violates check constraint "pos_int_check"
! select doubledecrement(1); -- fail at assignment to v
! ERROR:  value for domain pos_int violates check constraint "pos_int_check"
! CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 4 at assignment
! select doubledecrement(2); -- fail at return
! ERROR:  value for domain pos_int violates check constraint "pos_int_check"
! CONTEXT:  PL/pgSQL function doubledecrement(pos_int) while casting return value to function's return type
! select doubledecrement(3); -- good
!  doubledecrement 
! -----------------
!                1
! (1 row)
! 
! -- Check that ALTER DOMAIN tests columns of derived types
! create domain posint as int4;
! -- Currently, this doesn't work for composite types, but verify it complains
! create type ddtest1 as (f1 posint);
! create table ddtest2(f1 ddtest1);
! insert into ddtest2 values(row(-1));
! alter domain posint add constraint c1 check(value >= 0);
! ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
! drop table ddtest2;
! create table ddtest2(f1 ddtest1[]);
! insert into ddtest2 values('{(-1)}');
! alter domain posint add constraint c1 check(value >= 0);
! ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
! drop table ddtest2;
! alter domain posint add constraint c1 check(value >= 0);
! create domain posint2 as posint check (value % 2 = 0);
! create table ddtest2(f1 posint2);
! insert into ddtest2 values(11); -- fail
! ERROR:  value for domain posint2 violates check constraint "posint2_check"
! insert into ddtest2 values(-2); -- fail
! ERROR:  value for domain posint2 violates check constraint "c1"
! insert into ddtest2 values(2);
! alter domain posint add constraint c2 check(value >= 10); -- fail
! ERROR:  column "f1" of table "ddtest2" contains values that violate the new constraint
! alter domain posint add constraint c2 check(value > 0); -- OK
! drop table ddtest2;
! drop type ddtest1;
! drop domain posint cascade;
! NOTICE:  drop cascades to type posint2
! --
! -- Check enforcement of domain-related typmod in plpgsql (bug #5717)
! --
! create or replace function array_elem_check(numeric) returns numeric as $$
! declare
!   x numeric(4,2)[1];
! begin
!   x[1] := $1;
!   return x[1];
! end$$ language plpgsql;
! select array_elem_check(121.00);
! ERROR:  numeric field overflow
! DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
! CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
! select array_elem_check(1.23456);
!  array_elem_check 
! ------------------
!              1.23
! (1 row)
! 
! create domain mynums as numeric(4,2)[1];
! create or replace function array_elem_check(numeric) returns numeric as $$
! declare
!   x mynums;
! begin
!   x[1] := $1;
!   return x[1];
! end$$ language plpgsql;
! select array_elem_check(121.00);
! ERROR:  numeric field overflow
! DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
! CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
! select array_elem_check(1.23456);
!  array_elem_check 
! ------------------
!              1.23
! (1 row)
! 
! create domain mynums2 as mynums;
! create or replace function array_elem_check(numeric) returns numeric as $$
! declare
!   x mynums2;
! begin
!   x[1] := $1;
!   return x[1];
! end$$ language plpgsql;
! select array_elem_check(121.00);
! ERROR:  numeric field overflow
! DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
! CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
! select array_elem_check(1.23456);
!  array_elem_check 
! ------------------
!              1.23
! (1 row)
! 
! drop function array_elem_check(numeric);
! --
! -- Check enforcement of array-level domain constraints
! --
! create domain orderedpair as int[2] check (value[1] < value[2]);
! select array[1,2]::orderedpair;
!  array 
! -------
!  {1,2}
! (1 row)
! 
! select array[2,1]::orderedpair;  -- fail
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
! create temp table op (f1 orderedpair);
! insert into op values (array[1,2]);
! insert into op values (array[2,1]);  -- fail
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
! update op set f1[2] = 3;
! update op set f1[2] = 0;  -- fail
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
! select * from op;
!   f1   
! -------
!  {1,3}
! (1 row)
! 
! create or replace function array_elem_check(int) returns int as $$
! declare
!   x orderedpair := '{1,2}';
! begin
!   x[2] := $1;
!   return x[2];
! end$$ language plpgsql;
! select array_elem_check(3);
!  array_elem_check 
! ------------------
!                 3
! (1 row)
! 
! select array_elem_check(-1);
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
! CONTEXT:  PL/pgSQL function array_elem_check(integer) line 5 at assignment
! drop function array_elem_check(int);
! --
! -- Renaming
! --
! create domain testdomain1 as int;
! alter domain testdomain1 rename to testdomain2;
! alter type testdomain2 rename to testdomain3;  -- alter type also works
! drop domain testdomain3;
! --
! -- Renaming domain constraints
! --
! create domain testdomain1 as int constraint unsigned check (value > 0);
! alter domain testdomain1 rename constraint unsigned to unsigned_foo;
! alter domain testdomain1 drop constraint unsigned_foo;
! drop domain testdomain1;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rangefuncs.out	2014-11-21 01:48:04.347427000 +0300
--- /home/orion/postgres/src/test/regress/results/rangefuncs.out	2015-01-26 12:33:26.331031434 +0300
***************
*** 1,2060 ****
! SELECT name, setting FROM pg_settings WHERE name LIKE 'enable%';
!          name         | setting 
! ----------------------+---------
!  enable_bitmapscan    | on
!  enable_hashagg       | on
!  enable_hashjoin      | on
!  enable_indexonlyscan | on
!  enable_indexscan     | on
!  enable_material      | on
!  enable_mergejoin     | on
!  enable_nestloop      | on
!  enable_seqscan       | on
!  enable_sort          | on
!  enable_tidscan       | on
! (11 rows)
! 
! CREATE TABLE foo2(fooid int, f2 int);
! INSERT INTO foo2 VALUES(1, 11);
! INSERT INTO foo2 VALUES(2, 22);
! INSERT INTO foo2 VALUES(1, 111);
! CREATE FUNCTION foot(int) returns setof foo2 as 'SELECT * FROM foo2 WHERE fooid = $1 ORDER BY f2;' LANGUAGE SQL;
! -- function with ORDINALITY
! select * from foot(1) with ordinality as z(a,b,ord);
!  a |  b  | ord 
! ---+-----+-----
!  1 |  11 |   1
!  1 | 111 |   2
! (2 rows)
! 
! select * from foot(1) with ordinality as z(a,b,ord) where b > 100;   -- ordinal 2, not 1
!  a |  b  | ord 
! ---+-----+-----
!  1 | 111 |   2
! (1 row)
! 
! -- ordinality vs. column names and types
! select a,b,ord from foot(1) with ordinality as z(a,b,ord);
!  a |  b  | ord 
! ---+-----+-----
!  1 |  11 |   1
!  1 | 111 |   2
! (2 rows)
! 
! select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
!  a | ord 
! ---+-----
!  a |   1
!  b |   2
! (2 rows)
! 
! select * from unnest(array['a','b']) with ordinality as z(a,ord);
!  a | ord 
! ---+-----
!  a |   1
!  b |   2
! (2 rows)
! 
! select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
!  a | ord 
! ---+-----
!  1 |   1
! (1 row)
! 
! select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
!  a | ord 
! ---+-----
!  1 |   1
! (1 row)
! 
! select row_to_json(s.*) from generate_series(11,14) with ordinality s;
!        row_to_json       
! -------------------------
!  {"s":11,"ordinality":1}
!  {"s":12,"ordinality":2}
!  {"s":13,"ordinality":3}
!  {"s":14,"ordinality":4}
! (4 rows)
! 
! -- ordinality vs. views
! create temporary view vw_ord as select * from (values (1)) v(n) join foot(1) with ordinality as z(a,b,ord) on (n=ord);
! select * from vw_ord;
!  n | a | b  | ord 
! ---+---+----+-----
!  1 | 1 | 11 |   1
! (1 row)
! 
! select definition from pg_views where viewname='vw_ord';
!                              definition                              
! ---------------------------------------------------------------------
!   SELECT v.n,                                                       +
!      z.a,                                                           +
!      z.b,                                                           +
!      z.ord                                                          +
!     FROM (( VALUES (1)) v(n)                                        +
!       JOIN foot(1) WITH ORDINALITY z(a, b, ord) ON ((v.n = z.ord)));
! (1 row)
! 
! drop view vw_ord;
! -- multiple functions
! select * from rows from(foot(1),foot(2)) with ordinality as z(a,b,c,d,ord);
!  a |  b  | c | d  | ord 
! ---+-----+---+----+-----
!  1 |  11 | 2 | 22 |   1
!  1 | 111 |   |    |   2
! (2 rows)
! 
! create temporary view vw_ord as select * from (values (1)) v(n) join rows from(foot(1),foot(2)) with ordinality as z(a,b,c,d,ord) on (n=ord);
! select * from vw_ord;
!  n | a | b  | c | d  | ord 
! ---+---+----+---+----+-----
!  1 | 1 | 11 | 2 | 22 |   1
! (1 row)
! 
! select definition from pg_views where viewname='vw_ord';
!                                           definition                                           
! -----------------------------------------------------------------------------------------------
!   SELECT v.n,                                                                                 +
!      z.a,                                                                                     +
!      z.b,                                                                                     +
!      z.c,                                                                                     +
!      z.d,                                                                                     +
!      z.ord                                                                                    +
!     FROM (( VALUES (1)) v(n)                                                                  +
!       JOIN ROWS FROM(foot(1), foot(2)) WITH ORDINALITY z(a, b, c, d, ord) ON ((v.n = z.ord)));
! (1 row)
! 
! drop view vw_ord;
! -- expansions of unnest()
! select * from unnest(array[10,20],array['foo','bar'],array[1.0]);
!  unnest | unnest | unnest 
! --------+--------+--------
!      10 | foo    |    1.0
!      20 | bar    |       
! (2 rows)
! 
! select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
!  a  |  b  |  c  | ord 
! ----+-----+-----+-----
!  10 | foo | 1.0 |   1
!  20 | bar |     |   2
! (2 rows)
! 
! select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
!  a  |  b  |  c  | ord 
! ----+-----+-----+-----
!  10 | foo | 1.0 |   1
!  20 | bar |     |   2
! (2 rows)
! 
! select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
!  a  |  b  |  c  | ord 
! ----+-----+-----+-----
!  10 | foo | 101 |   1
!  20 | bar | 102 |   2
! (2 rows)
! 
! create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
! select * from vw_ord;
!  a  |  b  |  c  
! ----+-----+-----
!  10 | foo | 1.0
!  20 | bar |    
! (2 rows)
! 
! select definition from pg_views where viewname='vw_ord';
!                                        definition                                       
! ----------------------------------------------------------------------------------------
!   SELECT z.a,                                                                          +
!      z.b,                                                                              +
!      z.c                                                                               +
!     FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
! (1 row)
! 
! drop view vw_ord;
! create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
! select * from vw_ord;
!  a  |  b  |  c  
! ----+-----+-----
!  10 | foo | 1.0
!  20 | bar |    
! (2 rows)
! 
! select definition from pg_views where viewname='vw_ord';
!                                        definition                                       
! ----------------------------------------------------------------------------------------
!   SELECT z.a,                                                                          +
!      z.b,                                                                              +
!      z.c                                                                               +
!     FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
! (1 row)
! 
! drop view vw_ord;
! create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
! select * from vw_ord;
!  a  |  b  | c 
! ----+-----+---
!  10 | foo | 1
!  20 | bar | 2
! (2 rows)
! 
! select definition from pg_views where viewname='vw_ord';
!                                                       definition                                                      
! ----------------------------------------------------------------------------------------------------------------------
!   SELECT z.a,                                                                                                        +
!      z.b,                                                                                                            +
!      z.c                                                                                                             +
!     FROM ROWS FROM(unnest(ARRAY[10, 20]), unnest(ARRAY['foo'::text, 'bar'::text]), generate_series(1, 2)) z(a, b, c);
! (1 row)
! 
! drop view vw_ord;
! -- ordinality and multiple functions vs. rewind and reverse scan
! begin;
! declare foo scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
! fetch all from foo;
!  i | j | o 
! ---+---+---
!  1 | 1 | 1
!  2 | 2 | 2
!  3 |   | 3
!  4 |   | 4
!  5 |   | 5
! (5 rows)
! 
! fetch backward all from foo;
!  i | j | o 
! ---+---+---
!  5 |   | 5
!  4 |   | 4
!  3 |   | 3
!  2 | 2 | 2
!  1 | 1 | 1
! (5 rows)
! 
! fetch all from foo;
!  i | j | o 
! ---+---+---
!  1 | 1 | 1
!  2 | 2 | 2
!  3 |   | 3
!  4 |   | 4
!  5 |   | 5
! (5 rows)
! 
! fetch next from foo;
!  i | j | o 
! ---+---+---
! (0 rows)
! 
! fetch next from foo;
!  i | j | o 
! ---+---+---
! (0 rows)
! 
! fetch prior from foo;
!  i | j | o 
! ---+---+---
!  5 |   | 5
! (1 row)
! 
! fetch absolute 1 from foo;
!  i | j | o 
! ---+---+---
!  1 | 1 | 1
! (1 row)
! 
! fetch next from foo;
!  i | j | o 
! ---+---+---
!  2 | 2 | 2
! (1 row)
! 
! fetch next from foo;
!  i | j | o 
! ---+---+---
!  3 |   | 3
! (1 row)
! 
! fetch next from foo;
!  i | j | o 
! ---+---+---
!  4 |   | 4
! (1 row)
! 
! fetch prior from foo;
!  i | j | o 
! ---+---+---
!  3 |   | 3
! (1 row)
! 
! fetch prior from foo;
!  i | j | o 
! ---+---+---
!  2 | 2 | 2
! (1 row)
! 
! fetch prior from foo;
!  i | j | o 
! ---+---+---
!  1 | 1 | 1
! (1 row)
! 
! commit;
! -- function with implicit LATERAL
! select * from foo2, foot(foo2.fooid) z where foo2.f2 = z.f2;
!  fooid | f2  | fooid | f2  
! -------+-----+-------+-----
!      1 |  11 |     1 |  11
!      2 |  22 |     2 |  22
!      1 | 111 |     1 | 111
! (3 rows)
! 
! -- function with implicit LATERAL and explicit ORDINALITY
! select * from foo2, foot(foo2.fooid) with ordinality as z(fooid,f2,ord) where foo2.f2 = z.f2;
!  fooid | f2  | fooid | f2  | ord 
! -------+-----+-------+-----+-----
!      1 |  11 |     1 |  11 |   1
!      2 |  22 |     2 |  22 |   1
!      1 | 111 |     1 | 111 |   2
! (3 rows)
! 
! -- function in subselect
! select * from foo2 where f2 in (select f2 from foot(foo2.fooid) z where z.fooid = foo2.fooid) ORDER BY 1,2;
!  fooid | f2  
! -------+-----
!      1 |  11
!      1 | 111
!      2 |  22
! (3 rows)
! 
! -- function in subselect
! select * from foo2 where f2 in (select f2 from foot(1) z where z.fooid = foo2.fooid) ORDER BY 1,2;
!  fooid | f2  
! -------+-----
!      1 |  11
!      1 | 111
! (2 rows)
! 
! -- function in subselect
! select * from foo2 where f2 in (select f2 from foot(foo2.fooid) z where z.fooid = 1) ORDER BY 1,2;
!  fooid | f2  
! -------+-----
!      1 |  11
!      1 | 111
! (2 rows)
! 
! -- nested functions
! select foot.fooid, foot.f2 from foot(sin(pi()/2)::int) ORDER BY 1,2;
!  fooid | f2  
! -------+-----
!      1 |  11
!      1 | 111
! (2 rows)
! 
! CREATE TABLE foo (fooid int, foosubid int, fooname text, primary key(fooid,foosubid));
! INSERT INTO foo VALUES(1,1,'Joe');
! INSERT INTO foo VALUES(1,2,'Ed');
! INSERT INTO foo VALUES(2,1,'Mary');
! -- sql, proretset = f, prorettype = b
! CREATE FUNCTION getfoo1(int) RETURNS int AS 'SELECT $1;' LANGUAGE SQL;
! SELECT * FROM getfoo1(1) AS t1;
!  t1 
! ----
!   1
! (1 row)
! 
! SELECT * FROM getfoo1(1) WITH ORDINALITY AS t1(v,o);
!  v | o 
! ---+---
!  1 | 1
! (1 row)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo1(1);
! SELECT * FROM vw_getfoo;
!  getfoo1 
! ---------
!        1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo1(1) WITH ORDINALITY as t1(v,o);
! SELECT * FROM vw_getfoo;
!  v | o 
! ---+---
!  1 | 1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = t, prorettype = b
! CREATE FUNCTION getfoo2(int) RETURNS setof int AS 'SELECT fooid FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo2(1) AS t1;
!  t1 
! ----
!   1
!   1
! (2 rows)
! 
! SELECT * FROM getfoo2(1) WITH ORDINALITY AS t1(v,o);
!  v | o 
! ---+---
!  1 | 1
!  1 | 2
! (2 rows)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo2(1);
! SELECT * FROM vw_getfoo;
!  getfoo2 
! ---------
!        1
!        1
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo2(1) WITH ORDINALITY AS t1(v,o);
! SELECT * FROM vw_getfoo;
!  v | o 
! ---+---
!  1 | 1
!  1 | 2
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = t, prorettype = b
! CREATE FUNCTION getfoo3(int) RETURNS setof text AS 'SELECT fooname FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo3(1) AS t1;
!  t1  
! -----
!  Joe
!  Ed
! (2 rows)
! 
! SELECT * FROM getfoo3(1) WITH ORDINALITY AS t1(v,o);
!   v  | o 
! -----+---
!  Joe | 1
!  Ed  | 2
! (2 rows)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo3(1);
! SELECT * FROM vw_getfoo;
!  getfoo3 
! ---------
!  Joe
!  Ed
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo3(1) WITH ORDINALITY AS t1(v,o);
! SELECT * FROM vw_getfoo;
!   v  | o 
! -----+---
!  Joe | 1
!  Ed  | 2
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = f, prorettype = c
! CREATE FUNCTION getfoo4(int) RETURNS foo AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo4(1) AS t1;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! SELECT * FROM getfoo4(1) WITH ORDINALITY AS t1(a,b,c,o);
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
! (1 row)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo4(1);
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo4(1) WITH ORDINALITY AS t1(a,b,c,o);
! SELECT * FROM vw_getfoo;
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = t, prorettype = c
! CREATE FUNCTION getfoo5(int) RETURNS setof foo AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo5(1) AS t1;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
!      1 |        2 | Ed
! (2 rows)
! 
! SELECT * FROM getfoo5(1) WITH ORDINALITY AS t1(a,b,c,o);
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
!  1 | 2 | Ed  | 2
! (2 rows)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo5(1);
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
!      1 |        2 | Ed
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo5(1) WITH ORDINALITY AS t1(a,b,c,o);
! SELECT * FROM vw_getfoo;
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
!  1 | 2 | Ed  | 2
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = f, prorettype = record
! CREATE FUNCTION getfoo6(int) RETURNS RECORD AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo6(1) AS t1(fooid int, foosubid int, fooname text);
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! SELECT * FROM ROWS FROM( getfoo6(1) AS (fooid int, foosubid int, fooname text) ) WITH ORDINALITY;
!  fooid | foosubid | fooname | ordinality 
! -------+----------+---------+------------
!      1 |        1 | Joe     |          1
! (1 row)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo6(1) AS
! (fooid int, foosubid int, fooname text);
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS
!   SELECT * FROM ROWS FROM( getfoo6(1) AS (fooid int, foosubid int, fooname text) )
!                 WITH ORDINALITY;
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname | ordinality 
! -------+----------+---------+------------
!      1 |        1 | Joe     |          1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! -- sql, proretset = t, prorettype = record
! CREATE FUNCTION getfoo7(int) RETURNS setof record AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
! SELECT * FROM getfoo7(1) AS t1(fooid int, foosubid int, fooname text);
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
!      1 |        2 | Ed
! (2 rows)
! 
! SELECT * FROM ROWS FROM( getfoo7(1) AS (fooid int, foosubid int, fooname text) ) WITH ORDINALITY;
!  fooid | foosubid | fooname | ordinality 
! -------+----------+---------+------------
!      1 |        1 | Joe     |          1
!      1 |        2 | Ed      |          2
! (2 rows)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo7(1) AS
! (fooid int, foosubid int, fooname text);
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
!      1 |        2 | Ed
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS
!   SELECT * FROM ROWS FROM( getfoo7(1) AS (fooid int, foosubid int, fooname text) )
!                 WITH ORDINALITY;
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname | ordinality 
! -------+----------+---------+------------
!      1 |        1 | Joe     |          1
!      1 |        2 | Ed      |          2
! (2 rows)
! 
! DROP VIEW vw_getfoo;
! -- plpgsql, proretset = f, prorettype = b
! CREATE FUNCTION getfoo8(int) RETURNS int AS 'DECLARE fooint int; BEGIN SELECT fooid into fooint FROM foo WHERE fooid = $1; RETURN fooint; END;' LANGUAGE plpgsql;
! SELECT * FROM getfoo8(1) AS t1;
!  t1 
! ----
!   1
! (1 row)
! 
! SELECT * FROM getfoo8(1) WITH ORDINALITY AS t1(v,o);
!  v | o 
! ---+---
!  1 | 1
! (1 row)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo8(1);
! SELECT * FROM vw_getfoo;
!  getfoo8 
! ---------
!        1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo8(1) WITH ORDINALITY AS t1(v,o);
! SELECT * FROM vw_getfoo;
!  v | o 
! ---+---
!  1 | 1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! -- plpgsql, proretset = f, prorettype = c
! CREATE FUNCTION getfoo9(int) RETURNS foo AS 'DECLARE footup foo%ROWTYPE; BEGIN SELECT * into footup FROM foo WHERE fooid = $1; RETURN footup; END;' LANGUAGE plpgsql;
! SELECT * FROM getfoo9(1) AS t1;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! SELECT * FROM getfoo9(1) WITH ORDINALITY AS t1(a,b,c,o);
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
! (1 row)
! 
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo9(1);
! SELECT * FROM vw_getfoo;
!  fooid | foosubid | fooname 
! -------+----------+---------
!      1 |        1 | Joe
! (1 row)
! 
! DROP VIEW vw_getfoo;
! CREATE VIEW vw_getfoo AS SELECT * FROM getfoo9(1) WITH ORDINALITY AS t1(a,b,c,o);
! SELECT * FROM vw_getfoo;
!  a | b |  c  | o 
! ---+---+-----+---
!  1 | 1 | Joe | 1
! (1 row)
! 
! DROP VIEW vw_getfoo;
! -- mix 'n match kinds, to exercise expandRTE and related logic
! select * from rows from(getfoo1(1),getfoo2(1),getfoo3(1),getfoo4(1),getfoo5(1),
!                     getfoo6(1) AS (fooid int, foosubid int, fooname text),
!                     getfoo7(1) AS (fooid int, foosubid int, fooname text),
!                     getfoo8(1),getfoo9(1))
!               with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
!  a | b |  c  | d | e |  f  | g | h |  i  | j | k |  l  | m | o |  p  | q | r | s |  t  | u 
! ---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+---+-----+---
!  1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | 1 | Joe | 1
!    | 1 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |   |     | 2
! (2 rows)
! 
! select * from rows from(getfoo9(1),getfoo8(1),
!                     getfoo7(1) AS (fooid int, foosubid int, fooname text),
!                     getfoo6(1) AS (fooid int, foosubid int, fooname text),
!                     getfoo5(1),getfoo4(1),getfoo3(1),getfoo2(1),getfoo1(1))
!               with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
!  a | b |  c  | d | e | f |  g  | h | i |  j  | k | l |  m  | o | p |  q  |  r  | s | t | u 
! ---+---+-----+---+---+---+-----+---+---+-----+---+---+-----+---+---+-----+-----+---+---+---
!  1 | 1 | Joe | 1 | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | Joe | 1 | 1 | 1
!    |   |     |   | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | Ed  | 1 |   | 2
! (2 rows)
! 
! create temporary view vw_foo as
!   select * from rows from(getfoo9(1),
!                       getfoo7(1) AS (fooid int, foosubid int, fooname text),
!                       getfoo1(1))
!                 with ordinality as t1(a,b,c,d,e,f,g,n);
! select * from vw_foo;
!  a | b |  c  | d | e |  f  | g | n 
! ---+---+-----+---+---+-----+---+---
!  1 | 1 | Joe | 1 | 1 | Joe | 1 | 1
!    |   |     | 1 | 2 | Ed  |   | 2
! (2 rows)
! 
! select pg_get_viewdef('vw_foo');
!                                                                     pg_get_viewdef                                                                    
! ------------------------------------------------------------------------------------------------------------------------------------------------------
!   SELECT t1.a,                                                                                                                                       +
!      t1.b,                                                                                                                                           +
!      t1.c,                                                                                                                                           +
!      t1.d,                                                                                                                                           +
!      t1.e,                                                                                                                                           +
!      t1.f,                                                                                                                                           +
!      t1.g,                                                                                                                                           +
!      t1.n                                                                                                                                            +
!     FROM ROWS FROM(getfoo9(1), getfoo7(1) AS (fooid integer, foosubid integer, fooname text), getfoo1(1)) WITH ORDINALITY t1(a, b, c, d, e, f, g, n);
! (1 row)
! 
! drop view vw_foo;
! DROP FUNCTION getfoo1(int);
! DROP FUNCTION getfoo2(int);
! DROP FUNCTION getfoo3(int);
! DROP FUNCTION getfoo4(int);
! DROP FUNCTION getfoo5(int);
! DROP FUNCTION getfoo6(int);
! DROP FUNCTION getfoo7(int);
! DROP FUNCTION getfoo8(int);
! DROP FUNCTION getfoo9(int);
! DROP FUNCTION foot(int);
! DROP TABLE foo2;
! DROP TABLE foo;
! -- Rescan tests --
! CREATE TEMPORARY SEQUENCE foo_rescan_seq1;
! CREATE TEMPORARY SEQUENCE foo_rescan_seq2;
! CREATE TYPE foo_rescan_t AS (i integer, s bigint);
! CREATE FUNCTION foo_sql(int,int) RETURNS setof foo_rescan_t AS 'SELECT i, nextval(''foo_rescan_seq1'') FROM generate_series($1,$2) i;' LANGUAGE SQL;
! -- plpgsql functions use materialize mode
! CREATE FUNCTION foo_mat(int,int) RETURNS setof foo_rescan_t AS 'begin for i in $1..$2 loop return next (i, nextval(''foo_rescan_seq2'')); end loop; end;' LANGUAGE plpgsql;
! --invokes ExecReScanFunctionScan - all these cases should materialize the function only once
! -- LEFT JOIN on a condition that the planner can't prove to be true is used to ensure the function
! -- is on the inner path of a nestloop join
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN foo_sql(11,13) ON (r+i)<100;
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  2 | 11 | 1
!  2 | 12 | 2
!  2 | 13 | 3
!  3 | 11 | 1
!  3 | 12 | 2
!  3 | 13 | 3
! (9 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN foo_sql(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  1 | 12 | 2 | 2
!  1 | 13 | 3 | 3
!  2 | 11 | 1 | 1
!  2 | 12 | 2 | 2
!  2 | 13 | 3 | 3
!  3 | 11 | 1 | 1
!  3 | 12 | 2 | 2
!  3 | 13 | 3 | 3
! (9 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN foo_mat(11,13) ON (r+i)<100;
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  2 | 11 | 1
!  2 | 12 | 2
!  2 | 13 | 3
!  3 | 11 | 1
!  3 | 12 | 2
!  3 | 13 | 3
! (9 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN foo_mat(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  1 | 12 | 2 | 2
!  1 | 13 | 3 | 3
!  2 | 11 | 1 | 1
!  2 | 12 | 2 | 2
!  2 | 13 | 3 | 3
!  3 | 11 | 1 | 1
!  3 | 12 | 2 | 2
!  3 | 13 | 3 | 3
! (9 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN ROWS FROM( foo_sql(11,13), foo_mat(11,13) ) WITH ORDINALITY AS f(i1,s1,i2,s2,o) ON (r+i1+i2)<100;
!  r | i1 | s1 | i2 | s2 | o 
! ---+----+----+----+----+---
!  1 | 11 |  1 | 11 |  1 | 1
!  1 | 12 |  2 | 12 |  2 | 2
!  1 | 13 |  3 | 13 |  3 | 3
!  2 | 11 |  1 | 11 |  1 | 1
!  2 | 12 |  2 | 12 |  2 | 2
!  2 | 13 |  3 | 13 |  3 | 3
!  3 | 11 |  1 | 11 |  1 | 1
!  3 | 12 |  2 | 12 |  2 | 2
!  3 | 13 |  3 | 13 |  3 | 3
! (9 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) f(i) ON (r+i)<100;
!  r | i  
! ---+----
!  1 | 11
!  1 | 12
!  1 | 13
!  2 | 11
!  2 | 12
!  2 | 13
!  3 | 11
!  3 | 12
!  3 | 13
! (9 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
!  r | i  | o 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  2 | 11 | 1
!  2 | 12 | 2
!  2 | 13 | 3
!  3 | 11 | 1
!  3 | 12 | 2
!  3 | 13 | 3
! (9 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) f(i) ON (r+i)<100;
!  r | i  
! ---+----
!  1 | 10
!  1 | 20
!  1 | 30
!  2 | 10
!  2 | 20
!  2 | 30
!  3 | 10
!  3 | 20
!  3 | 30
! (9 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
!  r | i  | o 
! ---+----+---
!  1 | 10 | 1
!  1 | 20 | 2
!  1 | 30 | 3
!  2 | 10 | 1
!  2 | 20 | 2
!  2 | 30 | 3
!  3 | 10 | 1
!  3 | 20 | 2
!  3 | 30 | 3
! (9 rows)
! 
! --invokes ExecReScanFunctionScan with chgParam != NULL (using implied LATERAL)
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_sql(10+r,13);
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  2 | 12 | 4
!  2 | 13 | 5
!  3 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_sql(10+r,13) WITH ORDINALITY AS f(i,s,o);
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  1 | 12 | 2 | 2
!  1 | 13 | 3 | 3
!  2 | 12 | 4 | 1
!  2 | 13 | 5 | 2
!  3 | 13 | 6 | 1
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_sql(11,10+r);
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  2 | 11 | 2
!  2 | 12 | 3
!  3 | 11 | 4
!  3 | 12 | 5
!  3 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_sql(11,10+r) WITH ORDINALITY AS f(i,s,o);
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  2 | 11 | 2 | 1
!  2 | 12 | 3 | 2
!  3 | 11 | 4 | 1
!  3 | 12 | 5 | 2
!  3 | 13 | 6 | 3
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), foo_sql(r1,r2);
!  r1 | r2 | i  | s  
! ----+----+----+----
!  11 | 12 | 11 |  1
!  11 | 12 | 12 |  2
!  13 | 15 | 13 |  3
!  13 | 15 | 14 |  4
!  13 | 15 | 15 |  5
!  16 | 20 | 16 |  6
!  16 | 20 | 17 |  7
!  16 | 20 | 18 |  8
!  16 | 20 | 19 |  9
!  16 | 20 | 20 | 10
! (10 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), foo_sql(r1,r2) WITH ORDINALITY AS f(i,s,o);
!  r1 | r2 | i  | s  | o 
! ----+----+----+----+---
!  11 | 12 | 11 |  1 | 1
!  11 | 12 | 12 |  2 | 2
!  13 | 15 | 13 |  3 | 1
!  13 | 15 | 14 |  4 | 2
!  13 | 15 | 15 |  5 | 3
!  16 | 20 | 16 |  6 | 1
!  16 | 20 | 17 |  7 | 2
!  16 | 20 | 18 |  8 | 3
!  16 | 20 | 19 |  9 | 4
!  16 | 20 | 20 | 10 | 5
! (10 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_mat(10+r,13);
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  2 | 12 | 4
!  2 | 13 | 5
!  3 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_mat(10+r,13) WITH ORDINALITY AS f(i,s,o);
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  1 | 12 | 2 | 2
!  1 | 13 | 3 | 3
!  2 | 12 | 4 | 1
!  2 | 13 | 5 | 2
!  3 | 13 | 6 | 1
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_mat(11,10+r);
!  r | i  | s 
! ---+----+---
!  1 | 11 | 1
!  2 | 11 | 2
!  2 | 12 | 3
!  3 | 11 | 4
!  3 | 12 | 5
!  3 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), foo_mat(11,10+r) WITH ORDINALITY AS f(i,s,o);
!  r | i  | s | o 
! ---+----+---+---
!  1 | 11 | 1 | 1
!  2 | 11 | 2 | 1
!  2 | 12 | 3 | 2
!  3 | 11 | 4 | 1
!  3 | 12 | 5 | 2
!  3 | 13 | 6 | 3
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), foo_mat(r1,r2);
!  r1 | r2 | i  | s  
! ----+----+----+----
!  11 | 12 | 11 |  1
!  11 | 12 | 12 |  2
!  13 | 15 | 13 |  3
!  13 | 15 | 14 |  4
!  13 | 15 | 15 |  5
!  16 | 20 | 16 |  6
!  16 | 20 | 17 |  7
!  16 | 20 | 18 |  8
!  16 | 20 | 19 |  9
!  16 | 20 | 20 | 10
! (10 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), foo_mat(r1,r2) WITH ORDINALITY AS f(i,s,o);
!  r1 | r2 | i  | s  | o 
! ----+----+----+----+---
!  11 | 12 | 11 |  1 | 1
!  11 | 12 | 12 |  2 | 2
!  13 | 15 | 13 |  3 | 1
!  13 | 15 | 14 |  4 | 2
!  13 | 15 | 15 |  5 | 3
!  16 | 20 | 16 |  6 | 1
!  16 | 20 | 17 |  7 | 2
!  16 | 20 | 18 |  8 | 3
!  16 | 20 | 19 |  9 | 4
!  16 | 20 | 20 | 10 | 5
! (10 rows)
! 
! -- selective rescan of multiple functions:
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( foo_sql(11,11), foo_mat(10+r,13) );
!  r | i  | s | i  | s 
! ---+----+---+----+---
!  1 | 11 | 1 | 11 | 1
!  1 |    |   | 12 | 2
!  1 |    |   | 13 | 3
!  2 | 11 | 1 | 12 | 4
!  2 |    |   | 13 | 5
!  3 | 11 | 1 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( foo_sql(10+r,13), foo_mat(11,11) );
!  r | i  | s | i  | s 
! ---+----+---+----+---
!  1 | 11 | 1 | 11 | 1
!  1 | 12 | 2 |    |  
!  1 | 13 | 3 |    |  
!  2 | 12 | 4 | 11 | 1
!  2 | 13 | 5 |    |  
!  3 | 13 | 6 | 11 | 1
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( foo_sql(10+r,13), foo_mat(10+r,13) );
!  r | i  | s | i  | s 
! ---+----+---+----+---
!  1 | 11 | 1 | 11 | 1
!  1 | 12 | 2 | 12 | 2
!  1 | 13 | 3 | 13 | 3
!  2 | 12 | 4 | 12 | 4
!  2 | 13 | 5 | 13 | 5
!  3 | 13 | 6 | 13 | 6
! (6 rows)
! 
! SELECT setval('foo_rescan_seq1',1,false),setval('foo_rescan_seq2',1,false);
!  setval | setval 
! --------+--------
!       1 |      1
! (1 row)
! 
! SELECT * FROM generate_series(1,2) r1, generate_series(r1,3) r2, ROWS FROM( foo_sql(10+r1,13), foo_mat(10+r2,13) );
!  r1 | r2 | i  | s  | i  | s 
! ----+----+----+----+----+---
!   1 |  1 | 11 |  1 | 11 | 1
!   1 |  1 | 12 |  2 | 12 | 2
!   1 |  1 | 13 |  3 | 13 | 3
!   1 |  2 | 11 |  4 | 12 | 4
!   1 |  2 | 12 |  5 | 13 | 5
!   1 |  2 | 13 |  6 |    |  
!   1 |  3 | 11 |  7 | 13 | 6
!   1 |  3 | 12 |  8 |    |  
!   1 |  3 | 13 |  9 |    |  
!   2 |  2 | 12 | 10 | 12 | 7
!   2 |  2 | 13 | 11 | 13 | 8
!   2 |  3 | 12 | 12 | 13 | 9
!   2 |  3 | 13 | 13 |    |  
! (13 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) f(i);
!  r | i  
! ---+----
!  1 | 11
!  1 | 12
!  1 | 13
!  1 | 14
!  1 | 15
!  1 | 16
!  1 | 17
!  1 | 18
!  1 | 19
!  2 | 12
!  2 | 13
!  2 | 14
!  2 | 15
!  2 | 16
!  2 | 17
!  2 | 18
!  3 | 13
!  3 | 14
!  3 | 15
!  3 | 16
!  3 | 17
! (21 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) WITH ORDINALITY AS f(i,o);
!  r | i  | o 
! ---+----+---
!  1 | 11 | 1
!  1 | 12 | 2
!  1 | 13 | 3
!  1 | 14 | 4
!  1 | 15 | 5
!  1 | 16 | 6
!  1 | 17 | 7
!  1 | 18 | 8
!  1 | 19 | 9
!  2 | 12 | 1
!  2 | 13 | 2
!  2 | 14 | 3
!  2 | 15 | 4
!  2 | 16 | 5
!  2 | 17 | 6
!  2 | 18 | 7
!  3 | 13 | 1
!  3 | 14 | 2
!  3 | 15 | 3
!  3 | 16 | 4
!  3 | 17 | 5
! (21 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) f(i);
!  r | i  
! ---+----
!  1 | 10
!  1 | 20
!  1 | 30
!  2 | 20
!  2 | 40
!  2 | 60
!  3 | 30
!  3 | 60
!  3 | 90
! (9 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) WITH ORDINALITY AS f(i,o);
!  r | i  | o 
! ---+----+---
!  1 | 10 | 1
!  1 | 20 | 2
!  1 | 30 | 3
!  2 | 20 | 1
!  2 | 40 | 2
!  2 | 60 | 3
!  3 | 30 | 1
!  3 | 60 | 2
!  3 | 90 | 3
! (9 rows)
! 
! -- deep nesting
! SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
!               LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
!                                          LEFT JOIN generate_series(21,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
!  r1 | r1 | r2 | i  
! ----+----+----+----
!   1 |  1 | 10 | 21
!   1 |  1 | 10 | 22
!   1 |  1 | 10 | 23
!   1 |  1 | 20 | 21
!   1 |  1 | 20 | 22
!   1 |  1 | 20 | 23
!   1 |  1 | 30 | 21
!   1 |  1 | 30 | 22
!   1 |  1 | 30 | 23
!   2 |  2 | 10 | 21
!   2 |  2 | 10 | 22
!   2 |  2 | 10 | 23
!   2 |  2 | 20 | 21
!   2 |  2 | 20 | 22
!   2 |  2 | 20 | 23
!   2 |  2 | 30 | 21
!   2 |  2 | 30 | 22
!   2 |  2 | 30 | 23
!   3 |  3 | 10 | 21
!   3 |  3 | 10 | 22
!   3 |  3 | 10 | 23
!   3 |  3 | 20 | 21
!   3 |  3 | 20 | 22
!   3 |  3 | 20 | 23
!   3 |  3 | 30 | 21
!   3 |  3 | 30 | 22
!   3 |  3 | 30 | 23
! (27 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
!               LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
!                                          LEFT JOIN generate_series(20+r1,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
!  r1 | r1 | r2 | i  
! ----+----+----+----
!   1 |  1 | 10 | 21
!   1 |  1 | 10 | 22
!   1 |  1 | 10 | 23
!   1 |  1 | 20 | 21
!   1 |  1 | 20 | 22
!   1 |  1 | 20 | 23
!   1 |  1 | 30 | 21
!   1 |  1 | 30 | 22
!   1 |  1 | 30 | 23
!   2 |  2 | 10 | 22
!   2 |  2 | 10 | 23
!   2 |  2 | 20 | 22
!   2 |  2 | 20 | 23
!   2 |  2 | 30 | 22
!   2 |  2 | 30 | 23
!   3 |  3 | 10 | 23
!   3 |  3 | 20 | 23
!   3 |  3 | 30 | 23
! (18 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
!               LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
!                                          LEFT JOIN generate_series(r2,r2+3) f(i) ON ((r2+i)<100) OFFSET 0) s1;
!  r1 | r1 | r2 | i  
! ----+----+----+----
!   1 |  1 | 10 | 10
!   1 |  1 | 10 | 11
!   1 |  1 | 10 | 12
!   1 |  1 | 10 | 13
!   1 |  1 | 20 | 20
!   1 |  1 | 20 | 21
!   1 |  1 | 20 | 22
!   1 |  1 | 20 | 23
!   1 |  1 | 30 | 30
!   1 |  1 | 30 | 31
!   1 |  1 | 30 | 32
!   1 |  1 | 30 | 33
!   2 |  2 | 10 | 10
!   2 |  2 | 10 | 11
!   2 |  2 | 10 | 12
!   2 |  2 | 10 | 13
!   2 |  2 | 20 | 20
!   2 |  2 | 20 | 21
!   2 |  2 | 20 | 22
!   2 |  2 | 20 | 23
!   2 |  2 | 30 | 30
!   2 |  2 | 30 | 31
!   2 |  2 | 30 | 32
!   2 |  2 | 30 | 33
!   3 |  3 | 10 | 10
!   3 |  3 | 10 | 11
!   3 |  3 | 10 | 12
!   3 |  3 | 10 | 13
!   3 |  3 | 20 | 20
!   3 |  3 | 20 | 21
!   3 |  3 | 20 | 22
!   3 |  3 | 20 | 23
!   3 |  3 | 30 | 30
!   3 |  3 | 30 | 31
!   3 |  3 | 30 | 32
!   3 |  3 | 30 | 33
! (36 rows)
! 
! SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
!               LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
!                                          LEFT JOIN generate_series(r1,2+r2/5) f(i) ON ((r2+i)<100) OFFSET 0) s1;
!  r1 | r1 | r2 | i 
! ----+----+----+---
!   1 |  1 | 10 | 1
!   1 |  1 | 10 | 2
!   1 |  1 | 10 | 3
!   1 |  1 | 10 | 4
!   1 |  1 | 20 | 1
!   1 |  1 | 20 | 2
!   1 |  1 | 20 | 3
!   1 |  1 | 20 | 4
!   1 |  1 | 20 | 5
!   1 |  1 | 20 | 6
!   1 |  1 | 30 | 1
!   1 |  1 | 30 | 2
!   1 |  1 | 30 | 3
!   1 |  1 | 30 | 4
!   1 |  1 | 30 | 5
!   1 |  1 | 30 | 6
!   1 |  1 | 30 | 7
!   1 |  1 | 30 | 8
!   2 |  2 | 10 | 2
!   2 |  2 | 10 | 3
!   2 |  2 | 10 | 4
!   2 |  2 | 20 | 2
!   2 |  2 | 20 | 3
!   2 |  2 | 20 | 4
!   2 |  2 | 20 | 5
!   2 |  2 | 20 | 6
!   2 |  2 | 30 | 2
!   2 |  2 | 30 | 3
!   2 |  2 | 30 | 4
!   2 |  2 | 30 | 5
!   2 |  2 | 30 | 6
!   2 |  2 | 30 | 7
!   2 |  2 | 30 | 8
!   3 |  3 | 10 | 3
!   3 |  3 | 10 | 4
!   3 |  3 | 20 | 3
!   3 |  3 | 20 | 4
!   3 |  3 | 20 | 5
!   3 |  3 | 20 | 6
!   3 |  3 | 30 | 3
!   3 |  3 | 30 | 4
!   3 |  3 | 30 | 5
!   3 |  3 | 30 | 6
!   3 |  3 | 30 | 7
!   3 |  3 | 30 | 8
! (45 rows)
! 
! DROP FUNCTION foo_sql(int,int);
! DROP FUNCTION foo_mat(int,int);
! DROP SEQUENCE foo_rescan_seq1;
! DROP SEQUENCE foo_rescan_seq2;
! --
! -- Test cases involving OUT parameters
! --
! CREATE FUNCTION foo(in f1 int, out f2 int)
! AS 'select $1+1' LANGUAGE sql;
! SELECT foo(42);
!  foo 
! -----
!   43
! (1 row)
! 
! SELECT * FROM foo(42);
!  f2 
! ----
!  43
! (1 row)
! 
! SELECT * FROM foo(42) AS p(x);
!  x  
! ----
!  43
! (1 row)
! 
! -- explicit spec of return type is OK
! CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int) RETURNS int
! AS 'select $1+1' LANGUAGE sql;
! -- error, wrong result type
! CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int) RETURNS float
! AS 'select $1+1' LANGUAGE sql;
! ERROR:  function result type must be integer because of OUT parameters
! -- with multiple OUT params you must get a RECORD result
! CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int, out f3 text) RETURNS int
! AS 'select $1+1' LANGUAGE sql;
! ERROR:  function result type must be record because of OUT parameters
! CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int, out f3 text)
! RETURNS record
! AS 'select $1+1' LANGUAGE sql;
! ERROR:  cannot change return type of existing function
! HINT:  Use DROP FUNCTION foo(integer) first.
! CREATE OR REPLACE FUNCTION foor(in f1 int, out f2 int, out text)
! AS $$select $1-1, $1::text || 'z'$$ LANGUAGE sql;
! SELECT f1, foor(f1) FROM int4_tbl;
!      f1      |            foor            
! -------------+----------------------------
!            0 | (-1,0z)
!       123456 | (123455,123456z)
!      -123456 | (-123457,-123456z)
!   2147483647 | (2147483646,2147483647z)
!  -2147483647 | (-2147483648,-2147483647z)
! (5 rows)
! 
! SELECT * FROM foor(42);
!  f2 | column2 
! ----+---------
!  41 | 42z
! (1 row)
! 
! SELECT * FROM foor(42) AS p(a,b);
!  a  |  b  
! ----+-----
!  41 | 42z
! (1 row)
! 
! CREATE OR REPLACE FUNCTION foob(in f1 int, inout f2 int, out text)
! AS $$select $2-1, $1::text || 'z'$$ LANGUAGE sql;
! SELECT f1, foob(f1, f1/2) FROM int4_tbl;
!      f1      |            foob            
! -------------+----------------------------
!            0 | (-1,0z)
!       123456 | (61727,123456z)
!      -123456 | (-61729,-123456z)
!   2147483647 | (1073741822,2147483647z)
!  -2147483647 | (-1073741824,-2147483647z)
! (5 rows)
! 
! SELECT * FROM foob(42, 99);
!  f2 | column2 
! ----+---------
!  98 | 42z
! (1 row)
! 
! SELECT * FROM foob(42, 99) AS p(a,b);
!  a  |  b  
! ----+-----
!  98 | 42z
! (1 row)
! 
! -- Can reference function with or without OUT params for DROP, etc
! DROP FUNCTION foo(int);
! DROP FUNCTION foor(in f2 int, out f1 int, out text);
! DROP FUNCTION foob(in f1 int, inout f2 int);
! --
! -- For my next trick, polymorphic OUT parameters
! --
! CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)
! AS 'select $1, array[$1,$1]' LANGUAGE sql;
! SELECT dup(22);
!       dup       
! ----------------
!  (22,"{22,22}")
! (1 row)
! 
! SELECT dup('xyz');	-- fails
! ERROR:  could not determine polymorphic type because input has type "unknown"
! SELECT dup('xyz'::text);
!         dup        
! -------------------
!  (xyz,"{xyz,xyz}")
! (1 row)
! 
! SELECT * FROM dup('xyz'::text);
!  f2  |    f3     
! -----+-----------
!  xyz | {xyz,xyz}
! (1 row)
! 
! -- fails, as we are attempting to rename first argument
! CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
! AS 'select $1, array[$1,$1]' LANGUAGE sql;
! ERROR:  cannot change name of input parameter "f1"
! HINT:  Use DROP FUNCTION dup(anyelement) first.
! DROP FUNCTION dup(anyelement);
! -- equivalent behavior, though different name exposed for input arg
! CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
! AS 'select $1, array[$1,$1]' LANGUAGE sql;
! SELECT dup(22);
!       dup       
! ----------------
!  (22,"{22,22}")
! (1 row)
! 
! DROP FUNCTION dup(anyelement);
! -- fails, no way to deduce outputs
! CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
! AS 'select $1, array[$1,$1]' LANGUAGE sql;
! ERROR:  cannot determine result data type
! DETAIL:  A function returning a polymorphic type must have at least one polymorphic argument.
! --
! -- table functions
! --
! CREATE OR REPLACE FUNCTION foo()
! RETURNS TABLE(a int)
! AS $$ SELECT a FROM generate_series(1,5) a(a) $$ LANGUAGE sql;
! SELECT * FROM foo();
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
! DROP FUNCTION foo();
! CREATE OR REPLACE FUNCTION foo(int)
! RETURNS TABLE(a int, b int)
! AS $$ SELECT a, b
!          FROM generate_series(1,$1) a(a),
!               generate_series(1,$1) b(b) $$ LANGUAGE sql;
! SELECT * FROM foo(3);
!  a | b 
! ---+---
!  1 | 1
!  1 | 2
!  1 | 3
!  2 | 1
!  2 | 2
!  2 | 3
!  3 | 1
!  3 | 2
!  3 | 3
! (9 rows)
! 
! DROP FUNCTION foo(int);
! -- case that causes change of typmod knowledge during inlining
! CREATE OR REPLACE FUNCTION foo()
! RETURNS TABLE(a varchar(5))
! AS $$ SELECT 'hello'::varchar(5) $$ LANGUAGE sql STABLE;
! SELECT * FROM foo() GROUP BY 1;
!    a   
! -------
!  hello
! (1 row)
! 
! DROP FUNCTION foo();
! --
! -- some tests on SQL functions with RETURNING
! --
! create temp table tt(f1 serial, data text);
! create function insert_tt(text) returns int as
! $$ insert into tt(data) values($1) returning f1 $$
! language sql;
! select insert_tt('foo');
!  insert_tt 
! -----------
!          1
! (1 row)
! 
! select insert_tt('bar');
!  insert_tt 
! -----------
!          2
! (1 row)
! 
! select * from tt;
!  f1 | data 
! ----+------
!   1 | foo
!   2 | bar
! (2 rows)
! 
! -- insert will execute to completion even if function needs just 1 row
! create or replace function insert_tt(text) returns int as
! $$ insert into tt(data) values($1),($1||$1) returning f1 $$
! language sql;
! select insert_tt('fool');
!  insert_tt 
! -----------
!          3
! (1 row)
! 
! select * from tt;
!  f1 |   data   
! ----+----------
!   1 | foo
!   2 | bar
!   3 | fool
!   4 | foolfool
! (4 rows)
! 
! -- setof does what's expected
! create or replace function insert_tt2(text,text) returns setof int as
! $$ insert into tt(data) values($1),($2) returning f1 $$
! language sql;
! select insert_tt2('foolish','barrish');
!  insert_tt2 
! ------------
!           5
!           6
! (2 rows)
! 
! select * from insert_tt2('baz','quux');
!  insert_tt2 
! ------------
!           7
!           8
! (2 rows)
! 
! select * from tt;
!  f1 |   data   
! ----+----------
!   1 | foo
!   2 | bar
!   3 | fool
!   4 | foolfool
!   5 | foolish
!   6 | barrish
!   7 | baz
!   8 | quux
! (8 rows)
! 
! -- limit doesn't prevent execution to completion
! select insert_tt2('foolish','barrish') limit 1;
!  insert_tt2 
! ------------
!           9
! (1 row)
! 
! select * from tt;
!  f1 |   data   
! ----+----------
!   1 | foo
!   2 | bar
!   3 | fool
!   4 | foolfool
!   5 | foolish
!   6 | barrish
!   7 | baz
!   8 | quux
!   9 | foolish
!  10 | barrish
! (10 rows)
! 
! -- triggers will fire, too
! create function noticetrigger() returns trigger as $$
! begin
!   raise notice 'noticetrigger % %', new.f1, new.data;
!   return null;
! end $$ language plpgsql;
! create trigger tnoticetrigger after insert on tt for each row
! execute procedure noticetrigger();
! select insert_tt2('foolme','barme') limit 1;
! NOTICE:  noticetrigger 11 foolme
! CONTEXT:  SQL function "insert_tt2" statement 1
! NOTICE:  noticetrigger 12 barme
! CONTEXT:  SQL function "insert_tt2" statement 1
!  insert_tt2 
! ------------
!          11
! (1 row)
! 
! select * from tt;
!  f1 |   data   
! ----+----------
!   1 | foo
!   2 | bar
!   3 | fool
!   4 | foolfool
!   5 | foolish
!   6 | barrish
!   7 | baz
!   8 | quux
!   9 | foolish
!  10 | barrish
!  11 | foolme
!  12 | barme
! (12 rows)
! 
! -- and rules work
! create temp table tt_log(f1 int, data text);
! create rule insert_tt_rule as on insert to tt do also
!   insert into tt_log values(new.*);
! select insert_tt2('foollog','barlog') limit 1;
! NOTICE:  noticetrigger 13 foollog
! CONTEXT:  SQL function "insert_tt2" statement 1
! NOTICE:  noticetrigger 14 barlog
! CONTEXT:  SQL function "insert_tt2" statement 1
!  insert_tt2 
! ------------
!          13
! (1 row)
! 
! select * from tt;
!  f1 |   data   
! ----+----------
!   1 | foo
!   2 | bar
!   3 | fool
!   4 | foolfool
!   5 | foolish
!   6 | barrish
!   7 | baz
!   8 | quux
!   9 | foolish
!  10 | barrish
!  11 | foolme
!  12 | barme
!  13 | foollog
!  14 | barlog
! (14 rows)
! 
! -- note that nextval() gets executed a second time in the rule expansion,
! -- which is expected.
! select * from tt_log;
!  f1 |  data   
! ----+---------
!  15 | foollog
!  16 | barlog
! (2 rows)
! 
! -- test case for a whole-row-variable bug
! create function foo1(n integer, out a text, out b text)
!   returns setof record
!   language sql
!   as $$ select 'foo ' || i, 'bar ' || i from generate_series(1,$1) i $$;
! set work_mem='64kB';
! select t.a, t, t.a from foo1(10000) t limit 1;
!    a   |         t         |   a   
! -------+-------------------+-------
!  foo 1 | ("foo 1","bar 1") | foo 1
! (1 row)
! 
! reset work_mem;
! select t.a, t, t.a from foo1(10000) t limit 1;
!    a   |         t         |   a   
! -------+-------------------+-------
!  foo 1 | ("foo 1","bar 1") | foo 1
! (1 row)
! 
! drop function foo1(n integer);
! -- test use of SQL functions returning record
! -- this is supported in some cases where the query doesn't specify
! -- the actual record type ...
! create function array_to_set(anyarray) returns setof record as $$
!   select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i
! $$ language sql strict immutable;
! select array_to_set(array['one', 'two']);
!  array_to_set 
! --------------
!  (1,one)
!  (2,two)
! (2 rows)
! 
! select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
!  f1 | f2  
! ----+-----
!   1 | one
!   2 | two
! (2 rows)
! 
! select * from array_to_set(array['one', 'two']); -- fail
! ERROR:  a column definition list is required for functions returning "record"
! LINE 1: select * from array_to_set(array['one', 'two']);
!                       ^
! create temp table foo(f1 int8, f2 int8);
! create function testfoo() returns record as $$
!   insert into foo values (1,2) returning *;
! $$ language sql;
! select testfoo();
!  testfoo 
! ---------
!  (1,2)
! (1 row)
! 
! select * from testfoo() as t(f1 int8,f2 int8);
!  f1 | f2 
! ----+----
!   1 |  2
! (1 row)
! 
! select * from testfoo(); -- fail
! ERROR:  a column definition list is required for functions returning "record"
! LINE 1: select * from testfoo();
!                       ^
! drop function testfoo();
! create function testfoo() returns setof record as $$
!   insert into foo values (1,2), (3,4) returning *;
! $$ language sql;
! select testfoo();
!  testfoo 
! ---------
!  (1,2)
!  (3,4)
! (2 rows)
! 
! select * from testfoo() as t(f1 int8,f2 int8);
!  f1 | f2 
! ----+----
!   1 |  2
!   3 |  4
! (2 rows)
! 
! select * from testfoo(); -- fail
! ERROR:  a column definition list is required for functions returning "record"
! LINE 1: select * from testfoo();
!                       ^
! drop function testfoo();
! --
! -- Check some cases involving added/dropped columns in a rowtype result
! --
! create temp table users (userid text, seq int, email text, todrop bool, moredrop int, enabled bool);
! insert into users values ('id',1,'email',true,11,true);
! insert into users values ('id2',2,'email2',true,12,true);
! alter table users drop column todrop;
! create or replace function get_first_user() returns users as
! $$ SELECT * FROM users ORDER BY userid LIMIT 1; $$
! language sql stable;
! SELECT get_first_user();
!   get_first_user   
! -------------------
!  (id,1,email,11,t)
! (1 row)
! 
! SELECT * FROM get_first_user();
!  userid | seq | email | moredrop | enabled 
! --------+-----+-------+----------+---------
!  id     |   1 | email |       11 | t
! (1 row)
! 
! create or replace function get_users() returns setof users as
! $$ SELECT * FROM users ORDER BY userid; $$
! language sql stable;
! SELECT get_users();
!       get_users      
! ---------------------
!  (id,1,email,11,t)
!  (id2,2,email2,12,t)
! (2 rows)
! 
! SELECT * FROM get_users();
!  userid | seq | email  | moredrop | enabled 
! --------+-----+--------+----------+---------
!  id     |   1 | email  |       11 | t
!  id2    |   2 | email2 |       12 | t
! (2 rows)
! 
! SELECT * FROM get_users() WITH ORDINALITY;   -- make sure ordinality copes
!  userid | seq | email  | moredrop | enabled | ordinality 
! --------+-----+--------+----------+---------+------------
!  id     |   1 | email  |       11 | t       |          1
!  id2    |   2 | email2 |       12 | t       |          2
! (2 rows)
! 
! -- multiple functions vs. dropped columns
! SELECT * FROM ROWS FROM(generate_series(10,11), get_users()) WITH ORDINALITY;
!  generate_series | userid | seq | email  | moredrop | enabled | ordinality 
! -----------------+--------+-----+--------+----------+---------+------------
!               10 | id     |   1 | email  |       11 | t       |          1
!               11 | id2    |   2 | email2 |       12 | t       |          2
! (2 rows)
! 
! SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
!  userid | seq | email  | moredrop | enabled | generate_series | ordinality 
! --------+-----+--------+----------+---------+-----------------+------------
!  id     |   1 | email  |       11 | t       |              10 |          1
!  id2    |   2 | email2 |       12 | t       |              11 |          2
! (2 rows)
! 
! -- check that we can cope with post-parsing changes in rowtypes
! create temp view usersview as
! SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
! select * from usersview;
!  userid | seq | email  | moredrop | enabled | generate_series | ordinality 
! --------+-----+--------+----------+---------+-----------------+------------
!  id     |   1 | email  |       11 | t       |              10 |          1
!  id2    |   2 | email2 |       12 | t       |              11 |          2
! (2 rows)
! 
! alter table users drop column moredrop;
! select * from usersview;
!  userid | seq | email  | moredrop | enabled | generate_series | ordinality 
! --------+-----+--------+----------+---------+-----------------+------------
!  id     |   1 | email  |          | t       |              10 |          1
!  id2    |   2 | email2 |          | t       |              11 |          2
! (2 rows)
! 
! alter table users add column junk text;
! select * from usersview;
!  userid | seq | email  | moredrop | enabled | generate_series | ordinality 
! --------+-----+--------+----------+---------+-----------------+------------
!  id     |   1 | email  |          | t       |              10 |          1
!  id2    |   2 | email2 |          | t       |              11 |          2
! (2 rows)
! 
! alter table users alter column seq type numeric;
! select * from usersview;  -- expect clean failure
! ERROR:  attribute 2 has wrong type
! DETAIL:  Table has type numeric, but query expects integer.
! drop view usersview;
! drop function get_first_user();
! drop function get_users();
! drop table users;
! -- this won't get inlined because of type coercion, but it shouldn't fail
! create or replace function foobar() returns setof text as
! $$ select 'foo'::varchar union all select 'bar'::varchar ; $$
! language sql stable;
! select foobar();
!  foobar 
! --------
!  foo
!  bar
! (2 rows)
! 
! select * from foobar();
!  foobar 
! --------
!  foo
!  bar
! (2 rows)
! 
! drop function foobar();
! -- check handling of a SQL function with multiple OUT params (bug #5777)
! create or replace function foobar(out integer, out numeric) as
! $$ select (1, 2.1) $$ language sql;
! select * from foobar();
!  column1 | column2 
! ---------+---------
!        1 |     2.1
! (1 row)
! 
! create or replace function foobar(out integer, out numeric) as
! $$ select (1, 2) $$ language sql;
! select * from foobar();  -- fail
! ERROR:  function return row and query-specified return row do not match
! DETAIL:  Returned type integer at ordinal position 2, but query expects numeric.
! create or replace function foobar(out integer, out numeric) as
! $$ select (1, 2.1, 3) $$ language sql;
! select * from foobar();  -- fail
! ERROR:  function return row and query-specified return row do not match
! DETAIL:  Returned row contains 3 attributes, but query expects 2.
! drop function foobar();
! -- check behavior when a function's input sometimes returns a set (bug #8228)
! SELECT *,
!   lower(CASE WHEN id = 2 THEN (regexp_matches(str, '^0*([1-9]\d+)$'))[1]
!         ELSE str
!         END)
! FROM
!   (VALUES (1,''), (2,'0000000049404'), (3,'FROM 10000000876')) v(id, str);
!  id |       str        |      lower       
! ----+------------------+------------------
!   1 |                  | 
!   2 | 0000000049404    | 49404
!   3 | FROM 10000000876 | from 10000000876
! (3 rows)
! 
! -- check whole-row-Var handling in nested lateral functions (bug #11703)
! create function extractq2(t int8_tbl) returns int8 as $$
!   select t.q2
! $$ language sql immutable;
! explain (verbose, costs off)
! select x from int8_tbl, extractq2(int8_tbl) f(x);
!                 QUERY PLAN                
! ------------------------------------------
!  Nested Loop
!    Output: f.x
!    ->  Seq Scan on public.int8_tbl
!          Output: int8_tbl.q1, int8_tbl.q2
!    ->  Function Scan on f
!          Output: f.x
!          Function Call: int8_tbl.q2
! (7 rows)
! 
! select x from int8_tbl, extractq2(int8_tbl) f(x);
!          x         
! -------------------
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (5 rows)
! 
! create function extractq2_2(t int8_tbl) returns table(ret1 int8) as $$
!   select extractq2(t)
! $$ language sql immutable;
! explain (verbose, costs off)
! select x from int8_tbl, extractq2_2(int8_tbl) f(x);
!             QUERY PLAN             
! -----------------------------------
!  Nested Loop
!    Output: ((int8_tbl.*).q2)
!    ->  Seq Scan on public.int8_tbl
!          Output: int8_tbl.*
!    ->  Result
!          Output: (int8_tbl.*).q2
! (6 rows)
! 
! select x from int8_tbl, extractq2_2(int8_tbl) f(x);
!          x         
! -------------------
!                456
!   4567890123456789
!                123
!   4567890123456789
!  -4567890123456789
! (5 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/prepare.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/prepare.out	2015-01-26 12:33:26.319031434 +0300
***************
*** 1,180 ****
! -- Regression tests for prepareable statements. We query the content
! -- of the pg_prepared_statements view as prepared statements are
! -- created and removed.
! SELECT name, statement, parameter_types FROM pg_prepared_statements;
!  name | statement | parameter_types 
! ------+-----------+-----------------
! (0 rows)
! 
! PREPARE q1 AS SELECT 1 AS a;
! EXECUTE q1;
!  a 
! ---
!  1
! (1 row)
! 
! SELECT name, statement, parameter_types FROM pg_prepared_statements;
!  name |          statement           | parameter_types 
! ------+------------------------------+-----------------
!  q1   | PREPARE q1 AS SELECT 1 AS a; | {}
! (1 row)
! 
! -- should fail
! PREPARE q1 AS SELECT 2;
! ERROR:  prepared statement "q1" already exists
! -- should succeed
! DEALLOCATE q1;
! PREPARE q1 AS SELECT 2;
! EXECUTE q1;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! PREPARE q2 AS SELECT 2 AS b;
! SELECT name, statement, parameter_types FROM pg_prepared_statements;
!  name |          statement           | parameter_types 
! ------+------------------------------+-----------------
!  q1   | PREPARE q1 AS SELECT 2;      | {}
!  q2   | PREPARE q2 AS SELECT 2 AS b; | {}
! (2 rows)
! 
! -- sql92 syntax
! DEALLOCATE PREPARE q1;
! SELECT name, statement, parameter_types FROM pg_prepared_statements;
!  name |          statement           | parameter_types 
! ------+------------------------------+-----------------
!  q2   | PREPARE q2 AS SELECT 2 AS b; | {}
! (1 row)
! 
! DEALLOCATE PREPARE q2;
! -- the view should return the empty set again
! SELECT name, statement, parameter_types FROM pg_prepared_statements;
!  name | statement | parameter_types 
! ------+-----------+-----------------
! (0 rows)
! 
! -- parameterized queries
! PREPARE q2(text) AS
! 	SELECT datname, datistemplate, datallowconn
! 	FROM pg_database WHERE datname = $1;
! EXECUTE q2('postgres');
!  datname  | datistemplate | datallowconn 
! ----------+---------------+--------------
!  postgres | f             | t
! (1 row)
! 
! PREPARE q3(text, int, float, boolean, oid, smallint) AS
! 	SELECT * FROM tenk1 WHERE string4 = $1 AND (four = $2 OR
! 	ten = $3::bigint OR true = $4 OR oid = $5 OR odd = $6::int)
! 	ORDER BY unique1;
! EXECUTE q3('AAAAxx', 5::smallint, 10.5::float, false, 500::oid, 4::bigint);
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        2 |    2716 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | MAEAAA   | AAAAxx
!      102 |     612 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |       102 |      102 |   4 |    5 | YDAAAA   | OXAAAA   | AAAAxx
!      802 |    2908 |   0 |    2 |   2 |      2 |       2 |      802 |         802 |       802 |      802 |   4 |    5 | WEAAAA   | WHEAAA   | AAAAxx
!      902 |    1104 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |       902 |      902 |   4 |    5 | SIAAAA   | MQBAAA   | AAAAxx
!     1002 |    2580 |   0 |    2 |   2 |      2 |       2 |        2 |        1002 |      1002 |     1002 |   4 |    5 | OMAAAA   | GVDAAA   | AAAAxx
!     1602 |    8148 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      1602 |     1602 |   4 |    5 | QJAAAA   | KBMAAA   | AAAAxx
!     1702 |    7940 |   0 |    2 |   2 |      2 |       2 |      702 |        1702 |      1702 |     1702 |   4 |    5 | MNAAAA   | KTLAAA   | AAAAxx
!     2102 |    6184 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      2102 |     2102 |   4 |    5 | WCAAAA   | WDJAAA   | AAAAxx
!     2202 |    8028 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      2202 |     2202 |   4 |    5 | SGAAAA   | UWLAAA   | AAAAxx
!     2302 |    7112 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      2302 |     2302 |   4 |    5 | OKAAAA   | ONKAAA   | AAAAxx
!     2902 |    6816 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      2902 |     2902 |   4 |    5 | QHAAAA   | ECKAAA   | AAAAxx
!     3202 |    7128 |   0 |    2 |   2 |      2 |       2 |      202 |        1202 |      3202 |     3202 |   4 |    5 | ETAAAA   | EOKAAA   | AAAAxx
!     3902 |    9224 |   0 |    2 |   2 |      2 |       2 |      902 |        1902 |      3902 |     3902 |   4 |    5 | CUAAAA   | UQNAAA   | AAAAxx
!     4102 |    7676 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      4102 |     4102 |   4 |    5 | UBAAAA   | GJLAAA   | AAAAxx
!     4202 |    6628 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      4202 |     4202 |   4 |    5 | QFAAAA   | YUJAAA   | AAAAxx
!     4502 |     412 |   0 |    2 |   2 |      2 |       2 |      502 |         502 |      4502 |     4502 |   4 |    5 | ERAAAA   | WPAAAA   | AAAAxx
!     4702 |    2520 |   0 |    2 |   2 |      2 |       2 |      702 |         702 |      4702 |     4702 |   4 |    5 | WYAAAA   | YSDAAA   | AAAAxx
!     4902 |    1600 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      4902 |     4902 |   4 |    5 | OGAAAA   | OJCAAA   | AAAAxx
!     5602 |    8796 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |       602 |     5602 |   4 |    5 | MHAAAA   | IANAAA   | AAAAxx
!     6002 |    8932 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      1002 |     6002 |   4 |    5 | WWAAAA   | OFNAAA   | AAAAxx
!     6402 |    3808 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      1402 |     6402 |   4 |    5 | GMAAAA   | MQFAAA   | AAAAxx
!     7602 |    1040 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      2602 |     7602 |   4 |    5 | KGAAAA   | AOBAAA   | AAAAxx
!     7802 |    7508 |   0 |    2 |   2 |      2 |       2 |      802 |        1802 |      2802 |     7802 |   4 |    5 | COAAAA   | UCLAAA   | AAAAxx
!     8002 |    9980 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      3002 |     8002 |   4 |    5 | UVAAAA   | WTOAAA   | AAAAxx
!     8302 |    7800 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      3302 |     8302 |   4 |    5 | IHAAAA   | AOLAAA   | AAAAxx
!     8402 |    5708 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      3402 |     8402 |   4 |    5 | ELAAAA   | OLIAAA   | AAAAxx
!     8602 |    5440 |   0 |    2 |   2 |      2 |       2 |      602 |         602 |      3602 |     8602 |   4 |    5 | WSAAAA   | GBIAAA   | AAAAxx
!     9502 |    1812 |   0 |    2 |   2 |      2 |       2 |      502 |        1502 |      4502 |     9502 |   4 |    5 | MBAAAA   | SRCAAA   | AAAAxx
!     9602 |    9972 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      4602 |     9602 |   4 |    5 | IFAAAA   | OTOAAA   | AAAAxx
! (29 rows)
! 
! -- too few params
! EXECUTE q3('bool');
! ERROR:  wrong number of parameters for prepared statement "q3"
! DETAIL:  Expected 6 parameters but got 1.
! -- too many params
! EXECUTE q3('bytea', 5::smallint, 10.5::float, false, 500::oid, 4::bigint, true);
! ERROR:  wrong number of parameters for prepared statement "q3"
! DETAIL:  Expected 6 parameters but got 7.
! -- wrong param types
! EXECUTE q3(5::smallint, 10.5::float, false, 500::oid, 4::bigint, 'bytea');
! ERROR:  parameter $3 of type boolean cannot be coerced to the expected type double precision
! HINT:  You will need to rewrite or cast the expression.
! -- invalid type
! PREPARE q4(nonexistenttype) AS SELECT $1;
! ERROR:  type "nonexistenttype" does not exist
! LINE 1: PREPARE q4(nonexistenttype) AS SELECT $1;
!                    ^
! -- create table as execute
! PREPARE q5(int, text) AS
! 	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2
! 	ORDER BY unique1;
! CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
! SELECT * FROM q5_prep_results;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!      200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx
!      497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx
!     1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx
!     1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx
!     2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx
!     3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx
!     3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx
!     4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx
!     5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx
!     5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx
!     6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx
!     7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx
!     7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx
!     8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx
!     9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx
!     9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx
! (16 rows)
! 
! -- unknown or unspecified parameter types: should succeed
! PREPARE q6 AS
!     SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
! PREPARE q7(unknown) AS
!     SELECT * FROM road WHERE thepath = $1;
! SELECT name, statement, parameter_types FROM pg_prepared_statements
!     ORDER BY name;
!  name |                              statement                              |                    parameter_types                     
! ------+---------------------------------------------------------------------+--------------------------------------------------------
!  q2   | PREPARE q2(text) AS                                                +| {text}
!       |         SELECT datname, datistemplate, datallowconn                +| 
!       |         FROM pg_database WHERE datname = $1;                        | 
!  q3   | PREPARE q3(text, int, float, boolean, oid, smallint) AS            +| {text,integer,"double precision",boolean,oid,smallint}
!       |         SELECT * FROM tenk1 WHERE string4 = $1 AND (four = $2 OR   +| 
!       |         ten = $3::bigint OR true = $4 OR oid = $5 OR odd = $6::int)+| 
!       |         ORDER BY unique1;                                           | 
!  q5   | PREPARE q5(int, text) AS                                           +| {integer,text}
!       |         SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2    +| 
!       |         ORDER BY unique1;                                           | 
!  q6   | PREPARE q6 AS                                                      +| {integer,name}
!       |     SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;       | 
!  q7   | PREPARE q7(unknown) AS                                             +| {path}
!       |     SELECT * FROM road WHERE thepath = $1;                          | 
! (5 rows)
! 
! -- test DEALLOCATE ALL;
! DEALLOCATE ALL;
! SELECT name, statement, parameter_types FROM pg_prepared_statements
!     ORDER BY name;
!  name | statement | parameter_types 
! ------+-----------+-----------------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/without_oid.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/without_oid.out	2015-01-26 12:33:26.331031434 +0300
***************
*** 1,103 ****
! --
! -- WITHOUT OID
! --
! --
! -- This test tries to verify that WITHOUT OIDS actually saves space.
! -- On machines where MAXALIGN is 8, WITHOUT OIDS may or may not save any
! -- space, depending on the size of the tuple header + null bitmap.
! -- As of 8.3 we need a null bitmap of 8 or less bits for the difference
! -- to appear.
! --
! CREATE TABLE wi (i INT,
!                  n1 int, n2 int, n3 int, n4 int,
!                  n5 int, n6 int, n7 int) WITH OIDS;
! CREATE TABLE wo (i INT,
!                  n1 int, n2 int, n3 int, n4 int,
!                  n5 int, n6 int, n7 int) WITHOUT OIDS;
! INSERT INTO wi VALUES (1);  -- 1
! INSERT INTO wo SELECT i FROM wi;  -- 1
! INSERT INTO wo SELECT i+1 FROM wi;  -- 1+1=2
! INSERT INTO wi SELECT i+1 FROM wo;  -- 1+2=3
! INSERT INTO wi SELECT i+3 FROM wi;  -- 3+3=6
! INSERT INTO wo SELECT i+2 FROM wi;  -- 2+6=8
! INSERT INTO wo SELECT i+8 FROM wo;  -- 8+8=16
! INSERT INTO wi SELECT i+6 FROM wo;  -- 6+16=22
! INSERT INTO wi SELECT i+22 FROM wi;  -- 22+22=44
! INSERT INTO wo SELECT i+16 FROM wi;  -- 16+44=60
! INSERT INTO wo SELECT i+60 FROM wo;  -- 60+60=120
! INSERT INTO wi SELECT i+44 FROM wo;  -- 44+120=164
! INSERT INTO wi SELECT i+164 FROM wi;  -- 164+164=328
! INSERT INTO wo SELECT i+120 FROM wi;  -- 120+328=448
! INSERT INTO wo SELECT i+448 FROM wo;  -- 448+448=896
! INSERT INTO wi SELECT i+328 FROM wo;  -- 328+896=1224
! INSERT INTO wi SELECT i+1224 FROM wi;  -- 1224+1224=2448
! INSERT INTO wo SELECT i+896 FROM wi;  -- 896+2448=3344
! INSERT INTO wo SELECT i+3344 FROM wo;  -- 3344+3344=6688
! INSERT INTO wi SELECT i+2448 FROM wo;  -- 2448+6688=9136
! INSERT INTO wo SELECT i+6688 FROM wi WHERE i<=2448;  -- 6688+2448=9136
! SELECT count(oid) FROM wi;
!  count 
! -------
!   9136
! (1 row)
! 
! -- should fail
! SELECT count(oid) FROM wo;
! ERROR:  column "oid" does not exist
! LINE 1: SELECT count(oid) FROM wo;
!                      ^
! VACUUM ANALYZE wi;
! VACUUM ANALYZE wo;
! SELECT min(relpages) < max(relpages), min(reltuples) - max(reltuples)
!   FROM pg_class
!  WHERE relname IN ('wi', 'wo');
!  ?column? | ?column? 
! ----------+----------
!  t        |        0
! (1 row)
! 
! DROP TABLE wi;
! DROP TABLE wo;
! --
! -- WITH / WITHOUT OIDS in CREATE TABLE AS
! --
! CREATE TABLE create_table_test (
!     a int,
!     b int
! );
! COPY create_table_test FROM stdin;
! CREATE TABLE create_table_test2 WITH OIDS AS
!     SELECT a + b AS c1, a - b AS c2 FROM create_table_test;
! CREATE TABLE create_table_test3 WITHOUT OIDS AS
!     SELECT a + b AS c1, a - b AS c2 FROM create_table_test;
! SELECT count(oid) FROM create_table_test2;
!  count 
! -------
!      2
! (1 row)
! 
! -- should fail
! SELECT count(oid) FROM create_table_test3;
! ERROR:  column "oid" does not exist
! LINE 1: SELECT count(oid) FROM create_table_test3;
!                      ^
! PREPARE table_source(int) AS
!     SELECT a + b AS c1, a - b AS c2, $1 AS c3 FROM create_table_test;
! CREATE TABLE execute_with WITH OIDS AS EXECUTE table_source(1);
! CREATE TABLE execute_without WITHOUT OIDS AS EXECUTE table_source(2);
! SELECT count(oid) FROM execute_with;
!  count 
! -------
!      2
! (1 row)
! 
! -- should fail
! SELECT count(oid) FROM execute_without;
! ERROR:  column "oid" does not exist
! LINE 1: SELECT count(oid) FROM execute_without;
!                      ^
! DROP TABLE create_table_test;
! DROP TABLE create_table_test2;
! DROP TABLE create_table_test3;
! DROP TABLE execute_with;
! DROP TABLE execute_without;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/conversion.out	2014-11-21 01:48:04.315412000 +0300
--- /home/orion/postgres/src/test/regress/results/conversion.out	2015-01-26 12:33:26.299031433 +0300
***************
*** 1,949 ****
! -- ensure consistent test output regardless of the default bytea format
! SET bytea_output TO escape;
! --
! -- create user defined conversion
! --
! CREATE USER conversion_test_user WITH NOCREATEDB NOCREATEUSER;
! SET SESSION AUTHORIZATION conversion_test_user;
! CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! --
! -- cannot make same name conversion in same schema
! --
! CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  conversion "myconv" already exists
! --
! -- create default conversion with qualified name
! --
! CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! --
! -- cannot make default conversion with same shcema/for_encoding/to_encoding
! --
! CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  default conversion for LATIN1 to UTF8 already exists
! -- test comments
! COMMENT ON CONVERSION myconv_bad IS 'foo';
! ERROR:  conversion "myconv_bad" does not exist
! COMMENT ON CONVERSION myconv IS 'bar';
! COMMENT ON CONVERSION myconv IS NULL;
! --
! -- drop user defined conversion
! --
! DROP CONVERSION myconv;
! DROP CONVERSION mydef;
! --
! -- make sure all pre-defined conversions are fine.
! -- SQL_ASCII --> MULE_INTERNAL
! SELECT CONVERT('foo', 'SQL_ASCII', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> SQL_ASCII
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'SQL_ASCII');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- KOI8R --> MULE_INTERNAL
! SELECT CONVERT('foo', 'KOI8R', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> KOI8R
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'KOI8R');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-5 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'ISO-8859-5', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> ISO-8859-5
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'ISO-8859-5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1251 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'WIN1251', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> WIN1251
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'WIN1251');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN866 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'WIN866', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> WIN866
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'WIN866');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- KOI8R --> WIN1251
! SELECT CONVERT('foo', 'KOI8R', 'WIN1251');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1251 --> KOI8R
! SELECT CONVERT('foo', 'WIN1251', 'KOI8R');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- KOI8R --> WIN866
! SELECT CONVERT('foo', 'KOI8R', 'WIN866');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN866 --> KOI8R
! SELECT CONVERT('foo', 'WIN866', 'KOI8R');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN866 --> WIN1251
! SELECT CONVERT('foo', 'WIN866', 'WIN1251');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1251 --> WIN866
! SELECT CONVERT('foo', 'WIN1251', 'WIN866');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-5 --> KOI8R
! SELECT CONVERT('foo', 'ISO-8859-5', 'KOI8R');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- KOI8R --> ISO-8859-5
! SELECT CONVERT('foo', 'KOI8R', 'ISO-8859-5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-5 --> WIN1251
! SELECT CONVERT('foo', 'ISO-8859-5', 'WIN1251');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1251 --> ISO-8859-5
! SELECT CONVERT('foo', 'WIN1251', 'ISO-8859-5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-5 --> WIN866
! SELECT CONVERT('foo', 'ISO-8859-5', 'WIN866');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN866 --> ISO-8859-5
! SELECT CONVERT('foo', 'WIN866', 'ISO-8859-5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_CN --> MULE_INTERNAL
! SELECT CONVERT('foo', 'EUC_CN', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> EUC_CN
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'EUC_CN');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_JP --> SJIS
! SELECT CONVERT('foo', 'EUC_JP', 'SJIS');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SJIS --> EUC_JP
! SELECT CONVERT('foo', 'SJIS', 'EUC_JP');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_JP --> MULE_INTERNAL
! SELECT CONVERT('foo', 'EUC_JP', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SJIS --> MULE_INTERNAL
! SELECT CONVERT('foo', 'SJIS', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> EUC_JP
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'EUC_JP');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> SJIS
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'SJIS');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_KR --> MULE_INTERNAL
! SELECT CONVERT('foo', 'EUC_KR', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> EUC_KR
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'EUC_KR');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_TW --> BIG5
! SELECT CONVERT('foo', 'EUC_TW', 'BIG5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- BIG5 --> EUC_TW
! SELECT CONVERT('foo', 'BIG5', 'EUC_TW');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_TW --> MULE_INTERNAL
! SELECT CONVERT('foo', 'EUC_TW', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- BIG5 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'BIG5', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> EUC_TW
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'EUC_TW');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> BIG5
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'BIG5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN2 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'LATIN2', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> LATIN2
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'LATIN2');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1250 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'WIN1250', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> WIN1250
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'WIN1250');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN2 --> WIN1250
! SELECT CONVERT('foo', 'LATIN2', 'WIN1250');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1250 --> LATIN2
! SELECT CONVERT('foo', 'WIN1250', 'LATIN2');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN1 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'LATIN1', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> LATIN1
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'LATIN1');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN3 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'LATIN3', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> LATIN3
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'LATIN3');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN4 --> MULE_INTERNAL
! SELECT CONVERT('foo', 'LATIN4', 'MULE_INTERNAL');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- MULE_INTERNAL --> LATIN4
! SELECT CONVERT('foo', 'MULE_INTERNAL', 'LATIN4');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SQL_ASCII --> UTF8
! SELECT CONVERT('foo', 'SQL_ASCII', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> SQL_ASCII
! SELECT CONVERT('foo', 'UTF8', 'SQL_ASCII');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- BIG5 --> UTF8
! SELECT CONVERT('foo', 'BIG5', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> BIG5
! SELECT CONVERT('foo', 'UTF8', 'BIG5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> KOI8R
! SELECT CONVERT('foo', 'UTF8', 'KOI8R');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- KOI8R --> UTF8
! SELECT CONVERT('foo', 'KOI8R', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1251
! SELECT CONVERT('foo', 'UTF8', 'WIN1251');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1251 --> UTF8
! SELECT CONVERT('foo', 'WIN1251', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1252
! SELECT CONVERT('foo', 'UTF8', 'WIN1252');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1252 --> UTF8
! SELECT CONVERT('foo', 'WIN1252', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN866
! SELECT CONVERT('foo', 'UTF8', 'WIN866');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN866 --> UTF8
! SELECT CONVERT('foo', 'WIN866', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_CN --> UTF8
! SELECT CONVERT('foo', 'EUC_CN', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> EUC_CN
! SELECT CONVERT('foo', 'UTF8', 'EUC_CN');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_JP --> UTF8
! SELECT CONVERT('foo', 'EUC_JP', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> EUC_JP
! SELECT CONVERT('foo', 'UTF8', 'EUC_JP');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_KR --> UTF8
! SELECT CONVERT('foo', 'EUC_KR', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> EUC_KR
! SELECT CONVERT('foo', 'UTF8', 'EUC_KR');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_TW --> UTF8
! SELECT CONVERT('foo', 'EUC_TW', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> EUC_TW
! SELECT CONVERT('foo', 'UTF8', 'EUC_TW');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- GB18030 --> UTF8
! SELECT CONVERT('foo', 'GB18030', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> GB18030
! SELECT CONVERT('foo', 'UTF8', 'GB18030');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- GBK --> UTF8
! SELECT CONVERT('foo', 'GBK', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> GBK
! SELECT CONVERT('foo', 'UTF8', 'GBK');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN2
! SELECT CONVERT('foo', 'UTF8', 'LATIN2');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN2 --> UTF8
! SELECT CONVERT('foo', 'LATIN2', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN3
! SELECT CONVERT('foo', 'UTF8', 'LATIN3');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN3 --> UTF8
! SELECT CONVERT('foo', 'LATIN3', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN4
! SELECT CONVERT('foo', 'UTF8', 'LATIN4');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN4 --> UTF8
! SELECT CONVERT('foo', 'LATIN4', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN5
! SELECT CONVERT('foo', 'UTF8', 'LATIN5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN5 --> UTF8
! SELECT CONVERT('foo', 'LATIN5', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN6
! SELECT CONVERT('foo', 'UTF8', 'LATIN6');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN6 --> UTF8
! SELECT CONVERT('foo', 'LATIN6', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN7
! SELECT CONVERT('foo', 'UTF8', 'LATIN7');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN7 --> UTF8
! SELECT CONVERT('foo', 'LATIN7', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN8
! SELECT CONVERT('foo', 'UTF8', 'LATIN8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN8 --> UTF8
! SELECT CONVERT('foo', 'LATIN8', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN9
! SELECT CONVERT('foo', 'UTF8', 'LATIN9');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN9 --> UTF8
! SELECT CONVERT('foo', 'LATIN9', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN10
! SELECT CONVERT('foo', 'UTF8', 'LATIN10');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN10 --> UTF8
! SELECT CONVERT('foo', 'LATIN10', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> ISO-8859-5
! SELECT CONVERT('foo', 'UTF8', 'ISO-8859-5');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-5 --> UTF8
! SELECT CONVERT('foo', 'ISO-8859-5', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> ISO-8859-6
! SELECT CONVERT('foo', 'UTF8', 'ISO-8859-6');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-6 --> UTF8
! SELECT CONVERT('foo', 'ISO-8859-6', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> ISO-8859-7
! SELECT CONVERT('foo', 'UTF8', 'ISO-8859-7');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-7 --> UTF8
! SELECT CONVERT('foo', 'ISO-8859-7', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> ISO-8859-8
! SELECT CONVERT('foo', 'UTF8', 'ISO-8859-8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- ISO-8859-8 --> UTF8
! SELECT CONVERT('foo', 'ISO-8859-8', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- LATIN1 --> UTF8
! SELECT CONVERT('foo', 'LATIN1', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> LATIN1
! SELECT CONVERT('foo', 'UTF8', 'LATIN1');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- JOHAB --> UTF8
! SELECT CONVERT('foo', 'JOHAB', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> JOHAB
! SELECT CONVERT('foo', 'UTF8', 'JOHAB');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SJIS --> UTF8
! SELECT CONVERT('foo', 'SJIS', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> SJIS
! SELECT CONVERT('foo', 'UTF8', 'SJIS');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1258 --> UTF8
! SELECT CONVERT('foo', 'WIN1258', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1258
! SELECT CONVERT('foo', 'UTF8', 'WIN1258');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UHC --> UTF8
! SELECT CONVERT('foo', 'UHC', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> UHC
! SELECT CONVERT('foo', 'UTF8', 'UHC');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1250
! SELECT CONVERT('foo', 'UTF8', 'WIN1250');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1250 --> UTF8
! SELECT CONVERT('foo', 'WIN1250', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1256
! SELECT CONVERT('foo', 'UTF8', 'WIN1256');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1256 --> UTF8
! SELECT CONVERT('foo', 'WIN1256', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN874
! SELECT CONVERT('foo', 'UTF8', 'WIN874');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN874 --> UTF8
! SELECT CONVERT('foo', 'WIN874', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1253
! SELECT CONVERT('foo', 'UTF8', 'WIN1253');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1253 --> UTF8
! SELECT CONVERT('foo', 'WIN1253', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1254
! SELECT CONVERT('foo', 'UTF8', 'WIN1254');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1254 --> UTF8
! SELECT CONVERT('foo', 'WIN1254', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1255
! SELECT CONVERT('foo', 'UTF8', 'WIN1255');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1255 --> UTF8
! SELECT CONVERT('foo', 'WIN1255', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> WIN1257
! SELECT CONVERT('foo', 'UTF8', 'WIN1257');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- WIN1257 --> UTF8
! SELECT CONVERT('foo', 'WIN1257', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> EUC_JIS_2004
! SELECT CONVERT('foo', 'UTF8', 'EUC_JIS_2004');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_JIS_2004 --> UTF8
! SELECT CONVERT('foo', 'EUC_JIS_2004', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- UTF8 --> SHIFT_JIS_2004
! SELECT CONVERT('foo', 'UTF8', 'SHIFT_JIS_2004');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SHIFT_JIS_2004 --> UTF8
! SELECT CONVERT('foo', 'SHIFT_JIS_2004', 'UTF8');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- EUC_JIS_2004 --> SHIFT_JIS_2004
! SELECT CONVERT('foo', 'EUC_JIS_2004', 'SHIFT_JIS_2004');
!  convert 
! ---------
!  foo
! (1 row)
! 
! -- SHIFT_JIS_2004 --> EUC_JIS_2004
! SELECT CONVERT('foo', 'SHIFT_JIS_2004', 'EUC_JIS_2004');
!  convert 
! ---------
!  foo
! (1 row)
! 
! --
! -- return to the super user
! --
! RESET SESSION AUTHORIZATION;
! DROP USER conversion_test_user;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/truncate.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/truncate.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,422 ****
! -- Test basic TRUNCATE functionality.
! CREATE TABLE truncate_a (col1 integer primary key);
! INSERT INTO truncate_a VALUES (1);
! INSERT INTO truncate_a VALUES (2);
! SELECT * FROM truncate_a;
!  col1 
! ------
!     1
!     2
! (2 rows)
! 
! -- Roll truncate back
! BEGIN;
! TRUNCATE truncate_a;
! ROLLBACK;
! SELECT * FROM truncate_a;
!  col1 
! ------
!     1
!     2
! (2 rows)
! 
! -- Commit the truncate this time
! BEGIN;
! TRUNCATE truncate_a;
! COMMIT;
! SELECT * FROM truncate_a;
!  col1 
! ------
! (0 rows)
! 
! -- Test foreign-key checks
! CREATE TABLE trunc_b (a int REFERENCES truncate_a);
! CREATE TABLE trunc_c (a serial PRIMARY KEY);
! CREATE TABLE trunc_d (a int REFERENCES trunc_c);
! CREATE TABLE trunc_e (a int REFERENCES truncate_a, b int REFERENCES trunc_c);
! TRUNCATE TABLE truncate_a;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE truncate_a,trunc_b;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "truncate_a".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE truncate_a,trunc_b,trunc_e;	-- ok
! TRUNCATE TABLE truncate_a,trunc_e;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_d" references "trunc_c".
! HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,trunc_d;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "trunc_c".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,trunc_d,trunc_e;	-- ok
! TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;	-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;	-- ok
! TRUNCATE TABLE truncate_a RESTRICT; -- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE truncate_a CASCADE;  -- ok
! NOTICE:  truncate cascades to table "trunc_b"
! NOTICE:  truncate cascades to table "trunc_e"
! -- circular references
! ALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;
! -- Add some data to verify that truncating actually works ...
! INSERT INTO trunc_c VALUES (1);
! INSERT INTO truncate_a VALUES (1);
! INSERT INTO trunc_b VALUES (1);
! INSERT INTO trunc_d VALUES (1);
! INSERT INTO trunc_e VALUES (1,1);
! TRUNCATE TABLE trunc_c;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "truncate_a" references "trunc_c".
! HINT:  Truncate table "truncate_a" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,truncate_a;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_d" references "trunc_c".
! HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "trunc_c".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
! TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;
! -- Verify that truncating did actually work
! SELECT * FROM truncate_a
!    UNION ALL
!  SELECT * FROM trunc_c
!    UNION ALL
!  SELECT * FROM trunc_b
!    UNION ALL
!  SELECT * FROM trunc_d;
!  col1 
! ------
! (0 rows)
! 
! SELECT * FROM trunc_e;
!  a | b 
! ---+---
! (0 rows)
! 
! -- Add data again to test TRUNCATE ... CASCADE
! INSERT INTO trunc_c VALUES (1);
! INSERT INTO truncate_a VALUES (1);
! INSERT INTO trunc_b VALUES (1);
! INSERT INTO trunc_d VALUES (1);
! INSERT INTO trunc_e VALUES (1,1);
! TRUNCATE TABLE trunc_c CASCADE;  -- ok
! NOTICE:  truncate cascades to table "truncate_a"
! NOTICE:  truncate cascades to table "trunc_d"
! NOTICE:  truncate cascades to table "trunc_e"
! NOTICE:  truncate cascades to table "trunc_b"
! SELECT * FROM truncate_a
!    UNION ALL
!  SELECT * FROM trunc_c
!    UNION ALL
!  SELECT * FROM trunc_b
!    UNION ALL
!  SELECT * FROM trunc_d;
!  col1 
! ------
! (0 rows)
! 
! SELECT * FROM trunc_e;
!  a | b 
! ---+---
! (0 rows)
! 
! DROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;
! -- Test TRUNCATE with inheritance
! CREATE TABLE trunc_f (col1 integer primary key);
! INSERT INTO trunc_f VALUES (1);
! INSERT INTO trunc_f VALUES (2);
! CREATE TABLE trunc_fa (col2a text) INHERITS (trunc_f);
! INSERT INTO trunc_fa VALUES (3, 'three');
! CREATE TABLE trunc_fb (col2b int) INHERITS (trunc_f);
! INSERT INTO trunc_fb VALUES (4, 444);
! CREATE TABLE trunc_faa (col3 text) INHERITS (trunc_fa);
! INSERT INTO trunc_faa VALUES (5, 'five', 'FIVE');
! BEGIN;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
!     3
!     4
!     5
! (5 rows)
! 
! TRUNCATE trunc_f;
! SELECT * FROM trunc_f;
!  col1 
! ------
! (0 rows)
! 
! ROLLBACK;
! BEGIN;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
!     3
!     4
!     5
! (5 rows)
! 
! TRUNCATE ONLY trunc_f;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     3
!     4
!     5
! (3 rows)
! 
! ROLLBACK;
! BEGIN;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
!     3
!     4
!     5
! (5 rows)
! 
! SELECT * FROM trunc_fa;
!  col1 | col2a 
! ------+-------
!     3 | three
!     5 | five
! (2 rows)
! 
! SELECT * FROM trunc_faa;
!  col1 | col2a | col3 
! ------+-------+------
!     5 | five  | FIVE
! (1 row)
! 
! TRUNCATE ONLY trunc_fb, ONLY trunc_fa;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
!     5
! (3 rows)
! 
! SELECT * FROM trunc_fa;
!  col1 | col2a 
! ------+-------
!     5 | five
! (1 row)
! 
! SELECT * FROM trunc_faa;
!  col1 | col2a | col3 
! ------+-------+------
!     5 | five  | FIVE
! (1 row)
! 
! ROLLBACK;
! BEGIN;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
!     3
!     4
!     5
! (5 rows)
! 
! SELECT * FROM trunc_fa;
!  col1 | col2a 
! ------+-------
!     3 | three
!     5 | five
! (2 rows)
! 
! SELECT * FROM trunc_faa;
!  col1 | col2a | col3 
! ------+-------+------
!     5 | five  | FIVE
! (1 row)
! 
! TRUNCATE ONLY trunc_fb, trunc_fa;
! SELECT * FROM trunc_f;
!  col1 
! ------
!     1
!     2
! (2 rows)
! 
! SELECT * FROM trunc_fa;
!  col1 | col2a 
! ------+-------
! (0 rows)
! 
! SELECT * FROM trunc_faa;
!  col1 | col2a | col3 
! ------+-------+------
! (0 rows)
! 
! ROLLBACK;
! DROP TABLE trunc_f CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table trunc_fa
! drop cascades to table trunc_faa
! drop cascades to table trunc_fb
! -- Test ON TRUNCATE triggers
! CREATE TABLE trunc_trigger_test (f1 int, f2 text, f3 text);
! CREATE TABLE trunc_trigger_log (tgop text, tglevel text, tgwhen text,
!         tgargv text, tgtable name, rowcount bigint);
! CREATE FUNCTION trunctrigger() RETURNS trigger as $$
! declare c bigint;
! begin
!     execute 'select count(*) from ' || quote_ident(tg_table_name) into c;
!     insert into trunc_trigger_log values
!       (TG_OP, TG_LEVEL, TG_WHEN, TG_ARGV[0], tg_table_name, c);
!     return null;
! end;
! $$ LANGUAGE plpgsql;
! -- basic before trigger
! INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
! CREATE TRIGGER t
! BEFORE TRUNCATE ON trunc_trigger_test
! FOR EACH STATEMENT
! EXECUTE PROCEDURE trunctrigger('before trigger truncate');
! SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
!  Row count in test table 
! -------------------------
!                        2
! (1 row)
! 
! SELECT * FROM trunc_trigger_log;
!  tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
! ------+---------+--------+--------+---------+----------
! (0 rows)
! 
! TRUNCATE trunc_trigger_test;
! SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
!  Row count in test table 
! -------------------------
!                        0
! (1 row)
! 
! SELECT * FROM trunc_trigger_log;
!    tgop   |  tglevel  | tgwhen |         tgargv          |      tgtable       | rowcount 
! ----------+-----------+--------+-------------------------+--------------------+----------
!  TRUNCATE | STATEMENT | BEFORE | before trigger truncate | trunc_trigger_test |        2
! (1 row)
! 
! DROP TRIGGER t ON trunc_trigger_test;
! truncate trunc_trigger_log;
! -- same test with an after trigger
! INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
! CREATE TRIGGER tt
! AFTER TRUNCATE ON trunc_trigger_test
! FOR EACH STATEMENT
! EXECUTE PROCEDURE trunctrigger('after trigger truncate');
! SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
!  Row count in test table 
! -------------------------
!                        2
! (1 row)
! 
! SELECT * FROM trunc_trigger_log;
!  tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
! ------+---------+--------+--------+---------+----------
! (0 rows)
! 
! TRUNCATE trunc_trigger_test;
! SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
!  Row count in test table 
! -------------------------
!                        0
! (1 row)
! 
! SELECT * FROM trunc_trigger_log;
!    tgop   |  tglevel  | tgwhen |         tgargv         |      tgtable       | rowcount 
! ----------+-----------+--------+------------------------+--------------------+----------
!  TRUNCATE | STATEMENT | AFTER  | after trigger truncate | trunc_trigger_test |        0
! (1 row)
! 
! DROP TABLE trunc_trigger_test;
! DROP TABLE trunc_trigger_log;
! DROP FUNCTION trunctrigger();
! -- test TRUNCATE ... RESTART IDENTITY
! CREATE SEQUENCE truncate_a_id1 START WITH 33;
! CREATE TABLE truncate_a (id serial,
!                          id1 integer default nextval('truncate_a_id1'));
! ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
! INSERT INTO truncate_a DEFAULT VALUES;
! INSERT INTO truncate_a DEFAULT VALUES;
! SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   1 |  33
!   2 |  34
! (2 rows)
! 
! TRUNCATE truncate_a;
! INSERT INTO truncate_a DEFAULT VALUES;
! INSERT INTO truncate_a DEFAULT VALUES;
! SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   3 |  35
!   4 |  36
! (2 rows)
! 
! TRUNCATE truncate_a RESTART IDENTITY;
! INSERT INTO truncate_a DEFAULT VALUES;
! INSERT INTO truncate_a DEFAULT VALUES;
! SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   1 |  33
!   2 |  34
! (2 rows)
! 
! -- check rollback of a RESTART IDENTITY operation
! BEGIN;
! TRUNCATE truncate_a RESTART IDENTITY;
! INSERT INTO truncate_a DEFAULT VALUES;
! SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   1 |  33
! (1 row)
! 
! ROLLBACK;
! INSERT INTO truncate_a DEFAULT VALUES;
! INSERT INTO truncate_a DEFAULT VALUES;
! SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   1 |  33
!   2 |  34
!   3 |  35
!   4 |  36
! (4 rows)
! 
! DROP TABLE truncate_a;
! SELECT nextval('truncate_a_id1'); -- fail, seq should have been dropped
! ERROR:  relation "truncate_a_id1" does not exist
! LINE 1: SELECT nextval('truncate_a_id1');
!                        ^
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/alter_table.out	2014-11-21 01:48:04.311410000 +0300
--- /home/orion/postgres/src/test/regress/results/alter_table.out	2015-01-26 12:33:26.347031435 +0300
***************
*** 1,2536 ****
! --
! -- ALTER_TABLE
! -- add attribute
! --
! CREATE TABLE tmp (initial int4);
! COMMENT ON TABLE tmp_wrong IS 'table comment';
! ERROR:  relation "tmp_wrong" does not exist
! COMMENT ON TABLE tmp IS 'table comment';
! COMMENT ON TABLE tmp IS NULL;
! ALTER TABLE tmp ADD COLUMN xmin integer; -- fails
! ERROR:  column name "xmin" conflicts with a system column name
! ALTER TABLE tmp ADD COLUMN a int4 default 3;
! ALTER TABLE tmp ADD COLUMN b name;
! ALTER TABLE tmp ADD COLUMN c text;
! ALTER TABLE tmp ADD COLUMN d float8;
! ALTER TABLE tmp ADD COLUMN e float4;
! ALTER TABLE tmp ADD COLUMN f int2;
! ALTER TABLE tmp ADD COLUMN g polygon;
! ALTER TABLE tmp ADD COLUMN h abstime;
! ALTER TABLE tmp ADD COLUMN i char;
! ALTER TABLE tmp ADD COLUMN j abstime[];
! ALTER TABLE tmp ADD COLUMN k int4;
! ALTER TABLE tmp ADD COLUMN l tid;
! ALTER TABLE tmp ADD COLUMN m xid;
! ALTER TABLE tmp ADD COLUMN n oidvector;
! --ALTER TABLE tmp ADD COLUMN o lock;
! ALTER TABLE tmp ADD COLUMN p smgr;
! ALTER TABLE tmp ADD COLUMN q point;
! ALTER TABLE tmp ADD COLUMN r lseg;
! ALTER TABLE tmp ADD COLUMN s path;
! ALTER TABLE tmp ADD COLUMN t box;
! ALTER TABLE tmp ADD COLUMN u tinterval;
! ALTER TABLE tmp ADD COLUMN v timestamp;
! ALTER TABLE tmp ADD COLUMN w interval;
! ALTER TABLE tmp ADD COLUMN x float8[];
! ALTER TABLE tmp ADD COLUMN y float4[];
! ALTER TABLE tmp ADD COLUMN z int2[];
! INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
! 	v, w, x, y, z)
!    VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
!         'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
! 	314159, '(1,1)', '512',
! 	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
! 	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
! 	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
! SELECT * FROM tmp;
!  initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
! ---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
!          | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
! (1 row)
! 
! DROP TABLE tmp;
! -- the wolf bug - schema mods caused inconsistent row descriptors
! CREATE TABLE tmp (
! 	initial 	int4
! );
! ALTER TABLE tmp ADD COLUMN a int4;
! ALTER TABLE tmp ADD COLUMN b name;
! ALTER TABLE tmp ADD COLUMN c text;
! ALTER TABLE tmp ADD COLUMN d float8;
! ALTER TABLE tmp ADD COLUMN e float4;
! ALTER TABLE tmp ADD COLUMN f int2;
! ALTER TABLE tmp ADD COLUMN g polygon;
! ALTER TABLE tmp ADD COLUMN h abstime;
! ALTER TABLE tmp ADD COLUMN i char;
! ALTER TABLE tmp ADD COLUMN j abstime[];
! ALTER TABLE tmp ADD COLUMN k int4;
! ALTER TABLE tmp ADD COLUMN l tid;
! ALTER TABLE tmp ADD COLUMN m xid;
! ALTER TABLE tmp ADD COLUMN n oidvector;
! --ALTER TABLE tmp ADD COLUMN o lock;
! ALTER TABLE tmp ADD COLUMN p smgr;
! ALTER TABLE tmp ADD COLUMN q point;
! ALTER TABLE tmp ADD COLUMN r lseg;
! ALTER TABLE tmp ADD COLUMN s path;
! ALTER TABLE tmp ADD COLUMN t box;
! ALTER TABLE tmp ADD COLUMN u tinterval;
! ALTER TABLE tmp ADD COLUMN v timestamp;
! ALTER TABLE tmp ADD COLUMN w interval;
! ALTER TABLE tmp ADD COLUMN x float8[];
! ALTER TABLE tmp ADD COLUMN y float4[];
! ALTER TABLE tmp ADD COLUMN z int2[];
! INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
! 	v, w, x, y, z)
!    VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
!         'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
! 	314159, '(1,1)', '512',
! 	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
! 	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
! 	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
! SELECT * FROM tmp;
!  initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
! ---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
!          | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
! (1 row)
! 
! DROP TABLE tmp;
! --
! -- rename - check on both non-temp and temp tables
! --
! CREATE TABLE tmp (regtable int);
! CREATE TEMP TABLE tmp (tmptable int);
! ALTER TABLE tmp RENAME TO tmp_new;
! SELECT * FROM tmp;
!  regtable 
! ----------
! (0 rows)
! 
! SELECT * FROM tmp_new;
!  tmptable 
! ----------
! (0 rows)
! 
! ALTER TABLE tmp RENAME TO tmp_new2;
! SELECT * FROM tmp;		-- should fail
! ERROR:  relation "tmp" does not exist
! LINE 1: SELECT * FROM tmp;
!                       ^
! SELECT * FROM tmp_new;
!  tmptable 
! ----------
! (0 rows)
! 
! SELECT * FROM tmp_new2;
!  regtable 
! ----------
! (0 rows)
! 
! DROP TABLE tmp_new;
! DROP TABLE tmp_new2;
! -- ALTER TABLE ... RENAME on non-table relations
! -- renaming indexes (FIXME: this should probably test the index's functionality)
! ALTER INDEX IF EXISTS __onek_unique1 RENAME TO tmp_onek_unique1;
! NOTICE:  relation "__onek_unique1" does not exist, skipping
! ALTER INDEX IF EXISTS __tmp_onek_unique1 RENAME TO onek_unique1;
! NOTICE:  relation "__tmp_onek_unique1" does not exist, skipping
! ALTER INDEX onek_unique1 RENAME TO tmp_onek_unique1;
! ALTER INDEX tmp_onek_unique1 RENAME TO onek_unique1;
! -- renaming views
! CREATE VIEW tmp_view (unique1) AS SELECT unique1 FROM tenk1;
! ALTER TABLE tmp_view RENAME TO tmp_view_new;
! -- hack to ensure we get an indexscan here
! set enable_seqscan to off;
! set enable_bitmapscan to off;
! -- 5 values, sorted
! SELECT unique1 FROM tenk1 WHERE unique1 < 5;
!  unique1 
! ---------
!        0
!        1
!        2
!        3
!        4
! (5 rows)
! 
! reset enable_seqscan;
! reset enable_bitmapscan;
! DROP VIEW tmp_view_new;
! -- toast-like relation name
! alter table stud_emp rename to pg_toast_stud_emp;
! alter table pg_toast_stud_emp rename to stud_emp;
! -- renaming index should rename constraint as well
! ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
! ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
! ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
! -- renaming constraint
! ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
! ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
! ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
! -- renaming constraint should rename index as well
! ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
! DROP INDEX onek_unique1_constraint;  -- to see whether it's there
! ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
! HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
! ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
! DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
! ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
! HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
! ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
! -- renaming constraints vs. inheritance
! CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
! \d constraint_rename_test
! Table "public.constraint_rename_test"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
! Check constraints:
!     "con1" CHECK (a > 0)
! 
! CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging constraint "con1" with inherited definition
! \d constraint_rename_test2
! Table "public.constraint_rename_test2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
!  d      | integer | 
! Check constraints:
!     "con1" CHECK (a > 0)
! Inherits: constraint_rename_test
! 
! ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  cannot rename inherited constraint "con1"
! ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  inherited constraint "con1" must be renamed in child tables too
! ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
! \d constraint_rename_test
! Table "public.constraint_rename_test"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
! Check constraints:
!     "con1foo" CHECK (a > 0)
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d constraint_rename_test2
! Table "public.constraint_rename_test2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
!  d      | integer | 
! Check constraints:
!     "con1foo" CHECK (a > 0)
! Inherits: constraint_rename_test
! 
! ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
! ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
! ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
! \d constraint_rename_test
! Table "public.constraint_rename_test"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
! Check constraints:
!     "con1foo" CHECK (a > 0)
!     "con2bar" CHECK (b > 0) NO INHERIT
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d constraint_rename_test2
! Table "public.constraint_rename_test2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
!  d      | integer | 
! Check constraints:
!     "con1foo" CHECK (a > 0)
! Inherits: constraint_rename_test
! 
! ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
! ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
! \d constraint_rename_test
! Table "public.constraint_rename_test"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | not null
!  b      | integer | 
!  c      | integer | 
! Indexes:
!     "con3foo" PRIMARY KEY, btree (a)
! Check constraints:
!     "con1foo" CHECK (a > 0)
!     "con2bar" CHECK (b > 0) NO INHERIT
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d constraint_rename_test2
! Table "public.constraint_rename_test2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
!  c      | integer | 
!  d      | integer | 
! Check constraints:
!     "con1foo" CHECK (a > 0)
! Inherits: constraint_rename_test
! 
! DROP TABLE constraint_rename_test2;
! DROP TABLE constraint_rename_test;
! ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
! NOTICE:  relation "constraint_rename_test" does not exist, skipping
! -- FOREIGN KEY CONSTRAINT adding TEST
! CREATE TABLE tmp2 (a int primary key);
! CREATE TABLE tmp3 (a int, b int);
! CREATE TABLE tmp4 (a int, b int, unique(a,b));
! CREATE TABLE tmp5 (a int, b int);
! -- Insert rows into tmp2 (pktable)
! INSERT INTO tmp2 values (1);
! INSERT INTO tmp2 values (2);
! INSERT INTO tmp2 values (3);
! INSERT INTO tmp2 values (4);
! -- Insert rows into tmp3
! INSERT INTO tmp3 values (1,10);
! INSERT INTO tmp3 values (1,20);
! INSERT INTO tmp3 values (5,50);
! -- Try (and fail) to add constraint due to invalid source columns
! ALTER TABLE tmp3 add constraint tmpconstr foreign key(c) references tmp2 match full;
! ERROR:  column "c" referenced in foreign key constraint does not exist
! -- Try (and fail) to add constraint due to invalide destination columns explicitly given
! ALTER TABLE tmp3 add constraint tmpconstr foreign key(a) references tmp2(b) match full;
! ERROR:  column "b" referenced in foreign key constraint does not exist
! -- Try (and fail) to add constraint due to invalid data
! ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
! ERROR:  insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
! DETAIL:  Key (a)=(5) is not present in table "tmp2".
! -- Delete failing row
! DELETE FROM tmp3 where a=5;
! -- Try (and succeed)
! ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
! ALTER TABLE tmp3 drop constraint tmpconstr;
! INSERT INTO tmp3 values (5,50);
! -- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
! ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full NOT VALID;
! ALTER TABLE tmp3 validate constraint tmpconstr;
! ERROR:  insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
! DETAIL:  Key (a)=(5) is not present in table "tmp2".
! -- Delete failing row
! DELETE FROM tmp3 where a=5;
! -- Try (and succeed) and repeat to show it works on already valid constraint
! ALTER TABLE tmp3 validate constraint tmpconstr;
! ALTER TABLE tmp3 validate constraint tmpconstr;
! -- Try a non-verified CHECK constraint
! ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
! ERROR:  check constraint "b_greater_than_ten" is violated by some row
! ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
! ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
! ERROR:  check constraint "b_greater_than_ten" is violated by some row
! DELETE FROM tmp3 WHERE NOT b > 10;
! ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
! ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
! -- Test inherited NOT VALID CHECK constraints
! select * from tmp3;
!  a | b  
! ---+----
!  1 | 20
! (1 row)
! 
! CREATE TABLE tmp6 () INHERITS (tmp3);
! CREATE TABLE tmp7 () INHERITS (tmp3);
! INSERT INTO tmp6 VALUES (6, 30), (7, 16);
! ALTER TABLE tmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
! ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
! ERROR:  check constraint "b_le_20" is violated by some row
! DELETE FROM tmp6 WHERE b > 20;
! ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
! -- An already validated constraint must not be revalidated
! CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
! INSERT INTO tmp7 VALUES (8, 18);
! ALTER TABLE tmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
! NOTICE:  boo: 18
! ALTER TABLE tmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
! NOTICE:  merging constraint "identity" with inherited definition
! ALTER TABLE tmp3 VALIDATE CONSTRAINT identity;
! NOTICE:  boo: 16
! NOTICE:  boo: 20
! -- Try (and fail) to create constraint from tmp5(a) to tmp4(a) - unique constraint on
! -- tmp4 is a,b
! ALTER TABLE tmp5 add constraint tmpconstr foreign key(a) references tmp4(a) match full;
! ERROR:  there is no unique constraint matching given keys for referenced table "tmp4"
! DROP TABLE tmp7;
! DROP TABLE tmp6;
! DROP TABLE tmp5;
! DROP TABLE tmp4;
! DROP TABLE tmp3;
! DROP TABLE tmp2;
! -- NOT VALID with plan invalidation -- ensure we don't use a constraint for
! -- exclusion until validated
! set constraint_exclusion TO 'partition';
! create table nv_parent (d date);
! create table nv_child_2010 () inherits (nv_parent);
! create table nv_child_2011 () inherits (nv_parent);
! alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
! alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
! explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Append
!    ->  Seq Scan on nv_parent
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
!    ->  Seq Scan on nv_child_2010
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
!    ->  Seq Scan on nv_child_2011
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
! (7 rows)
! 
! create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
! explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Append
!    ->  Seq Scan on nv_parent
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
!    ->  Seq Scan on nv_child_2010
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
!    ->  Seq Scan on nv_child_2011
!          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
! (7 rows)
! 
! explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Append
!    ->  Seq Scan on nv_parent
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
!    ->  Seq Scan on nv_child_2010
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
!    ->  Seq Scan on nv_child_2011
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
!    ->  Seq Scan on nv_child_2009
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
! (9 rows)
! 
! -- after validation, the constraint should be used
! alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
! explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Append
!    ->  Seq Scan on nv_parent
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
!    ->  Seq Scan on nv_child_2010
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
!    ->  Seq Scan on nv_child_2009
!          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
! (7 rows)
! 
! -- Foreign key adding test with mixed types
! -- Note: these tables are TEMP to avoid name conflicts when this test
! -- is run in parallel with foreign_key.sql.
! CREATE TEMP TABLE PKTABLE (ptest1 int PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! CREATE TEMP TABLE FKTABLE (ftest1 inet);
! -- This next should fail, because int=inet does not exist
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! -- This should also fail for the same reason, but here we
! -- give the column name
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
! DROP TABLE FKTABLE;
! -- This should succeed, even though they are different types,
! -- because int=int8 exists and is a member of the integer opfamily
! CREATE TEMP TABLE FKTABLE (ftest1 int8);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! -- This should fail, because we'd have to cast numeric to int which is
! -- not an implicit coercion (or use numeric=numeric, but that's not part
! -- of the integer opfamily)
! CREATE TEMP TABLE FKTABLE (ftest1 numeric);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! -- On the other hand, this should work because int implicitly promotes to
! -- numeric, and we allow promotion on the FK side
! CREATE TEMP TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
! INSERT INTO PKTABLE VALUES(42);
! CREATE TEMP TABLE FKTABLE (ftest1 int);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! -- Check it actually works
! INSERT INTO FKTABLE VALUES(42);		-- should succeed
! INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
! DROP TABLE FKTABLE;
! DROP TABLE PKTABLE;
! CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
!                            PRIMARY KEY(ptest1, ptest2));
! -- This should fail, because we just chose really odd types
! CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! DROP TABLE FKTABLE;
! -- Again, so should this...
! CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
!      references pktable(ptest1, ptest2);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
! DROP TABLE FKTABLE;
! -- This fails because we mixed up the column ordering
! CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
!      references pktable(ptest2, ptest1);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
! -- As does this...
! ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
!      references pktable(ptest1, ptest2);
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
! -- temp tables should go away by themselves, need not drop them.
! -- test check constraint adding
! create table atacc1 ( test int );
! -- add a check constraint
! alter table atacc1 add constraint atacc_test1 check (test>3);
! -- should fail
! insert into atacc1 (test) values (2);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
! DETAIL:  Failing row contains (2).
! -- should succeed
! insert into atacc1 (test) values (4);
! drop table atacc1;
! -- let's do one where the check fails when added
! create table atacc1 ( test int );
! -- insert a soon to be failing row
! insert into atacc1 (test) values (2);
! -- add a check constraint (fails)
! alter table atacc1 add constraint atacc_test1 check (test>3);
! ERROR:  check constraint "atacc_test1" is violated by some row
! insert into atacc1 (test) values (4);
! drop table atacc1;
! -- let's do one where the check fails because the column doesn't exist
! create table atacc1 ( test int );
! -- add a check constraint (fails)
! alter table atacc1 add constraint atacc_test1 check (test1>3);
! ERROR:  column "test1" does not exist
! drop table atacc1;
! -- something a little more complicated
! create table atacc1 ( test int, test2 int, test3 int);
! -- add a check constraint (fails)
! alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
! -- should fail
! insert into atacc1 (test,test2,test3) values (4,4,2);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
! DETAIL:  Failing row contains (4, 4, 2).
! -- should succeed
! insert into atacc1 (test,test2,test3) values (4,4,5);
! drop table atacc1;
! -- lets do some naming tests
! create table atacc1 (test int check (test>3), test2 int);
! alter table atacc1 add check (test2>test);
! -- should fail for $2
! insert into atacc1 (test2, test) values (3, 4);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
! DETAIL:  Failing row contains (4, 3).
! drop table atacc1;
! -- inheritance related tests
! create table atacc1 (test int);
! create table atacc2 (test2 int);
! create table atacc3 (test3 int) inherits (atacc1, atacc2);
! alter table atacc2 add constraint foo check (test2>0);
! -- fail and then succeed on atacc2
! insert into atacc2 (test2) values (-3);
! ERROR:  new row for relation "atacc2" violates check constraint "foo"
! DETAIL:  Failing row contains (-3).
! insert into atacc2 (test2) values (3);
! -- fail and then succeed on atacc3
! insert into atacc3 (test2) values (-3);
! ERROR:  new row for relation "atacc3" violates check constraint "foo"
! DETAIL:  Failing row contains (null, -3, null).
! insert into atacc3 (test2) values (3);
! drop table atacc3;
! drop table atacc2;
! drop table atacc1;
! -- same things with one created with INHERIT
! create table atacc1 (test int);
! create table atacc2 (test2 int);
! create table atacc3 (test3 int) inherits (atacc1, atacc2);
! alter table atacc3 no inherit atacc2;
! -- fail
! alter table atacc3 no inherit atacc2;
! ERROR:  relation "atacc2" is not a parent of relation "atacc3"
! -- make sure it really isn't a child
! insert into atacc3 (test2) values (3);
! select test2 from atacc2;
!  test2 
! -------
! (0 rows)
! 
! -- fail due to missing constraint
! alter table atacc2 add constraint foo check (test2>0);
! alter table atacc3 inherit atacc2;
! ERROR:  child table is missing constraint "foo"
! -- fail due to missing column
! alter table atacc3 rename test2 to testx;
! alter table atacc3 inherit atacc2;
! ERROR:  child table is missing column "test2"
! -- fail due to mismatched data type
! alter table atacc3 add test2 bool;
! alter table atacc3 inherit atacc2;
! ERROR:  child table "atacc3" has different type for column "test2"
! alter table atacc3 drop test2;
! -- succeed
! alter table atacc3 add test2 int;
! update atacc3 set test2 = 4 where test2 is null;
! alter table atacc3 add constraint foo check (test2>0);
! alter table atacc3 inherit atacc2;
! -- fail due to duplicates and circular inheritance
! alter table atacc3 inherit atacc2;
! ERROR:  relation "atacc2" would be inherited from more than once
! alter table atacc2 inherit atacc3;
! ERROR:  circular inheritance not allowed
! DETAIL:  "atacc3" is already a child of "atacc2".
! alter table atacc2 inherit atacc2;
! ERROR:  circular inheritance not allowed
! DETAIL:  "atacc2" is already a child of "atacc2".
! -- test that we really are a child now (should see 4 not 3 and cascade should go through)
! select test2 from atacc2;
!  test2 
! -------
!      4
! (1 row)
! 
! drop table atacc2 cascade;
! NOTICE:  drop cascades to table atacc3
! drop table atacc1;
! -- adding only to a parent is allowed as of 9.2
! create table atacc1 (test int);
! create table atacc2 (test2 int) inherits (atacc1);
! -- ok:
! alter table atacc1 add constraint foo check (test>0) no inherit;
! -- check constraint is not there on child
! insert into atacc2 (test) values (-3);
! -- check constraint is there on parent
! insert into atacc1 (test) values (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "foo"
! DETAIL:  Failing row contains (-3).
! insert into atacc1 (test) values (3);
! -- fail, violating row:
! alter table atacc2 add constraint foo check (test>0) no inherit;
! ERROR:  check constraint "foo" is violated by some row
! drop table atacc2;
! drop table atacc1;
! -- test unique constraint adding
! create table atacc1 ( test int ) with oids;
! -- add a unique constraint
! alter table atacc1 add constraint atacc_test1 unique (test);
! -- insert first value
! insert into atacc1 (test) values (2);
! -- should fail
! insert into atacc1 (test) values (2);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
! DETAIL:  Key (test)=(2) already exists.
! -- should succeed
! insert into atacc1 (test) values (4);
! -- try adding a unique oid constraint
! alter table atacc1 add constraint atacc_oid1 unique(oid);
! -- try to create duplicates via alter table using - should fail
! alter table atacc1 alter column test type integer using 0;
! ERROR:  could not create unique index "atacc_test1"
! DETAIL:  Key (test)=(0) is duplicated.
! drop table atacc1;
! -- let's do one where the unique constraint fails when added
! create table atacc1 ( test int );
! -- insert soon to be failing rows
! insert into atacc1 (test) values (2);
! insert into atacc1 (test) values (2);
! -- add a unique constraint (fails)
! alter table atacc1 add constraint atacc_test1 unique (test);
! ERROR:  could not create unique index "atacc_test1"
! DETAIL:  Key (test)=(2) is duplicated.
! insert into atacc1 (test) values (3);
! drop table atacc1;
! -- let's do one where the unique constraint fails
! -- because the column doesn't exist
! create table atacc1 ( test int );
! -- add a unique constraint (fails)
! alter table atacc1 add constraint atacc_test1 unique (test1);
! ERROR:  column "test1" named in key does not exist
! drop table atacc1;
! -- something a little more complicated
! create table atacc1 ( test int, test2 int);
! -- add a unique constraint
! alter table atacc1 add constraint atacc_test1 unique (test, test2);
! -- insert initial value
! insert into atacc1 (test,test2) values (4,4);
! -- should fail
! insert into atacc1 (test,test2) values (4,4);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
! DETAIL:  Key (test, test2)=(4, 4) already exists.
! -- should all succeed
! insert into atacc1 (test,test2) values (4,5);
! insert into atacc1 (test,test2) values (5,4);
! insert into atacc1 (test,test2) values (5,5);
! drop table atacc1;
! -- lets do some naming tests
! create table atacc1 (test int, test2 int, unique(test));
! alter table atacc1 add unique (test2);
! -- should fail for @@ second one @@
! insert into atacc1 (test2, test) values (3, 3);
! insert into atacc1 (test2, test) values (2, 3);
! ERROR:  duplicate key value violates unique constraint "atacc1_test_key"
! DETAIL:  Key (test)=(3) already exists.
! drop table atacc1;
! -- test primary key constraint adding
! create table atacc1 ( test int ) with oids;
! -- add a primary key constraint
! alter table atacc1 add constraint atacc_test1 primary key (test);
! -- insert first value
! insert into atacc1 (test) values (2);
! -- should fail
! insert into atacc1 (test) values (2);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
! DETAIL:  Key (test)=(2) already exists.
! -- should succeed
! insert into atacc1 (test) values (4);
! -- inserting NULL should fail
! insert into atacc1 (test) values(NULL);
! ERROR:  null value in column "test" violates not-null constraint
! DETAIL:  Failing row contains (null).
! -- try adding a second primary key (should fail)
! alter table atacc1 add constraint atacc_oid1 primary key(oid);
! ERROR:  multiple primary keys for table "atacc1" are not allowed
! -- drop first primary key constraint
! alter table atacc1 drop constraint atacc_test1 restrict;
! -- try adding a primary key on oid (should succeed)
! alter table atacc1 add constraint atacc_oid1 primary key(oid);
! drop table atacc1;
! -- let's do one where the primary key constraint fails when added
! create table atacc1 ( test int );
! -- insert soon to be failing rows
! insert into atacc1 (test) values (2);
! insert into atacc1 (test) values (2);
! -- add a primary key (fails)
! alter table atacc1 add constraint atacc_test1 primary key (test);
! ERROR:  could not create unique index "atacc_test1"
! DETAIL:  Key (test)=(2) is duplicated.
! insert into atacc1 (test) values (3);
! drop table atacc1;
! -- let's do another one where the primary key constraint fails when added
! create table atacc1 ( test int );
! -- insert soon to be failing row
! insert into atacc1 (test) values (NULL);
! -- add a primary key (fails)
! alter table atacc1 add constraint atacc_test1 primary key (test);
! ERROR:  column "test" contains null values
! insert into atacc1 (test) values (3);
! drop table atacc1;
! -- let's do one where the primary key constraint fails
! -- because the column doesn't exist
! create table atacc1 ( test int );
! -- add a primary key constraint (fails)
! alter table atacc1 add constraint atacc_test1 primary key (test1);
! ERROR:  column "test1" named in key does not exist
! drop table atacc1;
! -- adding a new column as primary key to a non-empty table.
! -- should fail unless the column has a non-null default value.
! create table atacc1 ( test int );
! insert into atacc1 (test) values (0);
! -- add a primary key column without a default (fails).
! alter table atacc1 add column test2 int primary key;
! ERROR:  column "test2" contains null values
! -- now add a primary key column with a default (succeeds).
! alter table atacc1 add column test2 int default 0 primary key;
! drop table atacc1;
! -- something a little more complicated
! create table atacc1 ( test int, test2 int);
! -- add a primary key constraint
! alter table atacc1 add constraint atacc_test1 primary key (test, test2);
! -- try adding a second primary key - should fail
! alter table atacc1 add constraint atacc_test2 primary key (test);
! ERROR:  multiple primary keys for table "atacc1" are not allowed
! -- insert initial value
! insert into atacc1 (test,test2) values (4,4);
! -- should fail
! insert into atacc1 (test,test2) values (4,4);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
! DETAIL:  Key (test, test2)=(4, 4) already exists.
! insert into atacc1 (test,test2) values (NULL,3);
! ERROR:  null value in column "test" violates not-null constraint
! DETAIL:  Failing row contains (null, 3).
! insert into atacc1 (test,test2) values (3, NULL);
! ERROR:  null value in column "test2" violates not-null constraint
! DETAIL:  Failing row contains (3, null).
! insert into atacc1 (test,test2) values (NULL,NULL);
! ERROR:  null value in column "test" violates not-null constraint
! DETAIL:  Failing row contains (null, null).
! -- should all succeed
! insert into atacc1 (test,test2) values (4,5);
! insert into atacc1 (test,test2) values (5,4);
! insert into atacc1 (test,test2) values (5,5);
! drop table atacc1;
! -- lets do some naming tests
! create table atacc1 (test int, test2 int, primary key(test));
! -- only first should succeed
! insert into atacc1 (test2, test) values (3, 3);
! insert into atacc1 (test2, test) values (2, 3);
! ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
! DETAIL:  Key (test)=(3) already exists.
! insert into atacc1 (test2, test) values (1, NULL);
! ERROR:  null value in column "test" violates not-null constraint
! DETAIL:  Failing row contains (null, 1).
! drop table atacc1;
! -- alter table / alter column [set/drop] not null tests
! -- try altering system catalogs, should fail
! alter table pg_class alter column relname drop not null;
! ERROR:  permission denied: "pg_class" is a system catalog
! alter table pg_class alter relname set not null;
! ERROR:  permission denied: "pg_class" is a system catalog
! -- try altering non-existent table, should fail
! alter table non_existent alter column bar set not null;
! ERROR:  relation "non_existent" does not exist
! alter table non_existent alter column bar drop not null;
! ERROR:  relation "non_existent" does not exist
! -- test setting columns to null and not null and vice versa
! -- test checking for null values and primary key
! create table atacc1 (test int not null) with oids;
! alter table atacc1 add constraint "atacc1_pkey" primary key (test);
! alter table atacc1 alter column test drop not null;
! ERROR:  column "test" is in a primary key
! alter table atacc1 drop constraint "atacc1_pkey";
! alter table atacc1 alter column test drop not null;
! insert into atacc1 values (null);
! alter table atacc1 alter test set not null;
! ERROR:  column "test" contains null values
! delete from atacc1;
! alter table atacc1 alter test set not null;
! -- try altering a non-existent column, should fail
! alter table atacc1 alter bar set not null;
! ERROR:  column "bar" of relation "atacc1" does not exist
! alter table atacc1 alter bar drop not null;
! ERROR:  column "bar" of relation "atacc1" does not exist
! -- try altering the oid column, should fail
! alter table atacc1 alter oid set not null;
! ERROR:  cannot alter system column "oid"
! alter table atacc1 alter oid drop not null;
! ERROR:  cannot alter system column "oid"
! -- try creating a view and altering that, should fail
! create view myview as select * from atacc1;
! alter table myview alter column test drop not null;
! ERROR:  "myview" is not a table or foreign table
! alter table myview alter column test set not null;
! ERROR:  "myview" is not a table or foreign table
! drop view myview;
! drop table atacc1;
! -- test inheritance
! create table parent (a int);
! create table child (b varchar(255)) inherits (parent);
! alter table parent alter a set not null;
! insert into parent values (NULL);
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null).
! insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null, foo).
! alter table parent alter a drop not null;
! insert into parent values (NULL);
! insert into child (a, b) values (NULL, 'foo');
! alter table only parent alter a set not null;
! ERROR:  column "a" contains null values
! alter table child alter a set not null;
! ERROR:  column "a" contains null values
! delete from parent;
! alter table only parent alter a set not null;
! insert into parent values (NULL);
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null).
! alter table child alter a set not null;
! insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null, foo).
! delete from child;
! alter table child alter a set not null;
! insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null, foo).
! drop table child;
! drop table parent;
! -- test setting and removing default values
! create table def_test (
! 	c1	int4 default 5,
! 	c2	text default 'initial_default'
! );
! insert into def_test default values;
! alter table def_test alter column c1 drop default;
! insert into def_test default values;
! alter table def_test alter column c2 drop default;
! insert into def_test default values;
! alter table def_test alter column c1 set default 10;
! alter table def_test alter column c2 set default 'new_default';
! insert into def_test default values;
! select * from def_test;
!  c1 |       c2        
! ----+-----------------
!   5 | initial_default
!     | initial_default
!     | 
!  10 | new_default
! (4 rows)
! 
! -- set defaults to an incorrect type: this should fail
! alter table def_test alter column c1 set default 'wrong_datatype';
! ERROR:  invalid input syntax for integer: "wrong_datatype"
! alter table def_test alter column c2 set default 20;
! -- set defaults on a non-existent column: this should fail
! alter table def_test alter column c3 set default 30;
! ERROR:  column "c3" of relation "def_test" does not exist
! -- set defaults on views: we need to create a view, add a rule
! -- to allow insertions into it, and then alter the view to add
! -- a default
! create view def_view_test as select * from def_test;
! create rule def_view_test_ins as
! 	on insert to def_view_test
! 	do instead insert into def_test select new.*;
! insert into def_view_test default values;
! alter table def_view_test alter column c1 set default 45;
! insert into def_view_test default values;
! alter table def_view_test alter column c2 set default 'view_default';
! insert into def_view_test default values;
! select * from def_view_test;
!  c1 |       c2        
! ----+-----------------
!   5 | initial_default
!     | initial_default
!     | 
!  10 | new_default
!     | 
!  45 | 
!  45 | view_default
! (7 rows)
! 
! drop rule def_view_test_ins on def_view_test;
! drop view def_view_test;
! drop table def_test;
! -- alter table / drop column tests
! -- try altering system catalogs, should fail
! alter table pg_class drop column relname;
! ERROR:  permission denied: "pg_class" is a system catalog
! -- try altering non-existent table, should fail
! alter table nosuchtable drop column bar;
! ERROR:  relation "nosuchtable" does not exist
! -- test dropping columns
! create table atacc1 (a int4 not null, b int4, c int4 not null, d int4) with oids;
! insert into atacc1 values (1, 2, 3, 4);
! alter table atacc1 drop a;
! alter table atacc1 drop a;
! ERROR:  column "a" of relation "atacc1" does not exist
! -- SELECTs
! select * from atacc1;
!  b | c | d 
! ---+---+---
!  2 | 3 | 4
! (1 row)
! 
! select * from atacc1 order by a;
! ERROR:  column "a" does not exist
! LINE 1: select * from atacc1 order by a;
!                                       ^
! select * from atacc1 order by "........pg.dropped.1........";
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
!                                       ^
! select * from atacc1 group by a;
! ERROR:  column "a" does not exist
! LINE 1: select * from atacc1 group by a;
!                                       ^
! select * from atacc1 group by "........pg.dropped.1........";
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
!                                       ^
! select atacc1.* from atacc1;
!  b | c | d 
! ---+---+---
!  2 | 3 | 4
! (1 row)
! 
! select a from atacc1;
! ERROR:  column "a" does not exist
! LINE 1: select a from atacc1;
!                ^
! select atacc1.a from atacc1;
! ERROR:  column atacc1.a does not exist
! LINE 1: select atacc1.a from atacc1;
!                ^
! select b,c,d from atacc1;
!  b | c | d 
! ---+---+---
!  2 | 3 | 4
! (1 row)
! 
! select a,b,c,d from atacc1;
! ERROR:  column "a" does not exist
! LINE 1: select a,b,c,d from atacc1;
!                ^
! select * from atacc1 where a = 1;
! ERROR:  column "a" does not exist
! LINE 1: select * from atacc1 where a = 1;
!                                    ^
! select "........pg.dropped.1........" from atacc1;
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: select "........pg.dropped.1........" from atacc1;
!                ^
! select atacc1."........pg.dropped.1........" from atacc1;
! ERROR:  column atacc1.........pg.dropped.1........ does not exist
! LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
!                ^
! select "........pg.dropped.1........",b,c,d from atacc1;
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
!                ^
! select * from atacc1 where "........pg.dropped.1........" = 1;
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
!                                    ^
! -- UPDATEs
! update atacc1 set a = 3;
! ERROR:  column "a" of relation "atacc1" does not exist
! LINE 1: update atacc1 set a = 3;
!                           ^
! update atacc1 set b = 2 where a = 3;
! ERROR:  column "a" does not exist
! LINE 1: update atacc1 set b = 2 where a = 3;
!                                       ^
! update atacc1 set "........pg.dropped.1........" = 3;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
!                           ^
! update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
!                                       ^
! -- INSERTs
! insert into atacc1 values (10, 11, 12, 13);
! ERROR:  INSERT has more expressions than target columns
! LINE 1: insert into atacc1 values (10, 11, 12, 13);
!                                                ^
! insert into atacc1 values (default, 11, 12, 13);
! ERROR:  INSERT has more expressions than target columns
! LINE 1: insert into atacc1 values (default, 11, 12, 13);
!                                                     ^
! insert into atacc1 values (11, 12, 13);
! insert into atacc1 (a) values (10);
! ERROR:  column "a" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 (a) values (10);
!                             ^
! insert into atacc1 (a) values (default);
! ERROR:  column "a" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 (a) values (default);
!                             ^
! insert into atacc1 (a,b,c,d) values (10,11,12,13);
! ERROR:  column "a" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
!                             ^
! insert into atacc1 (a,b,c,d) values (default,11,12,13);
! ERROR:  column "a" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
!                             ^
! insert into atacc1 (b,c,d) values (11,12,13);
! insert into atacc1 ("........pg.dropped.1........") values (10);
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
!                             ^
! insert into atacc1 ("........pg.dropped.1........") values (default);
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
!                             ^
! insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
!                             ^
! insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
!                             ^
! -- DELETEs
! delete from atacc1 where a = 3;
! ERROR:  column "a" does not exist
! LINE 1: delete from atacc1 where a = 3;
!                                  ^
! delete from atacc1 where "........pg.dropped.1........" = 3;
! ERROR:  column "........pg.dropped.1........" does not exist
! LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
!                                  ^
! delete from atacc1;
! -- try dropping a non-existent column, should fail
! alter table atacc1 drop bar;
! ERROR:  column "bar" of relation "atacc1" does not exist
! -- try dropping the oid column, should succeed
! alter table atacc1 drop oid;
! -- try dropping the xmin column, should fail
! alter table atacc1 drop xmin;
! ERROR:  cannot drop system column "xmin"
! -- try creating a view and altering that, should fail
! create view myview as select * from atacc1;
! select * from myview;
!  b | c | d 
! ---+---+---
! (0 rows)
! 
! alter table myview drop d;
! ERROR:  "myview" is not a table, composite type, or foreign table
! drop view myview;
! -- test some commands to make sure they fail on the dropped column
! analyze atacc1(a);
! ERROR:  column "a" of relation "atacc1" does not exist
! analyze atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! vacuum analyze atacc1(a);
! ERROR:  column "a" of relation "atacc1" does not exist
! vacuum analyze atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! comment on column atacc1.a is 'testing';
! ERROR:  column "a" of relation "atacc1" does not exist
! comment on column atacc1."........pg.dropped.1........" is 'testing';
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a set storage plain;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" set storage plain;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a set statistics 0;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a set default 3;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" set default 3;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a drop default;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" drop default;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a set not null;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" set not null;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 alter a drop not null;
! ERROR:  column "a" of relation "atacc1" does not exist
! alter table atacc1 alter "........pg.dropped.1........" drop not null;
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
! alter table atacc1 rename a to x;
! ERROR:  column "a" does not exist
! alter table atacc1 rename "........pg.dropped.1........" to x;
! ERROR:  column "........pg.dropped.1........" does not exist
! alter table atacc1 add primary key(a);
! ERROR:  column "a" named in key does not exist
! alter table atacc1 add primary key("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" named in key does not exist
! alter table atacc1 add unique(a);
! ERROR:  column "a" named in key does not exist
! alter table atacc1 add unique("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" named in key does not exist
! alter table atacc1 add check (a > 3);
! ERROR:  column "a" does not exist
! alter table atacc1 add check ("........pg.dropped.1........" > 3);
! ERROR:  column "........pg.dropped.1........" does not exist
! create table atacc2 (id int4 unique);
! alter table atacc1 add foreign key (a) references atacc2(id);
! ERROR:  column "a" referenced in foreign key constraint does not exist
! alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
! ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
! alter table atacc2 add foreign key (id) references atacc1(a);
! ERROR:  column "a" referenced in foreign key constraint does not exist
! alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
! drop table atacc2;
! create index "testing_idx" on atacc1(a);
! ERROR:  column "a" does not exist
! create index "testing_idx" on atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" does not exist
! -- test create as and select into
! insert into atacc1 values (21, 22, 23);
! create table test1 as select * from atacc1;
! select * from test1;
!  b  | c  | d  
! ----+----+----
!  21 | 22 | 23
! (1 row)
! 
! drop table test1;
! select * into test2 from atacc1;
! select * from test2;
!  b  | c  | d  
! ----+----+----
!  21 | 22 | 23
! (1 row)
! 
! drop table test2;
! -- try dropping all columns
! alter table atacc1 drop c;
! alter table atacc1 drop d;
! alter table atacc1 drop b;
! select * from atacc1;
! --
! (1 row)
! 
! drop table atacc1;
! -- test constraint error reporting in presence of dropped columns
! create table atacc1 (id serial primary key, value int check (value < 10));
! insert into atacc1(value) values (100);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
! DETAIL:  Failing row contains (1, 100).
! alter table atacc1 drop column value;
! alter table atacc1 add column value int check (value < 10);
! insert into atacc1(value) values (100);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
! DETAIL:  Failing row contains (2, 100).
! insert into atacc1(id, value) values (null, 0);
! ERROR:  null value in column "id" violates not-null constraint
! DETAIL:  Failing row contains (null, 0).
! drop table atacc1;
! -- test inheritance
! create table parent (a int, b int, c int);
! insert into parent values (1, 2, 3);
! alter table parent drop a;
! create table child (d varchar(255)) inherits (parent);
! insert into child values (12, 13, 'testing');
! select * from parent;
!  b  | c  
! ----+----
!   2 |  3
!  12 | 13
! (2 rows)
! 
! select * from child;
!  b  | c  |    d    
! ----+----+---------
!  12 | 13 | testing
! (1 row)
! 
! alter table parent drop c;
! select * from parent;
!  b  
! ----
!   2
!  12
! (2 rows)
! 
! select * from child;
!  b  |    d    
! ----+---------
!  12 | testing
! (1 row)
! 
! drop table child;
! drop table parent;
! -- test copy in/out
! create table test (a int4, b int4, c int4);
! insert into test values (1,2,3);
! alter table test drop a;
! copy test to stdout;
! 2	3
! copy test(a) to stdout;
! ERROR:  column "a" of relation "test" does not exist
! copy test("........pg.dropped.1........") to stdout;
! ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
! copy test from stdin;
! ERROR:  extra data after last expected column
! CONTEXT:  COPY test, line 1: "10	11	12"
! select * from test;
!  b | c 
! ---+---
!  2 | 3
! (1 row)
! 
! copy test from stdin;
! select * from test;
!  b  | c  
! ----+----
!   2 |  3
!  21 | 22
! (2 rows)
! 
! copy test(a) from stdin;
! ERROR:  column "a" of relation "test" does not exist
! copy test("........pg.dropped.1........") from stdin;
! ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
! copy test(b,c) from stdin;
! select * from test;
!  b  | c  
! ----+----
!   2 |  3
!  21 | 22
!  31 | 32
! (3 rows)
! 
! drop table test;
! -- test inheritance
! create table dropColumn (a int, b int, e int);
! create table dropColumnChild (c int) inherits (dropColumn);
! create table dropColumnAnother (d int) inherits (dropColumnChild);
! -- these two should fail
! alter table dropColumnchild drop column a;
! ERROR:  cannot drop inherited column "a"
! alter table only dropColumnChild drop column b;
! ERROR:  cannot drop inherited column "b"
! -- these three should work
! alter table only dropColumn drop column e;
! alter table dropColumnChild drop column c;
! alter table dropColumn drop column a;
! create table renameColumn (a int);
! create table renameColumnChild (b int) inherits (renameColumn);
! create table renameColumnAnother (c int) inherits (renameColumnChild);
! -- these three should fail
! alter table renameColumnChild rename column a to d;
! ERROR:  cannot rename inherited column "a"
! alter table only renameColumnChild rename column a to d;
! ERROR:  inherited column "a" must be renamed in child tables too
! alter table only renameColumn rename column a to d;
! ERROR:  inherited column "a" must be renamed in child tables too
! -- these should work
! alter table renameColumn rename column a to d;
! alter table renameColumnChild rename column b to a;
! -- these should work
! alter table if exists doesnt_exist_tab rename column a to d;
! NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
! alter table if exists doesnt_exist_tab rename column b to a;
! NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
! -- this should work
! alter table renameColumn add column w int;
! -- this should fail
! alter table only renameColumn add column x int;
! ERROR:  column must be added to child tables too
! -- Test corner cases in dropping of inherited columns
! create table p1 (f1 int, f2 int);
! create table c1 (f1 int not null) inherits(p1);
! NOTICE:  merging column "f1" with inherited definition
! -- should be rejected since c1.f1 is inherited
! alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
! -- should work
! alter table p1 drop column f1;
! -- c1.f1 is still there, but no longer inherited
! select f1 from c1;
!  f1 
! ----
! (0 rows)
! 
! alter table c1 drop column f1;
! select f1 from c1;
! ERROR:  column "f1" does not exist
! LINE 1: select f1 from c1;
!                ^
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! create table p1 (f1 int, f2 int);
! create table c1 () inherits(p1);
! -- should be rejected since c1.f1 is inherited
! alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
! alter table p1 drop column f1;
! -- c1.f1 is dropped now, since there is no local definition for it
! select f1 from c1;
! ERROR:  column "f1" does not exist
! LINE 1: select f1 from c1;
!                ^
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! create table p1 (f1 int, f2 int);
! create table c1 () inherits(p1);
! -- should be rejected since c1.f1 is inherited
! alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
! alter table only p1 drop column f1;
! -- c1.f1 is NOT dropped, but must now be considered non-inherited
! alter table c1 drop column f1;
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! create table p1 (f1 int, f2 int);
! create table c1 (f1 int not null) inherits(p1);
! NOTICE:  merging column "f1" with inherited definition
! -- should be rejected since c1.f1 is inherited
! alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
! alter table only p1 drop column f1;
! -- c1.f1 is still there, but no longer inherited
! alter table c1 drop column f1;
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! create table p1(id int, name text);
! create table p2(id2 int, name text, height int);
! create table c1(age int) inherits(p1,p2);
! NOTICE:  merging multiple inherited definitions of column "name"
! create table gc1() inherits (c1);
! select relname, attname, attinhcount, attislocal
! from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
! where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
! order by relname, attnum;
!  relname | attname | attinhcount | attislocal 
! ---------+---------+-------------+------------
!  c1      | id      |           1 | f
!  c1      | name    |           2 | f
!  c1      | id2     |           1 | f
!  c1      | height  |           1 | f
!  c1      | age     |           0 | t
!  gc1     | id      |           1 | f
!  gc1     | name    |           1 | f
!  gc1     | id2     |           1 | f
!  gc1     | height  |           1 | f
!  gc1     | age     |           1 | f
!  p1      | id      |           0 | t
!  p1      | name    |           0 | t
!  p2      | id2     |           0 | t
!  p2      | name    |           0 | t
!  p2      | height  |           0 | t
! (15 rows)
! 
! -- should work
! alter table only p1 drop column name;
! -- should work. Now c1.name is local and inhcount is 0.
! alter table p2 drop column name;
! -- should be rejected since its inherited
! alter table gc1 drop column name;
! ERROR:  cannot drop inherited column "name"
! -- should work, and drop gc1.name along
! alter table c1 drop column name;
! -- should fail: column does not exist
! alter table gc1 drop column name;
! ERROR:  column "name" of relation "gc1" does not exist
! -- should work and drop the attribute in all tables
! alter table p2 drop column height;
! -- IF EXISTS test
! create table dropColumnExists ();
! alter table dropColumnExists drop column non_existing; --fail
! ERROR:  column "non_existing" of relation "dropcolumnexists" does not exist
! alter table dropColumnExists drop column if exists non_existing; --succeed
! NOTICE:  column "non_existing" of relation "dropcolumnexists" does not exist, skipping
! select relname, attname, attinhcount, attislocal
! from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
! where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
! order by relname, attnum;
!  relname | attname | attinhcount | attislocal 
! ---------+---------+-------------+------------
!  c1      | id      |           1 | f
!  c1      | id2     |           1 | f
!  c1      | age     |           0 | t
!  gc1     | id      |           1 | f
!  gc1     | id2     |           1 | f
!  gc1     | age     |           1 | f
!  p1      | id      |           0 | t
!  p2      | id2     |           0 | t
! (8 rows)
! 
! drop table p1, p2 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table c1
! drop cascades to table gc1
! -- test attinhcount tracking with merged columns
! create table depth0();
! create table depth1(c text) inherits (depth0);
! create table depth2() inherits (depth1);
! alter table depth0 add c text;
! NOTICE:  merging definition of column "c" for child "depth1"
! select attrelid::regclass, attname, attinhcount, attislocal
! from pg_attribute
! where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
! order by attrelid::regclass::text, attnum;
!  attrelid | attname | attinhcount | attislocal 
! ----------+---------+-------------+------------
!  depth0   | c       |           0 | t
!  depth1   | c       |           1 | t
!  depth2   | c       |           1 | f
! (3 rows)
! 
! --
! -- Test the ALTER TABLE SET WITH/WITHOUT OIDS command
! --
! create table altstartwith (col integer) with oids;
! insert into altstartwith values (1);
! select oid > 0, * from altstartwith;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! alter table altstartwith set without oids;
! select oid > 0, * from altstartwith; -- fails
! ERROR:  column "oid" does not exist
! LINE 1: select oid > 0, * from altstartwith;
!                ^
! select * from altstartwith;
!  col 
! -----
!    1
! (1 row)
! 
! alter table altstartwith set with oids;
! select oid > 0, * from altstartwith;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! drop table altstartwith;
! -- Check inheritance cases
! create table altwithoid (col integer) with oids;
! -- Inherits parents oid column anyway
! create table altinhoid () inherits (altwithoid) without oids;
! insert into altinhoid values (1);
! select oid > 0, * from altwithoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! select oid > 0, * from altinhoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! alter table altwithoid set without oids;
! select oid > 0, * from altwithoid; -- fails
! ERROR:  column "oid" does not exist
! LINE 1: select oid > 0, * from altwithoid;
!                ^
! select oid > 0, * from altinhoid; -- fails
! ERROR:  column "oid" does not exist
! LINE 1: select oid > 0, * from altinhoid;
!                ^
! select * from altwithoid;
!  col 
! -----
!    1
! (1 row)
! 
! select * from altinhoid;
!  col 
! -----
!    1
! (1 row)
! 
! alter table altwithoid set with oids;
! select oid > 0, * from altwithoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! select oid > 0, * from altinhoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! drop table altwithoid cascade;
! NOTICE:  drop cascades to table altinhoid
! create table altwithoid (col integer) without oids;
! -- child can have local oid column
! create table altinhoid () inherits (altwithoid) with oids;
! insert into altinhoid values (1);
! select oid > 0, * from altwithoid; -- fails
! ERROR:  column "oid" does not exist
! LINE 1: select oid > 0, * from altwithoid;
!                ^
! select oid > 0, * from altinhoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! alter table altwithoid set with oids;
! NOTICE:  merging definition of column "oid" for child "altinhoid"
! select oid > 0, * from altwithoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! select oid > 0, * from altinhoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! -- the child's local definition should remain
! alter table altwithoid set without oids;
! select oid > 0, * from altwithoid; -- fails
! ERROR:  column "oid" does not exist
! LINE 1: select oid > 0, * from altwithoid;
!                ^
! select oid > 0, * from altinhoid;
!  ?column? | col 
! ----------+-----
!  t        |   1
! (1 row)
! 
! drop table altwithoid cascade;
! NOTICE:  drop cascades to table altinhoid
! -- test renumbering of child-table columns in inherited operations
! create table p1 (f1 int);
! create table c1 (f2 text, f3 int) inherits (p1);
! alter table p1 add column a1 int check (a1 > 0);
! alter table p1 add column f2 text;
! NOTICE:  merging definition of column "f2" for child "c1"
! insert into p1 values (1,2,'abc');
! insert into c1 values(11,'xyz',33,0); -- should fail
! ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
! DETAIL:  Failing row contains (11, xyz, 33, 0).
! insert into c1 values(11,'xyz',33,22);
! select * from p1;
!  f1 | a1 | f2  
! ----+----+-----
!   1 |  2 | abc
!  11 | 22 | xyz
! (2 rows)
! 
! update p1 set a1 = a1 + 1, f2 = upper(f2);
! select * from p1;
!  f1 | a1 | f2  
! ----+----+-----
!   1 |  3 | ABC
!  11 | 23 | XYZ
! (2 rows)
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! -- test that operations with a dropped column do not try to reference
! -- its datatype
! create domain mytype as text;
! create temp table foo (f1 text, f2 mytype, f3 text);
! insert into foo values('bb','cc','dd');
! select * from foo;
!  f1 | f2 | f3 
! ----+----+----
!  bb | cc | dd
! (1 row)
! 
! drop domain mytype cascade;
! NOTICE:  drop cascades to table foo column f2
! select * from foo;
!  f1 | f3 
! ----+----
!  bb | dd
! (1 row)
! 
! insert into foo values('qq','rr');
! select * from foo;
!  f1 | f3 
! ----+----
!  bb | dd
!  qq | rr
! (2 rows)
! 
! update foo set f3 = 'zz';
! select * from foo;
!  f1 | f3 
! ----+----
!  bb | zz
!  qq | zz
! (2 rows)
! 
! select f3,max(f1) from foo group by f3;
!  f3 | max 
! ----+-----
!  zz | qq
! (1 row)
! 
! -- Simple tests for alter table column type
! alter table foo alter f1 TYPE integer; -- fails
! ERROR:  column "f1" cannot be cast automatically to type integer
! HINT:  Specify a USING expression to perform the conversion.
! alter table foo alter f1 TYPE varchar(10);
! create table anothertab (atcol1 serial8, atcol2 boolean,
! 	constraint anothertab_chk check (atcol1 <= 3));
! insert into anothertab (atcol1, atcol2) values (default, true);
! insert into anothertab (atcol1, atcol2) values (default, false);
! select * from anothertab;
!  atcol1 | atcol2 
! --------+--------
!       1 | t
!       2 | f
! (2 rows)
! 
! alter table anothertab alter column atcol1 type boolean; -- fails
! ERROR:  column "atcol1" cannot be cast automatically to type boolean
! HINT:  Specify a USING expression to perform the conversion.
! alter table anothertab alter column atcol1 type integer;
! select * from anothertab;
!  atcol1 | atcol2 
! --------+--------
!       1 | t
!       2 | f
! (2 rows)
! 
! insert into anothertab (atcol1, atcol2) values (45, null); -- fails
! ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
! DETAIL:  Failing row contains (45, null).
! insert into anothertab (atcol1, atcol2) values (default, null);
! select * from anothertab;
!  atcol1 | atcol2 
! --------+--------
!       1 | t
!       2 | f
!       3 | 
! (3 rows)
! 
! alter table anothertab alter column atcol2 type text
!       using case when atcol2 is true then 'IT WAS TRUE'
!                  when atcol2 is false then 'IT WAS FALSE'
!                  else 'IT WAS NULL!' end;
! select * from anothertab;
!  atcol1 |    atcol2    
! --------+--------------
!       1 | IT WAS TRUE
!       2 | IT WAS FALSE
!       3 | IT WAS NULL!
! (3 rows)
! 
! alter table anothertab alter column atcol1 type boolean
!         using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  default for column "atcol1" cannot be cast automatically to type boolean
! alter table anothertab alter column atcol1 drop default;
! alter table anothertab alter column atcol1 type boolean
!         using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  operator does not exist: boolean <= integer
! HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
! alter table anothertab drop constraint anothertab_chk;
! alter table anothertab drop constraint anothertab_chk; -- fails
! ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
! alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
! NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
! alter table anothertab alter column atcol1 type boolean
!         using case when atcol1 % 2 = 0 then true else false end;
! select * from anothertab;
!  atcol1 |    atcol2    
! --------+--------------
!  f      | IT WAS TRUE
!  t      | IT WAS FALSE
!  f      | IT WAS NULL!
! (3 rows)
! 
! drop table anothertab;
! create table another (f1 int, f2 text);
! insert into another values(1, 'one');
! insert into another values(2, 'two');
! insert into another values(3, 'three');
! select * from another;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! alter table another
!   alter f1 type text using f2 || ' more',
!   alter f2 type bigint using f1 * 10;
! select * from another;
!      f1     | f2 
! ------------+----
!  one more   | 10
!  two more   | 20
!  three more | 30
! (3 rows)
! 
! drop table another;
! -- table's row type
! create table tab1 (a int, b text);
! create table tab2 (x int, y tab1);
! alter table tab1 alter column b type varchar; -- fails
! ERROR:  cannot alter table "tab1" because column "tab2.y" uses its row type
! -- disallow recursive containment of row types
! create temp table recur1 (f1 int);
! alter table recur1 add column f2 recur1; -- fails
! ERROR:  composite type recur1 cannot be made a member of itself
! alter table recur1 add column f2 recur1[]; -- fails
! ERROR:  composite type recur1 cannot be made a member of itself
! create domain array_of_recur1 as recur1[];
! alter table recur1 add column f2 array_of_recur1; -- fails
! ERROR:  composite type recur1 cannot be made a member of itself
! create temp table recur2 (f1 int, f2 recur1);
! alter table recur1 add column f2 recur2; -- fails
! ERROR:  composite type recur1 cannot be made a member of itself
! alter table recur1 add column f2 int;
! alter table recur1 alter column f2 type recur2; -- fails
! ERROR:  composite type recur1 cannot be made a member of itself
! -- SET STORAGE may need to add a TOAST table
! create table test_storage (a text);
! alter table test_storage alter a set storage plain;
! alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
! alter table test_storage alter a set storage extended; -- re-add TOAST table
! select reltoastrelid <> 0 as has_toast_table
! from pg_class
! where oid = 'test_storage'::regclass;
!  has_toast_table 
! -----------------
!  t
! (1 row)
! 
! -- ALTER TYPE with a check constraint and a child table (bug before Nov 2012)
! CREATE TABLE test_inh_check (a float check (a > 10.2));
! CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
! ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
! \d test_inh_check
! Table "public.test_inh_check"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | numeric | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d test_inh_check_child
! Table "public.test_inh_check_child"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | numeric | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Inherits: test_inh_check
! 
! -- check for rollback of ANALYZE corrupting table property flags (bug #11638)
! CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
! CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
! BEGIN;
! ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
! ANALYZE check_fk_presence_2;
! ROLLBACK;
! \d check_fk_presence_2
! Table "public.check_fk_presence_2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  id     | integer | 
!  t      | text    | 
! Foreign-key constraints:
!     "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)
! 
! DROP TABLE check_fk_presence_1, check_fk_presence_2;
! --
! -- lock levels
! --
! drop type lockmodes;
! ERROR:  type "lockmodes" does not exist
! create type lockmodes as enum (
!  'AccessShareLock'
! ,'RowShareLock'
! ,'RowExclusiveLock'
! ,'ShareUpdateExclusiveLock'
! ,'ShareLock'
! ,'ShareRowExclusiveLock'
! ,'ExclusiveLock'
! ,'AccessExclusiveLock'
! );
! drop view my_locks;
! ERROR:  view "my_locks" does not exist
! create or replace view my_locks as
! select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
! from pg_locks l join pg_class c on l.relation = c.oid
! where virtualtransaction = (
!         select virtualtransaction
!         from pg_locks
!         where transactionid = txid_current()::integer)
! and locktype = 'relation'
! and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
! and c.relname != 'my_locks'
! group by c.relname;
! create table alterlock (f1 int primary key, f2 text);
! insert into alterlock values (1, 'foo');
! create table alterlock2 (f3 int primary key, f1 int);
! insert into alterlock2 values (1, 1);
! begin; alter table alterlock alter column f2 set statistics 150;
! select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
! rollback;
! begin; alter table alterlock cluster on alterlock_pkey;
! select * from my_locks order by 1;
!     relname     |       max_lockmode       
! ----------------+--------------------------
!  alterlock      | ShareUpdateExclusiveLock
!  alterlock_pkey | ShareUpdateExclusiveLock
! (2 rows)
! 
! commit;
! begin; alter table alterlock set without cluster;
! select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
! commit;
! begin; alter table alterlock set (fillfactor = 100);
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
!  pg_toast  | AccessExclusiveLock
! (2 rows)
! 
! commit;
! begin; alter table alterlock reset (fillfactor);
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
!  pg_toast  | AccessExclusiveLock
! (2 rows)
! 
! commit;
! begin; alter table alterlock set (toast.autovacuum_enabled = off);
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
!  pg_toast  | AccessExclusiveLock
! (2 rows)
! 
! commit;
! begin; alter table alterlock set (autovacuum_enabled = off);
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
!  pg_toast  | AccessExclusiveLock
! (2 rows)
! 
! commit;
! begin; alter table alterlock alter column f2 set (n_distinct = 1);
! select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
! rollback;
! begin; alter table alterlock alter column f2 set storage extended;
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
! (1 row)
! 
! rollback;
! begin; alter table alterlock alter column f2 set default 'x';
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
! (1 row)
! 
! rollback;
! begin;
! create trigger ttdummy
! 	before delete or update on alterlock
! 	for each row
! 	execute procedure
! 	ttdummy (1, 1);
! select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
! (1 row)
! 
! rollback;
! begin;
! select * from my_locks order by 1;
!  relname | max_lockmode 
! ---------+--------------
! (0 rows)
! 
! alter table alterlock2 add foreign key (f1) references alterlock (f1);
! select * from my_locks order by 1;
!      relname     |    max_lockmode     
! -----------------+---------------------
!  alterlock       | AccessExclusiveLock
!  alterlock2      | AccessExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
! rollback;
! begin;
! alter table alterlock2
! add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
! select * from my_locks order by 1;
!   relname   |    max_lockmode     
! ------------+---------------------
!  alterlock  | AccessExclusiveLock
!  alterlock2 | AccessExclusiveLock
! (2 rows)
! 
! commit;
! begin;
! alter table alterlock2 validate constraint alterlock2nv;
! select * from my_locks order by 1;
!      relname     |       max_lockmode       
! -----------------+--------------------------
!  alterlock       | RowShareLock
!  alterlock2      | ShareUpdateExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
! rollback;
! -- cleanup
! drop table alterlock2;
! drop table alterlock;
! drop view my_locks;
! drop type lockmodes;
! --
! -- alter function
! --
! create function test_strict(text) returns text as
!     'select coalesce($1, ''got passed a null'');'
!     language sql returns null on null input;
! select test_strict(NULL);
!  test_strict 
! -------------
!  
! (1 row)
! 
! alter function test_strict(text) called on null input;
! select test_strict(NULL);
!     test_strict    
! -------------------
!  got passed a null
! (1 row)
! 
! create function non_strict(text) returns text as
!     'select coalesce($1, ''got passed a null'');'
!     language sql called on null input;
! select non_strict(NULL);
!     non_strict     
! -------------------
!  got passed a null
! (1 row)
! 
! alter function non_strict(text) returns null on null input;
! select non_strict(NULL);
!  non_strict 
! ------------
!  
! (1 row)
! 
! --
! -- alter object set schema
! --
! create schema alter1;
! create schema alter2;
! create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
! create view alter1.v1 as select * from alter1.t1;
! create function alter1.plus1(int) returns int as 'select $1+1' language sql;
! create domain alter1.posint integer check (value > 0);
! create type alter1.ctype as (f1 int, f2 text);
! create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
! as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
! create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
! create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
!   operator 1 alter1.=(alter1.ctype, alter1.ctype);
! create conversion alter1.ascii_to_utf8 for 'sql_ascii' to 'utf8' from ascii_to_utf8;
! create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
! create text search configuration alter1.cfg(parser = alter1.prs);
! create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
! create text search dictionary alter1.dict(template = alter1.tmpl);
! insert into alter1.t1(f2) values(11);
! insert into alter1.t1(f2) values(12);
! alter table alter1.t1 set schema alter2;
! alter table alter1.v1 set schema alter2;
! alter function alter1.plus1(int) set schema alter2;
! alter domain alter1.posint set schema alter2;
! alter operator class alter1.ctype_hash_ops using hash set schema alter2;
! alter operator family alter1.ctype_hash_ops using hash set schema alter2;
! alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
! alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
! alter type alter1.ctype set schema alter2;
! alter conversion alter1.ascii_to_utf8 set schema alter2;
! alter text search parser alter1.prs set schema alter2;
! alter text search configuration alter1.cfg set schema alter2;
! alter text search template alter1.tmpl set schema alter2;
! alter text search dictionary alter1.dict set schema alter2;
! -- this should succeed because nothing is left in alter1
! drop schema alter1;
! insert into alter2.t1(f2) values(13);
! insert into alter2.t1(f2) values(14);
! select * from alter2.t1;
!  f1 | f2 
! ----+----
!   1 | 11
!   2 | 12
!   3 | 13
!   4 | 14
! (4 rows)
! 
! select * from alter2.v1;
!  f1 | f2 
! ----+----
!   1 | 11
!   2 | 12
!   3 | 13
!   4 | 14
! (4 rows)
! 
! select alter2.plus1(41);
!  plus1 
! -------
!     42
! (1 row)
! 
! -- clean up
! drop schema alter2 cascade;
! NOTICE:  drop cascades to 13 other objects
! DETAIL:  drop cascades to table alter2.t1
! drop cascades to view alter2.v1
! drop cascades to function alter2.plus1(integer)
! drop cascades to type alter2.posint
! drop cascades to operator family alter2.ctype_hash_ops for access method hash
! drop cascades to type alter2.ctype
! drop cascades to function alter2.same(alter2.ctype,alter2.ctype)
! drop cascades to operator alter2.=(alter2.ctype,alter2.ctype)
! drop cascades to conversion ascii_to_utf8
! drop cascades to text search parser prs
! drop cascades to text search configuration cfg
! drop cascades to text search template tmpl
! drop cascades to text search dictionary dict
! --
! -- composite types
! --
! CREATE TYPE test_type AS (a int);
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
! 
! ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
! ERROR:  relation "nosuchtype" does not exist
! ALTER TYPE test_type ADD ATTRIBUTE b text;
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | text    | 
! 
! ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
! ERROR:  column "b" of relation "test_type" already exists
! ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
! \d test_type
!    Composite type "public.test_type"
!  Column |       Type        | Modifiers 
! --------+-------------------+-----------
!  a      | integer           | 
!  b      | character varying | 
! 
! ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | integer | 
! 
! ALTER TYPE test_type DROP ATTRIBUTE b;
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
! 
! ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
! ERROR:  column "c" of relation "test_type" does not exist
! ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
! NOTICE:  column "c" of relation "test_type" does not exist, skipping
! ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  d      | boolean | 
! 
! ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
! ERROR:  column "a" does not exist
! ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
! \d test_type
! Composite type "public.test_type"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  dd     | boolean | 
! 
! DROP TYPE test_type;
! CREATE TYPE test_type1 AS (a int, b text);
! CREATE TABLE test_tbl1 (x int, y test_type1);
! ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
! ERROR:  cannot alter type "test_type1" because column "test_tbl1.y" uses it
! CREATE TYPE test_type2 AS (a int, b text);
! CREATE TABLE test_tbl2 OF test_type2;
! CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
! \d test_type2
! Composite type "public.test_type2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | text    | 
! 
! \d test_tbl2
!    Table "public.test_tbl2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | text    | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
! ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
! ERROR:  cannot alter type "test_type2" because it is the type of a typed table
! HINT:  Use ALTER ... CASCADE to alter the typed tables too.
! ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
! \d test_type2
! Composite type "public.test_type2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | text    | 
!  c      | text    | 
! 
! \d test_tbl2
!    Table "public.test_tbl2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  b      | text    | 
!  c      | text    | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
! ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
! ERROR:  cannot alter type "test_type2" because it is the type of a typed table
! HINT:  Use ALTER ... CASCADE to alter the typed tables too.
! ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
! \d test_type2
!    Composite type "public.test_type2"
!  Column |       Type        | Modifiers 
! --------+-------------------+-----------
!  a      | integer           | 
!  b      | character varying | 
!  c      | text              | 
! 
! \d test_tbl2
!         Table "public.test_tbl2"
!  Column |       Type        | Modifiers 
! --------+-------------------+-----------
!  a      | integer           | 
!  b      | character varying | 
!  c      | text              | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
! ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
! ERROR:  cannot alter type "test_type2" because it is the type of a typed table
! HINT:  Use ALTER ... CASCADE to alter the typed tables too.
! ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
! \d test_type2
! Composite type "public.test_type2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  c      | text    | 
! 
! \d test_tbl2
!    Table "public.test_tbl2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  a      | integer | 
!  c      | text    | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
! ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
! ERROR:  cannot alter type "test_type2" because it is the type of a typed table
! HINT:  Use ALTER ... CASCADE to alter the typed tables too.
! ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
! \d test_type2
! Composite type "public.test_type2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  aa     | integer | 
!  c      | text    | 
! 
! \d test_tbl2
!    Table "public.test_tbl2"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  aa     | integer | 
!  c      | text    | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
! \d test_tbl2_subclass
! Table "public.test_tbl2_subclass"
!  Column |  Type   | Modifiers 
! --------+---------+-----------
!  aa     | integer | 
!  c      | text    | 
! Inherits: test_tbl2
! 
! DROP TABLE test_tbl2_subclass;
! -- This test isn't that interesting on its own, but the purpose is to leave
! -- behind a table to test pg_upgrade with. The table has a composite type
! -- column in it, and the composite type has a dropped attribute.
! CREATE TYPE test_type3 AS (a int);
! CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
! ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
! CREATE TYPE test_type_empty AS ();
! DROP TYPE test_type_empty;
! --
! -- typed tables: OF / NOT OF
! --
! CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
! ALTER TYPE tt_t0 DROP ATTRIBUTE z;
! CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
! CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
! CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
! CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
! CREATE TABLE tt4 (x int);							-- too few columns
! CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
! CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
! CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;
! ALTER TABLE tt7 DROP q;								-- OK
! ALTER TABLE tt0 OF tt_t0;
! ALTER TABLE tt1 OF tt_t0;
! ERROR:  table "tt1" has different type for column "y"
! ALTER TABLE tt2 OF tt_t0;
! ERROR:  table "tt2" has different type for column "y"
! ALTER TABLE tt3 OF tt_t0;
! ERROR:  table has column "y" where type requires "x"
! ALTER TABLE tt4 OF tt_t0;
! ERROR:  table is missing column "y"
! ALTER TABLE tt5 OF tt_t0;
! ERROR:  table has extra column "z"
! ALTER TABLE tt6 OF tt_t0;
! ERROR:  typed tables cannot inherit
! ALTER TABLE tt7 OF tt_t0;
! CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
! ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
! ALTER TABLE tt7 NOT OF;
! \d tt7
!         Table "public.tt7"
!  Column |     Type     | Modifiers 
! --------+--------------+-----------
!  x      | integer      | 
!  y      | numeric(8,2) | 
! 
! -- make sure we can drop a constraint on the parent but it remains on the child
! CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
! CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
! ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
! -- should fail
! INSERT INTO test_drop_constr_child (c) VALUES (NULL);
! ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
! DETAIL:  Failing row contains (null).
! DROP TABLE test_drop_constr_parent CASCADE;
! NOTICE:  drop cascades to table test_drop_constr_child
! --
! -- IF EXISTS test
! --
! ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
! NOTICE:  relation "tt8" does not exist, skipping
! ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
! NOTICE:  relation "tt8" does not exist, skipping
! ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
! NOTICE:  relation "tt8" does not exist, skipping
! ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
! NOTICE:  relation "tt8" does not exist, skipping
! ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
! NOTICE:  relation "tt8" does not exist, skipping
! ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
! NOTICE:  relation "tt8" does not exist, skipping
! CREATE TABLE tt8(a int);
! CREATE SCHEMA alter2;
! ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
! ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
! ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
! ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
! ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
! ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
! \d alter2.tt8
!           Table "alter2.tt8"
!  Column |  Type   |     Modifiers      
! --------+---------+--------------------
!  a      | integer | 
!  f1     | integer | not null default 0
! Indexes:
!     "xxx" PRIMARY KEY, btree (f1)
! Check constraints:
!     "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
! 
! DROP TABLE alter2.tt8;
! DROP SCHEMA alter2;
! -- Check that we map relation oids to filenodes and back correctly.  Only
! -- display bad mappings so the test output doesn't change all the time.  A
! -- filenode function call can return NULL for a relation dropped concurrently
! -- with the call's surrounding query, so ignore a NULL mapped_oid for
! -- relations that no longer exist after all calls finish.
! CREATE TEMP TABLE filenode_mapping AS
! SELECT
!     oid, mapped_oid, reltablespace, relfilenode, relname
! FROM pg_class,
!     pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
! WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
! SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
! WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
!  oid | mapped_oid | reltablespace | relfilenode | relname 
! -----+------------+---------------+-------------+---------
! (0 rows)
! 
! -- Checks on creating and manipulation of user defined relations in
! -- pg_catalog.
! --
! -- XXX: It would be useful to add checks around trying to manipulate
! -- catalog tables, but that might have ugly consequences when run
! -- against an existing server with allow_system_table_mods = on.
! SHOW allow_system_table_mods;
!  allow_system_table_mods 
! -------------------------
!  off
! (1 row)
! 
! -- disallowed because of search_path issues with pg_dump
! CREATE TABLE pg_catalog.new_system_table();
! ERROR:  permission denied to create "pg_catalog.new_system_table"
! DETAIL:  System catalog modifications are currently disallowed.
! -- instead create in public first, move to catalog
! CREATE TABLE new_system_table(id serial primary key, othercol text);
! ALTER TABLE new_system_table SET SCHEMA pg_catalog;
! -- XXX: it's currently impossible to move relations out of pg_catalog
! ALTER TABLE new_system_table SET SCHEMA public;
! ERROR:  cannot remove dependency on schema pg_catalog because it is a system object
! -- move back, will currently error out, already there
! ALTER TABLE new_system_table SET SCHEMA pg_catalog;
! ERROR:  table new_system_table is already in schema "pg_catalog"
! ALTER TABLE new_system_table RENAME TO old_system_table;
! CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
! INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
! UPDATE old_system_table SET id = -id;
! DELETE FROM old_system_table WHERE othercol = 'somedata';
! TRUNCATE old_system_table;
! ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
! ALTER TABLE old_system_table DROP COLUMN othercol;
! DROP TABLE old_system_table;
! -- set logged
! CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
! -- check relpersistence of an unlogged table
! SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
! UNION ALL
! SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
! UNION ALL
! SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
! ORDER BY relname;
!      relname      | relkind | relpersistence 
! ------------------+---------+----------------
!  toast index      | i       | u
!  toast table      | t       | u
!  unlogged1        | r       | u
!  unlogged1_f1_seq | S       | p
!  unlogged1_pkey   | i       | u
! (5 rows)
! 
! CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
! CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
! ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
! ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
! ERROR:  cannot change status of table unlogged2 to logged
! DETAIL:  Table unlogged2 references unlogged table unlogged1.
! ALTER TABLE unlogged1 SET LOGGED;
! -- check relpersistence of an unlogged table after changing to permament
! SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
! UNION ALL
! SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
! UNION ALL
! SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
! ORDER BY relname;
!      relname      | relkind | relpersistence 
! ------------------+---------+----------------
!  toast index      | i       | p
!  toast table      | t       | p
!  unlogged1        | r       | p
!  unlogged1_f1_seq | S       | p
!  unlogged1_pkey   | i       | p
! (5 rows)
! 
! ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
! DROP TABLE unlogged3;
! DROP TABLE unlogged2;
! DROP TABLE unlogged1;
! -- set unlogged
! CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
! -- check relpersistence of a permanent table
! SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
! UNION ALL
! SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
! UNION ALL
! SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
! ORDER BY relname;
!     relname     | relkind | relpersistence 
! ----------------+---------+----------------
!  logged1        | r       | p
!  logged1_f1_seq | S       | p
!  logged1_pkey   | i       | p
!  toast index    | i       | p
!  toast table    | t       | p
! (5 rows)
! 
! CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
! CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
! ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
! ERROR:  cannot change status of table logged1 to unlogged
! DETAIL:  Logged table logged2 is referenced by table logged1.
! ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
! ALTER TABLE logged2 SET UNLOGGED;
! ALTER TABLE logged1 SET UNLOGGED;
! -- check relpersistence of a permanent table after changing to unlogged
! SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
! UNION ALL
! SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
! UNION ALL
! SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
! ORDER BY relname;
!     relname     | relkind | relpersistence 
! ----------------+---------+----------------
!  logged1        | r       | u
!  logged1_f1_seq | S       | p
!  logged1_pkey   | i       | u
!  toast index    | i       | u
!  toast table    | t       | u
! (5 rows)
! 
! ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
! DROP TABLE logged3;
! DROP TABLE logged2;
! DROP TABLE logged1;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/sequence.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/sequence.out	2015-01-26 12:33:26.287031432 +0300
***************
*** 1,519 ****
! ---
! --- test creation of SERIAL column
! ---
! CREATE TABLE serialTest (f1 text, f2 serial);
! INSERT INTO serialTest VALUES ('foo');
! INSERT INTO serialTest VALUES ('bar');
! INSERT INTO serialTest VALUES ('force', 100);
! INSERT INTO serialTest VALUES ('wrong', NULL);
! ERROR:  null value in column "f2" violates not-null constraint
! DETAIL:  Failing row contains (wrong, null).
! SELECT * FROM serialTest;
!   f1   | f2  
! -------+-----
!  foo   |   1
!  bar   |   2
!  force | 100
! (3 rows)
! 
! -- test smallserial / bigserial
! CREATE TABLE serialTest2 (f1 text, f2 serial, f3 smallserial, f4 serial2,
!   f5 bigserial, f6 serial8);
! INSERT INTO serialTest2 (f1)
!   VALUES ('test_defaults');
! INSERT INTO serialTest2 (f1, f2, f3, f4, f5, f6)
!   VALUES ('test_max_vals', 2147483647, 32767, 32767, 9223372036854775807,
!           9223372036854775807),
!          ('test_min_vals', -2147483648, -32768, -32768, -9223372036854775808,
!           -9223372036854775808);
! -- All these INSERTs should fail:
! INSERT INTO serialTest2 (f1, f3)
!   VALUES ('bogus', -32769);
! ERROR:  smallint out of range
! INSERT INTO serialTest2 (f1, f4)
!   VALUES ('bogus', -32769);
! ERROR:  smallint out of range
! INSERT INTO serialTest2 (f1, f3)
!   VALUES ('bogus', 32768);
! ERROR:  smallint out of range
! INSERT INTO serialTest2 (f1, f4)
!   VALUES ('bogus', 32768);
! ERROR:  smallint out of range
! INSERT INTO serialTest2 (f1, f5)
!   VALUES ('bogus', -9223372036854775809);
! ERROR:  bigint out of range
! INSERT INTO serialTest2 (f1, f6)
!   VALUES ('bogus', -9223372036854775809);
! ERROR:  bigint out of range
! INSERT INTO serialTest2 (f1, f5)
!   VALUES ('bogus', 9223372036854775808);
! ERROR:  bigint out of range
! INSERT INTO serialTest2 (f1, f6)
!   VALUES ('bogus', 9223372036854775808);
! ERROR:  bigint out of range
! SELECT * FROM serialTest2 ORDER BY f2 ASC;
!       f1       |     f2      |   f3   |   f4   |          f5          |          f6          
! ---------------+-------------+--------+--------+----------------------+----------------------
!  test_min_vals | -2147483648 | -32768 | -32768 | -9223372036854775808 | -9223372036854775808
!  test_defaults |           1 |      1 |      1 |                    1 |                    1
!  test_max_vals |  2147483647 |  32767 |  32767 |  9223372036854775807 |  9223372036854775807
! (3 rows)
! 
! SELECT nextval('serialTest2_f2_seq');
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT nextval('serialTest2_f3_seq');
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT nextval('serialTest2_f4_seq');
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT nextval('serialTest2_f5_seq');
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT nextval('serialTest2_f6_seq');
!  nextval 
! ---------
!        2
! (1 row)
! 
! -- basic sequence operations using both text and oid references
! CREATE SEQUENCE sequence_test;
! CREATE SEQUENCE IF NOT EXISTS sequence_test;
! NOTICE:  relation "sequence_test" already exists, skipping
! SELECT nextval('sequence_test'::text);
!  nextval 
! ---------
!        1
! (1 row)
! 
! SELECT nextval('sequence_test'::regclass);
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT currval('sequence_test'::text);
!  currval 
! ---------
!        2
! (1 row)
! 
! SELECT currval('sequence_test'::regclass);
!  currval 
! ---------
!        2
! (1 row)
! 
! SELECT setval('sequence_test'::text, 32);
!  setval 
! --------
!      32
! (1 row)
! 
! SELECT nextval('sequence_test'::regclass);
!  nextval 
! ---------
!       33
! (1 row)
! 
! SELECT setval('sequence_test'::text, 99, false);
!  setval 
! --------
!      99
! (1 row)
! 
! SELECT nextval('sequence_test'::regclass);
!  nextval 
! ---------
!       99
! (1 row)
! 
! SELECT setval('sequence_test'::regclass, 32);
!  setval 
! --------
!      32
! (1 row)
! 
! SELECT nextval('sequence_test'::text);
!  nextval 
! ---------
!       33
! (1 row)
! 
! SELECT setval('sequence_test'::regclass, 99, false);
!  setval 
! --------
!      99
! (1 row)
! 
! SELECT nextval('sequence_test'::text);
!  nextval 
! ---------
!       99
! (1 row)
! 
! DISCARD SEQUENCES;
! SELECT currval('sequence_test'::regclass);
! ERROR:  currval of sequence "sequence_test" is not yet defined in this session
! DROP SEQUENCE sequence_test;
! -- renaming sequences
! CREATE SEQUENCE foo_seq;
! ALTER TABLE foo_seq RENAME TO foo_seq_new;
! SELECT * FROM foo_seq_new;
!  sequence_name | last_value | start_value | increment_by |      max_value      | min_value | cache_value | log_cnt | is_cycled | is_called 
! ---------------+------------+-------------+--------------+---------------------+-----------+-------------+---------+-----------+-----------
!  foo_seq       |          1 |           1 |            1 | 9223372036854775807 |         1 |           1 |       0 | f         | f
! (1 row)
! 
! SELECT nextval('foo_seq_new');
!  nextval 
! ---------
!        1
! (1 row)
! 
! SELECT nextval('foo_seq_new');
!  nextval 
! ---------
!        2
! (1 row)
! 
! SELECT * FROM foo_seq_new;
!  sequence_name | last_value | start_value | increment_by |      max_value      | min_value | cache_value | log_cnt | is_cycled | is_called 
! ---------------+------------+-------------+--------------+---------------------+-----------+-------------+---------+-----------+-----------
!  foo_seq       |          2 |           1 |            1 | 9223372036854775807 |         1 |           1 |      31 | f         | t
! (1 row)
! 
! DROP SEQUENCE foo_seq_new;
! -- renaming serial sequences
! ALTER TABLE serialtest_f2_seq RENAME TO serialtest_f2_foo;
! INSERT INTO serialTest VALUES ('more');
! SELECT * FROM serialTest;
!   f1   | f2  
! -------+-----
!  foo   |   1
!  bar   |   2
!  force | 100
!  more  |   3
! (4 rows)
! 
! --
! -- Check dependencies of serial and ordinary sequences
! --
! CREATE TEMP SEQUENCE myseq2;
! CREATE TEMP SEQUENCE myseq3;
! CREATE TEMP TABLE t1 (
!   f1 serial,
!   f2 int DEFAULT nextval('myseq2'),
!   f3 int DEFAULT nextval('myseq3'::text)
! );
! -- Both drops should fail, but with different error messages:
! DROP SEQUENCE t1_f1_seq;
! ERROR:  cannot drop sequence t1_f1_seq because other objects depend on it
! DETAIL:  default for table t1 column f1 depends on sequence t1_f1_seq
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP SEQUENCE myseq2;
! ERROR:  cannot drop sequence myseq2 because other objects depend on it
! DETAIL:  default for table t1 column f2 depends on sequence myseq2
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- This however will work:
! DROP SEQUENCE myseq3;
! DROP TABLE t1;
! -- Fails because no longer existent:
! DROP SEQUENCE t1_f1_seq;
! ERROR:  sequence "t1_f1_seq" does not exist
! -- Now OK:
! DROP SEQUENCE myseq2;
! --
! -- Alter sequence
! --
! ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 24
! 	 INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
! NOTICE:  relation "sequence_test2" does not exist, skipping
! CREATE SEQUENCE sequence_test2 START WITH 32;
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       32
! (1 row)
! 
! ALTER SEQUENCE sequence_test2 RESTART WITH 24
! 	 INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       24
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       28
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       32
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       36
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!        5
! (1 row)
! 
! ALTER SEQUENCE sequence_test2 RESTART;
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       32
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!       36
! (1 row)
! 
! SELECT nextval('sequence_test2');
!  nextval 
! ---------
!        5
! (1 row)
! 
! -- Information schema
! SELECT * FROM information_schema.sequences WHERE sequence_name IN
!   ('sequence_test2', 'serialtest2_f2_seq', 'serialtest2_f3_seq',
!    'serialtest2_f4_seq', 'serialtest2_f5_seq', 'serialtest2_f6_seq')
!   ORDER BY sequence_name ASC;
!  sequence_catalog | sequence_schema |   sequence_name    | data_type | numeric_precision | numeric_precision_radix | numeric_scale | start_value | minimum_value |    maximum_value    | increment | cycle_option 
! ------------------+-----------------+--------------------+-----------+-------------------+-------------------------+---------------+-------------+---------------+---------------------+-----------+--------------
!  regression       | public          | sequence_test2     | bigint    |                64 |                       2 |             0 | 32          | 5             | 36                  | 4         | YES
!  regression       | public          | serialtest2_f2_seq | bigint    |                64 |                       2 |             0 | 1           | 1             | 9223372036854775807 | 1         | NO
!  regression       | public          | serialtest2_f3_seq | bigint    |                64 |                       2 |             0 | 1           | 1             | 9223372036854775807 | 1         | NO
!  regression       | public          | serialtest2_f4_seq | bigint    |                64 |                       2 |             0 | 1           | 1             | 9223372036854775807 | 1         | NO
!  regression       | public          | serialtest2_f5_seq | bigint    |                64 |                       2 |             0 | 1           | 1             | 9223372036854775807 | 1         | NO
!  regression       | public          | serialtest2_f6_seq | bigint    |                64 |                       2 |             0 | 1           | 1             | 9223372036854775807 | 1         | NO
! (6 rows)
! 
! -- Test comments
! COMMENT ON SEQUENCE asdf IS 'won''t work';
! ERROR:  relation "asdf" does not exist
! COMMENT ON SEQUENCE sequence_test2 IS 'will work';
! COMMENT ON SEQUENCE sequence_test2 IS NULL;
! -- Test lastval()
! CREATE SEQUENCE seq;
! SELECT nextval('seq');
!  nextval 
! ---------
!        1
! (1 row)
! 
! SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
! SELECT setval('seq', 99);
!  setval 
! --------
!      99
! (1 row)
! 
! SELECT lastval();
!  lastval 
! ---------
!       99
! (1 row)
! 
! DISCARD SEQUENCES;
! SELECT lastval();
! ERROR:  lastval is not yet defined in this session
! CREATE SEQUENCE seq2;
! SELECT nextval('seq2');
!  nextval 
! ---------
!        1
! (1 row)
! 
! SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
! DROP SEQUENCE seq2;
! -- should fail
! SELECT lastval();
! ERROR:  lastval is not yet defined in this session
! CREATE USER seq_user;
! -- privileges tests
! -- nextval
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT SELECT ON seq3 TO seq_user;
! SELECT nextval('seq3');
! ERROR:  permission denied for sequence seq3
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT UPDATE ON seq3 TO seq_user;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT USAGE ON seq3 TO seq_user;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! -- currval
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT SELECT ON seq3 TO seq_user;
! SELECT currval('seq3');
!  currval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT UPDATE ON seq3 TO seq_user;
! SELECT currval('seq3');
! ERROR:  permission denied for sequence seq3
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT USAGE ON seq3 TO seq_user;
! SELECT currval('seq3');
!  currval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! -- lastval
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT SELECT ON seq3 TO seq_user;
! SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT UPDATE ON seq3 TO seq_user;
! SELECT lastval();
! ERROR:  permission denied for sequence seq3
! ROLLBACK;
! BEGIN;
! SET LOCAL SESSION AUTHORIZATION seq_user;
! CREATE SEQUENCE seq3;
! SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
! REVOKE ALL ON seq3 FROM seq_user;
! GRANT USAGE ON seq3 TO seq_user;
! SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
! ROLLBACK;
! -- Sequences should get wiped out as well:
! DROP TABLE serialTest, serialTest2;
! -- Make sure sequences are gone:
! SELECT * FROM information_schema.sequences WHERE sequence_name IN
!   ('sequence_test2', 'serialtest2_f2_seq', 'serialtest2_f3_seq',
!    'serialtest2_f4_seq', 'serialtest2_f5_seq', 'serialtest2_f6_seq')
!   ORDER BY sequence_name ASC;
!  sequence_catalog | sequence_schema | sequence_name  | data_type | numeric_precision | numeric_precision_radix | numeric_scale | start_value | minimum_value | maximum_value | increment | cycle_option 
! ------------------+-----------------+----------------+-----------+-------------------+-------------------------+---------------+-------------+---------------+---------------+-----------+--------------
!  regression       | public          | sequence_test2 | bigint    |                64 |                       2 |             0 | 32          | 5             | 36            | 4         | YES
! (1 row)
! 
! DROP USER seq_user;
! DROP SEQUENCE seq;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/polymorphism.out	2014-11-21 01:48:04.343425000 +0300
--- /home/orion/postgres/src/test/regress/results/polymorphism.out	2015-01-26 12:33:26.347031435 +0300
***************
*** 1,1391 ****
! -- Currently this tests polymorphic aggregates and indirectly does some
! -- testing of polymorphic SQL functions.  It ought to be extended.
! -- Tests for other features related to function-calling have snuck in, too.
! -- Legend:
! -----------
! -- A = type is ANY
! -- P = type is polymorphic
! -- N = type is non-polymorphic
! -- B = aggregate base type
! -- S = aggregate state type
! -- R = aggregate return type
! -- 1 = arg1 of a function
! -- 2 = arg2 of a function
! -- ag = aggregate
! -- tf = trans (state) function
! -- ff = final function
! -- rt = return type of a function
! -- -> = implies
! -- => = allowed
! -- !> = not allowed
! -- E  = exists
! -- NE = not-exists
! --
! -- Possible states:
! -- ----------------
! -- B = (A || P || N)
! --   when (B = A) -> (tf2 = NE)
! -- S = (P || N)
! -- ff = (E || NE)
! -- tf1 = (P || N)
! -- tf2 = (NE || P || N)
! -- R = (P || N)
! -- create functions for use as tf and ff with the needed combinations of
! -- argument polymorphism, but within the constraints of valid aggregate
! -- functions, i.e. tf arg1 and tf return type must match
! -- polymorphic single arg transfn
! CREATE FUNCTION stfp(anyarray) RETURNS anyarray AS
! 'select $1' LANGUAGE SQL;
! -- non-polymorphic single arg transfn
! CREATE FUNCTION stfnp(int[]) RETURNS int[] AS
! 'select $1' LANGUAGE SQL;
! -- dual polymorphic transfn
! CREATE FUNCTION tfp(anyarray,anyelement) RETURNS anyarray AS
! 'select $1 || $2' LANGUAGE SQL;
! -- dual non-polymorphic transfn
! CREATE FUNCTION tfnp(int[],int) RETURNS int[] AS
! 'select $1 || $2' LANGUAGE SQL;
! -- arg1 only polymorphic transfn
! CREATE FUNCTION tf1p(anyarray,int) RETURNS anyarray AS
! 'select $1' LANGUAGE SQL;
! -- arg2 only polymorphic transfn
! CREATE FUNCTION tf2p(int[],anyelement) RETURNS int[] AS
! 'select $1' LANGUAGE SQL;
! -- multi-arg polymorphic
! CREATE FUNCTION sum3(anyelement,anyelement,anyelement) returns anyelement AS
! 'select $1+$2+$3' language sql strict;
! -- finalfn polymorphic
! CREATE FUNCTION ffp(anyarray) RETURNS anyarray AS
! 'select $1' LANGUAGE SQL;
! -- finalfn non-polymorphic
! CREATE FUNCTION ffnp(int[]) returns int[] as
! 'select $1' LANGUAGE SQL;
! -- Try to cover all the possible states:
! --
! -- Note: in Cases 1 & 2, we are trying to return P. Therefore, if the transfn
! -- is stfnp, tfnp, or tf2p, we must use ffp as finalfn, because stfnp, tfnp,
! -- and tf2p do not return P. Conversely, in Cases 3 & 4, we are trying to
! -- return N. Therefore, if the transfn is stfp, tfp, or tf1p, we must use ffnp
! -- as finalfn, because stfp, tfp, and tf1p do not return N.
! --
! --     Case1 (R = P) && (B = A)
! --     ------------------------
! --     S    tf1
! --     -------
! --     N    N
! -- should CREATE
! CREATE AGGREGATE myaggp01a(*) (SFUNC = stfnp, STYPE = int4[],
!   FINALFUNC = ffp, INITCOND = '{}');
! --     P    N
! -- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
! CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --     N    P
! -- should CREATE
! CREATE AGGREGATE myaggp03a(*) (SFUNC = stfp, STYPE = int4[],
!   FINALFUNC = ffp, INITCOND = '{}');
! CREATE AGGREGATE myaggp03b(*) (SFUNC = stfp, STYPE = int4[],
!   INITCOND = '{}');
! --     P    P
! -- should ERROR: we have no way to resolve S
! CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    Case2 (R = P) && ((B = P) || (B = N))
! --    -------------------------------------
! --    S    tf1      B    tf2
! --    -----------------------
! --    N    N        N    N
! -- should CREATE
! CREATE AGGREGATE myaggp05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! --    N    N        N    P
! -- should CREATE
! CREATE AGGREGATE myaggp06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! --    N    N        P    N
! -- should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int)
! CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tfnp(integer[], anyelement) does not exist
! --    N    N        P    P
! -- should CREATE
! CREATE AGGREGATE myaggp08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! --    N    P        N    N
! -- should CREATE
! CREATE AGGREGATE myaggp09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! CREATE AGGREGATE myaggp09b(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
!   INITCOND = '{}');
! --    N    P        N    P
! -- should CREATE
! CREATE AGGREGATE myaggp10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! CREATE AGGREGATE myaggp10b(BASETYPE = int, SFUNC = tfp, STYPE = int[],
!   INITCOND = '{}');
! --    N    P        P    N
! -- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
! CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tf1p(integer[], anyelement) does not exist
! CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
!   INITCOND = '{}');
! ERROR:  function tf1p(integer[], anyelement) does not exist
! --    N    P        P    P
! -- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
! CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tfp(integer[], anyelement) does not exist
! CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
!   INITCOND = '{}');
! ERROR:  function tfp(integer[], anyelement) does not exist
! --    P    N        N    N
! -- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
! CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    N        N    P
! -- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
! CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    N        P    N
! -- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
! CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,
!   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tfnp(anyarray, anyelement) does not exist
! --    P    N        P    P
! -- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
! CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,
!   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tf2p(anyarray, anyelement) does not exist
! --    P    P        N    N
! -- should ERROR: we have no way to resolve S
! CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    P        N    P
! -- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
! CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
!   FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    P        P    N
! -- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
! CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,
!   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
! ERROR:  function tf1p(anyarray, anyelement) does not exist
! CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,
!   STYPE = anyarray, INITCOND = '{}');
! ERROR:  function tf1p(anyarray, anyelement) does not exist
! --    P    P        P    P
! -- should CREATE
! CREATE AGGREGATE myaggp20a(BASETYPE = anyelement, SFUNC = tfp,
!   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
! CREATE AGGREGATE myaggp20b(BASETYPE = anyelement, SFUNC = tfp,
!   STYPE = anyarray, INITCOND = '{}');
! --     Case3 (R = N) && (B = A)
! --     ------------------------
! --     S    tf1
! --     -------
! --     N    N
! -- should CREATE
! CREATE AGGREGATE myaggn01a(*) (SFUNC = stfnp, STYPE = int4[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! CREATE AGGREGATE myaggn01b(*) (SFUNC = stfnp, STYPE = int4[],
!   INITCOND = '{}');
! --     P    N
! -- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
! CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --     N    P
! -- should CREATE
! CREATE AGGREGATE myaggn03a(*) (SFUNC = stfp, STYPE = int4[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! --     P    P
! -- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
! CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    Case4 (R = N) && ((B = P) || (B = N))
! --    -------------------------------------
! --    S    tf1      B    tf2
! --    -----------------------
! --    N    N        N    N
! -- should CREATE
! CREATE AGGREGATE myaggn05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! CREATE AGGREGATE myaggn05b(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
!   INITCOND = '{}');
! --    N    N        N    P
! -- should CREATE
! CREATE AGGREGATE myaggn06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! CREATE AGGREGATE myaggn06b(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
!   INITCOND = '{}');
! --    N    N        P    N
! -- should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int)
! CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tfnp(integer[], anyelement) does not exist
! CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
!   INITCOND = '{}');
! ERROR:  function tfnp(integer[], anyelement) does not exist
! --    N    N        P    P
! -- should CREATE
! CREATE AGGREGATE myaggn08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! CREATE AGGREGATE myaggn08b(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
!   INITCOND = '{}');
! --    N    P        N    N
! -- should CREATE
! CREATE AGGREGATE myaggn09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! --    N    P        N    P
! -- should CREATE
! CREATE AGGREGATE myaggn10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! --    N    P        P    N
! -- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
! CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tf1p(integer[], anyelement) does not exist
! --    N    P        P    P
! -- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
! CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tfp(integer[], anyelement) does not exist
! --    P    N        N    N
! -- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
! CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    N        N    P
! -- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
! CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
!   INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    N        P    N
! -- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
! CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,
!   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tfnp(anyarray, anyelement) does not exist
! CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,
!   STYPE = anyarray, INITCOND = '{}');
! ERROR:  function tfnp(anyarray, anyelement) does not exist
! --    P    N        P    P
! -- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
! CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,
!   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tf2p(anyarray, anyelement) does not exist
! CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,
!   STYPE = anyarray, INITCOND = '{}');
! ERROR:  function tf2p(anyarray, anyelement) does not exist
! --    P    P        N    N
! -- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
! CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    P        N    P
! -- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
! CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
!   FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  cannot determine transition data type
! DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
! --    P    P        P    N
! -- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
! CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,
!   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function tf1p(anyarray, anyelement) does not exist
! --    P    P        P    P
! -- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
! CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,
!   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
! ERROR:  function ffnp(anyarray) does not exist
! -- multi-arg polymorphic
! CREATE AGGREGATE mysum2(anyelement,anyelement) (SFUNC = sum3,
!   STYPE = anyelement, INITCOND = '0');
! -- create test data for polymorphic aggregates
! create temp table t(f1 int, f2 int[], f3 text);
! insert into t values(1,array[1],'a');
! insert into t values(1,array[11],'b');
! insert into t values(1,array[111],'c');
! insert into t values(2,array[2],'a');
! insert into t values(2,array[22],'b');
! insert into t values(2,array[222],'c');
! insert into t values(3,array[3],'a');
! insert into t values(3,array[3],'b');
! -- test the successfully created polymorphic aggregates
! select f3, myaggp01a(*) from t group by f3 order by f3;
!  f3 | myaggp01a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp03a(*) from t group by f3 order by f3;
!  f3 | myaggp03a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp03b(*) from t group by f3 order by f3;
!  f3 | myaggp03b 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp05a(f1) from t group by f3 order by f3;
!  f3 | myaggp05a 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggp06a(f1) from t group by f3 order by f3;
!  f3 | myaggp06a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp08a(f1) from t group by f3 order by f3;
!  f3 | myaggp08a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp09a(f1) from t group by f3 order by f3;
!  f3 | myaggp09a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp09b(f1) from t group by f3 order by f3;
!  f3 | myaggp09b 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggp10a(f1) from t group by f3 order by f3;
!  f3 | myaggp10a 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggp10b(f1) from t group by f3 order by f3;
!  f3 | myaggp10b 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggp20a(f1) from t group by f3 order by f3;
!  f3 | myaggp20a 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggp20b(f1) from t group by f3 order by f3;
!  f3 | myaggp20b 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggn01a(*) from t group by f3 order by f3;
!  f3 | myaggn01a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn01b(*) from t group by f3 order by f3;
!  f3 | myaggn01b 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn03a(*) from t group by f3 order by f3;
!  f3 | myaggn03a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn05a(f1) from t group by f3 order by f3;
!  f3 | myaggn05a 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggn05b(f1) from t group by f3 order by f3;
!  f3 | myaggn05b 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select f3, myaggn06a(f1) from t group by f3 order by f3;
!  f3 | myaggn06a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn06b(f1) from t group by f3 order by f3;
!  f3 | myaggn06b 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn08a(f1) from t group by f3 order by f3;
!  f3 | myaggn08a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn08b(f1) from t group by f3 order by f3;
!  f3 | myaggn08b 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn09a(f1) from t group by f3 order by f3;
!  f3 | myaggn09a 
! ----+-----------
!  a  | {}
!  b  | {}
!  c  | {}
! (3 rows)
! 
! select f3, myaggn10a(f1) from t group by f3 order by f3;
!  f3 | myaggn10a 
! ----+-----------
!  a  | {1,2,3}
!  b  | {1,2,3}
!  c  | {1,2}
! (3 rows)
! 
! select mysum2(f1, f1 + 1) from t;
!  mysum2 
! --------
!      38
! (1 row)
! 
! -- test inlining of polymorphic SQL functions
! create function bleat(int) returns int as $$
! begin
!   raise notice 'bleat %', $1;
!   return $1;
! end$$ language plpgsql;
! create function sql_if(bool, anyelement, anyelement) returns anyelement as $$
! select case when $1 then $2 else $3 end $$ language sql;
! -- Note this would fail with integer overflow, never mind wrong bleat() output,
! -- if the CASE expression were not successfully inlined
! select f1, sql_if(f1 > 0, bleat(f1), bleat(f1 + 1)) from int4_tbl;
! NOTICE:  bleat 1
! NOTICE:  bleat 123456
! NOTICE:  bleat -123455
! NOTICE:  bleat 2147483647
! NOTICE:  bleat -2147483646
!      f1      |   sql_if    
! -------------+-------------
!            0 |           1
!       123456 |      123456
!      -123456 |     -123455
!   2147483647 |  2147483647
!  -2147483647 | -2147483646
! (5 rows)
! 
! select q2, sql_if(q2 > 0, q2, q2 + 1) from int8_tbl;
!         q2         |      sql_if       
! -------------------+-------------------
!                456 |               456
!   4567890123456789 |  4567890123456789
!                123 |               123
!   4567890123456789 |  4567890123456789
!  -4567890123456789 | -4567890123456788
! (5 rows)
! 
! -- another sort of polymorphic aggregate
! CREATE AGGREGATE array_cat_accum (anyarray)
! (
!     sfunc = array_cat,
!     stype = anyarray,
!     initcond = '{}'
! );
! SELECT array_cat_accum(i)
! FROM (VALUES (ARRAY[1,2]), (ARRAY[3,4])) as t(i);
!  array_cat_accum 
! -----------------
!  {1,2,3,4}
! (1 row)
! 
! SELECT array_cat_accum(i)
! FROM (VALUES (ARRAY[row(1,2),row(3,4)]), (ARRAY[row(5,6),row(7,8)])) as t(i);
!           array_cat_accum          
! -----------------------------------
!  {"(1,2)","(3,4)","(5,6)","(7,8)"}
! (1 row)
! 
! -- another kind of polymorphic aggregate
! create function add_group(grp anyarray, ad anyelement, size integer)
!   returns anyarray
!   as $$
! begin
!   if grp is null then
!     return array[ad];
!   end if;
!   if array_upper(grp, 1) < size then
!     return grp || ad;
!   end if;
!   return grp;
! end;
! $$
!   language plpgsql immutable;
! create aggregate build_group(anyelement, integer) (
!   SFUNC = add_group,
!   STYPE = anyarray
! );
! select build_group(q1,3) from int8_tbl;
!         build_group         
! ----------------------------
!  {123,123,4567890123456789}
! (1 row)
! 
! -- this should fail because stype isn't compatible with arg
! create aggregate build_group(int8, integer) (
!   SFUNC = add_group,
!   STYPE = int2[]
! );
! ERROR:  function add_group(smallint[], bigint, integer) does not exist
! -- but we can make a non-poly agg from a poly sfunc if types are OK
! create aggregate build_group(int8, integer) (
!   SFUNC = add_group,
!   STYPE = int8[]
! );
! -- check that we can apply functions taking ANYARRAY to pg_stats
! select distinct array_ndims(histogram_bounds) from pg_stats
! where histogram_bounds is not null;
!  array_ndims 
! -------------
!            1
! (1 row)
! 
! -- such functions must protect themselves if varying element type isn't OK
! -- (WHERE clause here is to avoid possibly getting a collation error instead)
! select max(histogram_bounds) from pg_stats where tablename = 'pg_am';
! ERROR:  cannot compare arrays of different element types
! -- test variadic polymorphic functions
! create function myleast(variadic anyarray) returns anyelement as $$
!   select min($1[i]) from generate_subscripts($1,1) g(i)
! $$ language sql immutable strict;
! select myleast(10, 1, 20, 33);
!  myleast 
! ---------
!        1
! (1 row)
! 
! select myleast(1.1, 0.22, 0.55);
!  myleast 
! ---------
!     0.22
! (1 row)
! 
! select myleast('z'::text);
!  myleast 
! ---------
!  z
! (1 row)
! 
! select myleast(); -- fail
! ERROR:  function myleast() does not exist
! LINE 1: select myleast();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! -- test with variadic call parameter
! select myleast(variadic array[1,2,3,4,-1]);
!  myleast 
! ---------
!       -1
! (1 row)
! 
! select myleast(variadic array[1.1, -5.5]);
!  myleast 
! ---------
!     -5.5
! (1 row)
! 
! --test with empty variadic call parameter
! select myleast(variadic array[]::int[]);
!  myleast 
! ---------
!         
! (1 row)
! 
! -- an example with some ordinary arguments too
! create function concat(text, variadic anyarray) returns text as $$
!   select array_to_string($2, $1);
! $$ language sql immutable strict;
! select concat('%', 1, 2, 3, 4, 5);
!   concat   
! -----------
!  1%2%3%4%5
! (1 row)
! 
! select concat('|', 'a'::text, 'b', 'c');
!  concat 
! --------
!  a|b|c
! (1 row)
! 
! select concat('|', variadic array[1,2,33]);
!  concat 
! --------
!  1|2|33
! (1 row)
! 
! select concat('|', variadic array[]::int[]);
!  concat 
! --------
!  
! (1 row)
! 
! drop function concat(text, anyarray);
! -- mix variadic with anyelement
! create function formarray(anyelement, variadic anyarray) returns anyarray as $$
!   select array_prepend($1, $2);
! $$ language sql immutable strict;
! select formarray(1,2,3,4,5);
!   formarray  
! -------------
!  {1,2,3,4,5}
! (1 row)
! 
! select formarray(1.1, variadic array[1.2,55.5]);
!    formarray    
! ----------------
!  {1.1,1.2,55.5}
! (1 row)
! 
! select formarray(1.1, array[1.2,55.5]); -- fail without variadic
! ERROR:  function formarray(numeric, numeric[]) does not exist
! LINE 1: select formarray(1.1, array[1.2,55.5]);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select formarray(1, 'x'::text); -- fail, type mismatch
! ERROR:  function formarray(integer, text) does not exist
! LINE 1: select formarray(1, 'x'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select formarray(1, variadic array['x'::text]); -- fail, type mismatch
! ERROR:  function formarray(integer, text[]) does not exist
! LINE 1: select formarray(1, variadic array['x'::text]);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! drop function formarray(anyelement, variadic anyarray);
! -- test pg_typeof() function
! select pg_typeof(null);           -- unknown
!  pg_typeof 
! -----------
!  unknown
! (1 row)
! 
! select pg_typeof(0);              -- integer
!  pg_typeof 
! -----------
!  integer
! (1 row)
! 
! select pg_typeof(0.0);            -- numeric
!  pg_typeof 
! -----------
!  numeric
! (1 row)
! 
! select pg_typeof(1+1 = 2);        -- boolean
!  pg_typeof 
! -----------
!  boolean
! (1 row)
! 
! select pg_typeof('x');            -- unknown
!  pg_typeof 
! -----------
!  unknown
! (1 row)
! 
! select pg_typeof('' || '');       -- text
!  pg_typeof 
! -----------
!  text
! (1 row)
! 
! select pg_typeof(pg_typeof(0));   -- regtype
!  pg_typeof 
! -----------
!  regtype
! (1 row)
! 
! select pg_typeof(array[1.2,55.5]); -- numeric[]
!  pg_typeof 
! -----------
!  numeric[]
! (1 row)
! 
! select pg_typeof(myleast(10, 1, 20, 33));  -- polymorphic input
!  pg_typeof 
! -----------
!  integer
! (1 row)
! 
! -- test functions with default parameters
! -- test basic functionality
! create function dfunc(a int = 1, int = 2) returns int as $$
!   select $1 + $2;
! $$ language sql;
! select dfunc();
!  dfunc 
! -------
!      3
! (1 row)
! 
! select dfunc(10);
!  dfunc 
! -------
!     12
! (1 row)
! 
! select dfunc(10, 20);
!  dfunc 
! -------
!     30
! (1 row)
! 
! select dfunc(10, 20, 30);  -- fail
! ERROR:  function dfunc(integer, integer, integer) does not exist
! LINE 1: select dfunc(10, 20, 30);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! drop function dfunc();  -- fail
! ERROR:  function dfunc() does not exist
! drop function dfunc(int);  -- fail
! ERROR:  function dfunc(integer) does not exist
! drop function dfunc(int, int);  -- ok
! -- fail: defaults must be at end of argument list
! create function dfunc(a int = 1, b int) returns int as $$
!   select $1 + $2;
! $$ language sql;
! ERROR:  input parameters after one with a default value must also have defaults
! -- however, this should work:
! create function dfunc(a int = 1, out sum int, b int = 2) as $$
!   select $1 + $2;
! $$ language sql;
! select dfunc();
!  dfunc 
! -------
!      3
! (1 row)
! 
! -- verify it lists properly
! \df dfunc
!                                            List of functions
!  Schema | Name  | Result data type |                    Argument data types                    |  Type  
! --------+-------+------------------+-----------------------------------------------------------+--------
!  public | dfunc | integer          | a integer DEFAULT 1, OUT sum integer, b integer DEFAULT 2 | normal
! (1 row)
! 
! drop function dfunc(int, int);
! -- check implicit coercion
! create function dfunc(a int DEFAULT 1.0, int DEFAULT '-1') returns int as $$
!   select $1 + $2;
! $$ language sql;
! select dfunc();
!  dfunc 
! -------
!      0
! (1 row)
! 
! create function dfunc(a text DEFAULT 'Hello', b text DEFAULT 'World') returns text as $$
!   select $1 || ', ' || $2;
! $$ language sql;
! select dfunc();  -- fail: which dfunc should be called? int or text
! ERROR:  function dfunc() is not unique
! LINE 1: select dfunc();
!                ^
! HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
! select dfunc('Hi');  -- ok
!    dfunc   
! -----------
!  Hi, World
! (1 row)
! 
! select dfunc('Hi', 'City');  -- ok
!   dfunc   
! ----------
!  Hi, City
! (1 row)
! 
! select dfunc(0);  -- ok
!  dfunc 
! -------
!     -1
! (1 row)
! 
! select dfunc(10, 20);  -- ok
!  dfunc 
! -------
!     30
! (1 row)
! 
! drop function dfunc(int, int);
! drop function dfunc(text, text);
! create function dfunc(int = 1, int = 2) returns int as $$
!   select 2;
! $$ language sql;
! create function dfunc(int = 1, int = 2, int = 3, int = 4) returns int as $$
!   select 4;
! $$ language sql;
! -- Now, dfunc(nargs = 2) and dfunc(nargs = 4) are ambiguous when called
! -- with 0 to 2 arguments.
! select dfunc();  -- fail
! ERROR:  function dfunc() is not unique
! LINE 1: select dfunc();
!                ^
! HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
! select dfunc(1);  -- fail
! ERROR:  function dfunc(integer) is not unique
! LINE 1: select dfunc(1);
!                ^
! HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
! select dfunc(1, 2);  -- fail
! ERROR:  function dfunc(integer, integer) is not unique
! LINE 1: select dfunc(1, 2);
!                ^
! HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
! select dfunc(1, 2, 3);  -- ok
!  dfunc 
! -------
!      4
! (1 row)
! 
! select dfunc(1, 2, 3, 4);  -- ok
!  dfunc 
! -------
!      4
! (1 row)
! 
! drop function dfunc(int, int);
! drop function dfunc(int, int, int, int);
! -- default values are not allowed for output parameters
! create function dfunc(out int = 20) returns int as $$
!   select 1;
! $$ language sql;
! ERROR:  only input parameters can have default values
! -- polymorphic parameter test
! create function dfunc(anyelement = 'World'::text) returns text as $$
!   select 'Hello, ' || $1::text;
! $$ language sql;
! select dfunc();
!     dfunc     
! --------------
!  Hello, World
! (1 row)
! 
! select dfunc(0);
!   dfunc   
! ----------
!  Hello, 0
! (1 row)
! 
! select dfunc(to_date('20081215','YYYYMMDD'));
!        dfunc       
! -------------------
!  Hello, 12-15-2008
! (1 row)
! 
! select dfunc('City'::text);
!     dfunc    
! -------------
!  Hello, City
! (1 row)
! 
! drop function dfunc(anyelement);
! -- check defaults for variadics
! create function dfunc(a variadic int[]) returns int as
! $$ select array_upper($1, 1) $$ language sql;
! select dfunc();  -- fail
! ERROR:  function dfunc() does not exist
! LINE 1: select dfunc();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select dfunc(10);
!  dfunc 
! -------
!      1
! (1 row)
! 
! select dfunc(10,20);
!  dfunc 
! -------
!      2
! (1 row)
! 
! create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as
! $$ select array_upper($1, 1) $$ language sql;
! select dfunc();  -- now ok
!  dfunc 
! -------
!       
! (1 row)
! 
! select dfunc(10);
!  dfunc 
! -------
!      1
! (1 row)
! 
! select dfunc(10,20);
!  dfunc 
! -------
!      2
! (1 row)
! 
! -- can't remove the default once it exists
! create or replace function dfunc(a variadic int[]) returns int as
! $$ select array_upper($1, 1) $$ language sql;
! ERROR:  cannot remove parameter defaults from existing function
! HINT:  Use DROP FUNCTION dfunc(integer[]) first.
! \df dfunc
!                                       List of functions
!  Schema | Name  | Result data type |               Argument data types               |  Type  
! --------+-------+------------------+-------------------------------------------------+--------
!  public | dfunc | integer          | VARIADIC a integer[] DEFAULT ARRAY[]::integer[] | normal
! (1 row)
! 
! drop function dfunc(a variadic int[]);
! -- Ambiguity should be reported only if there's not a better match available
! create function dfunc(int = 1, int = 2, int = 3) returns int as $$
!   select 3;
! $$ language sql;
! create function dfunc(int = 1, int = 2) returns int as $$
!   select 2;
! $$ language sql;
! create function dfunc(text) returns text as $$
!   select $1;
! $$ language sql;
! -- dfunc(narg=2) and dfunc(narg=3) are ambiguous
! select dfunc(1);  -- fail
! ERROR:  function dfunc(integer) is not unique
! LINE 1: select dfunc(1);
!                ^
! HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
! -- but this works since the ambiguous functions aren't preferred anyway
! select dfunc('Hi');
!  dfunc 
! -------
!  Hi
! (1 row)
! 
! drop function dfunc(int, int, int);
! drop function dfunc(int, int);
! drop function dfunc(text);
! --
! -- Tests for named- and mixed-notation function calling
! --
! create function dfunc(a int, b int, c int = 0, d int = 0)
!   returns table (a int, b int, c int, d int) as $$
!   select $1, $2, $3, $4;
! $$ language sql;
! select (dfunc(10,20,30)).*;
!  a  | b  | c  | d 
! ----+----+----+---
!  10 | 20 | 30 | 0
! (1 row)
! 
! select (dfunc(a := 10, b := 20, c := 30)).*;
!  a  | b  | c  | d 
! ----+----+----+---
!  10 | 20 | 30 | 0
! (1 row)
! 
! select * from dfunc(a := 10, b := 20);
!  a  | b  | c | d 
! ----+----+---+---
!  10 | 20 | 0 | 0
! (1 row)
! 
! select * from dfunc(b := 10, a := 20);
!  a  | b  | c | d 
! ----+----+---+---
!  20 | 10 | 0 | 0
! (1 row)
! 
! select * from dfunc(0);  -- fail
! ERROR:  function dfunc(integer) does not exist
! LINE 1: select * from dfunc(0);
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select * from dfunc(1,2);
!  a | b | c | d 
! ---+---+---+---
!  1 | 2 | 0 | 0
! (1 row)
! 
! select * from dfunc(1,2,c := 3);
!  a | b | c | d 
! ---+---+---+---
!  1 | 2 | 3 | 0
! (1 row)
! 
! select * from dfunc(1,2,d := 3);
!  a | b | c | d 
! ---+---+---+---
!  1 | 2 | 0 | 3
! (1 row)
! 
! select * from dfunc(x := 20, b := 10, x := 30);  -- fail, duplicate name
! ERROR:  argument name "x" used more than once
! LINE 1: select * from dfunc(x := 20, b := 10, x := 30);
!                                               ^
! select * from dfunc(10, b := 20, 30);  -- fail, named args must be last
! ERROR:  positional argument cannot follow named argument
! LINE 1: select * from dfunc(10, b := 20, 30);
!                                          ^
! select * from dfunc(x := 10, b := 20, c := 30);  -- fail, unknown param
! ERROR:  function dfunc(x := integer, b := integer, c := integer) does not exist
! LINE 1: select * from dfunc(x := 10, b := 20, c := 30);
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select * from dfunc(10, 10, a := 20);  -- fail, a overlaps positional parameter
! ERROR:  function dfunc(integer, integer, a := integer) does not exist
! LINE 1: select * from dfunc(10, 10, a := 20);
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select * from dfunc(1,c := 2,d := 3); -- fail, no value for b
! ERROR:  function dfunc(integer, c := integer, d := integer) does not exist
! LINE 1: select * from dfunc(1,c := 2,d := 3);
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! drop function dfunc(int, int, int, int);
! -- test with different parameter types
! create function dfunc(a varchar, b numeric, c date = current_date)
!   returns table (a varchar, b numeric, c date) as $$
!   select $1, $2, $3;
! $$ language sql;
! select (dfunc('Hello World', 20, '2009-07-25'::date)).*;
!       a      | b  |     c      
! -------------+----+------------
!  Hello World | 20 | 07-25-2009
! (1 row)
! 
! select * from dfunc('Hello World', 20, '2009-07-25'::date);
!       a      | b  |     c      
! -------------+----+------------
!  Hello World | 20 | 07-25-2009
! (1 row)
! 
! select * from dfunc(c := '2009-07-25'::date, a := 'Hello World', b := 20);
!       a      | b  |     c      
! -------------+----+------------
!  Hello World | 20 | 07-25-2009
! (1 row)
! 
! select * from dfunc('Hello World', b := 20, c := '2009-07-25'::date);
!       a      | b  |     c      
! -------------+----+------------
!  Hello World | 20 | 07-25-2009
! (1 row)
! 
! select * from dfunc('Hello World', c := '2009-07-25'::date, b := 20);
!       a      | b  |     c      
! -------------+----+------------
!  Hello World | 20 | 07-25-2009
! (1 row)
! 
! select * from dfunc('Hello World', c := 20, b := '2009-07-25'::date);  -- fail
! ERROR:  function dfunc(unknown, c := integer, b := date) does not exist
! LINE 1: select * from dfunc('Hello World', c := 20, b := '2009-07-25...
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! drop function dfunc(varchar, numeric, date);
! -- test out parameters with named params
! create function dfunc(a varchar = 'def a', out _a varchar, c numeric = NULL, out _c numeric)
! returns record as $$
!   select $1, $2;
! $$ language sql;
! select (dfunc()).*;
!   _a   | _c 
! -------+----
!  def a |   
! (1 row)
! 
! select * from dfunc();
!   _a   | _c 
! -------+----
!  def a |   
! (1 row)
! 
! select * from dfunc('Hello', 100);
!   _a   | _c  
! -------+-----
!  Hello | 100
! (1 row)
! 
! select * from dfunc(a := 'Hello', c := 100);
!   _a   | _c  
! -------+-----
!  Hello | 100
! (1 row)
! 
! select * from dfunc(c := 100, a := 'Hello');
!   _a   | _c  
! -------+-----
!  Hello | 100
! (1 row)
! 
! select * from dfunc('Hello');
!   _a   | _c 
! -------+----
!  Hello |   
! (1 row)
! 
! select * from dfunc('Hello', c := 100);
!   _a   | _c  
! -------+-----
!  Hello | 100
! (1 row)
! 
! select * from dfunc(c := 100);
!   _a   | _c  
! -------+-----
!  def a | 100
! (1 row)
! 
! -- fail, can no longer change an input parameter's name
! create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)
! returns record as $$
!   select $1, $2;
! $$ language sql;
! ERROR:  cannot change name of input parameter "c"
! HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
! create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)
! returns record as $$
!   select $1, $2;
! $$ language sql;
! ERROR:  cannot change name of input parameter "c"
! HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
! drop function dfunc(varchar, numeric);
! --fail, named parameters are not unique
! create function testfoo(a int, a int) returns int as $$ select 1;$$ language sql;
! ERROR:  parameter name "a" used more than once
! create function testfoo(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
! ERROR:  parameter name "a" used more than once
! create function testfoo(out a int, inout a int) returns int as $$ select 1;$$ language sql;
! ERROR:  parameter name "a" used more than once
! create function testfoo(a int, inout a int) returns int as $$ select 1;$$ language sql;
! ERROR:  parameter name "a" used more than once
! -- valid
! create function testfoo(a int, out a int) returns int as $$ select $1;$$ language sql;
! select testfoo(37);
!  testfoo 
! ---------
!       37
! (1 row)
! 
! drop function testfoo(int);
! create function testfoo(a int) returns table(a int) as $$ select $1;$$ language sql;
! select * from testfoo(37);
!  a  
! ----
!  37
! (1 row)
! 
! drop function testfoo(int);
! -- test polymorphic params and defaults
! create function dfunc(a anyelement, b anyelement = null, flag bool = true)
! returns anyelement as $$
!   select case when $3 then $1 else $2 end;
! $$ language sql;
! select dfunc(1,2);
!  dfunc 
! -------
!      1
! (1 row)
! 
! select dfunc('a'::text, 'b'); -- positional notation with default
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc(a := 1, b := 2);
!  dfunc 
! -------
!      1
! (1 row)
! 
! select dfunc(a := 'a'::text, b := 'b');
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc(a := 'a'::text, b := 'b', flag := false); -- named notation
!  dfunc 
! -------
!  b
! (1 row)
! 
! select dfunc(b := 'b'::text, a := 'a'); -- named notation with default
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc(a := 'a'::text, flag := true); -- named notation with default
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc(a := 'a'::text, flag := false); -- named notation with default
!  dfunc 
! -------
!  
! (1 row)
! 
! select dfunc(b := 'b'::text, a := 'a', flag := true); -- named notation
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc('a'::text, 'b', false); -- full positional notation
!  dfunc 
! -------
!  b
! (1 row)
! 
! select dfunc('a'::text, 'b', flag := false); -- mixed notation
!  dfunc 
! -------
!  b
! (1 row)
! 
! select dfunc('a'::text, 'b', true); -- full positional notation
!  dfunc 
! -------
!  a
! (1 row)
! 
! select dfunc('a'::text, 'b', flag := true); -- mixed notation
!  dfunc 
! -------
!  a
! (1 row)
! 
! -- check reverse-listing of named-arg calls
! CREATE VIEW dfview AS
!    SELECT q1, q2,
!      dfunc(q1,q2, flag := q1>q2) as c3,
!      dfunc(q1, flag := q1<q2, b := q2) as c4
!      FROM int8_tbl;
! select * from dfview;
!         q1        |        q2         |        c3        |        c4         
! ------------------+-------------------+------------------+-------------------
!               123 |               456 |              456 |               123
!               123 |  4567890123456789 | 4567890123456789 |               123
!  4567890123456789 |               123 | 4567890123456789 |               123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789
! (5 rows)
! 
! \d+ dfview
!                 View "public.dfview"
!  Column |  Type  | Modifiers | Storage | Description 
! --------+--------+-----------+---------+-------------
!  q1     | bigint |           | plain   | 
!  q2     | bigint |           | plain   | 
!  c3     | bigint |           | plain   | 
!  c4     | bigint |           | plain   | 
! View definition:
!  SELECT int8_tbl.q1,
!     int8_tbl.q2,
!     dfunc(int8_tbl.q1, int8_tbl.q2, flag := int8_tbl.q1 > int8_tbl.q2) AS c3,
!     dfunc(int8_tbl.q1, flag := int8_tbl.q1 < int8_tbl.q2, b := int8_tbl.q2) AS c4
!    FROM int8_tbl;
! 
! drop view dfview;
! drop function dfunc(anyelement, anyelement, bool);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/rowtypes.out	2014-11-21 01:48:04.355431000 +0300
--- /home/orion/postgres/src/test/regress/results/rowtypes.out	2015-01-26 12:33:26.339031435 +0300
***************
*** 1,636 ****
! --
! -- ROWTYPES
! --
! -- Make both a standalone composite type and a table rowtype
! create type complex as (r float8, i float8);
! create temp table fullname (first text, last text);
! -- Nested composite
! create type quad as (c1 complex, c2 complex);
! -- Some simple tests of I/O conversions and row construction
! select (1.1,2.2)::complex, row((3.3,4.4),(5.5,null))::quad;
!     row    |          row           
! -----------+------------------------
!  (1.1,2.2) | ("(3.3,4.4)","(5.5,)")
! (1 row)
! 
! select row('Joe', 'Blow')::fullname, '(Joe,Blow)'::fullname;
!     row     |  fullname  
! ------------+------------
!  (Joe,Blow) | (Joe,Blow)
! (1 row)
! 
! select '(Joe,von Blow)'::fullname, '(Joe,d''Blow)'::fullname;
!      fullname     |   fullname   
! ------------------+--------------
!  (Joe,"von Blow") | (Joe,d'Blow)
! (1 row)
! 
! select '(Joe,"von""Blow")'::fullname, E'(Joe,d\\\\Blow)'::fullname;
!      fullname      |    fullname     
! -------------------+-----------------
!  (Joe,"von""Blow") | (Joe,"d\\Blow")
! (1 row)
! 
! select '(Joe,"Blow,Jr")'::fullname;
!     fullname     
! -----------------
!  (Joe,"Blow,Jr")
! (1 row)
! 
! select '(Joe,)'::fullname;	-- ok, null 2nd column
!  fullname 
! ----------
!  (Joe,)
! (1 row)
! 
! select '(Joe)'::fullname;	-- bad
! ERROR:  malformed record literal: "(Joe)"
! LINE 1: select '(Joe)'::fullname;
!                ^
! DETAIL:  Too few columns.
! select '(Joe,,)'::fullname;	-- bad
! ERROR:  malformed record literal: "(Joe,,)"
! LINE 1: select '(Joe,,)'::fullname;
!                ^
! DETAIL:  Too many columns.
! create temp table quadtable(f1 int, q quad);
! insert into quadtable values (1, ((3.3,4.4),(5.5,6.6)));
! insert into quadtable values (2, ((null,4.4),(5.5,6.6)));
! select * from quadtable;
!  f1 |             q             
! ----+---------------------------
!   1 | ("(3.3,4.4)","(5.5,6.6)")
!   2 | ("(,4.4)","(5.5,6.6)")
! (2 rows)
! 
! select f1, q.c1 from quadtable;		-- fails, q is a table reference
! ERROR:  missing FROM-clause entry for table "q"
! LINE 1: select f1, q.c1 from quadtable;
!                    ^
! select f1, (q).c1, (qq.q).c1.i from quadtable qq;
!  f1 |    c1     |  i  
! ----+-----------+-----
!   1 | (3.3,4.4) | 4.4
!   2 | (,4.4)    | 4.4
! (2 rows)
! 
! create temp table people (fn fullname, bd date);
! insert into people values ('(Joe,Blow)', '1984-01-10');
! select * from people;
!      fn     |     bd     
! ------------+------------
!  (Joe,Blow) | 01-10-1984
! (1 row)
! 
! -- at the moment this will not work due to ALTER TABLE inadequacy:
! alter table fullname add column suffix text default '';
! ERROR:  cannot alter table "fullname" because column "people.fn" uses its row type
! -- but this should work:
! alter table fullname add column suffix text default null;
! select * from people;
!      fn      |     bd     
! -------------+------------
!  (Joe,Blow,) | 01-10-1984
! (1 row)
! 
! -- test insertion/updating of subfields
! update people set fn.suffix = 'Jr';
! select * from people;
!       fn       |     bd     
! ---------------+------------
!  (Joe,Blow,Jr) | 01-10-1984
! (1 row)
! 
! insert into quadtable (f1, q.c1.r, q.c2.i) values(44,55,66);
! select * from quadtable;
!  f1 |             q             
! ----+---------------------------
!   1 | ("(3.3,4.4)","(5.5,6.6)")
!   2 | ("(,4.4)","(5.5,6.6)")
!  44 | ("(55,)","(,66)")
! (3 rows)
! 
! -- The object here is to ensure that toasted references inside
! -- composite values don't cause problems.  The large f1 value will
! -- be toasted inside pp, it must still work after being copied to people.
! create temp table pp (f1 text);
! insert into pp values (repeat('abcdefghijkl', 100000));
! insert into people select ('Jim', f1, null)::fullname, current_date from pp;
! select (fn).first, substr((fn).last, 1, 20), length((fn).last) from people;
!  first |        substr        | length  
! -------+----------------------+---------
!  Joe   | Blow                 |       4
!  Jim   | abcdefghijklabcdefgh | 1200000
! (2 rows)
! 
! -- Test row comparison semantics.  Prior to PG 8.2 we did this in a totally
! -- non-spec-compliant way.
! select ROW(1,2) < ROW(1,3) as true;
!  true 
! ------
!  t
! (1 row)
! 
! select ROW(1,2) < ROW(1,1) as false;
!  false 
! -------
!  f
! (1 row)
! 
! select ROW(1,2) < ROW(1,NULL) as null;
!  null 
! ------
!  
! (1 row)
! 
! select ROW(1,2,3) < ROW(1,3,NULL) as true; -- the NULL is not examined
!  true 
! ------
!  t
! (1 row)
! 
! select ROW(11,'ABC') < ROW(11,'DEF') as true;
!  true 
! ------
!  t
! (1 row)
! 
! select ROW(11,'ABC') > ROW(11,'DEF') as false;
!  false 
! -------
!  f
! (1 row)
! 
! select ROW(12,'ABC') > ROW(11,'DEF') as true;
!  true 
! ------
!  t
! (1 row)
! 
! -- = and <> have different NULL-behavior than < etc
! select ROW(1,2,3) < ROW(1,NULL,4) as null;
!  null 
! ------
!  
! (1 row)
! 
! select ROW(1,2,3) = ROW(1,NULL,4) as false;
!  false 
! -------
!  f
! (1 row)
! 
! select ROW(1,2,3) <> ROW(1,NULL,4) as true;
!  true 
! ------
!  t
! (1 row)
! 
! -- We allow operators beyond the six standard ones, if they have btree
! -- operator classes.
! select ROW('ABC','DEF') ~<=~ ROW('DEF','ABC') as true;
!  true 
! ------
!  t
! (1 row)
! 
! select ROW('ABC','DEF') ~>=~ ROW('DEF','ABC') as false;
!  false 
! -------
!  f
! (1 row)
! 
! select ROW('ABC','DEF') ~~ ROW('DEF','ABC') as fail;
! ERROR:  could not determine interpretation of row comparison operator ~~
! LINE 1: select ROW('ABC','DEF') ~~ ROW('DEF','ABC') as fail;
!                                 ^
! HINT:  Row comparison operators must be associated with btree operator families.
! -- Comparisons of ROW() expressions can cope with some type mismatches
! select ROW(1,2) = ROW(1,2::int8);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select ROW(1,2) in (ROW(3,4), ROW(1,2));
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select ROW(1,2) in (ROW(3,4), ROW(1,2::int8));
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- Check row comparison with a subselect
! select unique1, unique2 from tenk1
! where (unique1, unique2) < any (select ten, ten from tenk1 where hundred < 3)
!       and unique1 <= 20
! order by 1;
!  unique1 | unique2 
! ---------+---------
!        0 |    9998
!        1 |    2838
! (2 rows)
! 
! -- Also check row comparison with an indexable condition
! explain (costs off)
! select thousand, tenthous from tenk1
! where (thousand, tenthous) >= (997, 5000)
! order by thousand, tenthous;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Index Only Scan using tenk1_thous_tenthous on tenk1
!    Index Cond: (ROW(thousand, tenthous) >= ROW(997, 5000))
! (2 rows)
! 
! select thousand, tenthous from tenk1
! where (thousand, tenthous) >= (997, 5000)
! order by thousand, tenthous;
!  thousand | tenthous 
! ----------+----------
!       997 |     5997
!       997 |     6997
!       997 |     7997
!       997 |     8997
!       997 |     9997
!       998 |      998
!       998 |     1998
!       998 |     2998
!       998 |     3998
!       998 |     4998
!       998 |     5998
!       998 |     6998
!       998 |     7998
!       998 |     8998
!       998 |     9998
!       999 |      999
!       999 |     1999
!       999 |     2999
!       999 |     3999
!       999 |     4999
!       999 |     5999
!       999 |     6999
!       999 |     7999
!       999 |     8999
!       999 |     9999
! (25 rows)
! 
! -- Check row comparisons with IN
! select * from int8_tbl i8 where i8 in (row(123,456));  -- fail, type mismatch
! ERROR:  cannot compare dissimilar column types bigint and integer at record column 1
! explain (costs off)
! select * from int8_tbl i8
! where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
!                                                  QUERY PLAN                                                  
! -------------------------------------------------------------------------------------------------------------
!  Seq Scan on int8_tbl i8
!    Filter: (i8.* = ANY (ARRAY[ROW(123::bigint, 456::bigint)::int8_tbl, '(4567890123456789,123)'::int8_tbl]))
! (2 rows)
! 
! select * from int8_tbl i8
! where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
!         q1        | q2  
! ------------------+-----
!               123 | 456
!  4567890123456789 | 123
! (2 rows)
! 
! -- Check some corner cases involving empty rowtypes
! select ROW();
!  row 
! -----
!  ()
! (1 row)
! 
! select ROW() IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select ROW() = ROW();
! ERROR:  cannot compare rows of zero length
! LINE 1: select ROW() = ROW();
!                      ^
! -- Check ability to create arrays of anonymous rowtypes
! select array[ row(1,2), row(3,4), row(5,6) ];
!            array           
! ---------------------------
!  {"(1,2)","(3,4)","(5,6)"}
! (1 row)
! 
! -- Check ability to compare an anonymous row to elements of an array
! select row(1,1.1) = any (array[ row(7,7.7), row(1,1.1), row(0,0.0) ]);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select row(1,1.1) = any (array[ row(7,7.7), row(1,1.0), row(0,0.0) ]);
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- Check behavior with a non-comparable rowtype
! create type cantcompare as (p point, r float8);
! create temp table cc (f1 cantcompare);
! insert into cc values('("(1,2)",3)');
! insert into cc values('("(4,5)",6)');
! select * from cc order by f1; -- fail, but should complain about cantcompare
! ERROR:  could not identify an ordering operator for type cantcompare
! LINE 1: select * from cc order by f1;
!                                   ^
! HINT:  Use an explicit ordering operator or modify the query.
! --
! -- Test case derived from bug #5716: check multiple uses of a rowtype result
! --
! BEGIN;
! CREATE TABLE price (
!     id SERIAL PRIMARY KEY,
!     active BOOLEAN NOT NULL,
!     price NUMERIC
! );
! CREATE TYPE price_input AS (
!     id INTEGER,
!     price NUMERIC
! );
! CREATE TYPE price_key AS (
!     id INTEGER
! );
! CREATE FUNCTION price_key_from_table(price) RETURNS price_key AS $$
!     SELECT $1.id
! $$ LANGUAGE SQL;
! CREATE FUNCTION price_key_from_input(price_input) RETURNS price_key AS $$
!     SELECT $1.id
! $$ LANGUAGE SQL;
! insert into price values (1,false,42), (10,false,100), (11,true,17.99);
! UPDATE price
!     SET active = true, price = input_prices.price
!     FROM unnest(ARRAY[(10, 123.00), (11, 99.99)]::price_input[]) input_prices
!     WHERE price_key_from_table(price.*) = price_key_from_input(input_prices.*);
! select * from price;
!  id | active | price  
! ----+--------+--------
!   1 | f      |     42
!  10 | t      | 123.00
!  11 | t      |  99.99
! (3 rows)
! 
! rollback;
! --
! -- Test case derived from bug #9085: check * qualification of composite
! -- parameters for SQL functions
! --
! create temp table compos (f1 int, f2 text);
! create function fcompos1(v compos) returns void as $$
! insert into compos values (v);  -- fail
! $$ language sql;
! ERROR:  column "f1" is of type integer but expression is of type compos
! LINE 2: insert into compos values (v);  -- fail
!                                    ^
! HINT:  You will need to rewrite or cast the expression.
! create function fcompos1(v compos) returns void as $$
! insert into compos values (v.*);
! $$ language sql;
! create function fcompos2(v compos) returns void as $$
! select fcompos1(v);
! $$ language sql;
! create function fcompos3(v compos) returns void as $$
! select fcompos1(fcompos3.v.*);
! $$ language sql;
! select fcompos1(row(1,'one'));
!  fcompos1 
! ----------
!  
! (1 row)
! 
! select fcompos2(row(2,'two'));
!  fcompos2 
! ----------
!  
! (1 row)
! 
! select fcompos3(row(3,'three'));
!  fcompos3 
! ----------
!  
! (1 row)
! 
! select * from compos;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! --
! -- We allow I/O conversion casts from composite types to strings to be
! -- invoked via cast syntax, but not functional syntax.  This is because
! -- the latter is too prone to be invoked unintentionally.
! --
! select cast (fullname as text) from fullname;
!  fullname 
! ----------
! (0 rows)
! 
! select fullname::text from fullname;
!  fullname 
! ----------
! (0 rows)
! 
! select text(fullname) from fullname;  -- error
! ERROR:  function text(fullname) does not exist
! LINE 1: select text(fullname) from fullname;
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select fullname.text from fullname;  -- error
! ERROR:  column fullname.text does not exist
! LINE 1: select fullname.text from fullname;
!                ^
! -- same, but RECORD instead of named composite type:
! select cast (row('Jim', 'Beam') as text);
!     row     
! ------------
!  (Jim,Beam)
! (1 row)
! 
! select (row('Jim', 'Beam'))::text;
!     row     
! ------------
!  (Jim,Beam)
! (1 row)
! 
! select text(row('Jim', 'Beam'));  -- error
! ERROR:  function text(record) does not exist
! LINE 1: select text(row('Jim', 'Beam'));
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! select (row('Jim', 'Beam')).text;  -- error
! ERROR:  could not identify column "text" in record data type
! LINE 1: select (row('Jim', 'Beam')).text;
!                 ^
! --
! -- Test that composite values are seen to have the correct column names
! -- (bug #11210 and other reports)
! --
! select row_to_json(i) from int8_tbl i;
!                   row_to_json                   
! ------------------------------------------------
!  {"q1":123,"q2":456}
!  {"q1":123,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":123}
!  {"q1":4567890123456789,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":-4567890123456789}
! (5 rows)
! 
! select row_to_json(i) from int8_tbl i(x,y);
!                  row_to_json                  
! ----------------------------------------------
!  {"x":123,"y":456}
!  {"x":123,"y":4567890123456789}
!  {"x":4567890123456789,"y":123}
!  {"x":4567890123456789,"y":4567890123456789}
!  {"x":4567890123456789,"y":-4567890123456789}
! (5 rows)
! 
! create temp view vv1 as select * from int8_tbl;
! select row_to_json(i) from vv1 i;
!                   row_to_json                   
! ------------------------------------------------
!  {"q1":123,"q2":456}
!  {"q1":123,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":123}
!  {"q1":4567890123456789,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":-4567890123456789}
! (5 rows)
! 
! select row_to_json(i) from vv1 i(x,y);
!                  row_to_json                  
! ----------------------------------------------
!  {"x":123,"y":456}
!  {"x":123,"y":4567890123456789}
!  {"x":4567890123456789,"y":123}
!  {"x":4567890123456789,"y":4567890123456789}
!  {"x":4567890123456789,"y":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1, q2 from int8_tbl) as ss;
!                   row_to_json                   
! ------------------------------------------------
!  {"q1":123,"q2":456}
!  {"q1":123,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":123}
!  {"q1":4567890123456789,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1, q2 from int8_tbl offset 0) as ss;
!                   row_to_json                   
! ------------------------------------------------
!  {"q1":123,"q2":456}
!  {"q1":123,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":123}
!  {"q1":4567890123456789,"q2":4567890123456789}
!  {"q1":4567890123456789,"q2":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1 as a, q2 as b from int8_tbl) as ss;
!                  row_to_json                  
! ----------------------------------------------
!  {"a":123,"b":456}
!  {"a":123,"b":4567890123456789}
!  {"a":4567890123456789,"b":123}
!  {"a":4567890123456789,"b":4567890123456789}
!  {"a":4567890123456789,"b":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1 as a, q2 as b from int8_tbl offset 0) as ss;
!                  row_to_json                  
! ----------------------------------------------
!  {"a":123,"b":456}
!  {"a":123,"b":4567890123456789}
!  {"a":4567890123456789,"b":123}
!  {"a":4567890123456789,"b":4567890123456789}
!  {"a":4567890123456789,"b":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1 as a, q2 as b from int8_tbl) as ss(x,y);
!                  row_to_json                  
! ----------------------------------------------
!  {"x":123,"y":456}
!  {"x":123,"y":4567890123456789}
!  {"x":4567890123456789,"y":123}
!  {"x":4567890123456789,"y":4567890123456789}
!  {"x":4567890123456789,"y":-4567890123456789}
! (5 rows)
! 
! select row_to_json(ss) from
!   (select q1 as a, q2 as b from int8_tbl offset 0) as ss(x,y);
!                  row_to_json                  
! ----------------------------------------------
!  {"x":123,"y":456}
!  {"x":123,"y":4567890123456789}
!  {"x":4567890123456789,"y":123}
!  {"x":4567890123456789,"y":4567890123456789}
!  {"x":4567890123456789,"y":-4567890123456789}
! (5 rows)
! 
! explain (costs off)
! select row_to_json(q) from
!   (select thousand, tenthous from tenk1
!    where thousand = 42 and tenthous < 2000 offset 0) q;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Subquery Scan on q
!    ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!          Index Cond: ((thousand = 42) AND (tenthous < 2000))
! (3 rows)
! 
! select row_to_json(q) from
!   (select thousand, tenthous from tenk1
!    where thousand = 42 and tenthous < 2000 offset 0) q;
!            row_to_json           
! ---------------------------------
!  {"thousand":42,"tenthous":42}
!  {"thousand":42,"tenthous":1042}
! (2 rows)
! 
! select row_to_json(q) from
!   (select thousand as x, tenthous as y from tenk1
!    where thousand = 42 and tenthous < 2000 offset 0) q;
!     row_to_json    
! -------------------
!  {"x":42,"y":42}
!  {"x":42,"y":1042}
! (2 rows)
! 
! select row_to_json(q) from
!   (select thousand as x, tenthous as y from tenk1
!    where thousand = 42 and tenthous < 2000 offset 0) q(a,b);
!     row_to_json    
! -------------------
!  {"a":42,"b":42}
!  {"a":42,"b":1042}
! (2 rows)
! 
! create temp table tt1 as select * from int8_tbl limit 2;
! create temp table tt2 () inherits(tt1);
! insert into tt2 values(0,0);
! select row_to_json(r) from (select q2,q1 from tt1 offset 0) r;
!            row_to_json            
! ----------------------------------
!  {"q2":456,"q1":123}
!  {"q2":4567890123456789,"q1":123}
!  {"q2":0,"q1":0}
! (3 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/returning.out	2014-11-21 01:48:04.351429000 +0300
--- /home/orion/postgres/src/test/regress/results/returning.out	2015-01-26 12:33:26.335031434 +0300
***************
*** 1,333 ****
! --
! -- Test INSERT/UPDATE/DELETE RETURNING
! --
! -- Simple cases
! CREATE TEMP TABLE foo (f1 serial, f2 text, f3 int default 42);
! INSERT INTO foo (f2,f3)
!   VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9)
!   RETURNING *, f1+f3 AS sum;
!  f1 |  f2  | f3 | sum 
! ----+------+----+-----
!   1 | test | 42 |  43
!   2 | More | 11 |  13
!   3 | MORE | 16 |  19
! (3 rows)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 
! ----+------+----
!   1 | test | 42
!   2 | More | 11
!   3 | MORE | 16
! (3 rows)
! 
! UPDATE foo SET f2 = lower(f2), f3 = DEFAULT RETURNING foo.*, f1+f3 AS sum13;
!  f1 |  f2  | f3 | sum13 
! ----+------+----+-------
!   1 | test | 42 |    43
!   2 | more | 42 |    44
!   3 | more | 42 |    45
! (3 rows)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 
! ----+------+----
!   1 | test | 42
!   2 | more | 42
!   3 | more | 42
! (3 rows)
! 
! DELETE FROM foo WHERE f1 > 2 RETURNING f3, f2, f1, least(f1,f3);
!  f3 |  f2  | f1 | least 
! ----+------+----+-------
!  42 | more |  3 |     3
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 
! ----+------+----
!   1 | test | 42
!   2 | more | 42
! (2 rows)
! 
! -- Subplans and initplans in the RETURNING list
! INSERT INTO foo SELECT f1+10, f2, f3+99 FROM foo
!   RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,
!     EXISTS(SELECT * FROM int4_tbl) AS initplan;
!  f1 |  f2  | f3  | subplan | initplan 
! ----+------+-----+---------+----------
!  11 | test | 141 | t       | t
!  12 | more | 141 | f       | t
! (2 rows)
! 
! UPDATE foo SET f3 = f3 * 2
!   WHERE f1 > 10
!   RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,
!     EXISTS(SELECT * FROM int4_tbl) AS initplan;
!  f1 |  f2  | f3  | subplan | initplan 
! ----+------+-----+---------+----------
!  11 | test | 282 | t       | t
!  12 | more | 282 | f       | t
! (2 rows)
! 
! DELETE FROM foo
!   WHERE f1 > 10
!   RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,
!     EXISTS(SELECT * FROM int4_tbl) AS initplan;
!  f1 |  f2  | f3  | subplan | initplan 
! ----+------+-----+---------+----------
!  11 | test | 282 | t       | t
!  12 | more | 282 | f       | t
! (2 rows)
! 
! -- Joins
! UPDATE foo SET f3 = f3*2
!   FROM int4_tbl i
!   WHERE foo.f1 + 123455 = i.f1
!   RETURNING foo.*, i.f1 as "i.f1";
!  f1 |  f2  | f3 |  i.f1  
! ----+------+----+--------
!   1 | test | 84 | 123456
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 
! ----+------+----
!   2 | more | 42
!   1 | test | 84
! (2 rows)
! 
! DELETE FROM foo
!   USING int4_tbl i
!   WHERE foo.f1 + 123455 = i.f1
!   RETURNING foo.*, i.f1 as "i.f1";
!  f1 |  f2  | f3 |  i.f1  
! ----+------+----+--------
!   1 | test | 84 | 123456
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 
! ----+------+----
!   2 | more | 42
! (1 row)
! 
! -- Check inheritance cases
! CREATE TEMP TABLE foochild (fc int) INHERITS (foo);
! INSERT INTO foochild VALUES(123,'child',999,-123);
! ALTER TABLE foo ADD COLUMN f4 int8 DEFAULT 99;
! SELECT * FROM foo;
!  f1  |  f2   | f3  | f4 
! -----+-------+-----+----
!    2 | more  |  42 | 99
!  123 | child | 999 | 99
! (2 rows)
! 
! SELECT * FROM foochild;
!  f1  |  f2   | f3  |  fc  | f4 
! -----+-------+-----+------+----
!  123 | child | 999 | -123 | 99
! (1 row)
! 
! UPDATE foo SET f4 = f4 + f3 WHERE f4 = 99 RETURNING *;
!  f1  |  f2   | f3  |  f4  
! -----+-------+-----+------
!    2 | more  |  42 |  141
!  123 | child | 999 | 1098
! (2 rows)
! 
! SELECT * FROM foo;
!  f1  |  f2   | f3  |  f4  
! -----+-------+-----+------
!    2 | more  |  42 |  141
!  123 | child | 999 | 1098
! (2 rows)
! 
! SELECT * FROM foochild;
!  f1  |  f2   | f3  |  fc  |  f4  
! -----+-------+-----+------+------
!  123 | child | 999 | -123 | 1098
! (1 row)
! 
! UPDATE foo SET f3 = f3*2
!   FROM int8_tbl i
!   WHERE foo.f1 = i.q2
!   RETURNING *;
!  f1  |  f2   |  f3  |  f4  |        q1        | q2  
! -----+-------+------+------+------------------+-----
!  123 | child | 1998 | 1098 | 4567890123456789 | 123
! (1 row)
! 
! SELECT * FROM foo;
!  f1  |  f2   |  f3  |  f4  
! -----+-------+------+------
!    2 | more  |   42 |  141
!  123 | child | 1998 | 1098
! (2 rows)
! 
! SELECT * FROM foochild;
!  f1  |  f2   |  f3  |  fc  |  f4  
! -----+-------+------+------+------
!  123 | child | 1998 | -123 | 1098
! (1 row)
! 
! DELETE FROM foo
!   USING int8_tbl i
!   WHERE foo.f1 = i.q2
!   RETURNING *;
!  f1  |  f2   |  f3  |  f4  |        q1        | q2  
! -----+-------+------+------+------------------+-----
!  123 | child | 1998 | 1098 | 4567890123456789 | 123
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 | f4  
! ----+------+----+-----
!   2 | more | 42 | 141
! (1 row)
! 
! SELECT * FROM foochild;
!  f1 | f2 | f3 | fc | f4 
! ----+----+----+----+----
! (0 rows)
! 
! DROP TABLE foochild;
! -- Rules and views
! CREATE TEMP VIEW voo AS SELECT f1, f2 FROM foo;
! CREATE RULE voo_i AS ON INSERT TO voo DO INSTEAD
!   INSERT INTO foo VALUES(new.*, 57);
! INSERT INTO voo VALUES(11,'zit');
! -- fails:
! INSERT INTO voo VALUES(12,'zoo') RETURNING *, f1*2;
! ERROR:  cannot perform INSERT RETURNING on relation "voo"
! HINT:  You need an unconditional ON INSERT DO INSTEAD rule with a RETURNING clause.
! -- fails, incompatible list:
! CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD
!   INSERT INTO foo VALUES(new.*, 57) RETURNING *;
! ERROR:  RETURNING list has too many entries
! CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD
!   INSERT INTO foo VALUES(new.*, 57) RETURNING f1, f2;
! -- should still work
! INSERT INTO voo VALUES(13,'zit2');
! -- works now
! INSERT INTO voo VALUES(14,'zoo2') RETURNING *;
!  f1 |  f2  
! ----+------
!  14 | zoo2
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 | f4  
! ----+------+----+-----
!   2 | more | 42 | 141
!  11 | zit  | 57 |  99
!  13 | zit2 | 57 |  99
!  14 | zoo2 | 57 |  99
! (4 rows)
! 
! SELECT * FROM voo;
!  f1 |  f2  
! ----+------
!   2 | more
!  11 | zit
!  13 | zit2
!  14 | zoo2
! (4 rows)
! 
! CREATE OR REPLACE RULE voo_u AS ON UPDATE TO voo DO INSTEAD
!   UPDATE foo SET f1 = new.f1, f2 = new.f2 WHERE f1 = old.f1
!   RETURNING f1, f2;
! update voo set f1 = f1 + 1 where f2 = 'zoo2';
! update voo set f1 = f1 + 1 where f2 = 'zoo2' RETURNING *, f1*2;
!  f1 |  f2  | ?column? 
! ----+------+----------
!  16 | zoo2 |       32
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 | f4  
! ----+------+----+-----
!   2 | more | 42 | 141
!  11 | zit  | 57 |  99
!  13 | zit2 | 57 |  99
!  16 | zoo2 | 57 |  99
! (4 rows)
! 
! SELECT * FROM voo;
!  f1 |  f2  
! ----+------
!   2 | more
!  11 | zit
!  13 | zit2
!  16 | zoo2
! (4 rows)
! 
! CREATE OR REPLACE RULE voo_d AS ON DELETE TO voo DO INSTEAD
!   DELETE FROM foo WHERE f1 = old.f1
!   RETURNING f1, f2;
! DELETE FROM foo WHERE f1 = 13;
! DELETE FROM foo WHERE f2 = 'zit' RETURNING *;
!  f1 | f2  | f3 | f4 
! ----+-----+----+----
!  11 | zit | 57 | 99
! (1 row)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 | f4  
! ----+------+----+-----
!   2 | more | 42 | 141
!  16 | zoo2 | 57 |  99
! (2 rows)
! 
! SELECT * FROM voo;
!  f1 |  f2  
! ----+------
!   2 | more
!  16 | zoo2
! (2 rows)
! 
! -- Try a join case
! CREATE TEMP TABLE joinme (f2j text, other int);
! INSERT INTO joinme VALUES('more', 12345);
! INSERT INTO joinme VALUES('zoo2', 54321);
! INSERT INTO joinme VALUES('other', 0);
! CREATE TEMP VIEW joinview AS
!   SELECT foo.*, other FROM foo JOIN joinme ON (f2 = f2j);
! SELECT * FROM joinview;
!  f1 |  f2  | f3 | f4  | other 
! ----+------+----+-----+-------
!   2 | more | 42 | 141 | 12345
!  16 | zoo2 | 57 |  99 | 54321
! (2 rows)
! 
! CREATE RULE joinview_u AS ON UPDATE TO joinview DO INSTEAD
!   UPDATE foo SET f1 = new.f1, f3 = new.f3
!     FROM joinme WHERE f2 = f2j AND f2 = old.f2
!     RETURNING foo.*, other;
! UPDATE joinview SET f1 = f1 + 1 WHERE f3 = 57 RETURNING *, other + 1;
!  f1 |  f2  | f3 | f4 | other | ?column? 
! ----+------+----+----+-------+----------
!  17 | zoo2 | 57 | 99 | 54321 |    54322
! (1 row)
! 
! SELECT * FROM joinview;
!  f1 |  f2  | f3 | f4  | other 
! ----+------+----+-----+-------
!   2 | more | 42 | 141 | 12345
!  17 | zoo2 | 57 |  99 | 54321
! (2 rows)
! 
! SELECT * FROM foo;
!  f1 |  f2  | f3 | f4  
! ----+------+----+-----
!   2 | more | 42 | 141
!  17 | zoo2 | 57 |  99
! (2 rows)
! 
! SELECT * FROM voo;
!  f1 |  f2  
! ----+------
!   2 | more
!  17 | zoo2
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/largeobject.out	2015-01-26 12:33:13.755030777 +0300
--- /home/orion/postgres/src/test/regress/results/largeobject.out	2015-01-26 12:33:26.347031435 +0300
***************
*** 1,473 ****
! --
! -- Test large object support
! --
! -- ensure consistent test output regardless of the default bytea format
! SET bytea_output TO escape;
! -- Load a file
! CREATE TABLE lotest_stash_values (loid oid, fd integer);
! -- lo_creat(mode integer) returns oid
! -- The mode arg to lo_creat is unused, some vestigal holdover from ancient times
! -- returns the large object id
! INSERT INTO lotest_stash_values (loid) SELECT lo_creat(42);
! -- Test ALTER LARGE OBJECT
! CREATE ROLE regresslo;
! DO $$
!   BEGIN
!     EXECUTE 'ALTER LARGE OBJECT ' || (select loid from lotest_stash_values)
! 		|| ' OWNER TO regresslo';
!   END
! $$;
! SELECT
! 	rol.rolname
! FROM
! 	lotest_stash_values s
! 	JOIN pg_largeobject_metadata lo ON s.loid = lo.oid
! 	JOIN pg_authid rol ON lo.lomowner = rol.oid;
!   rolname  
! -----------
!  regresslo
! (1 row)
! 
! -- NOTE: large objects require transactions
! BEGIN;
! -- lo_open(lobjId oid, mode integer) returns integer
! -- The mode parameter to lo_open uses two constants:
! --   INV_READ  = 0x20000
! --   INV_WRITE = 0x40000
! -- The return value is a file descriptor-like value which remains valid for the
! -- transaction.
! UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
! -- loread/lowrite names are wonky, different from other functions which are lo_*
! -- lowrite(fd integer, data bytea) returns integer
! -- the integer is the number of bytes written
! SELECT lowrite(fd, '
! I wandered lonely as a cloud
! That floats on high o''er vales and hills,
! When all at once I saw a crowd,
! A host, of golden daffodils;
! Beside the lake, beneath the trees,
! Fluttering and dancing in the breeze.
! 
! Continuous as the stars that shine
! And twinkle on the milky way,
! They stretched in never-ending line
! Along the margin of a bay:
! Ten thousand saw I at a glance,
! Tossing their heads in sprightly dance.
! 
! The waves beside them danced; but they
! Out-did the sparkling waves in glee:
! A poet could not but be gay,
! In such a jocund company:
! I gazed--and gazed--but little thought
! What wealth the show to me had brought:
! 
! For oft, when on my couch I lie
! In vacant or in pensive mood,
! They flash upon that inward eye
! Which is the bliss of solitude;
! And then my heart with pleasure fills,
! And dances with the daffodils.
! 
!          -- William Wordsworth
! ') FROM lotest_stash_values;
!  lowrite 
! ---------
!      848
! (1 row)
! 
! -- lo_close(fd integer) returns integer
! -- return value is 0 for success, or <0 for error (actually only -1, but...)
! SELECT lo_close(fd) FROM lotest_stash_values;
!  lo_close 
! ----------
!         0
! (1 row)
! 
! END;
! -- Copy to another large object.
! -- Note: we intentionally don't remove the object created here;
! -- it's left behind to help test pg_dump.
! SELECT lo_from_bytea(0, lo_get(loid)) AS newloid FROM lotest_stash_values
! \gset
! -- Ideally we'd put a comment on this object for pg_dump testing purposes.
! -- But since pg_upgrade fails to preserve large object comments, doing so
! -- would break pg_upgrade's regression test.
! -- COMMENT ON LARGE OBJECT :newloid IS 'I Wandered Lonely as a Cloud';
! -- Read out a portion
! BEGIN;
! UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
! -- lo_lseek(fd integer, offset integer, whence integer) returns integer
! -- offset is in bytes, whence is one of three values:
! --  SEEK_SET (= 0) meaning relative to beginning
! --  SEEK_CUR (= 1) meaning relative to current position
! --  SEEK_END (= 2) meaning relative to end (offset better be negative)
! -- returns current position in file
! SELECT lo_lseek(fd, 104, 0) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!       104
! (1 row)
! 
! -- loread/lowrite names are wonky, different from other functions which are lo_*
! -- loread(fd integer, len integer) returns bytea
! SELECT loread(fd, 28) FROM lotest_stash_values;
!             loread            
! ------------------------------
!  A host, of golden daffodils;
! (1 row)
! 
! SELECT lo_lseek(fd, -19, 1) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!       113
! (1 row)
! 
! SELECT lowrite(fd, 'n') FROM lotest_stash_values;
!  lowrite 
! ---------
!        1
! (1 row)
! 
! SELECT lo_tell(fd) FROM lotest_stash_values;
!  lo_tell 
! ---------
!      114
! (1 row)
! 
! SELECT lo_lseek(fd, -744, 2) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!       104
! (1 row)
! 
! SELECT loread(fd, 28) FROM lotest_stash_values;
!             loread            
! ------------------------------
!  A host, on golden daffodils;
! (1 row)
! 
! SELECT lo_close(fd) FROM lotest_stash_values;
!  lo_close 
! ----------
!         0
! (1 row)
! 
! END;
! -- Test resource management
! BEGIN;
! SELECT lo_open(loid, x'40000'::int) from lotest_stash_values;
!  lo_open 
! ---------
!        0
! (1 row)
! 
! ABORT;
! -- Test truncation.
! BEGIN;
! UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
! SELECT lo_truncate(fd, 11) FROM lotest_stash_values;
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! SELECT loread(fd, 15) FROM lotest_stash_values;
!      loread     
! ----------------
!  \012I wandered
! (1 row)
! 
! SELECT lo_truncate(fd, 10000) FROM lotest_stash_values;
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! SELECT loread(fd, 10) FROM lotest_stash_values;
!                   loread                  
! ------------------------------------------
!  \000\000\000\000\000\000\000\000\000\000
! (1 row)
! 
! SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!     10000
! (1 row)
! 
! SELECT lo_tell(fd) FROM lotest_stash_values;
!  lo_tell 
! ---------
!    10000
! (1 row)
! 
! SELECT lo_truncate(fd, 5000) FROM lotest_stash_values;
!  lo_truncate 
! -------------
!            0
! (1 row)
! 
! SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!      5000
! (1 row)
! 
! SELECT lo_tell(fd) FROM lotest_stash_values;
!  lo_tell 
! ---------
!     5000
! (1 row)
! 
! SELECT lo_close(fd) FROM lotest_stash_values;
!  lo_close 
! ----------
!         0
! (1 row)
! 
! END;
! -- Test 64-bit large object functions.
! BEGIN;
! UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
! SELECT lo_lseek64(fd, 4294967296, 0) FROM lotest_stash_values;
!  lo_lseek64 
! ------------
!  4294967296
! (1 row)
! 
! SELECT lowrite(fd, 'offset:4GB') FROM lotest_stash_values;
!  lowrite 
! ---------
!       10
! (1 row)
! 
! SELECT lo_tell64(fd) FROM lotest_stash_values;
!  lo_tell64  
! ------------
!  4294967306
! (1 row)
! 
! SELECT lo_lseek64(fd, -10, 1) FROM lotest_stash_values;
!  lo_lseek64 
! ------------
!  4294967296
! (1 row)
! 
! SELECT lo_tell64(fd) FROM lotest_stash_values;
!  lo_tell64  
! ------------
!  4294967296
! (1 row)
! 
! SELECT loread(fd, 10) FROM lotest_stash_values;
!    loread   
! ------------
!  offset:4GB
! (1 row)
! 
! SELECT lo_truncate64(fd, 5000000000) FROM lotest_stash_values;
!  lo_truncate64 
! ---------------
!              0
! (1 row)
! 
! SELECT lo_lseek64(fd, 0, 2) FROM lotest_stash_values;
!  lo_lseek64 
! ------------
!  5000000000
! (1 row)
! 
! SELECT lo_tell64(fd) FROM lotest_stash_values;
!  lo_tell64  
! ------------
!  5000000000
! (1 row)
! 
! SELECT lo_truncate64(fd, 3000000000) FROM lotest_stash_values;
!  lo_truncate64 
! ---------------
!              0
! (1 row)
! 
! SELECT lo_lseek64(fd, 0, 2) FROM lotest_stash_values;
!  lo_lseek64 
! ------------
!  3000000000
! (1 row)
! 
! SELECT lo_tell64(fd) FROM lotest_stash_values;
!  lo_tell64  
! ------------
!  3000000000
! (1 row)
! 
! SELECT lo_close(fd) FROM lotest_stash_values;
!  lo_close 
! ----------
!         0
! (1 row)
! 
! END;
! -- lo_unlink(lobjId oid) returns integer
! -- return value appears to always be 1
! SELECT lo_unlink(loid) from lotest_stash_values;
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! TRUNCATE lotest_stash_values;
! INSERT INTO lotest_stash_values (loid) SELECT lo_import('/home/orion/postgres/src/test/regress/data/tenk.data');
! BEGIN;
! UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
! -- verify length of large object
! SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!    670800
! (1 row)
! 
! -- with the default BLKSZ, LOBLKSZ = 2048, so this positions us for a block
! -- edge case
! SELECT lo_lseek(fd, 2030, 0) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!      2030
! (1 row)
! 
! -- this should get half of the value from page 0 and half from page 1 of the
! -- large object
! SELECT loread(fd, 36) FROM lotest_stash_values;
!                              loread                              
! -----------------------------------------------------------------
!  AAA\011FBAAAA\011VVVVxx\0122513\01132\0111\0111\0113\01113\0111
! (1 row)
! 
! SELECT lo_tell(fd) FROM lotest_stash_values;
!  lo_tell 
! ---------
!     2066
! (1 row)
! 
! SELECT lo_lseek(fd, -26, 1) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!      2040
! (1 row)
! 
! SELECT lowrite(fd, 'abcdefghijklmnop') FROM lotest_stash_values;
!  lowrite 
! ---------
!       16
! (1 row)
! 
! SELECT lo_lseek(fd, 2030, 0) FROM lotest_stash_values;
!  lo_lseek 
! ----------
!      2030
! (1 row)
! 
! SELECT loread(fd, 36) FROM lotest_stash_values;
!                        loread                        
! -----------------------------------------------------
!  AAA\011FBAAAAabcdefghijklmnop1\0111\0113\01113\0111
! (1 row)
! 
! SELECT lo_close(fd) FROM lotest_stash_values;
!  lo_close 
! ----------
!         0
! (1 row)
! 
! END;
! SELECT lo_export(loid, '/home/orion/postgres/src/test/regress/results/lotest.txt') FROM lotest_stash_values;
!  lo_export 
! -----------
!          1
! (1 row)
! 
! \lo_import 'results/lotest.txt'
! \set newloid :LASTOID
! -- just make sure \lo_export does not barf
! \lo_export :newloid 'results/lotest2.txt'
! -- This is a hack to test that export/import are reversible
! -- This uses knowledge about the inner workings of large object mechanism
! -- which should not be used outside it.  This makes it a HACK
! SELECT pageno, data FROM pg_largeobject WHERE loid = (SELECT loid from lotest_stash_values)
! EXCEPT
! SELECT pageno, data FROM pg_largeobject WHERE loid = :newloid;
!  pageno | data 
! --------+------
! (0 rows)
! 
! SELECT lo_unlink(loid) FROM lotest_stash_values;
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
! TRUNCATE lotest_stash_values;
! \lo_unlink :newloid
! \lo_import 'results/lotest.txt'
! \set newloid_1 :LASTOID
! SELECT lo_from_bytea(0, lo_get(:newloid_1)) AS newloid_2
! \gset
! SELECT md5(lo_get(:newloid_1)) = md5(lo_get(:newloid_2));
!  ?column? 
! ----------
!  t
! (1 row)
! 
! SELECT lo_get(:newloid_1, 0, 20);
!                   lo_get                   
! -------------------------------------------
!  8800\0110\0110\0110\0110\0110\0110\011800
! (1 row)
! 
! SELECT lo_get(:newloid_1, 10, 20);
!                   lo_get                   
! -------------------------------------------
!  \0110\0110\0110\011800\011800\0113800\011
! (1 row)
! 
! SELECT lo_put(:newloid_1, 5, decode('afafafaf', 'hex'));
!  lo_put 
! --------
!  
! (1 row)
! 
! SELECT lo_get(:newloid_1, 0, 20);
!                      lo_get                      
! -------------------------------------------------
!  8800\011\257\257\257\2570\0110\0110\0110\011800
! (1 row)
! 
! SELECT lo_put(:newloid_1, 4294967310, 'foo');
!  lo_put 
! --------
!  
! (1 row)
! 
! SELECT lo_get(:newloid_1);
! ERROR:  large object read request is too large
! SELECT lo_get(:newloid_1, 4294967294, 100);
!                                lo_get                                
! ---------------------------------------------------------------------
!  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000foo
! (1 row)
! 
! \lo_unlink :newloid_1
! \lo_unlink :newloid_2
! -- This object is left in the database for pg_dump test purposes
! SELECT lo_from_bytea(0, E'\\xdeadbeef') AS newloid
! \gset
! SET bytea_output TO hex;
! SELECT lo_get(:newloid);
!    lo_get   
! ------------
!  \xdeadbeef
! (1 row)
! 
! DROP TABLE lotest_stash_values;
! DROP ROLE regresslo;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/with.out	2014-11-21 01:48:04.363435000 +0300
--- /home/orion/postgres/src/test/regress/results/with.out	2015-01-26 12:33:26.347031435 +0300
***************
*** 1,2157 ****
! --
! -- Tests for common table expressions (WITH query, ... SELECT ...)
! --
! -- Basic WITH
! WITH q1(x,y) AS (SELECT 1,2)
! SELECT * FROM q1, q1 AS q2;
!  x | y | x | y 
! ---+---+---+---
!  1 | 2 | 1 | 2
! (1 row)
! 
! -- Multiple uses are evaluated only once
! SELECT count(*) FROM (
!   WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))
!     SELECT * FROM q1
!   UNION
!     SELECT * FROM q1
! ) ss;
!  count 
! -------
!      5
! (1 row)
! 
! -- WITH RECURSIVE
! -- sum of 1..100
! WITH RECURSIVE t(n) AS (
!     VALUES (1)
! UNION ALL
!     SELECT n+1 FROM t WHERE n < 100
! )
! SELECT sum(n) FROM t;
!  sum  
! ------
!  5050
! (1 row)
! 
! WITH RECURSIVE t(n) AS (
!     SELECT (VALUES(1))
! UNION ALL
!     SELECT n+1 FROM t WHERE n < 5
! )
! SELECT * FROM t;
!  n 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
! -- recursive view
! CREATE RECURSIVE VIEW nums (n) AS
!     VALUES (1)
! UNION ALL
!     SELECT n+1 FROM nums WHERE n < 5;
! SELECT * FROM nums;
!  n 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
! CREATE OR REPLACE RECURSIVE VIEW nums (n) AS
!     VALUES (1)
! UNION ALL
!     SELECT n+1 FROM nums WHERE n < 6;
! SELECT * FROM nums;
!  n 
! ---
!  1
!  2
!  3
!  4
!  5
!  6
! (6 rows)
! 
! -- This is an infinite loop with UNION ALL, but not with UNION
! WITH RECURSIVE t(n) AS (
!     SELECT 1
! UNION
!     SELECT 10-n FROM t)
! SELECT * FROM t;
!  n 
! ---
!  1
!  9
! (2 rows)
! 
! -- This'd be an infinite loop, but outside query reads only as much as needed
! WITH RECURSIVE t(n) AS (
!     VALUES (1)
! UNION ALL
!     SELECT n+1 FROM t)
! SELECT * FROM t LIMIT 10;
!  n  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (10 rows)
! 
! -- UNION case should have same property
! WITH RECURSIVE t(n) AS (
!     SELECT 1
! UNION
!     SELECT n+1 FROM t)
! SELECT * FROM t LIMIT 10;
!  n  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (10 rows)
! 
! -- Test behavior with an unknown-type literal in the WITH
! WITH q AS (SELECT 'foo' AS x)
! SELECT x, x IS OF (unknown) as is_unknown FROM q;
!   x  | is_unknown 
! -----+------------
!  foo | t
! (1 row)
! 
! WITH RECURSIVE t(n) AS (
!     SELECT 'foo'
! UNION ALL
!     SELECT n || ' bar' FROM t WHERE length(n) < 20
! )
! SELECT n, n IS OF (text) as is_text FROM t;
!             n            | is_text 
! -------------------------+---------
!  foo                     | t
!  foo bar                 | t
!  foo bar bar             | t
!  foo bar bar bar         | t
!  foo bar bar bar bar     | t
!  foo bar bar bar bar bar | t
! (6 rows)
! 
! --
! -- Some examples with a tree
! --
! -- department structure represented here is as follows:
! --
! -- ROOT-+->A-+->B-+->C
! --      |         |
! --      |         +->D-+->F
! --      +->E-+->G
! CREATE TEMP TABLE department (
! 	id INTEGER PRIMARY KEY,  -- department ID
! 	parent_department INTEGER REFERENCES department, -- upper department ID
! 	name TEXT -- department name
! );
! INSERT INTO department VALUES (0, NULL, 'ROOT');
! INSERT INTO department VALUES (1, 0, 'A');
! INSERT INTO department VALUES (2, 1, 'B');
! INSERT INTO department VALUES (3, 2, 'C');
! INSERT INTO department VALUES (4, 2, 'D');
! INSERT INTO department VALUES (5, 0, 'E');
! INSERT INTO department VALUES (6, 4, 'F');
! INSERT INTO department VALUES (7, 5, 'G');
! -- extract all departments under 'A'. Result should be A, B, C, D and F
! WITH RECURSIVE subdepartment AS
! (
! 	-- non recursive term
! 	SELECT name as root_name, * FROM department WHERE name = 'A'
! 	UNION ALL
! 	-- recursive term
! 	SELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd
! 		WHERE d.parent_department = sd.id
! )
! SELECT * FROM subdepartment ORDER BY name;
!  root_name | id | parent_department | name 
! -----------+----+-------------------+------
!  A         |  1 |                 0 | A
!  A         |  2 |                 1 | B
!  A         |  3 |                 2 | C
!  A         |  4 |                 2 | D
!  A         |  6 |                 4 | F
! (5 rows)
! 
! -- extract all departments under 'A' with "level" number
! WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
! (
! 	-- non recursive term
! 	SELECT 1, * FROM department WHERE name = 'A'
! 	UNION ALL
! 	-- recursive term
! 	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
! 		WHERE d.parent_department = sd.id
! )
! SELECT * FROM subdepartment ORDER BY name;
!  level | id | parent_department | name 
! -------+----+-------------------+------
!      1 |  1 |                 0 | A
!      2 |  2 |                 1 | B
!      3 |  3 |                 2 | C
!      3 |  4 |                 2 | D
!      4 |  6 |                 4 | F
! (5 rows)
! 
! -- extract all departments under 'A' with "level" number.
! -- Only shows level 2 or more
! WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
! (
! 	-- non recursive term
! 	SELECT 1, * FROM department WHERE name = 'A'
! 	UNION ALL
! 	-- recursive term
! 	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
! 		WHERE d.parent_department = sd.id
! )
! SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;
!  level | id | parent_department | name 
! -------+----+-------------------+------
!      2 |  2 |                 1 | B
!      3 |  3 |                 2 | C
!      3 |  4 |                 2 | D
!      4 |  6 |                 4 | F
! (4 rows)
! 
! -- "RECURSIVE" is ignored if the query has no self-reference
! WITH RECURSIVE subdepartment AS
! (
! 	-- note lack of recursive UNION structure
! 	SELECT * FROM department WHERE name = 'A'
! )
! SELECT * FROM subdepartment ORDER BY name;
!  id | parent_department | name 
! ----+-------------------+------
!   1 |                 0 | A
! (1 row)
! 
! -- inside subqueries
! SELECT count(*) FROM (
!     WITH RECURSIVE t(n) AS (
!         SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500
!     )
!     SELECT * FROM t) AS t WHERE n < (
!         SELECT count(*) FROM (
!             WITH RECURSIVE t(n) AS (
!                    SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100
!                 )
!             SELECT * FROM t WHERE n < 50000
!          ) AS t WHERE n < 100);
!  count 
! -------
!     98
! (1 row)
! 
! -- use same CTE twice at different subquery levels
! WITH q1(x,y) AS (
!     SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred
!   )
! SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);
!  count 
! -------
!     50
! (1 row)
! 
! -- via a VIEW
! CREATE TEMPORARY VIEW vsubdepartment AS
! 	WITH RECURSIVE subdepartment AS
! 	(
! 		 -- non recursive term
! 		SELECT * FROM department WHERE name = 'A'
! 		UNION ALL
! 		-- recursive term
! 		SELECT d.* FROM department AS d, subdepartment AS sd
! 			WHERE d.parent_department = sd.id
! 	)
! 	SELECT * FROM subdepartment;
! SELECT * FROM vsubdepartment ORDER BY name;
!  id | parent_department | name 
! ----+-------------------+------
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   6 |                 4 | F
! (5 rows)
! 
! -- Check reverse listing
! SELECT pg_get_viewdef('vsubdepartment'::regclass);
!                 pg_get_viewdef                 
! -----------------------------------------------
!   WITH RECURSIVE subdepartment AS (           +
!           SELECT department.id,               +
!              department.parent_department,    +
!              department.name                  +
!             FROM department                   +
!            WHERE (department.name = 'A'::text)+
!          UNION ALL                            +
!           SELECT d.id,                        +
!              d.parent_department,             +
!              d.name                           +
!             FROM department d,                +
!              subdepartment sd                 +
!            WHERE (d.parent_department = sd.id)+
!          )                                    +
!   SELECT subdepartment.id,                    +
!      subdepartment.parent_department,         +
!      subdepartment.name                       +
!     FROM subdepartment;
! (1 row)
! 
! SELECT pg_get_viewdef('vsubdepartment'::regclass, true);
!                pg_get_viewdef                
! ---------------------------------------------
!   WITH RECURSIVE subdepartment AS (         +
!           SELECT department.id,             +
!              department.parent_department,  +
!              department.name                +
!             FROM department                 +
!            WHERE department.name = 'A'::text+
!          UNION ALL                          +
!           SELECT d.id,                      +
!              d.parent_department,           +
!              d.name                         +
!             FROM department d,              +
!              subdepartment sd               +
!            WHERE d.parent_department = sd.id+
!          )                                  +
!   SELECT subdepartment.id,                  +
!      subdepartment.parent_department,       +
!      subdepartment.name                     +
!     FROM subdepartment;
! (1 row)
! 
! -- Another reverse-listing example
! CREATE VIEW sums_1_100 AS
! WITH RECURSIVE t(n) AS (
!     VALUES (1)
! UNION ALL
!     SELECT n+1 FROM t WHERE n < 100
! )
! SELECT sum(n) FROM t;
! \d+ sums_1_100
!               View "public.sums_1_100"
!  Column |  Type  | Modifiers | Storage | Description 
! --------+--------+-----------+---------+-------------
!  sum    | bigint |           | plain   | 
! View definition:
!  WITH RECURSIVE t(n) AS (
!          VALUES (1)
!         UNION ALL
!          SELECT t_1.n + 1
!            FROM t t_1
!           WHERE t_1.n < 100
!         )
!  SELECT sum(t.n) AS sum
!    FROM t;
! 
! -- corner case in which sub-WITH gets initialized first
! with recursive q as (
!       select * from department
!     union all
!       (with x as (select * from q)
!        select * from x)
!     )
! select * from q limit 24;
!  id | parent_department | name 
! ----+-------------------+------
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
! (24 rows)
! 
! with recursive q as (
!       select * from department
!     union all
!       (with recursive x as (
!            select * from department
!          union all
!            (select * from q union all select * from x)
!         )
!        select * from x)
!     )
! select * from q limit 32;
!  id | parent_department | name 
! ----+-------------------+------
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
!   0 |                   | ROOT
!   1 |                 0 | A
!   2 |                 1 | B
!   3 |                 2 | C
!   4 |                 2 | D
!   5 |                 0 | E
!   6 |                 4 | F
!   7 |                 5 | G
! (32 rows)
! 
! -- recursive term has sub-UNION
! WITH RECURSIVE t(i,j) AS (
! 	VALUES (1,2)
! 	UNION ALL
! 	SELECT t2.i, t.j+1 FROM
! 		(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2
! 		JOIN t ON (t2.i = t.i+1))
! 	SELECT * FROM t;
!  i | j 
! ---+---
!  1 | 2
!  2 | 3
!  3 | 4
! (3 rows)
! 
! --
! -- different tree example
! --
! CREATE TEMPORARY TABLE tree(
!     id INTEGER PRIMARY KEY,
!     parent_id INTEGER REFERENCES tree(id)
! );
! INSERT INTO tree
! VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),
!        (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);
! --
! -- get all paths from "second level" nodes to leaf nodes
! --
! WITH RECURSIVE t(id, path) AS (
!     VALUES(1,ARRAY[]::integer[])
! UNION ALL
!     SELECT tree.id, t.path || tree.id
!     FROM tree JOIN t ON (tree.parent_id = t.id)
! )
! SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON
! 	(t1.path[1] = t2.path[1] AND
! 	array_upper(t1.path,1) = 1 AND
! 	array_upper(t2.path,1) > 1)
! 	ORDER BY t1.id, t2.id;
!  id | path | id |    path     
! ----+------+----+-------------
!   2 | {2}  |  4 | {2,4}
!   2 | {2}  |  5 | {2,5}
!   2 | {2}  |  6 | {2,6}
!   2 | {2}  |  9 | {2,4,9}
!   2 | {2}  | 10 | {2,4,10}
!   2 | {2}  | 14 | {2,4,9,14}
!   3 | {3}  |  7 | {3,7}
!   3 | {3}  |  8 | {3,8}
!   3 | {3}  | 11 | {3,7,11}
!   3 | {3}  | 12 | {3,7,12}
!   3 | {3}  | 13 | {3,7,13}
!   3 | {3}  | 15 | {3,7,11,15}
!   3 | {3}  | 16 | {3,7,11,16}
! (13 rows)
! 
! -- just count 'em
! WITH RECURSIVE t(id, path) AS (
!     VALUES(1,ARRAY[]::integer[])
! UNION ALL
!     SELECT tree.id, t.path || tree.id
!     FROM tree JOIN t ON (tree.parent_id = t.id)
! )
! SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON
! 	(t1.path[1] = t2.path[1] AND
! 	array_upper(t1.path,1) = 1 AND
! 	array_upper(t2.path,1) > 1)
! 	GROUP BY t1.id
! 	ORDER BY t1.id;
!  id | count 
! ----+-------
!   2 |     6
!   3 |     7
! (2 rows)
! 
! -- this variant tickled a whole-row-variable bug in 8.4devel
! WITH RECURSIVE t(id, path) AS (
!     VALUES(1,ARRAY[]::integer[])
! UNION ALL
!     SELECT tree.id, t.path || tree.id
!     FROM tree JOIN t ON (tree.parent_id = t.id)
! )
! SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON
! (t1.id=t2.id);
!  id |    path     |         t2         
! ----+-------------+--------------------
!   1 | {}          | (1,{})
!   2 | {2}         | (2,{2})
!   3 | {3}         | (3,{3})
!   4 | {2,4}       | (4,"{2,4}")
!   5 | {2,5}       | (5,"{2,5}")
!   6 | {2,6}       | (6,"{2,6}")
!   7 | {3,7}       | (7,"{3,7}")
!   8 | {3,8}       | (8,"{3,8}")
!   9 | {2,4,9}     | (9,"{2,4,9}")
!  10 | {2,4,10}    | (10,"{2,4,10}")
!  11 | {3,7,11}    | (11,"{3,7,11}")
!  12 | {3,7,12}    | (12,"{3,7,12}")
!  13 | {3,7,13}    | (13,"{3,7,13}")
!  14 | {2,4,9,14}  | (14,"{2,4,9,14}")
!  15 | {3,7,11,15} | (15,"{3,7,11,15}")
!  16 | {3,7,11,16} | (16,"{3,7,11,16}")
! (16 rows)
! 
! --
! -- test cycle detection
! --
! create temp table graph( f int, t int, label text );
! insert into graph values
! 	(1, 2, 'arc 1 -> 2'),
! 	(1, 3, 'arc 1 -> 3'),
! 	(2, 3, 'arc 2 -> 3'),
! 	(1, 4, 'arc 1 -> 4'),
! 	(4, 5, 'arc 4 -> 5'),
! 	(5, 1, 'arc 5 -> 1');
! with recursive search_graph(f, t, label, path, cycle) as (
! 	select *, array[row(g.f, g.t)], false from graph g
! 	union all
! 	select g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)
! 	from graph g, search_graph sg
! 	where g.f = sg.t and not cycle
! )
! select * from search_graph;
!  f | t |   label    |                   path                    | cycle 
! ---+---+------------+-------------------------------------------+-------
!  1 | 2 | arc 1 -> 2 | {"(1,2)"}                                 | f
!  1 | 3 | arc 1 -> 3 | {"(1,3)"}                                 | f
!  2 | 3 | arc 2 -> 3 | {"(2,3)"}                                 | f
!  1 | 4 | arc 1 -> 4 | {"(1,4)"}                                 | f
!  4 | 5 | arc 4 -> 5 | {"(4,5)"}                                 | f
!  5 | 1 | arc 5 -> 1 | {"(5,1)"}                                 | f
!  1 | 2 | arc 1 -> 2 | {"(5,1)","(1,2)"}                         | f
!  1 | 3 | arc 1 -> 3 | {"(5,1)","(1,3)"}                         | f
!  1 | 4 | arc 1 -> 4 | {"(5,1)","(1,4)"}                         | f
!  2 | 3 | arc 2 -> 3 | {"(1,2)","(2,3)"}                         | f
!  4 | 5 | arc 4 -> 5 | {"(1,4)","(4,5)"}                         | f
!  5 | 1 | arc 5 -> 1 | {"(4,5)","(5,1)"}                         | f
!  1 | 2 | arc 1 -> 2 | {"(4,5)","(5,1)","(1,2)"}                 | f
!  1 | 3 | arc 1 -> 3 | {"(4,5)","(5,1)","(1,3)"}                 | f
!  1 | 4 | arc 1 -> 4 | {"(4,5)","(5,1)","(1,4)"}                 | f
!  2 | 3 | arc 2 -> 3 | {"(5,1)","(1,2)","(2,3)"}                 | f
!  4 | 5 | arc 4 -> 5 | {"(5,1)","(1,4)","(4,5)"}                 | f
!  5 | 1 | arc 5 -> 1 | {"(1,4)","(4,5)","(5,1)"}                 | f
!  1 | 2 | arc 1 -> 2 | {"(1,4)","(4,5)","(5,1)","(1,2)"}         | f
!  1 | 3 | arc 1 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,3)"}         | f
!  1 | 4 | arc 1 -> 4 | {"(1,4)","(4,5)","(5,1)","(1,4)"}         | t
!  2 | 3 | arc 2 -> 3 | {"(4,5)","(5,1)","(1,2)","(2,3)"}         | f
!  4 | 5 | arc 4 -> 5 | {"(4,5)","(5,1)","(1,4)","(4,5)"}         | t
!  5 | 1 | arc 5 -> 1 | {"(5,1)","(1,4)","(4,5)","(5,1)"}         | t
!  2 | 3 | arc 2 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"} | f
! (25 rows)
! 
! -- ordering by the path column has same effect as SEARCH DEPTH FIRST
! with recursive search_graph(f, t, label, path, cycle) as (
! 	select *, array[row(g.f, g.t)], false from graph g
! 	union all
! 	select g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)
! 	from graph g, search_graph sg
! 	where g.f = sg.t and not cycle
! )
! select * from search_graph order by path;
!  f | t |   label    |                   path                    | cycle 
! ---+---+------------+-------------------------------------------+-------
!  1 | 2 | arc 1 -> 2 | {"(1,2)"}                                 | f
!  2 | 3 | arc 2 -> 3 | {"(1,2)","(2,3)"}                         | f
!  1 | 3 | arc 1 -> 3 | {"(1,3)"}                                 | f
!  1 | 4 | arc 1 -> 4 | {"(1,4)"}                                 | f
!  4 | 5 | arc 4 -> 5 | {"(1,4)","(4,5)"}                         | f
!  5 | 1 | arc 5 -> 1 | {"(1,4)","(4,5)","(5,1)"}                 | f
!  1 | 2 | arc 1 -> 2 | {"(1,4)","(4,5)","(5,1)","(1,2)"}         | f
!  2 | 3 | arc 2 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"} | f
!  1 | 3 | arc 1 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,3)"}         | f
!  1 | 4 | arc 1 -> 4 | {"(1,4)","(4,5)","(5,1)","(1,4)"}         | t
!  2 | 3 | arc 2 -> 3 | {"(2,3)"}                                 | f
!  4 | 5 | arc 4 -> 5 | {"(4,5)"}                                 | f
!  5 | 1 | arc 5 -> 1 | {"(4,5)","(5,1)"}                         | f
!  1 | 2 | arc 1 -> 2 | {"(4,5)","(5,1)","(1,2)"}                 | f
!  2 | 3 | arc 2 -> 3 | {"(4,5)","(5,1)","(1,2)","(2,3)"}         | f
!  1 | 3 | arc 1 -> 3 | {"(4,5)","(5,1)","(1,3)"}                 | f
!  1 | 4 | arc 1 -> 4 | {"(4,5)","(5,1)","(1,4)"}                 | f
!  4 | 5 | arc 4 -> 5 | {"(4,5)","(5,1)","(1,4)","(4,5)"}         | t
!  5 | 1 | arc 5 -> 1 | {"(5,1)"}                                 | f
!  1 | 2 | arc 1 -> 2 | {"(5,1)","(1,2)"}                         | f
!  2 | 3 | arc 2 -> 3 | {"(5,1)","(1,2)","(2,3)"}                 | f
!  1 | 3 | arc 1 -> 3 | {"(5,1)","(1,3)"}                         | f
!  1 | 4 | arc 1 -> 4 | {"(5,1)","(1,4)"}                         | f
!  4 | 5 | arc 4 -> 5 | {"(5,1)","(1,4)","(4,5)"}                 | f
!  5 | 1 | arc 5 -> 1 | {"(5,1)","(1,4)","(4,5)","(5,1)"}         | t
! (25 rows)
! 
! --
! -- test multiple WITH queries
! --
! WITH RECURSIVE
!   y (id) AS (VALUES (1)),
!   x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)
! SELECT * FROM x;
!  id 
! ----
!   1
!   2
!   3
!   4
!   5
! (5 rows)
! 
! -- forward reference OK
! WITH RECURSIVE
!     x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),
!     y(id) AS (values (1))
!  SELECT * FROM x;
!  id 
! ----
!   1
!   2
!   3
!   4
!   5
! (5 rows)
! 
! WITH RECURSIVE
!    x(id) AS
!      (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
!    y(id) AS
!      (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)
!  SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
!  id | id 
! ----+----
!   1 |  1
!   2 |  2
!   3 |  3
!   4 |  4
!   5 |  5
!   6 |   
!   7 |   
!   8 |   
!   9 |   
!  10 |   
! (10 rows)
! 
! WITH RECURSIVE
!    x(id) AS
!      (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
!    y(id) AS
!      (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)
!  SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
!  id | id 
! ----+----
!   1 |  1
!   2 |  2
!   3 |  3
!   4 |  4
!   5 |  5
!   6 |   
! (6 rows)
! 
! WITH RECURSIVE
!    x(id) AS
!      (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
!    y(id) AS
!      (SELECT * FROM x UNION ALL SELECT * FROM x),
!    z(id) AS
!      (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)
!  SELECT * FROM z;
!  id 
! ----
!   1
!   2
!   3
!   2
!   3
!   4
!   3
!   4
!   5
!   4
!   5
!   6
!   5
!   6
!   7
!   6
!   7
!   8
!   7
!   8
!   9
!   8
!   9
!  10
!   9
!  10
!  10
! (27 rows)
! 
! WITH RECURSIVE
!    x(id) AS
!      (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
!    y(id) AS
!      (SELECT * FROM x UNION ALL SELECT * FROM x),
!    z(id) AS
!      (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)
!  SELECT * FROM z;
!  id 
! ----
!   1
!   2
!   3
!   1
!   2
!   3
!   2
!   3
!   4
!   2
!   3
!   4
!   3
!   4
!   5
!   3
!   4
!   5
!   4
!   5
!   6
!   4
!   5
!   6
!   5
!   6
!   7
!   5
!   6
!   7
!   6
!   7
!   8
!   6
!   7
!   8
!   7
!   8
!   9
!   7
!   8
!   9
!   8
!   9
!  10
!   8
!   9
!  10
!   9
!  10
!   9
!  10
!  10
!  10
! (54 rows)
! 
! --
! -- Test WITH attached to a data-modifying statement
! --
! CREATE TEMPORARY TABLE y (a INTEGER);
! INSERT INTO y SELECT generate_series(1, 10);
! WITH t AS (
! 	SELECT a FROM y
! )
! INSERT INTO y
! SELECT a+20 FROM t RETURNING *;
!  a  
! ----
!  21
!  22
!  23
!  24
!  25
!  26
!  27
!  28
!  29
!  30
! (10 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  21
!  22
!  23
!  24
!  25
!  26
!  27
!  28
!  29
!  30
! (20 rows)
! 
! WITH t AS (
! 	SELECT a FROM y
! )
! UPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;
!  a  
! ----
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
! (10 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
! (20 rows)
! 
! WITH RECURSIVE t(a) AS (
! 	SELECT 11
! 	UNION ALL
! 	SELECT a+1 FROM t WHERE a < 50
! )
! DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;
!  a  
! ----
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
! (10 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (10 rows)
! 
! DROP TABLE y;
! --
! -- error cases
! --
! -- INTERSECT
! WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)
! 	SELECT * FROM x;
! ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x...
!                        ^
! WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)
! 	SELECT * FROM x;
! ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FR...
!                        ^
! -- EXCEPT
! WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
! 	SELECT * FROM x;
! ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
!                        ^
! WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)
! 	SELECT * FROM x;
! ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM ...
!                        ^
! -- no non-recursive term
! WITH RECURSIVE x(n) AS (SELECT n FROM x)
! 	SELECT * FROM x;
! ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT n FROM x)
!                        ^
! -- recursive term in the left hand side (strictly speaking, should allow this)
! WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
! 	SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within its non-recursive term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
!                                               ^
! CREATE TEMPORARY TABLE y (a INTEGER);
! INSERT INTO y SELECT generate_series(1, 10);
! -- LEFT JOIN
! WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
! 	UNION ALL
! 	SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
! SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within an outer join
! LINE 3:  SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
!                                        ^
! -- RIGHT JOIN
! WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
! 	UNION ALL
! 	SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
! SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within an outer join
! LINE 3:  SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
!                            ^
! -- FULL JOIN
! WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
! 	UNION ALL
! 	SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
! SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within an outer join
! LINE 3:  SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
!                            ^
! -- subquery
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x
!                           WHERE n IN (SELECT * FROM x))
!   SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within a subquery
! LINE 2:                           WHERE n IN (SELECT * FROM x))
!                                                             ^
! -- aggregate functions
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)
!   SELECT * FROM x;
! ERROR:  aggregate functions are not allowed in a recursive query's recursive term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) F...
!                                                           ^
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)
!   SELECT * FROM x;
! ERROR:  aggregate functions are not allowed in a recursive query's recursive term
! LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FRO...
!                                                           ^
! -- ORDER BY
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
!   SELECT * FROM x;
! ERROR:  ORDER BY in a recursive query is not implemented
! LINE 1: ...VE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
!                                                                      ^
! -- LIMIT/OFFSET
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)
!   SELECT * FROM x;
! ERROR:  OFFSET in a recursive query is not implemented
! LINE 1: ... AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)
!                                                                      ^
! -- FOR UPDATE
! WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)
!   SELECT * FROM x;
! ERROR:  FOR UPDATE/SHARE in a recursive query is not implemented
! -- target list has a recursive query name
! WITH RECURSIVE x(id) AS (values (1)
!     UNION ALL
!     SELECT (SELECT * FROM x) FROM x WHERE id < 5
! ) SELECT * FROM x;
! ERROR:  recursive reference to query "x" must not appear within a subquery
! LINE 3:     SELECT (SELECT * FROM x) FROM x WHERE id < 5
!                                   ^
! -- mutual recursive query (not implemented)
! WITH RECURSIVE
!   x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),
!   y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)
! SELECT * FROM x;
! ERROR:  mutual recursion between WITH items is not implemented
! LINE 2:   x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id ...
!           ^
! -- non-linear recursion is not allowed
! WITH RECURSIVE foo(i) AS
!     (values (1)
!     UNION ALL
!        (SELECT i+1 FROM foo WHERE i < 10
!           UNION ALL
!        SELECT i+1 FROM foo WHERE i < 5)
! ) SELECT * FROM foo;
! ERROR:  recursive reference to query "foo" must not appear more than once
! LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
!                                ^
! WITH RECURSIVE foo(i) AS
!     (values (1)
!     UNION ALL
! 	   SELECT * FROM
!        (SELECT i+1 FROM foo WHERE i < 10
!           UNION ALL
!        SELECT i+1 FROM foo WHERE i < 5) AS t
! ) SELECT * FROM foo;
! ERROR:  recursive reference to query "foo" must not appear more than once
! LINE 7:        SELECT i+1 FROM foo WHERE i < 5) AS t
!                                ^
! WITH RECURSIVE foo(i) AS
!     (values (1)
!     UNION ALL
!        (SELECT i+1 FROM foo WHERE i < 10
!           EXCEPT
!        SELECT i+1 FROM foo WHERE i < 5)
! ) SELECT * FROM foo;
! ERROR:  recursive reference to query "foo" must not appear within EXCEPT
! LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
!                                ^
! WITH RECURSIVE foo(i) AS
!     (values (1)
!     UNION ALL
!        (SELECT i+1 FROM foo WHERE i < 10
!           INTERSECT
!        SELECT i+1 FROM foo WHERE i < 5)
! ) SELECT * FROM foo;
! ERROR:  recursive reference to query "foo" must not appear more than once
! LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
!                                ^
! -- Wrong type induced from non-recursive term
! WITH RECURSIVE foo(i) AS
!    (SELECT i FROM (VALUES(1),(2)) t(i)
!    UNION ALL
!    SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
! SELECT * FROM foo;
! ERROR:  recursive query "foo" column 1 has type integer in non-recursive term but type numeric overall
! LINE 2:    (SELECT i FROM (VALUES(1),(2)) t(i)
!                    ^
! HINT:  Cast the output of the non-recursive term to the correct type.
! -- rejects different typmod, too (should we allow this?)
! WITH RECURSIVE foo(i) AS
!    (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)
!    UNION ALL
!    SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
! SELECT * FROM foo;
! ERROR:  recursive query "foo" column 1 has type numeric(3,0) in non-recursive term but type numeric overall
! LINE 2:    (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)
!                    ^
! HINT:  Cast the output of the non-recursive term to the correct type.
! -- disallow OLD/NEW reference in CTE
! CREATE TEMPORARY TABLE x (n integer);
! CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD
!     WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;
! ERROR:  cannot refer to OLD within WITH query
! --
! -- test for bug #4902
! --
! with cte(foo) as ( values(42) ) values((select foo from cte));
!  column1 
! ---------
!       42
! (1 row)
! 
! with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q;
!  foo 
! -----
!   42
! (1 row)
! 
! -- test CTE referencing an outer-level variable (to see that changed-parameter
! -- signaling still works properly after fixing this bug)
! select ( with cte(foo) as ( values(f1) )
!          select (select foo from cte) )
! from int4_tbl;
!      foo     
! -------------
!            0
!       123456
!      -123456
!   2147483647
!  -2147483647
! (5 rows)
! 
! select ( with cte(foo) as ( values(f1) )
!           values((select foo from cte)) )
! from int4_tbl;
!    column1   
! -------------
!            0
!       123456
!      -123456
!   2147483647
!  -2147483647
! (5 rows)
! 
! --
! -- test for nested-recursive-WITH bug
! --
! WITH RECURSIVE t(j) AS (
!     WITH RECURSIVE s(i) AS (
!         VALUES (1)
!         UNION ALL
!         SELECT i+1 FROM s WHERE i < 10
!     )
!     SELECT i FROM s
!     UNION ALL
!     SELECT j+1 FROM t WHERE j < 10
! )
! SELECT * FROM t;
!  j  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!   5
!   6
!   7
!   8
!   9
!  10
!   6
!   7
!   8
!   9
!  10
!   7
!   8
!   9
!  10
!   8
!   9
!  10
!   9
!  10
!  10
! (55 rows)
! 
! --
! -- test WITH attached to intermediate-level set operation
! --
! WITH outermost(x) AS (
!   SELECT 1
!   UNION (WITH innermost as (SELECT 2)
!          SELECT * FROM innermost
!          UNION SELECT 3)
! )
! SELECT * FROM outermost;
!  x 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! WITH outermost(x) AS (
!   SELECT 1
!   UNION (WITH innermost as (SELECT 2)
!          SELECT * FROM outermost  -- fail
!          UNION SELECT * FROM innermost)
! )
! SELECT * FROM outermost;
! ERROR:  relation "outermost" does not exist
! LINE 4:          SELECT * FROM outermost  
!                                ^
! DETAIL:  There is a WITH item named "outermost", but it cannot be referenced from this part of the query.
! HINT:  Use WITH RECURSIVE, or re-order the WITH items to remove forward references.
! WITH RECURSIVE outermost(x) AS (
!   SELECT 1
!   UNION (WITH innermost as (SELECT 2)
!          SELECT * FROM outermost
!          UNION SELECT * FROM innermost)
! )
! SELECT * FROM outermost;
!  x 
! ---
!  1
!  2
! (2 rows)
! 
! WITH RECURSIVE outermost(x) AS (
!   WITH innermost as (SELECT 2 FROM outermost) -- fail
!     SELECT * FROM innermost
!     UNION SELECT * from outermost
! )
! SELECT * FROM outermost;
! ERROR:  recursive reference to query "outermost" must not appear within a subquery
! LINE 2:   WITH innermost as (SELECT 2 FROM outermost) 
!                                            ^
! --
! -- This test will fail with the old implementation of PARAM_EXEC parameter
! -- assignment, because the "q1" Var passed down to A's targetlist subselect
! -- looks exactly like the "A.id" Var passed down to C's subselect, causing
! -- the old code to give them the same runtime PARAM_EXEC slot.  But the
! -- lifespans of the two parameters overlap, thanks to B also reading A.
! --
! with
! A as ( select q2 as id, (select q1) as x from int8_tbl ),
! B as ( select id, row_number() over (partition by id) as r from A ),
! C as ( select A.id, array(select B.id from B where B.id = A.id) from A )
! select * from C;
!         id         |                array                
! -------------------+-------------------------------------
!                456 | {456}
!   4567890123456789 | {4567890123456789,4567890123456789}
!                123 | {123}
!   4567890123456789 | {4567890123456789,4567890123456789}
!  -4567890123456789 | {-4567890123456789}
! (5 rows)
! 
! --
! -- Test CTEs read in non-initialization orders
! --
! WITH RECURSIVE
!   tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
!   iter (id_key, row_type, link) AS (
!       SELECT 0, 'base', 17
!     UNION ALL (
!       WITH remaining(id_key, row_type, link, min) AS (
!         SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()
!         FROM tab INNER JOIN iter USING (link)
!         WHERE tab.id_key > iter.id_key
!       ),
!       first_remaining AS (
!         SELECT id_key, row_type, link
!         FROM remaining
!         WHERE id_key=min
!       ),
!       effect AS (
!         SELECT tab.id_key, 'new'::text, tab.link
!         FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
!         WHERE e.row_type = 'false'
!       )
!       SELECT * FROM first_remaining
!       UNION ALL SELECT * FROM effect
!     )
!   )
! SELECT * FROM iter;
!  id_key | row_type | link 
! --------+----------+------
!       0 | base     |   17
!       1 | true     |   17
!       2 | true     |   17
!       3 | true     |   17
!       4 | true     |   17
!       5 | true     |   17
!       6 | true     |   17
! (7 rows)
! 
! WITH RECURSIVE
!   tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
!   iter (id_key, row_type, link) AS (
!       SELECT 0, 'base', 17
!     UNION (
!       WITH remaining(id_key, row_type, link, min) AS (
!         SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()
!         FROM tab INNER JOIN iter USING (link)
!         WHERE tab.id_key > iter.id_key
!       ),
!       first_remaining AS (
!         SELECT id_key, row_type, link
!         FROM remaining
!         WHERE id_key=min
!       ),
!       effect AS (
!         SELECT tab.id_key, 'new'::text, tab.link
!         FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
!         WHERE e.row_type = 'false'
!       )
!       SELECT * FROM first_remaining
!       UNION ALL SELECT * FROM effect
!     )
!   )
! SELECT * FROM iter;
!  id_key | row_type | link 
! --------+----------+------
!       0 | base     |   17
!       1 | true     |   17
!       2 | true     |   17
!       3 | true     |   17
!       4 | true     |   17
!       5 | true     |   17
!       6 | true     |   17
! (7 rows)
! 
! --
! -- Data-modifying statements in WITH
! --
! -- INSERT ... RETURNING
! WITH t AS (
!     INSERT INTO y
!     VALUES
!         (11),
!         (12),
!         (13),
!         (14),
!         (15),
!         (16),
!         (17),
!         (18),
!         (19),
!         (20)
!     RETURNING *
! )
! SELECT * FROM t;
!  a  
! ----
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
! (10 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
! (20 rows)
! 
! -- UPDATE ... RETURNING
! WITH t AS (
!     UPDATE y
!     SET a=a+1
!     RETURNING *
! )
! SELECT * FROM t;
!  a  
! ----
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
!  21
! (20 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
!  21
! (20 rows)
! 
! -- DELETE ... RETURNING
! WITH t AS (
!     DELETE FROM y
!     WHERE a <= 10
!     RETURNING *
! )
! SELECT * FROM t;
!  a  
! ----
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (9 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!  11
!  12
!  13
!  14
!  15
!  16
!  17
!  18
!  19
!  20
!  21
! (11 rows)
! 
! -- forward reference
! WITH RECURSIVE t AS (
! 	INSERT INTO y
! 		SELECT a+5 FROM t2 WHERE a > 5
! 	RETURNING *
! ), t2 AS (
! 	UPDATE y SET a=a-11 RETURNING *
! )
! SELECT * FROM t
! UNION ALL
! SELECT * FROM t2;
!  a  
! ----
!  11
!  12
!  13
!  14
!  15
!   0
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
! (16 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   0
!   1
!   2
!   3
!   4
!   5
!   6
!  11
!   7
!  12
!   8
!  13
!   9
!  14
!  10
!  15
! (16 rows)
! 
! -- unconditional DO INSTEAD rule
! CREATE RULE y_rule AS ON DELETE TO y DO INSTEAD
!   INSERT INTO y VALUES(42) RETURNING *;
! WITH t AS (
! 	DELETE FROM y RETURNING *
! )
! SELECT * FROM t;
!  a  
! ----
!  42
! (1 row)
! 
! SELECT * FROM y;
!  a  
! ----
!   0
!   1
!   2
!   3
!   4
!   5
!   6
!  11
!   7
!  12
!   8
!  13
!   9
!  14
!  10
!  15
!  42
! (17 rows)
! 
! DROP RULE y_rule ON y;
! -- check merging of outer CTE with CTE in a rule action
! CREATE TEMP TABLE bug6051 AS
!   select i from generate_series(1,3) as t(i);
! SELECT * FROM bug6051;
!  i 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! WITH t1 AS ( DELETE FROM bug6051 RETURNING * )
! INSERT INTO bug6051 SELECT * FROM t1;
! SELECT * FROM bug6051;
!  i 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! CREATE TEMP TABLE bug6051_2 (i int);
! CREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD
!  INSERT INTO bug6051_2
!  SELECT NEW.i;
! WITH t1 AS ( DELETE FROM bug6051 RETURNING * )
! INSERT INTO bug6051 SELECT * FROM t1;
! SELECT * FROM bug6051;
!  i 
! ---
! (0 rows)
! 
! SELECT * FROM bug6051_2;
!  i 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! -- a truly recursive CTE in the same list
! WITH RECURSIVE t(a) AS (
! 	SELECT 0
! 		UNION ALL
! 	SELECT a+1 FROM t WHERE a+1 < 5
! ), t2 as (
! 	INSERT INTO y
! 		SELECT * FROM t RETURNING *
! )
! SELECT * FROM t2 JOIN y USING (a) ORDER BY a;
!  a 
! ---
!  0
!  1
!  2
!  3
!  4
! (5 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   0
!   1
!   2
!   3
!   4
!   5
!   6
!  11
!   7
!  12
!   8
!  13
!   9
!  14
!  10
!  15
!  42
!   0
!   1
!   2
!   3
!   4
! (22 rows)
! 
! -- data-modifying WITH in a modifying statement
! WITH t AS (
!     DELETE FROM y
!     WHERE a <= 10
!     RETURNING *
! )
! INSERT INTO y SELECT -a FROM t RETURNING *;
!   a  
! -----
!    0
!   -1
!   -2
!   -3
!   -4
!   -5
!   -6
!   -7
!   -8
!   -9
!  -10
!    0
!   -1
!   -2
!   -3
!   -4
! (16 rows)
! 
! SELECT * FROM y;
!   a  
! -----
!   11
!   12
!   13
!   14
!   15
!   42
!    0
!   -1
!   -2
!   -3
!   -4
!   -5
!   -6
!   -7
!   -8
!   -9
!  -10
!    0
!   -1
!   -2
!   -3
!   -4
! (22 rows)
! 
! -- check that WITH query is run to completion even if outer query isn't
! WITH t AS (
!     UPDATE y SET a = a * 100 RETURNING *
! )
! SELECT * FROM t LIMIT 10;
!   a   
! ------
!  1100
!  1200
!  1300
!  1400
!  1500
!  4200
!     0
!  -100
!  -200
!  -300
! (10 rows)
! 
! SELECT * FROM y;
!    a   
! -------
!   1100
!   1200
!   1300
!   1400
!   1500
!   4200
!      0
!   -100
!   -200
!   -300
!   -400
!   -500
!   -600
!   -700
!   -800
!   -900
!  -1000
!      0
!   -100
!   -200
!   -300
!   -400
! (22 rows)
! 
! -- check that run to completion happens in proper ordering
! TRUNCATE TABLE y;
! INSERT INTO y SELECT generate_series(1, 3);
! CREATE TEMPORARY TABLE yy (a INTEGER);
! WITH RECURSIVE t1 AS (
!   INSERT INTO y SELECT * FROM y RETURNING *
! ), t2 AS (
!   INSERT INTO yy SELECT * FROM t1 RETURNING *
! )
! SELECT 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT * FROM y;
!  a 
! ---
!  1
!  2
!  3
!  1
!  2
!  3
! (6 rows)
! 
! SELECT * FROM yy;
!  a 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! WITH RECURSIVE t1 AS (
!   INSERT INTO yy SELECT * FROM t2 RETURNING *
! ), t2 AS (
!   INSERT INTO y SELECT * FROM y RETURNING *
! )
! SELECT 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! SELECT * FROM y;
!  a 
! ---
!  1
!  2
!  3
!  1
!  2
!  3
!  1
!  2
!  3
!  1
!  2
!  3
! (12 rows)
! 
! SELECT * FROM yy;
!  a 
! ---
!  1
!  2
!  3
!  1
!  2
!  3
!  1
!  2
!  3
! (9 rows)
! 
! -- triggers
! TRUNCATE TABLE y;
! INSERT INTO y SELECT generate_series(1, 10);
! CREATE FUNCTION y_trigger() RETURNS trigger AS $$
! begin
!   raise notice 'y_trigger: a = %', new.a;
!   return new;
! end;
! $$ LANGUAGE plpgsql;
! CREATE TRIGGER y_trig BEFORE INSERT ON y FOR EACH ROW
!     EXECUTE PROCEDURE y_trigger();
! WITH t AS (
!     INSERT INTO y
!     VALUES
!         (21),
!         (22),
!         (23)
!     RETURNING *
! )
! SELECT * FROM t;
! NOTICE:  y_trigger: a = 21
! NOTICE:  y_trigger: a = 22
! NOTICE:  y_trigger: a = 23
!  a  
! ----
!  21
!  22
!  23
! (3 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  21
!  22
!  23
! (13 rows)
! 
! DROP TRIGGER y_trig ON y;
! CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH ROW
!     EXECUTE PROCEDURE y_trigger();
! WITH t AS (
!     INSERT INTO y
!     VALUES
!         (31),
!         (32),
!         (33)
!     RETURNING *
! )
! SELECT * FROM t LIMIT 1;
! NOTICE:  y_trigger: a = 31
! NOTICE:  y_trigger: a = 32
! NOTICE:  y_trigger: a = 33
!  a  
! ----
!  31
! (1 row)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  21
!  22
!  23
!  31
!  32
!  33
! (16 rows)
! 
! DROP TRIGGER y_trig ON y;
! CREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$
! begin
!   raise notice 'y_trigger';
!   return null;
! end;
! $$ LANGUAGE plpgsql;
! CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT
!     EXECUTE PROCEDURE y_trigger();
! WITH t AS (
!     INSERT INTO y
!     VALUES
!         (41),
!         (42),
!         (43)
!     RETURNING *
! )
! SELECT * FROM t;
! NOTICE:  y_trigger
!  a  
! ----
!  41
!  42
!  43
! (3 rows)
! 
! SELECT * FROM y;
!  a  
! ----
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
!   9
!  10
!  21
!  22
!  23
!  31
!  32
!  33
!  41
!  42
!  43
! (19 rows)
! 
! DROP TRIGGER y_trig ON y;
! DROP FUNCTION y_trigger();
! -- WITH attached to inherited UPDATE or DELETE
! CREATE TEMP TABLE parent ( id int, val text );
! CREATE TEMP TABLE child1 ( ) INHERITS ( parent );
! CREATE TEMP TABLE child2 ( ) INHERITS ( parent );
! INSERT INTO parent VALUES ( 1, 'p1' );
! INSERT INTO child1 VALUES ( 11, 'c11' ),( 12, 'c12' );
! INSERT INTO child2 VALUES ( 23, 'c21' ),( 24, 'c22' );
! WITH rcte AS ( SELECT sum(id) AS totalid FROM parent )
! UPDATE parent SET id = id + totalid FROM rcte;
! SELECT * FROM parent;
!  id | val 
! ----+-----
!  72 | p1
!  82 | c11
!  83 | c12
!  94 | c21
!  95 | c22
! (5 rows)
! 
! WITH wcte AS ( INSERT INTO child1 VALUES ( 42, 'new' ) RETURNING id AS newid )
! UPDATE parent SET id = id + newid FROM wcte;
! SELECT * FROM parent;
!  id  | val 
! -----+-----
!  114 | p1
!   42 | new
!  124 | c11
!  125 | c12
!  136 | c21
!  137 | c22
! (6 rows)
! 
! WITH rcte AS ( SELECT max(id) AS maxid FROM parent )
! DELETE FROM parent USING rcte WHERE id = maxid;
! SELECT * FROM parent;
!  id  | val 
! -----+-----
!  114 | p1
!   42 | new
!  124 | c11
!  125 | c12
!  136 | c21
! (5 rows)
! 
! WITH wcte AS ( INSERT INTO child2 VALUES ( 42, 'new2' ) RETURNING id AS newid )
! DELETE FROM parent USING wcte WHERE id = newid;
! SELECT * FROM parent;
!  id  | val  
! -----+------
!  114 | p1
!  124 | c11
!  125 | c12
!  136 | c21
!   42 | new2
! (5 rows)
! 
! -- check EXPLAIN VERBOSE for a wCTE with RETURNING
! EXPLAIN (VERBOSE, COSTS OFF)
! WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )
! DELETE FROM a USING wcte WHERE aa = q2;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Delete on public.a
!    CTE wcte
!      ->  Insert on public.int8_tbl
!            Output: int8_tbl.q2
!            ->  Result
!                  Output: 42::bigint, 47::bigint
!    ->  Nested Loop
!          Output: a.ctid, wcte.*
!          Join Filter: (a.aa = wcte.q2)
!          ->  Seq Scan on public.a
!                Output: a.ctid, a.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: b.ctid, wcte.*
!          Join Filter: (b.aa = wcte.q2)
!          ->  Seq Scan on public.b
!                Output: b.ctid, b.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: c.ctid, wcte.*
!          Join Filter: (c.aa = wcte.q2)
!          ->  Seq Scan on public.c
!                Output: c.ctid, c.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
!    ->  Nested Loop
!          Output: d.ctid, wcte.*
!          Join Filter: (d.aa = wcte.q2)
!          ->  Seq Scan on public.d
!                Output: d.ctid, d.aa
!          ->  CTE Scan on wcte
!                Output: wcte.*, wcte.q2
! (34 rows)
! 
! -- error cases
! -- data-modifying WITH tries to use its own output
! WITH RECURSIVE t AS (
! 	INSERT INTO y
! 		SELECT * FROM t
! )
! VALUES(FALSE);
! ERROR:  recursive query "t" must not contain data-modifying statements
! LINE 1: WITH RECURSIVE t AS (
!                        ^
! -- no RETURNING in a referenced data-modifying WITH
! WITH t AS (
! 	INSERT INTO y VALUES(0)
! )
! SELECT * FROM t;
! ERROR:  WITH query "t" does not have a RETURNING clause
! LINE 4: SELECT * FROM t;
!                       ^
! -- data-modifying WITH allowed only at the top level
! SELECT * FROM (
! 	WITH t AS (UPDATE y SET a=a+1 RETURNING *)
! 	SELECT * FROM t
! ) ss;
! ERROR:  WITH clause containing a data-modifying statement must be at the top level
! LINE 2:  WITH t AS (UPDATE y SET a=a+1 RETURNING *)
!               ^
! -- most variants of rules aren't allowed
! CREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;
! WITH t AS (
! 	INSERT INTO y VALUES(0)
! )
! VALUES(FALSE);
! ERROR:  conditional DO INSTEAD rules are not supported for data-modifying statements in WITH
! DROP RULE y_rule ON y;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** /home/orion/postgres/src/test/regress/expected/xml_1.out	2014-11-21 01:48:04.367437000 +0300
--- /home/orion/postgres/src/test/regress/results/xml.out	2015-01-26 12:33:26.331031434 +0300
***************
*** 1,821 ****
! CREATE TABLE xmltest (
!     id int,
!     data xml
! );
! INSERT INTO xmltest VALUES (1, '<value>one</value>');
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (1, '<value>one</value>');
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (2, '<value>two</value>');
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (2, '<value>two</value>');
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (3, '<wrong');
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (3, '<wrong');
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT * FROM xmltest;
!  id | data 
! ----+------
! (0 rows)
! 
! SELECT xmlcomment('test');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlcomment('-test');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlcomment('test-');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlcomment('--test');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlcomment('te st');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat(xmlcomment('hello'),
!                  xmlelement(NAME qux, 'foo'),
!                  xmlcomment('world'));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat('hello', 'you');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlconcat('hello', 'you');
!                          ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat(1, 2);
! ERROR:  argument of XMLCONCAT must be type xml, not type integer
! LINE 1: SELECT xmlconcat(1, 2);
!                          ^
! SELECT xmlconcat('bad', '<syntax');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlconcat('bad', '<syntax');
!                          ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standa...
!                          ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml...
!                          ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlconcat(NULL);
!  xmlconcat 
! -----------
!  
! (1 row)
! 
! SELECT xmlconcat(NULL, NULL);
!  xmlconcat 
! -----------
!  
! (1 row)
! 
! SELECT xmlelement(name element,
!                   xmlattributes (1 as one, 'deuce' as two),
!                   'content');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name element,
!                   xmlattributes ('unnamed and wrong'));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name element, xmlelement(name nested, 'stuff'));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name num, 37);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, text 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xml 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, text 'b<a/>r');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xml 'b<a/>r');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, array[1, 2, 3]);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SET xmlbinary TO base64;
! SELECT xmlelement(name foo, bytea 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SET xmlbinary TO hex;
! SELECT xmlelement(name foo, bytea 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xmlattributes(true as bar));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier));
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '  ');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content 'abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<abc>x</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<invalidentity>&</invalidentity>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<undefinedentity>&idontexist;</undefinedentity>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<invalidns xmlns=''&lt;''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<relativens xmlns=''relative''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<twoerrors>&idontexist;</unbalanced>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(content '<nosuchprefix:tag/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '   ');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document 'abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<abc>x</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<invalidentity>&</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<undefinedentity>&idontexist;</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<invalidns xmlns=''&lt;''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<relativens xmlns=''relative''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<twoerrors>&idontexist;</unbalanced>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlparse(document '<nosuchprefix:tag/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name foo);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name xml);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name xmlstuff);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name foo, 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name foo, 'in?>valid');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name foo, null);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name xml, null);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name xmlstuff, null);
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name "xml-stylesheet", 'href="mystyle.css" type="text/css"');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name foo, '   bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot(xml '<foo/>', version no value, standalone no value);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot(xml '<foo/>', version no value, standalone no...
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot(xml '<foo/>', version '2.0');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot(xml '<foo/>', version '2.0');
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot(xml '<foo/>', version no value, standalone ye...
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no...
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version...
!                                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>...
!                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>...
!                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>...
!                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlroot (
!   xmlelement (
!     name gazonk,
!     xmlattributes (
!       'val' AS name,
!       1 + 1 AS num
!     ),
!     xmlelement (
!       NAME qux,
!       'foo'
!     )
!   ),
!   version '1.0',
!   standalone yes
! );
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlserialize(content data as character varying(20)) FROM xmltest;
!  xmlserialize 
! --------------
! (0 rows)
! 
! SELECT xmlserialize(content 'good' as char(10));
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlserialize(content 'good' as char(10));
!                                     ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlserialize(document 'bad' as text);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xmlserialize(document 'bad' as text);
!                                      ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml '<foo>bar</foo>' IS DOCUMENT;
! ERROR:  unsupported XML feature
! LINE 1: SELECT xml '<foo>bar</foo>' IS DOCUMENT;
!                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
! ERROR:  unsupported XML feature
! LINE 1: SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
!                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml '<abc/>' IS NOT DOCUMENT;
! ERROR:  unsupported XML feature
! LINE 1: SELECT xml '<abc/>' IS NOT DOCUMENT;
!                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml 'abc' IS NOT DOCUMENT;
! ERROR:  unsupported XML feature
! LINE 1: SELECT xml 'abc' IS NOT DOCUMENT;
!                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT '<>' IS NOT DOCUMENT;
! ERROR:  unsupported XML feature
! LINE 1: SELECT '<>' IS NOT DOCUMENT;
!                ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlagg(data) FROM xmltest;
!  xmlagg 
! --------
!  
! (1 row)
! 
! SELECT xmlagg(data) FROM xmltest WHERE id > 10;
!  xmlagg 
! --------
!  
! (1 row)
! 
! SELECT xmlelement(name employees, xmlagg(xmlelement(name name, name))) FROM emp;
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- Check mapping SQL identifier to XML name
! SELECT xmlpi(name ":::_xml_abc135.%-&_");
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlpi(name "123");
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
! ERROR:  unsupported XML feature
! LINE 1: PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
!                                               ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SET XML OPTION DOCUMENT;
! EXECUTE foo ('<bar/>');
! ERROR:  prepared statement "foo" does not exist
! EXECUTE foo ('bad');
! ERROR:  prepared statement "foo" does not exist
! SET XML OPTION CONTENT;
! EXECUTE foo ('<bar/>');
! ERROR:  prepared statement "foo" does not exist
! EXECUTE foo ('good');
! ERROR:  prepared statement "foo" does not exist
! -- Test backwards parsing
! CREATE VIEW xmlview1 AS SELECT xmlcomment('test');
! CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you');
! ERROR:  unsupported XML feature
! LINE 1: CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you');
!                                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview3 AS SELECT xmlelement(name element, xmlattributes (1 as ":one:", 'deuce' as two), 'content&');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview4 AS SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview5 AS SELECT xmlparse(content '<abc>x</abc>');
! CREATE VIEW xmlview6 AS SELECT xmlpi(name foo, 'bar');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
! ERROR:  unsupported XML feature
! LINE 1: CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version...
!                                                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10));
! ERROR:  unsupported XML feature
! LINE 1: ...EATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as ...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text);
! ERROR:  unsupported XML feature
! LINE 1: ...EATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as ...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT table_name, view_definition FROM information_schema.views
!   WHERE table_name LIKE 'xmlview%' ORDER BY 1;
!  table_name |                                view_definition                                 
! ------------+--------------------------------------------------------------------------------
!  xmlview1   |  SELECT xmlcomment('test'::text) AS xmlcomment;
!  xmlview5   |  SELECT XMLPARSE(CONTENT '<abc>x</abc>'::text STRIP WHITESPACE) AS "xmlparse";
! (2 rows)
! 
! -- Text XPath expressions evaluation
! SELECT xpath('/value', data) FROM xmltest;
!  xpath 
! -------
! (0 rows)
! 
! SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
!  ?column? 
! ----------
! (0 rows)
! 
! SELECT xpath('', '<!-- error -->');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('', '<!-- error -->');
!                          ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('//text()', '<local:data xmlns:local="http://12...
!                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('//loc:piece/@id', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('//loc:piece/@id', '<local:data xmlns:local="ht...
!                                         ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>'...
!                             ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('//text()', '<root>&lt;</root>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('//text()', '<root>&lt;</root>');
!                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('//@value', '<root value="&lt;"/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('//@value', '<root value="&lt;"/>');
!                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('''<<invalid>>''', '<root/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('''<<invalid>>''', '<root/>');
!                                         ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
!                                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
!                                      ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
!                                      ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
!                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath('/nosuchtag', '<root/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('/nosuchtag', '<root/>');
!                                    ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- Test xmlexists and xpath_exists
! SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
! ERROR:  unsupported XML feature
! LINE 1: ...sts('//town[text() = ''Toronto'']' PASSING BY REF '<towns><t...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlexists('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
! ERROR:  unsupported XML feature
! LINE 1: ...sts('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><t...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>');
! ERROR:  unsupported XML feature
! LINE 1: ...LECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>')...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: ...ELECT xpath_exists('//town[text() = ''Toronto'']','<towns><t...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: ...ELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><t...
!                                                              ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
!                                                  ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (4, '<menu><beers><name>Budvar</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (4, '<menu><beers><name>Budvar</n...
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (5, '<menu><beers><name>Molson</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (5, '<menu><beers><name>Molson</n...
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (6, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Budvar</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (6, '<myns:menu xmlns:myns="http:...
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! INSERT INTO xmltest VALUES (7, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Molson</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
! ERROR:  unsupported XML feature
! LINE 1: INSERT INTO xmltest VALUES (7, '<myns:menu xmlns:myns="http:...
!                                        ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING BY REF data BY REF);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers' PASSING BY REF data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers/name[text() = ''Molson'']' PASSING BY REF data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beer',data,ARRAY[ARRAY['myns','http://myns.com']]);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers',data,ARRAY[ARRAY['myns','http://myns.com']]);
!  count 
! -------
!      0
! (1 row)
! 
! SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers/myns:name[text() = ''Molson'']',data,ARRAY[ARRAY['myns','http://myns.com']]);
!  count 
! -------
!      0
! (1 row)
! 
! CREATE TABLE query ( expr TEXT );
! INSERT INTO query VALUES ('/menu/beers/cost[text() = ''lots'']');
! SELECT COUNT(id) FROM xmltest, query WHERE xmlexists(expr PASSING BY REF data);
!  count 
! -------
!      0
! (1 row)
! 
! -- Test xml_is_well_formed and variants
! SELECT xml_is_well_formed_document('<foo>bar</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed_document('abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed_content('<foo>bar</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed_content('abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SET xmloption TO DOCUMENT;
! SELECT xml_is_well_formed('abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<abc/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<foo>bar</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<foo>bar</foo');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<foo><bar>baz</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<invalidentity>&</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<undefinedentity>&idontexist;</abc>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<invalidns xmlns=''&lt;''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<relativens xmlns=''relative''/>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT xml_is_well_formed('<twoerrors>&idontexist;</unbalanced>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SET xmloption TO CONTENT;
! SELECT xml_is_well_formed('abc');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- Since xpath() deals with namespaces, it's a bit stricter about
! -- what's well-formed and what's not. If we don't obey these rules
! -- (i.e. ignore namespace-related errors from libxml), xpath()
! -- fails in subtle ways. The following would for example produce
! -- the xml value
! --   <invalidns xmlns='<'/>
! -- which is invalid because '<' may not appear un-escaped in
! -- attribute values.
! -- Since different libxml versions emit slightly different
! -- error messages, we suppress the DETAIL in this test.
! \set VERBOSITY terse
! SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
! ERROR:  unsupported XML feature at character 20
! \set VERBOSITY default
! -- Again, the XML isn't well-formed for namespace purposes
! SELECT xpath('/*', '<nosuchprefix:tag/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('/*', '<nosuchprefix:tag/>');
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- XPath deprecates relative namespaces, but they're not supposed to
! -- throw an error, only a warning.
! SELECT xpath('/*', '<relativens xmlns=''relative''/>');
! ERROR:  unsupported XML feature
! LINE 1: SELECT xpath('/*', '<relativens xmlns=''relative''/>');
!                            ^
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- External entity references should not leak filesystem information.
! SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c;</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c;</foo>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
! -- This might or might not load the requested DTD, but it mustn't throw error.
! SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp;</chapter>');
! ERROR:  unsupported XML feature
! DETAIL:  This functionality requires the server to be built with libxml support.
! HINT:  You need to rebuild PostgreSQL using --with-libxml.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode
>>>>>>> 03c5c6344d75e2e7a91b277d52346d0e94d3e3a1

======================================================================

